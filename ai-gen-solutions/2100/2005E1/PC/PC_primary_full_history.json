[
  {
    "role": "user",
    "content": "E1. Subtangle Game (Easy Version)\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nThis is the easy version of the problem. The differences between the two versions are the constraints on all the variables. You can make hacks only if both versions of the problem are solved.\n\n\n\nTsovak and Narek are playing a game. They have an array a\n\n and a matrix b\n\n of integers with n\n\n rows and m\n\n columns, numbered from 1\n\n. The cell in the i\n\n-th row and the j\n\n-th column is (i,j)\n\n.\n\n\n\nThey are looking for the elements of a\n\n in turns; Tsovak starts first. Each time a player looks for a cell in the matrix containing the current element of a\n\n (Tsovak looks for the first, then Narek looks for the second, etc.). Let's say a player has chosen the cell (r,c)\n\n. The next player has to choose his cell in the submatrix starting at (r+1,c+1)\n\n and ending in (n,m)\n\n (the submatrix can be empty if r=n\n\n or c=m\n\n). If a player cannot find such a cell (or the remaining submatrix is empty) or the array ends (the previous player has chosen the last element), then he loses.\n\n\n\nYour task is to determine the winner if the players play optimally.\n\n\n\nInput\n\nThe first line of the input contains t\n\n (1≤t≤300\n\n) – the number of test cases.\n\n\n\nThe first line of each test case contains three integers l\n\n, n\n\n, and m\n\n (1≤l,n,m≤300\n\n) – the size of the array and the sizes of the matrix.\n\n\n\nThe second line contains l\n\n integers a1,a2,a3,…al\n\n (1≤ai≤min(7,n⋅m)\n\n) – the elements of the array a\n\n.\n\n\n\nThe i\n\n-th of the last n\n\n lines contains m\n\n integers bi,1,bi,2,bi,3,…bi,m\n\n (1≤bi,j≤min(7,n⋅m)\n\n) – representing the i\n\n-th row of the matrix.\n\n\n\nIt is guaranteed that the sum of n⋅m\n\n over all test cases does not exceed 105\n\n.\n\n\n\nIt is guaranteed that the sum of l\n\n over all test cases does not exceed 300\n\n.\n\n\n\nOutput\n\nYou should output t\n\n lines, the i\n\n-th of them containing a character representing the answer of the i\n\n-th test case: \"T\" if Tsovak wins or \"N\", otherwise (without quotes).\n\n\n\nExample\n\nInputCopy\n\n3\n\n2 2 3\n\n1 2\n\n1 3 5\n\n4 5 2\n\n2 2 4\n\n1 2\n\n1 1 3 2\n\n4 2 5 1\n\n2 4 2\n\n1 2\n\n3 4\n\n5 5\n\n5 5\n\n5 5\n\nOutputCopy\n\nN\n\nT\n\nN\n\nNote\n\nIn the first example, Tsovak starts by looking for 1\n\n. There is only one occurrence of 1\n\n at (1,1)\n\n, so he chooses it. Then Narek needs to look for 2\n\n in the submatrix of (2,2)\n\n, which consists of just the last two elements: 5\n\n and 2\n\n. He chooses 2\n\n, and then Tsovak loses since the array has ended.\n\n\n\nIn the second example, Tsovak needs to choose 1\n\n. There is a 1\n\n at the cell (n,m)\n\n, so he chooses that cell. Then, since the submatrix of (n+1,m+1)\n\n is empty, Narek cannot find 2\n\n, so he loses.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have an \\(n\\times m\\) grid \\(b\\) of small integer values (\\(\\le7\\)) and a sequence \\(a_1,a_2,\\dots,a_\\ell\\).  Two players, Tsovak and Narek, alternately “pick” the next value in the sequence from the grid, with the extra rule that each pick must lie strictly to the southeast of the previous pick (that is, if the previous pick was at \\((r,c)\\), the next pick must be at some \\((r',c')\\) with \\(r'>r\\) and \\(c'>c\\)).  Tsovak goes first on \\(a_1\\), then Narek picks \\(a_2\\), Tsovak picks \\(a_3\\), and so on.  If it is your turn but you cannot pick (either there is no matching entry in the required submatrix, or the sequence has already ended), you lose.\n\nObserve that whoever picks the last element of \\(a\\) immediately wins, because the *other* player then has no move (the sequence is finished).  We therefore have a standard “last‐move‐wins” impartial game, which we can solve by computing, for every prefix index \\(k\\) (meaning “we are about to pick \\(a_k\\)”) and every possible “previous pick location” \\((r,c)\\), whether the current player to move is in a winning or losing position.\n\nLet\n```\ndp[k][r][c] = true\n```\nif, when it is your turn to pick \\(a_k\\) and the last pick was at row \\(r\\), column \\(c\\), you have a forced win.  If \\(k=\\ell+1\\), that means the previous player just took \\(a_\\ell\\), so you have no move and hence lose:  \n\\[\ndp[\\ell+1][r][c] = \\mathrm{false}\\quad\\forall\\,r,c.\n\\]\n\nFor \\(1 \\le k \\le \\ell\\), you can move only to those cells \\((r',c')\\) with \\(r'>r\\), \\(c'>c\\), and \\(b[r'][c']==a_k\\).  You want one of those moves to land your opponent in a losing position, i.e.\n\\[\ndp[k][r][c]\\;=\\;\\bigl(\\exists\\,r'>r,\\;c'>c\\text{ with }b[r'][c']=a_k\\text{ and }dp[k+1][r'][c']=\\mathrm{false}\\bigr).\n\\]\nIf you can find such a move, you win; otherwise you lose.\n\nA direct 3D DP with transitions would be too big (\\(\\ell n m\\) states each scanning up to \\(nm\\) transitions).  But observe that\n1. We only ever look at the submatrix strictly southeast of \\((r,c)\\).\n2. We only care whether *any* such \\((r',c')\\) has \\(b[r'][c']=a_k\\) *and* \\(dp[k+1][r'][c']=\\text{false}\\).\n\nThus for each \\(k\\) we build a mask\n\\[\nM[r'][c']=1\\quad\\text{if }b[r'][c']=a_k\\text{ and }dp[k+1][r'][c']=\\mathrm{false},\n\\]\nzero otherwise.  Then let\n\\[\nS[r][c] \\;=\\;\\sum_{i=r}^n\\sum_{j=c}^m M[i][j]\n\\]\nbe the usual 2D suffix‐sum array of \\(M\\).  Clearly\n\\[\ndp[k][r][c] \\;=\\; \\bigl(S[r+1][c+1]>0\\bigr).\n\\]\n\nWe roll \\(k\\) backward from \\(\\ell\\) to \\(1\\).  We keep two 2D boolean arrays `dp_next` = \\(dp[k+1]\\) and `dp_cur` = \\(dp[k]\\).  We build \\(M\\) on the fly while doing the suffix sums.  Each stage takes \\(O(nm)\\).  Since \\(\\sum n m\\le10^5\\) over all test cases and \\(\\sum \\ell\\le300\\), the total work is\n\\[\n\\sum_{\\text{tests}} \\sum_{k=1}^{\\ell}(n m)\\;\\le\\;300\\cdot10^5\\;=\\;3\\times10^7\n\\]\ninteger‐type operations, which easily fits under the time limit in Java.\n\nAt the end we check `dp_next[0][0]`, which is \\(dp[1][0][0]\\): “it's Tsovak's turn picking \\(a_1\\), with no prior pick (we treat that as \\((0,0)\\)).”  If that is `true`, Tsovak has a winning strategy; otherwise Narek wins.\n\nBelow is a Java implementation.\n\n```java\nimport java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int t = Integer.parseInt(st.nextToken());\n\n        StringBuilder sb = new StringBuilder();\n        while (t-- > 0) {\n            st = new StringTokenizer(br.readLine());\n            int l = Integer.parseInt(st.nextToken());\n            int n = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(st.nextToken());\n\n            // Read the sequence a[0..l-1]\n            int[] a = new int[l];\n            st = new StringTokenizer(br.readLine());\n            for (int i = 0; i < l; i++) {\n                a[i] = Integer.parseInt(st.nextToken());\n            }\n\n            // Read the grid b[1..n][1..m]\n            int[][] b = new int[n+1][m+1];\n            for (int i = 1; i <= n; i++) {\n                st = new StringTokenizer(br.readLine());\n                for (int j = 1; j <= m; j++) {\n                    b[i][j] = Integer.parseInt(st.nextToken());\n                }\n            }\n\n            // dp_next[r][c] will hold dp[k+1][r][c], initially all false (losing).\n            boolean[][] dp_next = new boolean[n+2][m+2];\n            boolean[][] dp_cur  = new boolean[n+2][m+2];\n\n            // S[r][c] = suffix sum of the \"mask\" M at or below/ right of (r,c).\n            int[][] S = new int[n+2][m+2];\n\n            // Process k = l-1 down to 0\n            for (int idx = l - 1; idx >= 0; idx--) {\n                int want = a[idx];\n\n                // Build suffix sum S of the mask M defined by\n                // M[r][c] = 1 if b[r][c]==want and dp_next[r][c]==false, else 0.\n                // S[r][c] = M[r][c] + S[r+1][c] + S[r][c+1] - S[r+1][c+1].\n                for (int r = n; r >= 1; r--) {\n                    for (int c = m; c >= 1; c--) {\n                        int mVal = (b[r][c] == want && !dp_next[r][c]) ? 1 : 0;\n                        S[r][c] = S[r+1][c] + S[r][c+1] - S[r+1][c+1] + mVal;\n                    }\n                }\n\n                // Now dp_cur[r][c] = (S[r+1][c+1] > 0)\n                // for r in [0..n], c in [0..m].\n                for (int r = 0; r <= n; r++) {\n                    for (int c = 0; c <= m; c++) {\n                        dp_cur[r][c] = S[r+1][c+1] > 0;\n                    }\n                }\n\n                // Swap dp_next and dp_cur for the next iteration\n                boolean[][] tmp = dp_next;\n                dp_next = dp_cur;\n                dp_cur  = tmp;\n                // (No need to clear dp_cur; it will be overwritten.)\n                // S will be overwritten next round as well.\n            }\n\n            // Finally dp_next[0][0] is dp[1][0][0], the answer for the first move.\n            sb.append(dp_next[0][0] ? 'T' : 'N').append('\\n');\n        }\n\n        System.out.print(sb);\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. We only ever need to know, for each “next index” \\(k\\), and each possible “last‐picked cell” \\((r,c)\\), whether the current player to move is in a winning position.\n\n2. If it is your turn to pick \\(a_k\\) with last pick \\((r,c)\\), you look at all grid cells \\((r',c')\\) with \\(r'>r\\), \\(c'>c\\) and \\(b[r'][c']=a_k\\).  If *any* of those moves sends your opponent to a losing position (i.e.\\ \\(dp[k+1][r'][c']=\\) false), then \\(dp[k][r][c]\\) is true (you win).  Otherwise you lose.\n\n3. We roll \\(k\\) *backwards*.  For \\(k=\\ell+1\\), there are no picks to make, so \\(dp[\\ell+1][r][c]=\\) false.  Then we compute \\(dp[\\ell]\\), \\(dp[\\ell-1]\\), … down to \\(dp[1]\\).\n\n4. At step \\(k\\) we only need to detect whether *any* target cell \\((r',c')\\) satisfies both \\(b[r'][c']=a_k\\) and \\(dp[k+1][r'][c']=\\)false.  We form the 0–1 array\n   \\[\n     M[r'][c'] \\;=\\;\n     \\bigl(b[r'][c']=a_k\\text{ and }dp[k+1][r'][c']=\\mathrm{false}\\bigr)\\,?1:0,\n   \\]\n   then build its 2D suffix sum\n   \\[\n     S[r][c] = \\sum_{i=r}^{n}\\sum_{j=c}^{m} M[i][j].\n   \\]\n   Now\n   \\[\n     dp[k][r][c] = \\bigl(S[r+1][c+1] > 0\\bigr).\n   \\]\n\n5. Each of the \\(\\ell\\) steps costs \\(O(nm)\\) to build \\(S\\) plus \\(O(nm)\\) to fill the new dp table.  Since \\(\\sum nm\\le10^5\\) and \\(\\ell\\le300\\), the total is about \\(3\\times10^7\\) operations, which runs comfortably within the time limit in Java.\n\nFinally we look at `dp_next[0][0]` after processing \\(k=1\\).  That tells us whether Tsovak (the first player, picking \\(a_1\\) from scratch) is in a winning position (`T`) or losing position (`N`)."
  },
  {
    "role": "user",
    "content": "Please provide only the complete Java solution code in one block, without any additional explanations or commentary, ready for submission."
  },
  {
    "role": "assistant",
    "content": "```java\nimport java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int t = Integer.parseInt(st.nextToken());\n        StringBuilder sb = new StringBuilder();\n        while (t-- > 0) {\n            st = new StringTokenizer(br.readLine());\n            int l = Integer.parseInt(st.nextToken());\n            int n = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(st.nextToken());\n            int[] a = new int[l];\n            st = new StringTokenizer(br.readLine());\n            for (int i = 0; i < l; i++) {\n                a[i] = Integer.parseInt(st.nextToken());\n            }\n            int[][] b = new int[n+1][m+1];\n            for (int i = 1; i <= n; i++) {\n                st = new StringTokenizer(br.readLine());\n                for (int j = 1; j <= m; j++) {\n                    b[i][j] = Integer.parseInt(st.nextToken());\n                }\n            }\n            boolean[][] dpNext = new boolean[n+2][m+2];\n            boolean[][] dpCur  = new boolean[n+2][m+2];\n            int[][] S = new int[n+2][m+2];\n            for (int idx = l - 1; idx >= 0; idx--) {\n                int want = a[idx];\n                for (int r = n; r >= 1; r--) {\n                    for (int c = m; c >= 1; c--) {\n                        int mVal = (b[r][c] == want && !dpNext[r][c]) ? 1 : 0;\n                        S[r][c] = S[r+1][c] + S[r][c+1] - S[r+1][c+1] + mVal;\n                    }\n                }\n                for (int r = 0; r <= n; r++) {\n                    for (int c = 0; c <= m; c++) {\n                        dpCur[r][c] = S[r+1][c+1] > 0;\n                    }\n                }\n                boolean[][] tmp = dpNext;\n                dpNext = dpCur;\n                dpCur = tmp;\n            }\n            sb.append(dpNext[0][0] ? 'T' : 'N').append('\\n');\n        }\n        System.out.print(sb);\n    }\n}\n```"
  }
]