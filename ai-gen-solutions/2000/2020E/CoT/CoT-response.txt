**Analysis**

We have an array \(a_1,\dots,a_n\) of integers (each up to \(1023\), so at most 10 bits) and an array of probabilities  
\[
p_i \,/\,10000
\]  
that each \(a_i\) is independently included in a multiset \(S\).  We let
\[
X \;=\;\bigoplus_{x\in S} x
\]
be the bitwise XOR of all those chosen elements, and we want
\[
\mathbb{E}\bigl[X^2\bigr]\pmod{10^9+7}.
\]

---

### 1. Bit‐wise expansion

Write
\[
X = \sum_{b=0}^{9} 2^b\,B_b,
\]
where \(B_b\in\{0,1\}\) is the parity (XOR) of the \(b\)-th bit of all chosen \(a_i\).  Then
\[
X^2 \;=\;\Bigl(\sum_b 2^b B_b\Bigr)^2
       \;=\;
       \sum_{b=0}^{9} 2^{2b}\,B_b
       \;+\;
       \sum_{\substack{b,c=0\\b\neq c}}^{9} 2^b\,2^c\,B_b\,B_c.
\]
Hence
\[
\mathbb{E}[X^2]
=\sum_{b=0}^{9}2^{2b}\,\Pr(B_b=1)
\;+\;\sum_{b\neq c}2^b2^c\,\Pr(B_b=1\wedge B_c=1).
\]

---

### 2. XOR‐parity of independent Bernoullis

Each \(B_b\) is the XOR (mod 2 sum) of those bits of the selected \(a_i\).  Concretely, if
\[
G_b=\{\,i: \text{the $b$-th bit of }a_i\text{ is }1\},
\]
and each \(i\in G_b\) is chosen with probability \(p_i/10000\), then
\[
B_b \;=\;\bigoplus_{i\in G_b} Y_i,
\]
where \(Y_i\) are independent Bernoulli\((p_i/10000)\).  A standard fact about the XOR of independent Bernoulli’s says
\[
\Pr\bigl(\bigoplus_i Y_i = 1\bigr)
=\frac{1-\prod_i(1-2p_i/10000)}{2}.
\]
Define for convenience
\[
D_i \;=\;1 - 2\,(p_i/10000)\pmod{10^9+7},
\]
so that
\[
\Pr(B_b=1)
=\frac{1 - \prod_{i\in G_b}D_i}{2}.
\]

Likewise, for two bits \(b\neq c\), one shows that the joint probability
\(\Pr(B_b=1\wedge B_c=1)\)
can be written in terms of three such products.  Let
\[
A_b \;=\;\prod_{i\in G_b}D_i,
\qquad
A_c \;=\;\prod_{i\in G_c}D_i,
\]
and let
\[
H_{b,c}
=\{\,i: \text{the $b$-th bit}\oplus\text{the $c$-th bit of }a_i=1\}
\]
be the symmetric‐difference set of \(G_b\) and \(G_c\).  Set
\[
B_{b,c}
=\prod_{i\in H_{b,c}}D_i.
\]
A small parity‐calculation shows
\[
\Pr(B_b=1\wedge B_c=1)
=\frac{\,1 - A_b - A_c + B_{b,c}\,}{4}.
\]

---

### 3. Putting it together

Let \(\mathrm{inv2}=(10^9+7+1)/2\) and \(\mathrm{inv4}=\mathrm{inv2}^2\pmod{10^9+7}\), and precompute powers of 2 up to \(2^{18}\).  Then

1.  Compute \(D_i\) for each element,
2.  Maintain arrays
   \[
     A[0\ldots9]\quad\text{and}\quad B[0\ldots9][0\ldots9]
   \]
   all initialized to 1 modulo \(10^9+7\).
3.  For each element \(i\) with bit‐mask \(m=a_i\), update
   ```
   for b in 0..9:
     if ((m>>b)&1)==1:
       A[b] = A[b]*D[i] mod
   for 0<=b<c<=9:
     if (((m>>b)&1)^( (m>>c)&1))==1:
       B[b][c] = B[b][c]*D[i] mod
   ```
4.  Finally compute
   ```
   ans = 0
   // the diagonal i=j part
   for b in 0..9:
     term = 2^{2b} * (1 - A[b]) * inv2  mod
     ans = (ans + term) mod
   // the off-diagonal i≠j part
   for b in 0..9:
     for c in 0..9:
       if (b==c) continue
       if (b<c) X = B[b][c]; else X = B[c][b];
       num = (1 - A[b] - A[c] + X) mod
       term = 2^{b+c} * num * inv4 mod
       ans = (ans + term) mod
   ```
5.  Print `ans`.

All loops are tiny (10×10=100 pairs) except for the per‐element update which is \(O(45)\) per element, for a grand total of about \(2\times10^5\cdot 45\approx9\times10^6\) multiplications, which fits easily in the 4 s time limit.

---

```java
import java.io.*;
import java.util.*;

public class Main {
    static final int MOD = 1_000_000_007;

    // fast exponentiation mod
    static long modPow(long a, long e) {
        long res = 1 % MOD;
        a %= MOD;
        while (e > 0) {
            if ((e & 1) == 1) res = (res * a) % MOD;
            a = (a * a) % MOD;
            e >>= 1;
        }
        return res;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out);

        // Precompute inverses and powers of 2
        long inv10000 = modPow(10000, MOD - 2);
        long inv2 = (MOD + 1) / 2;
        long inv4 = (inv2 * inv2) % MOD;
        long[] pow2 = new long[20];
        pow2[0] = 1;
        for (int i = 1; i < pow2.length; i++) {
            pow2[i] = (pow2[i - 1] * 2) % MOD;
        }

        int t = Integer.parseInt(br.readLine().trim());
        while (t-- > 0) {
            int n = Integer.parseInt(br.readLine().trim());
            int[] a = new int[n];
            int[] p = new int[n];

            StringTokenizer stA = new StringTokenizer(br.readLine());
            for (int i = 0; i < n; i++) {
                a[i] = Integer.parseInt(stA.nextToken());
            }
            StringTokenizer stP = new StringTokenizer(br.readLine());
            for (int i = 0; i < n; i++) {
                p[i] = Integer.parseInt(stP.nextToken());
            }

            // A[b] = product of (1-2p_i) over those i with b-th bit = 1
            // B[b][c] = product of (1-2p_i) over those i where exactly one of bits b,c is 1
            long[] A = new long[10];
            long[][] B = new long[10][10];
            Arrays.fill(A, 1L);
            for (int i = 0; i < 10; i++) {
                Arrays.fill(B[i], 1L);
            }

            // Build A and B
            for (int i = 0; i < n; i++) {
                long prob = (p[i] * inv10000) % MOD;        // p_i / 10000 mod
                long D = (1 - 2 * prob) % MOD;              // 1 - 2*p_i
                if (D < 0) D += MOD;

                int mask = a[i];
                // update A
                for (int b = 0; b < 10; b++) {
                    if (((mask >> b) & 1) == 1) {
                        A[b] = (A[b] * D) % MOD;
                    }
                }
                // update B for b<c
                for (int b = 0; b < 10; b++) {
                    int bitb = (mask >> b) & 1;
                    for (int c = b + 1; c < 10; c++) {
                        int bitc = (mask >> c) & 1;
                        if ((bitb ^ bitc) == 1) {
                            B[b][c] = (B[b][c] * D) % MOD;
                        }
                    }
                }
            }

            // Compute the expectation
            long ans = 0;

            // diagonal terms i=j
            for (int b = 0; b < 10; b++) {
                long term = ((1 - A[b]) % MOD + MOD) % MOD;
                term = (term * inv2) % MOD;
                term = (term * pow2[2 * b]) % MOD;
                ans = (ans + term) % MOD;
            }

            // off-diagonal terms i != j
            for (int b = 0; b < 10; b++) {
                for (int c = 0; c < 10; c++) {
                    if (b == c) continue;
                    long Ab = A[b], Ac = A[c];
                    long Bbc = (b < c ? B[b][c] : B[c][b]);
                    long num = (1 - Ab - Ac + Bbc) % MOD;
                    if (num < 0) num += MOD;
                    long term = (pow2[b + c] * num) % MOD;
                    term = (term * inv4) % MOD;
                    ans = (ans + term) % MOD;
                }
            }

            out.println(ans);
        }

        out.flush();
    }
}
```

**Explanation of Key Steps**

1.  **Bit‐decomposition**  
    Every random XOR \(X\) can be written as  
    \[
      X = \sum_{b=0}^{9} 2^b\,B_b,
    \]
    where \(B_b\in\{0,1\}\) is the parity of the \(b\)-th bits of the chosen \(a_i\).  

2.  **Second moment**  
    \[
      X^2
      = \sum_{b}2^{2b}B_b
        \;+\;
        \sum_{b\neq c}2^b2^c\,B_b\,B_c,
    \]
    so we need
    \(\Pr(B_b=1)\) for each \(b\) and \(\Pr(B_b=1\wedge B_c=1)\) for \(b\neq c\).

3.  **XOR of independent Bernoullis**  
    If we XOR independent Bernoulli\((p_i)\) variables, the probability of an odd result is
    \[
      \frac{1 - \prod_i(1-2p_i)}{2}.
    \]
    We set 
    \[
      D_i = 1-2\,\frac{p_i}{10000}\pmod{10^9+7},
    \]
    and accumulate products of the relevant \(D_i\) into arrays \(A[b]\) and \(B[b][c]\).

4.  **Putting it all together**  
    Finally we sum up the diagonal terms \(\sum_b 2^{2b}\Pr(B_b=1)\) and the off‐diagonal terms \(\sum_{b\neq c}2^b2^c\Pr(B_b=1\wedge B_c=1)\), all under modulo arithmetic.

This runs in \(O(n\cdot 45 + 10^2)\approx 9\times10^6\) multiplications in the worst case, well within the 4 s limit.