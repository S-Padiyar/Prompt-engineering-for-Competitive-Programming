**Analysis**

We have \(n\) islands in a line, plus \(m\) “alternative” one‐way bridges from a lower‐indexed island \(u\) to a higher‐indexed island \(v\).  Bessie can only use the unit “main” bridges \(i\to i+1\), while Elsie can use both the main bridges and any of the \(m\) extra bridges.  All bridges go from smaller index to larger index.  

-  Bessie starts on island \(s\), Elsie on island \(1\).
-  They move in alternating turns, Bessie first. 
-  On your turn, if you are on island \(i\) you must take _one_ outgoing bridge to some \(j>i\), then island \(i\) “collapses” (and so do all bridges touching \(i\)).  If you have no outgoing bridges, you are eliminated.  
-  If you leave an island and your opponent was _also_ on that island, that opponent is eliminated immediately.
-  The first cow to reach island \(n\) _wins_; ties cannot occur (someone always reaches first or the other has been eliminated).  

We must decide for each \(1\le s\le n-1\) (Bessie’s starting island) whether Bessie can force a win (print ‘1’) or Elsie can force a win (print ‘0’).

---

**Key observations**

1.  **Bessie’s path is fixed**: from \(s\) she must march along the main bridges
   \[
      s \;\to\; s+1\;\to\cdots\to\;n,
   \]
   one step per her turn.  It takes her \((n-s)\) moves, and since her moves occur on turns \(1,3,5,\dots\), she arrives at island \(n\) exactly on global turn 
   \[
      T_B = 2\,(n-s)\;-\;1.
   \]

2.  **Elsie’s best race** is the shortest‐path (in edges) from \(1\) to \(n\) in the directed acyclic graph (the main chain plus the extras).  A standard BFS gives us 
   \[
     \mathrm{dist}[i] \;=\;\text{minimum \# of edges from 1 to }i.
   \]
   If Elsie uses a shortest‐path of length \(d=\mathrm{dist}[n]\), she arrives on global turn 
   \[
     T_E \;=\;2d.
   \]
   For Elsie _to beat_ Bessie on _the same island_ \(i\), we would need 
   \[
     2d \;<\;2(n-s)-1,
   \]
   i.e.\ \(d\le (n-s)-1\).  This already tells us: if Elsie can reach \(n\) in at most 
   \[
     (n-s)-1
   \]
   edges, then Elsie arrives _before_ Bessie and so Elsie wins.  

3.  **The “collapse‐and‐ambush”** effect could in principle let Elsie intercept Bessie on some island \(i<n\) and kill her by moving off \(i\).  But it turns out that, because Bessie _must_ collapse island \(s\) on her very first turn, then \(s+1\) on her second turn, etc., any island on Bessie’s main path
   \[
     s \to s+1\to\cdots
   \]
   is destroyed _before_ Elsie can ever use it, unless Elsie jumps over it in one direct alternative move.  A shortest‐path BFS from 1 already models the _least\_ number of edges Elsie needs to jump to each island, and the only subtlety is that Elsie must not “land” on a collapsed island.  One can show that this “no‐land” constraint exactly forces us to look at, for each vertex \(i\), the _minimum predecessor_ of \(i\) on any shortest path.  

4.  **Computing the forbidden intervals**  
   -  Let \(\mathrm{dist}[i]\) = BFS distance of \(i\) from 1.  
   -  Among _all_ shortest paths (length \(\mathrm{dist}[i]\)) from 1 to \(i\), let
      \[
        \mathrm{predMin}[i] 
        \;=\;
        \min\{\,u\mid \text{there is a shortest‐path }1\to\cdots\to u\to i\}\!,
      \]
     i.e.\ the _smallest_ index of the vertex just _before_ \(i\) on some shortest path.  

   On such a shortest path of length \(d=\mathrm{dist}[i]\), the second‐to‐last vertex is \(\ge\mathrm{predMin}[i]\).  One can show that Elsie can _intercept_ Bessie on island \(i\) exactly for starting‐positions \(s\) in the _integer interval_
   \[
     \bigl[\;\mathrm{predMin}[i]+1 \;,\; i \;-\;\mathrm{dist}[i]\;-\;1\bigl].
   \]
   Whenever that interval is nonempty and includes some \(s\), Elsie can either  
   - jump onto \(i\) in \(\mathrm{dist}[i]\) edges _before_ Bessie does, or  
   - land on the unique predecessor \(\mathrm{predMin}[i]\) and on her next move kill Bessie by collapsing \(i\).  

   Hence for each \(i\) with a valid interval \([L_i,R_i]\), _any_ \(s\in[L_i,R_i]\) is a losing start for Bessie.  

5.  Finally we do a range‐addition / prefix‐sum sweep over all these intervals.  We keep an integer array \(\text{diff}[\,]\) of length \(n+2\) initialized to 0.  For each valid interval \([L,R]\) with \(1\le L\le R\le n-1\) we do
   \[
     \text{diff}[L]++,\quad \text{diff}[R+1]--.
   \]
   Then a single pass accumulates \(\text{cover}[s]=\sum_{j\le s}\text{diff}[j]\).  Wherever \(\text{cover}[s]>0\), it means \(s\) lies in _some_ losing interval \(\Rightarrow\) Bessie loses \(\Rightarrow\) print '0'.  Otherwise print '1'.

Overall each test case is
- BFS in \(O(n+m)\),  
- one more walk over edges in \(O(n+m)\) to compute \(\mathrm{predMin}[\ ]\),  
- then \(O(n)\) to build the diff array and \(O(n)\) to output.  

That comfortably fits under \(2\times10^5\) total \(n+m\).

---

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out);
        StringTokenizer tok = new StringTokenizer(in.readLine());
        int t = Integer.parseInt(tok.nextToken());

        // We will re-allocate per test since sum(n+m) ≤ 2e5.
        while (t-- > 0) {
            tok = new StringTokenizer(in.readLine());
            int n = Integer.parseInt(tok.nextToken());
            int m = Integer.parseInt(tok.nextToken());

            // Build adjacency list for the DAG (main chain + m extras)
            ArrayList<Integer>[] adj = new ArrayList[n+1];
            for (int i = 1; i <= n; i++) {
                adj[i] = new ArrayList<>();
            }
            // main bridges i->i+1
            for (int i = 1; i < n; i++) {
                adj[i].add(i+1);
            }
            // extra bridges
            for (int i = 0; i < m; i++) {
                tok = new StringTokenizer(in.readLine());
                int u = Integer.parseInt(tok.nextToken());
                int v = Integer.parseInt(tok.nextToken());
                adj[u].add(v);
            }

            // 1) BFS from 1 to compute dist[i] = min #edges from 1 to i
            final int INF = n + 5;
            int[] dist = new int[n+1];
            Arrays.fill(dist, INF);
            dist[1] = 0;
            Deque<Integer> dq = new ArrayDeque<>();
            dq.add(1);
            while (!dq.isEmpty()) {
                int u = dq.poll();
                for (int v : adj[u]) {
                    if (dist[v] == INF) {
                        dist[v] = dist[u] + 1;
                        dq.add(v);
                    }
                }
            }

            // 2) Group nodes by dist
            int maxd = 0;
            for (int i = 1; i <= n; i++) {
                if (dist[i] < INF && dist[i] > maxd) {
                    maxd = dist[i];
                }
            }
            ArrayList<Integer>[] byDist = new ArrayList[maxd+1];
            for (int d = 0; d <= maxd; d++) {
                byDist[d] = new ArrayList<>();
            }
            for (int i = 1; i <= n; i++) {
                if (dist[i] < INF) {
                    byDist[dist[i]].add(i);
                }
            }

            // 3) For each i, predMin[i] = smallest u that appears just before i on some shortest path
            int[] predMin = new int[n+1];
            Arrays.fill(predMin, n+1);
            predMin[1] = 0;  // dummy

            // process in increasing dist
            for (int d = 0; d < maxd; d++) {
                for (int u : byDist[d]) {
                    for (int v : adj[u]) {
                        // only edges that go to dist+1
                        if (dist[v] == d + 1) {
                            // candidate predecessor is 'u'
                            if (u < predMin[v]) {
                                predMin[v] = u;
                            }
                        }
                    }
                }
            }

            // 4) Build difference array for intervals [L_i,R_i]
            //    where L_i = predMin[i]+1, R_i = i-dist[i]-1, if L_i <= R_i
            int[] diff = new int[n+2];
            for (int i = 2; i <= n; i++) {
                if (dist[i] == INF) continue;     // unreachable
                int L = predMin[i] + 1;
                int R = i - dist[i] - 1;
                if (L <= R && L <= n-1 && R >= 1) {
                    if (L < 1) L = 1;
                    if (R > n-1) R = n-1;
                    diff[L]++;
                    diff[R+1]--;
                }
            }

            // 5) Prefix-sum and output
            StringBuilder ans = new StringBuilder(n-1);
            int cover = 0;
            for (int s = 1; s < n; s++) {
                cover += diff[s];
                // cover>0 => s in some losing-interval => Bessie loses => '0'
                // cover==0 => Bessie never intercepted => '1'
                ans.append(cover > 0 ? '0' : '1');
            }

            out.println(ans);
        }

        out.flush();
    }
}
```

**Explanation of the main steps**

1. **BFS to find `dist[i]`**  
   We form an unweighted directed graph with the “main” edges \(i\to i+1\) and the \(m\) extra edges.  A single BFS from node 1 gives `dist[i] =` the minimum number of edges from 1 to \(i\).  

2. **Find `predMin[i]`**  
   Among _all_ shortest paths of length `dist[i]` from 1 to \(i\), let  
   \[
     \mathrm{predMin}[i]\;=\;\min\{\,u : \text{there is a shortest path }1\to\cdots\to u\to i\}\!.
   \]  
   This is computed by a simple DP over distance‐layers: for each layer \(d\), for each node \(u\) with `dist[u] = d`, we relax all edges \(u\to v\) that go to `dist[v] = d+1` by  
   ``` 
     predMin[v] = min(predMin[v], u)
   ```

3. **Derive each losing interval**  
   A standard combinatorial‐game / “collapse” argument shows that _any_ starting \(s\) in  
   \[
     \bigl[\mathrm{predMin}[i]{+}1\,,\,i - \mathrm{dist}[i] - 1\bigr]
   \]  
   is one in which Elsie can either  
   - intercept island \(i\) _before_ Bessie gets there, or  
   - land on the unique shortest‐path predecessor \(\mathrm{predMin}[i]\) and kill Bessie by collapsing \(i\) next.  

4. **Mark intervals via a difference array**  
   We build an array `diff[1..n]` so that adding +1 at `L` and –1 at `R+1` marks the half‐open interval \([L,R]\).  A final prefix‐sum gives at each \(s\) the count of how many intervals cover \(s\).  If that count is positive, Bessie _loses_ (we print ‘0’); if zero, Bessie _wins_ (print ‘1’).  

Overall, each test runs in \(O(n+m)\) time (BFS + one more pass over edges + one pass to accumulate intervals), which easily handles \(\sum(n+m)\le2\times10^5\).