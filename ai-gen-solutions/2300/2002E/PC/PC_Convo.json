[
  {
    "timestamp": "2025-07-24T05:56:22.651123",
    "role": "user",
    "content": "E. Cosmic Rays\n\ntime limit per test2 seconds\n\nmemory limit per test512 megabytes\n\nGiven an array of integers s1,s2,…,sl\n\n, every second, cosmic rays will cause all si\n\n such that i=1\n\n or si≠si−1\n\n to be deleted simultaneously, and the remaining parts will be concatenated together in order to form the new array s1,s2,…,sl′\n\n.\n\n\n\nDefine the strength of an array as the number of seconds it takes to become empty.\n\n\n\nYou are given an array of integers compressed in the form of n\n\n pairs that describe the array left to right. Each pair (ai,bi)\n\n represents ai\n\n copies of bi\n\n, i.e. bi,bi,⋯,biai times\n\n.\n\n\n\nFor each i=1,2,…,n\n\n, please find the strength of the sequence described by the first i\n\n pairs.\n\n\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n\n (1≤t≤104\n\n). The description of the test cases follows.\n\n\n\nThe first line of each test case contains a single integer n\n\n (1≤n≤3⋅105\n\n) — the length of sequence a\n\n.\n\n\n\nThe next n\n\n lines contain two integers each ai\n\n, bi\n\n (1≤ai≤109,0≤bi≤n\n\n) — the pairs which describe the sequence.\n\n\n\nIt is guaranteed that the sum of all n\n\n does not exceed 3⋅105\n\n.\n\n\n\nIt is guaranteed that for all 1≤i<n\n\n, bi≠bi+1\n\n holds.\n\n\n\nOutput\n\nFor each test case, print one line containing n\n\n integers — the answer for each prefix of pairs.\n\n\n\nExample\n\nInputCopy\n\n4\n\n4\n\n2 0\n\n1 1\n\n3 0\n\n5 1\n\n6\n\n4 6\n\n1 3\n\n4 6\n\n4 0\n\n7 6\n\n6 3\n\n7\n\n9 0\n\n7 1\n\n5 0\n\n7 1\n\n9 0\n\n1 1\n\n2 0\n\n10\n\n10 7\n\n4 9\n\n2 2\n\n7 9\n\n2 8\n\n8 5\n\n11 7\n\n15 5\n\n12 7\n\n4 0\n\nOutputCopy\n\n2 2 4 5 \n\n4 4 7 7 10 10 \n\n9 9 9 9 9 9 10 \n\n10 10 10 10 10 10 12 15 15 15 \n\nNote\n\nIn the first test case, for the prefix of length 4\n\n, the changes will be [0,0,1,0,0,0,1,1,1,1,1]→[0,0,0,1,1,1,1]→[0,0,1,1,1]→[0,1,1]→[1]→[]\n\n, so the array becomes empty after 5\n\n seconds.\n\n\n\nIn the second test case, for the prefix of length 4\n\n, the changes will be [6,6,6,6,3,6,6,6,6,0,0,0,0]→[6,6,6,6,6,6,0,0,0]→[6,6,6,6,6,0,0]→[6,6,6,6,0]→[6,6,6]→[6,6]→[6]→[]\n\n, so the array becomes empty after 7\n\n seconds.\n\nUse Java."
  },
  {
    "timestamp": "2025-07-24T06:07:47.360648",
    "role": "assistant",
    "content": "**Analysis**\n\nWe have a run‐length encoded array of “runs” \n\\[\n( a_1,b_1 ),( a_2,b_2 ),\\dots,( a_n,b_n),\n\\]\nwhere each \\((a_i,b_i)\\) represents \\(b_i\\) repeated \\(a_i\\) times, and \\(b_i\\ne b_{i+1}\\).  When we expand the whole array and label its entries\n\\[\ns_1,s_2,\\dots,s_L,\n\\]\nthe cosmic‐ray process at each second \\(t\\) deletes all positions \\(i\\) which are at the start of a (current) contiguous block, i.e. \\(i=1\\) or \\(s_i\\ne s_{i-1}\\).  Equivalently, each “run” of equal values shrinks by 1 at every step; when it hits zero length, it disappears, and if it disappears between two runs of the same value, those two runs merge (and continue to shrink together thereafter).\n\nWe must answer—in \\(O(n\\log n)\\) total for each test—​the time until full deletion (the “strength”) of the array consisting of the first \\(i\\) runs, for all \\(i=1,\\dots,n\\).\n\nKey observations:\n\n 1.  **Death time of a run**.  If a run of length \\(A\\) stands alone, it disappears after \\(A\\) seconds.  \n 2.  **Merging two runs** of the same value, with death‐times \\(D_1\\) and \\(D_2\\), **only** occurs at the moment the intervening runs all have died.  If those intervening runs die at time \\(T_{\\rm mid}\\), both of the same‐value runs must still survive at \\(T_{\\rm mid}\\); i.e.\\ \\(T_{\\rm mid}<D_1\\) and \\(T_{\\rm mid}<D_2\\).  At that moment they become adjacent and merge into one run whose new “remaining length” is\n\\[\n(D_1 - T_{\\rm mid}) + (D_2 - T_{\\rm mid}),\n\\]\nso its new death‐time becomes\n\\[\nT_{\\rm mid}\\;+\\;(D_1-T_{\\rm mid})+(D_2-T_{\\rm mid})\n\\;=\\;D_1+D_2 - T_{\\rm mid}\\,.\n\\]\n 3.  If \\(T_{\\rm mid}\\ge \\min(D_1,D_2)\\), then at time \\(T_{\\rm mid}\\) at least one of those two runs has already died, so **no merge** ever takes place.\n\nWe process runs \\((a_i,b_i)\\) in order \\(i=1,2,\\dots,n\\), maintaining:\n\n– `lastPos[c]`: the index of the **still‐alive** run of color \\(c\\) that is farthest to the right (if any).  \n– `best[c]`: the **death time** of that run.  \n– A segment tree (or Fenwick tree) that stores for each run position \\(k\\), the death time `death[k]` of the run placed at \\(k\\).  This lets us compute\n\\[\nT_{\\rm mid}\n=\n\\max_{k\\in[j+1..i-1]} \\,\\text{death}[k]\n\\]\nin \\(O(\\log n)\\) whenever run \\(i\\) has the same color \\(b_i\\) as some earlier run at position \\(j\\).  If \\(j+1>i-1\\) we take \\(T_{\\rm mid}=0\\).\n\nWe also keep a running array `dp[i]` = the strength of the prefix of \\(i\\) runs = \\(\\max(dp[i-1],\\,\\text{death}[i])\\).  This is simply the maximum death time among all runs seen so far.\n\nWhen we insert a new run \\((a_i,b_i)\\) at index \\(i\\), let \\(c=b_i\\).  \n\n1.  If `lastPos[c]==0`, this is the first run of color \\(c\\).  \n   – We set `death[i]=a_i`, `best[c]=a_i`, `lastPos[c]=i`.\n\n2.  Otherwise let \\(j=\\text{lastPos}[c]\\) and \\(L=\\text{best}[c]\\).  Compute \n   \\[\n   T_{\\rm mid}\n   = \n   \\begin{cases}\n     \\max(\\text{death}[j+1..i-1]) & j+1\\le i-1,\\\\\n     0 & \\text{otherwise}.\n   \\end{cases}\n   \\]\n   We then have three cases:\n\n   a)  **Merge** if \\(T_{\\rm mid}<L\\) and \\(T_{\\rm mid}<a_i\\).  Then\n   \\[\n     \\text{death}[i]\\;=\\;L\\;+\\;a_i\\;-\\;T_{\\rm mid},\n     \\quad\n     \\text{best}[c]\\;=\\;\\text{death}[i],\n     \\quad\n     \\text{lastPos}[c]\\;=\\;i.\n   \\]\n\n   b)  **No merge**, but the _old_ run of color \\(c\\) has bigger death time (\\(L>a_i\\)).\n      Then we set \n      \\[\n        \\text{death}[i]=a_i,\n      \\]\n      but leave \\(\\text{best}[c]=L\\) and \\(\\text{lastPos}[c]=j\\) unchanged.  \n      That is, the old run outlives the new one, so future merges (with color \\(c\\)) still refer to the old run at \\(j\\).\n\n   c)  **No merge**, and the _new_ run of color \\(c\\) lives at least as long as the old one (\\(a_i\\ge L\\)).  \n      Then\n      \\[\n        \\text{death}[i]=a_i,\n        \\quad\n        \\text{best}[c]=a_i,\n        \\quad\n        \\text{lastPos}[c]=i.\n      \\]\n      The new run will outlive the old one (or tie it), so future merges refer to the new one.\n\nAfter deciding `death[i]`, we update the segment tree at position \\(i\\) to `death[i]`, and set\n\\[\n  dp[i]\\;=\\;\\max(dp[i-1],\\,\\text{death}[i]).\n\\]\nAt the end, \\(\\{dp[1],dp[2],\\dots,dp[n]\\}\\) is exactly the sequence of strengths of the first \\(i\\) runs.\n\nBuilding and querying a segment‐tree for range‐maximum over \\(1\\le k\\le n\\) takes \\(O(\\log n)\\) per update or query, and we do just one query and one update per run.  Thus the total time per test is \\(O(n\\log n)\\), which is fine for \\(\\sum n\\le 3\\cdot10^5\\).  \n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class SegTree {\n        int n;\n        long[] st;\n        SegTree(int _n) {\n            n = 1;\n            while (n < _n) n <<= 1;\n            st = new long[2*n];\n        }\n        // point update: set position p (1-based) to value v\n        void update(int p, long v) {\n            p += n - 1;\n            st[p] = v;\n            for (p >>= 1; p >= 1; p >>= 1) {\n                st[p] = Math.max(st[2*p], st[2*p+1]);\n            }\n        }\n        // range max on [L..R], 1-based\n        long query(int L, int R) {\n            if (L > R) return 0;\n            L += n - 1;\n            R += n - 1;\n            long ans = 0;\n            while (L <= R) {\n                if ((L & 1) == 1) ans = Math.max(ans, st[L++]);\n                if ((R & 1) == 0) ans = Math.max(ans, st[R--]);\n                L >>= 1;\n                R >>= 1;\n            }\n            return ans;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(br.readLine().trim());\n        StringBuilder out = new StringBuilder();\n\n        while (t-- > 0) {\n            int n = Integer.parseInt(br.readLine().trim());\n            int[] a = new int[n+1], b = new int[n+1];\n            for (int i = 1; i <= n; i++) {\n                StringTokenizer st = new StringTokenizer(br.readLine());\n                a[i] = Integer.parseInt(st.nextToken());\n                b[i] = Integer.parseInt(st.nextToken());\n            }\n\n            // lastPos[c] = position of the 'alive' run of color c\n            // best[c]    = its death-time\n            int[] lastPos = new int[n+1];\n            long[] best   = new long[n+1];\n            long[] dp     = new long[n+1];\n            long[] death  = new long[n+1];\n\n            SegTree seg = new SegTree(n);\n\n            for (int i = 1; i <= n; i++) {\n                int col = b[i];\n                long length = a[i];\n\n                if (lastPos[col] == 0) {\n                    // first run of this color\n                    death[i]    = length;\n                    best[col]   = length;\n                    lastPos[col]= i;\n                } else {\n                    int j = lastPos[col];\n                    long L = best[col];\n                    long midMax = seg.query(j+1, i-1);\n\n                    // case (a): possible merge?\n                    if (midMax < L && midMax < length) {\n                        long merged = L + length - midMax;\n                        death[i]    = merged;\n                        best[col]   = merged;\n                        lastPos[col]= i;\n                    } else {\n                        // no merge\n                        if (L > length) {\n                            // old run outlives new\n                            death[i] = length;\n                            // best[col], lastPos[col] unchanged\n                        } else {\n                            // new run outlives (or ties) old\n                            death[i]    = length;\n                            best[col]   = length;\n                            lastPos[col]= i;\n                        }\n                    }\n                }\n\n                // record it in the segment tree\n                seg.update(i, death[i]);\n                // strength of prefix i\n                dp[i] = Math.max(dp[i-1], death[i]);\n            }\n\n            // output\n            for (int i = 1; i <= n; i++) {\n                out.append(dp[i]).append(i==n?'\\n':' ');\n            }\n        }\n\n        System.out.print(out);\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1.  **Death times**  \n    We keep an array `death[i]` = the time at which the run we place at index \\(i\\) finally disappears (possibly after merging).\n\n2.  **Tracking “alive” runs per color**  \n    - `lastPos[c]` holds the index of the current still‐alive run of color \\(c\\).  \n    - `best[c]` holds that run’s death time.  \n\n3.  **Merging logic**  \n    When we insert a new run \\((a_i,b_i)\\) of color \\(c\\):  \n    - If we’ve never seen \\(c\\) before, it simply lives \\(a_i\\) seconds.  \n    - Otherwise let \\(j=\\text{lastPos}[c]\\), \\(L=\\text{best}[c]\\).  We compute  \n      \\[\n        T_{\\rm mid} = \\max(\\text{death}[\\,j+1..i-1]),\n      \\]\n      the time when the last run between them dies.  \n    - If \\(T_{\\rm mid}<L\\) and \\(T_{\\rm mid}<a_i\\), both old and new runs are alive at \\(T_{\\rm mid}\\), so they merge and the merged death time is\n      \\[\n        L + a_i - T_{\\rm mid}.\n      \\]\n      We record that as `death[i]` and make it the new `best[c]`, `lastPos[c]=i`.  \n    - Otherwise there is **no** merge:\n      - If \\(L>a_i\\), the old run outlives the new one, so we keep `best[c]=L`, `lastPos[c]=j`.  \n      - If \\(a_i\\ge L\\), the new run outlives (or ties) the old, so we set `best[c]=a_i`, `lastPos[c]=i`.  \n\n4.  **Segment‐tree**  \n    We use a classic segment tree of size \\(n\\) to support  \n    - point‐updates `st.update(i, death[i])`,  \n    - range‐maximum `st.query(L,R)`.  \n    Each in \\(O(\\log n)\\).  \n\n5.  **Prefix strength**  \n    Finally `dp[i] = max(dp[i-1], death[i])` is the time by which *all* runs among the first \\(i\\) are gone; that is the “strength” of the prefix of length \\(i\\).\n\nSince each of the \\(n\\) runs does just one query and one update on the segment tree, the total is \\(O(n\\log n)\\) per test, well within the problem’s limits."
  }
]