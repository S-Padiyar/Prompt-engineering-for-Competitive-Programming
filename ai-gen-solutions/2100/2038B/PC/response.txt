**Analysis**

We have an array a of length n.  One allowed operation is:

  • pick an index i  
  • do  
     a[i] -= 2  
     a[i+1] += 1  
    (with indices taken cyclically, i.e. if i=n then i+1 becomes 1)

We want—in the end—to have all entries equal to some non‐negative integer k.  Each such operation decreases the total sum of the array by 1, so if initially

 S = ∑ᵢ a[i],  

and we perform m operations, the final sum is S – m.  Since the n entries are all equal to k, we must have

  S – m = n·k,  

hence

  m = S – n·k.  

We wish to make all entries equal, and we want to minimize m.  Since m≥0, we must choose an integer k≤⌊S/n⌋, and

  m = S – n·k.  

Clearly to minimize m we would try to push k as large as possible—i.e. k=⌊S/n⌋—and then check if it is actually possible to level out the array to that value k.  If it is possible, m=S–n·⌊S/n⌋ is the answer; otherwise no smaller k can do better in terms of fewer operations, and we report –1.

So the algorithm is:

1.  Compute  
     S = ∑₁ⁿ a[i],  
    let  
     k = S / n     (integer division),  
     neededOps = S – n·k.  

2.  Form  
     c[i] = a[i] – k,  
    so that ∑c[i]=neededOps≥0.

3.  We must check whether, by a sequence of the allowed “–2 here, +1 next” moves, we can drive all c[i] to 0 simultaneously.  

   A well-known trick is to note that the total ∑c[i]≥0 guarantees that there *is* some cyclic starting position from which a “prefix‐sum-never-drops-below-0” argument holds (a classical “gas‐station” argument).  Concretely:

   • We scan c[0..n–1] once, maintaining a running sum cur.  
   • Whenever cur+drops<0, we reset cur=0 and declare the next index our new “start.”  
   • By the end, we have found a start index s (0≤s<n) such that, if you cyclically lay out the c[i] beginning at s, all partial sums are ≥0.

4.  Once we have a valid start s, we *simulate* a single pass of the array from i=s, s+1, …, s+n–1 (mod n).  We carry a variable prev, initially 0, which represents how many “+1’s” have been carried in from the previous slot’s operations.  At each slot i:

     cp = c[i] + prev
     if cp<0 then fail immediately (we couldn’t fill a deficit here)
     let ops = cp/2  (each operation here removes 2 from cp and generates 1 to carry)
     totalOps += ops
     prev = ops

   After we do exactly n positions, every c[i] + whatever carry arrives must have been nonnegative, so we never had a negative deficit, and we only ever did integral operations.  

5.  At the end of that single sweep, two things must hold:

   (a) we never “fail” with cp<0  
   (b) the total number of operations we actually *used* ≔ totalOps must equal neededOps  

   if so, the answer is totalOps; otherwise it is impossible (–1).

This runs in O(n) per test.  Summed over all test cases, the total n≤2⋅10⁵, so it is perfectly fast.

Below is a Java implementation.

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        
        int t = Integer.parseInt(br.readLine().trim());
        StringBuilder sb = new StringBuilder();
        
        while (t-- > 0) {
            int n = Integer.parseInt(br.readLine().trim());
            long[] a = new long[n];
            st = new StringTokenizer(br.readLine());
            long sum = 0;
            for (int i = 0; i < n; i++) {
                a[i] = Long.parseLong(st.nextToken());
                sum += a[i];
            }
            
            // k = floor(sum / n), number of operations needed = sum - n*k
            long k = sum / n;
            long needed = sum - k * n;  // this is >= 0
            
            // Build c[i] = a[i] - k
            long[] c = new long[n];
            for (int i = 0; i < n; i++) {
                c[i] = a[i] - k;
            }
            
            // Find a start index s using the "gas station" trick
            long curr = 0;
            int start = 0;
            for (int i = 0; i < n; i++) {
                curr += c[i];
                if (curr < 0) {
                    curr = 0;
                    start = i + 1;
                }
            }
            if (start >= n) start = 0;  // wrap if needed
            
            // One pass simulation
            long prev = 0;
            long usedOps = 0;
            boolean ok = true;
            for (int tpos = 0; tpos < n; tpos++) {
                int idx = (start + tpos) % n;
                long cp = c[idx] + prev;
                if (cp < 0) {
                    ok = false;
                    break;
                }
                long ops = cp / 2;      // how many "–2 here, +1 next" we do
                usedOps += ops;
                prev = ops;             // that many +1's carry to the next slot
            }
            
            if (!ok || usedOps != needed) {
                sb.append("-1\n");
            } else {
                sb.append(usedOps).append('\n');
            }
        }
        
        System.out.print(sb);
    }
}
```

**Explanation of Key Steps**

1.  **Choosing k**  
    Since each operation reduces the total sum by 1, if we do exactly m operations, the final sum is S–m, which must equal n·k when all n entries are the same integer k.  Thus

       m = S – n·k  ≥ 0  

    and to make m as small as possible we take the largest integer k≤S/n, i.e. k=⌊S/n⌋.

2.  **Reduction to an array c**  
    Write c[i]=a[i]–k.  Then ∑c[i]=S–n·k=m≥0.  We want by our “–2 here, +1 next” moves to drive all c[i] to 0.  Observe that an operation at i exactly takes 2 from c[i] and adds 1 to c[i+1].

3.  **Finding a non‐negative prefix rotation**  
    A classical lemma (“gas station” or “circular sequence of gains/losses”) says: if the total sum of c is non‐negative then there is some cyclic shift of the c array so that *every* prefix is non‐negative.  Equivalently, there is a start index s so that
     
       c[s] + c[s+1] + … + c[s+t]  ≥ 0  for  t=0,1,…,n–1.

    We find that s in O(n) by scanning once and resetting whenever the partial sum would go negative.

4.  **One‐pass “greedy” simulation**  
    Starting at index s, we carry an integer prev = how many “+1’s” from the previous slot’s operations.  At slot i we see 

       c[i] + prev = current surplus

    if that is negative we cannot fill a deficit ⇒ fail.  
    Otherwise we can perform ops = (c[i]+prev)/2 operations at i, each removes 2 from the local surplus and creates 1 to carry on.  We accumulate those ops in usedOps, and set prev = ops to carry to the next index.  

    After exactly n steps, if we have neither failed nor used more/ fewer than the required m=S–n·k operations, we have shown we can indeed level the array to k in exactly usedOps=m steps.  If anything goes wrong, the answer is –1.

This runs in O(n) per test, which is fast enough for n total up to 2·10⁵.