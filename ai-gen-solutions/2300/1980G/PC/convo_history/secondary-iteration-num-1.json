[
  {
    "role": "user",
    "content": "G. Yasya and the Mysterious Tree\n\ntime limit per test2.5 seconds\n\nmemory limit per test512 megabytes\n\nYasya was walking in the forest and accidentally found a tree with n\n\n vertices. A tree is a connected undirected graph with no cycles.\n\n\n\nNext to the tree, the girl found an ancient manuscript with m\n\n queries written on it. The queries can be of two types.\n\n\n\nThe first type of query is described by the integer y\n\n. The weight of each edge in the tree is replaced by the bitwise exclusive OR of the weight of that edge and the integer y\n\n.\n\n\n\nThe second type is described by the vertex v\n\n and the integer x\n\n. Yasya chooses a vertex u\n\n (1≤u≤n\n\n, u≠v\n\n) and mentally draws a bidirectional edge of weight x\n\n from v\n\n to u\n\n in the tree.\n\n\n\nThen Yasya finds a simple cycle in the resulting graph and calculates the bitwise exclusive OR of all the edges in it. She wants to choose a vertex u\n\n such that the calculated value is maximum. This calculated value will be the answer to the query. It can be shown that such a cycle exists and is unique under the given constraints (independent of the choice of u\n\n). If an edge between v\n\n and u\n\n already existed, a simple cycle is the path v→u→v\n\n.\n\n\n\nNote that the second type of query is performed mentally, meaning the tree does not change in any way after it.\n\n\n\nHelp Yasya answer all the queries.\n\n\n\nInput\n\nThe first line contains an integer t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nThe descriptions of the test cases follow.\n\n\n\nThe first line of each test case contains two integers n\n\n, m\n\n (2≤n≤2⋅105\n\n, 1≤m≤2⋅105\n\n) — the number of vertices in the tree and the number of queries.\n\n\n\nThe next n−1\n\n lines of each test case contain three integers v\n\n, u\n\n, w\n\n (1≤v,u≤n\n\n, 1≤w≤109\n\n) — the ends of some edge in the tree and its weight.\n\n\n\nIt is guaranteed that the given set of edges forms a tree.\n\n\n\nThe next m\n\n lines of each test case describe the queries:\n\n\n\n^ y\n\n (1≤y≤109\n\n) — parameter of the first type query;\n\n? v\n\n x\n\n (1≤v≤n\n\n, 1≤x≤109\n\n) — parameters of the second type query.\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2⋅105\n\n. The same is guaranteed for m\n\n.\n\n\n\nOutput\n\nFor each test case, output the answers to the queries of the second type.\n\n\n\nExamples\n\nInputCopy\n\n2\n\n3 7\n\n1 2 1\n\n3 1 8\n\n^ 5\n\n? 2 9\n\n^ 1\n\n? 1 10\n\n^ 6\n\n? 3 1\n\n? 2 9\n\n5 6\n\n1 2 777\n\n3 2 2812\n\n4 1 16\n\n5 3 1000000000\n\n^ 4\n\n? 3 123\n\n? 5 1000000000\n\n^ 1000000000\n\n? 1 908070\n\n? 2 1\n\nOutputCopy\n\n13 15 11 10 \n\n1000000127 2812 999756331 999999756 \n\nInputCopy\n\n3\n\n8 4\n\n8 6 3\n\n6 3 4\n\n2 5 4\n\n7 6 2\n\n7 1 10\n\n4 1 4\n\n5 1 2\n\n^ 4\n\n^ 7\n\n? 7 8\n\n? 4 10\n\n5 6\n\n3 1 4\n\n2 3 9\n\n4 3 6\n\n5 2 10\n\n? 5 7\n\n^ 1\n\n^ 8\n\n? 4 10\n\n? 1 9\n\n? 3 6\n\n4 2\n\n2 1 4\n\n4 3 5\n\n2 3 4\n\n^ 13\n\n? 1 10\n\nOutputCopy\n\n14 13 \n\n13 8 11 11 \n\n10 \n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have a tree of \\(n\\) vertices with integer weights on the edges.  We must support two kinds of queries:\n\n1. **Global XOR update**  \n   We are given an integer \\(y\\) and we must replace _every_ edge‐weight \\(w\\) by \\(w\\;\\oplus\\;y\\).  These updates accumulate: if we apply \\(y_1\\), then \\(y_2\\), … then effectively every edge weight becomes\n   \\[\n     w_{\\rm new} \n     = w_{\\rm original}\\;\\oplus\\;(y_1\\;\\oplus\\;y_2\\;\\oplus\\;\\dots).\n   \\]\n   We maintain a single running XOR, call it `Ytot`, which is the XOR of all the \\(y\\)’s applied so far.\n\n2. **Max‐XOR‐cycle query**  \n   We are given a vertex \\(v\\) and an integer \\(x\\).  We imagine temporarily adding a new edge of weight \\(x\\) from \\(v\\) to some other vertex \\(u\\neq v\\).  This creates exactly one simple cycle in the graph.  The XOR of that cycle is\n   \\[\n     (\\text{XOR of the tree‐path from }v\\text{ to }u)\\;\\oplus\\;x.\n   \\]\n   We want to choose \\(u\\neq v\\) so as to **maximize** that cycle‐XOR, and output it.\n\nBecause the graph is a tree, if we root arbitrarily (say at 1) and let\n\n\\[\n  \\mathit{dist0}[u]\n  = \\bigl(\\text{XOR of original weights on the root‐to‐}u\\text{ path}\\bigr),\n\\]\nand let\n\\[\n  p[u]\\in\\{0,1\\}\n  \\;=\\;\n  (\\text{depth of \\(u\\) in that root} )\\bmod 2,\n\\]\nthen after we have applied a global XOR of `Ytot` to _all_ edges, the new XOR‐distance from the root to \\(u\\) becomes\n\\[\n  \\mathit{dist}[u]\n  =\n  \\mathit{dist0}[u]\n  \\;\\oplus\\;\n  \\bigl(p[u]\\times Y_{\\rm tot}\\bigr)\n  =\n  \\begin{cases}\n    \\mathit{dist0}[u], & p[u]=0,\\\\\n    \\mathit{dist0}[u]\\;\\oplus\\;Y_{\\rm tot}, & p[u]=1.\n  \\end{cases}\n\\]\n\nWhen we add an edge \\((v,u)\\) of weight \\(x\\), the XOR around the cycle is\n\\[\n  \\bigl(\\mathit{dist}[v]\\;\\oplus\\;\\mathit{dist}[u]\\bigr)\\;\\oplus\\;x.\n\\]\nSince \\(\\mathit{dist}[v]\\) is fixed for a query, maximizing that over \\(u\\neq v\\) is the same as\n\\[\n  \\max_{u\\neq v}\\;\\bigl(\\mathit{dist}[u]\\;\\oplus\\;T\\bigr),\n  \\quad\\text{where }T=\\mathit{dist}[v]\\oplus x.\n\\]\n\nThus each query \\(\"?~v~x\"\\) reduces to:\n  - Compute \\(T = \\mathit{dist}[v]\\oplus x\\).\n  - Find \\(\\max_{u\\neq v}\\bigl(\\mathit{dist}[u]\\oplus T\\bigr)\\).\n\nA classic data structure for “maximum XOR‐with‐a‐query‐value” is a binary _bit‐trie_ of the set of numbers \\(\\{\\mathit{dist}[u]\\}\\).  We would like to maintain all current \\(\\mathit{dist}[u]\\) in a trie so that a query “maximum XOR with \\(T\\)” takes \\(O(\\log C)\\) time (where \\(C\\) is the maximum bit‐width, here up to 30 bits for values up to \\(10^9\\)).\n\nThe only extra subtlety is that we must forbid \\(u=v\\).  A simple way is:\n  1. Temporarily **remove** \\(\\mathit{dist}[v]\\) from the trie,\n  2. Query for the maximum XOR with \\(T\\),\n  3. Re‐insert \\(\\mathit{dist}[v]\\).\n\nEach remove/insert is \\(O(\\log C)\\), so each “\\(?\\)” query costs \\(O(\\log C)\\).  Since \\(n,m\\le2\\cdot10^5\\) and \\(\\log C\\approx30\\), this is around \\(30\\cdot (n+m)\\) operations, which fits in time.\n\nFinally, we observe that \\(\\mathit{dist}[u]\\) depends on whether \\(u\\) has even or odd depth (parity \\(p[u]\\)), because of the global XOR‐updates.  A common trick is to build **two** tries:\n\n- **Trie0** holds \\(\\mathit{dist0}[u]\\) for all \\(u\\) with even parity \\(p[u]=0\\).  Those never get the global \\(Y_{\\rm tot}\\) XOR‐added.\n- **Trie1** holds \\(\\mathit{dist0}[u]\\) for all \\(u\\) with odd parity \\(p[u]=1\\).  In reality their current distance is \\(\\mathit{dist0}[u]\\oplus Y_{\\rm tot}\\).\n\nWhen querying we split into two groups:\n\n- For the even‐parity group we want \\(\\max (\\mathit{dist0}[u]\\oplus T)\\) over \\(u\\) with \\(p[u]=0\\).  \n- For the odd‐parity group they actually store \\(D\\oplus Y_{\\rm tot}\\), so\n  \\[\n    (D\\oplus Y_{\\rm tot}) \\;\\oplus\\;T\n    = D \\;\\oplus\\;(T\\oplus Y_{\\rm tot}).\n  \\]\n  Hence we query Trie1 with \\((T\\oplus Y_{\\rm tot})\\).\n\nWe take the maximum of the two.  To exclude \\(v\\), we remove \\(\\mathit{dist0}[v]\\) from **exactly** the trie it lives in \\((=p[v])\\), query both tries, then re‐insert.\n\n**Implementation Details**\n\n- We do a single DFS (iterative) from node 1 to compute:\n  - `dist0[u]` = XOR‐distance from root using the _original_ weights.\n  - `p[u]` = parity of depth (0 or 1).\n- We build two tries (really, two roots of bit‐tries) of the `dist0[u]`.\n- We keep a global integer `Ytot=0`.  On a “^ y” query we do `Ytot ^= y`.\n- On a “? v x” query:\n   1. Remove `dist0[v]` from trie `p[v]`.\n   2. Compute `curDistV = (p[v]==0 ? dist0[v] : dist0[v]^Ytot)`.\n   3. Compute `T = curDistV ^ x`.\n   4. Query trie0 for `max XOR with T` (if nonempty).\n   5. Query trie1 for `max XOR with (T^Ytot)` (if nonempty).\n   6. Answer = max of those two.\n   7. Re‐insert `dist0[v]` into its trie.\n- Each insert/remove or max‐XOR query takes \\(O(30)\\) steps.  \n\nOverall complexity is\n  \\[\n    O\\bigl((n+m)\\times 30\\bigr),\n  \\]\nwhich fits well for \\(n,m\\le2\\cdot10^5\\).\n\nBelow is the full Java implementation.\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int MAXN = 200_000;\n    // We only need about 30 levels for ints up to ~1e9.\n    static final int BITS = 30;    \n    // Maximum number of trie‐nodes:\n    // approx = MAXN * BITS.\n    static final int MAXNODE = MAXN * BITS + 5;\n    \n    // The two tries: nextBit[b][node] → child on bit b=0/1\n    static int[][] nextBit = new int[2][MAXNODE];\n    // counts[node][grp] = how many values of group grp (0 or 1) pass here\n    static int[][] counts = new int[2][MAXNODE];\n    // How many values total in each group\n    static int size0, size1;\n    // Next free node\n    static int nodeCnt;\n\n    // Insert or delete (delta = +1 or -1) a value into group grp (0 or 1)\n    static void adjustTrie(int value, int grp, int delta) {\n        int cur = 0;\n        for (int b = BITS - 1; b >= 0; b--) {\n            int bit = (value >>> b) & 1;\n            int nx = nextBit[bit][cur];\n            if (nx == 0) {\n                nx = nodeCnt++;\n                nextBit[bit][cur] = nx;\n            }\n            cur = nx;\n            counts[grp][cur] += delta;\n        }\n    }\n\n    // Query maximum XOR with 'mask' in group grp's trie.\n    // Return -∞ if that group's size is zero.\n    static int queryTrie(int mask, int grp) {\n        if ((grp == 0 && size0 == 0) || (grp == 1 && size1 == 0)) {\n            return Integer.MIN_VALUE; \n        }\n        int cur = 0, ans = 0;\n        for (int b = BITS - 1; b >= 0; b--) {\n            int want = 1 - ((mask >>> b) & 1);\n            int cnode = nextBit[want][cur];\n            if (cnode != 0 && counts[grp][cnode] > 0) {\n                ans |= (1 << b);\n                cur = cnode;\n            } else {\n                cur = nextBit[1 - want][cur];\n            }\n        }\n        return ans;\n    }\n\n    // Adjacency for the tree\n    static int[] head = new int[MAXN + 1];\n    static int[] to = new int[2 * MAXN];\n    static int[] wgt = new int[2 * MAXN];\n    static int[] nxt = new int[2 * MAXN];\n    static int edgeCnt;\n\n    static int[] dist0 = new int[MAXN + 1];\n    static int[] parity = new int[MAXN + 1];\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        int T = Integer.parseInt(in.readLine().trim());\n        while (T-- > 0) {\n            StringTokenizer st = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(st.nextToken());\n\n            // Build adjacency\n            Arrays.fill(head, 1, n+1, -1);\n            edgeCnt = 0;\n            for (int i = 0; i < n - 1; i++) {\n                st = new StringTokenizer(in.readLine());\n                int u = Integer.parseInt(st.nextToken());\n                int v = Integer.parseInt(st.nextToken());\n                int w = Integer.parseInt(st.nextToken());\n                to[edgeCnt] = v; wgt[edgeCnt] = w;\n                nxt[edgeCnt] = head[u]; head[u] = edgeCnt++;\n                to[edgeCnt] = u; wgt[edgeCnt] = w;\n                nxt[edgeCnt] = head[v]; head[v] = edgeCnt++;\n            }\n\n            // DFS to compute dist0[] and parity[]\n            dist0[1] = 0;\n            parity[1] = 0;\n            int[] stack = new int[n];\n            int[] parent = new int[n];\n            int sp = 0;\n            stack[sp] = 1;\n            parent[sp++] = 0;\n            while (sp > 0) {\n                int u = stack[--sp], p = parent[sp];\n                for (int e = head[u]; e != -1; e = nxt[e]) {\n                    int v = to[e];\n                    if (v == p) continue;\n                    parity[v] = parity[u] ^ 1;\n                    dist0[v] = dist0[u] ^ wgt[e];\n                    stack[sp] = v;\n                    parent[sp++] = u;\n                }\n            }\n\n            // Build the two tries\n            nodeCnt = 1; // root at 0\n            size0 = size1 = 0;\n            for (int u = 1; u <= n; u++) {\n                if (parity[u] == 0) {\n                    adjustTrie(dist0[u], 0, +1);\n                    size0++;\n                } else {\n                    adjustTrie(dist0[u], 1, +1);\n                    size1++;\n                }\n            }\n\n            int Ytot = 0;   // cumulative XOR of all global-updates\n            // Process queries\n            for (int qi = 0; qi < m; qi++) {\n                st = new StringTokenizer(in.readLine());\n                String op = st.nextToken();\n                if (op.equals(\"^\")) {\n                    int y = Integer.parseInt(st.nextToken());\n                    Ytot ^= y;\n                } else {\n                    // op = \"?\"\n                    int v = Integer.parseInt(st.nextToken());\n                    int x = Integer.parseInt(st.nextToken());\n                    int g = parity[v];\n\n                    // Temporarily remove dist0[v]\n                    adjustTrie(dist0[v], g, -1);\n                    if (g == 0) size0--; else size1--;\n\n                    // compute the T = dist[v] ^ x\n                    int curDistV = (g == 0 ? dist0[v] : dist0[v] ^ Ytot);\n                    int Tmask = curDistV ^ x;\n\n                    // Query both tries\n                    int a0 = queryTrie(Tmask, 0);\n                    int a1 = queryTrie(Tmask ^ Ytot, 1);\n\n                    int ans = Math.max(a0, a1);\n                    out.append(ans).append(' ');\n\n                    // Re‐insert\n                    adjustTrie(dist0[v], g, +1);\n                    if (g == 0) size0++; else size1++;\n                }\n            }\n            out.append('\\n');\n        }\n\n        System.out.print(out.toString());\n    }\n}\n```\n\n**Explanation of the Main Steps**\n\n1. **Reading and Storing the Tree**  \n   We read \\(n\\) and build an undirected adjacency list (`head`, `to`, `nxt`, `wgt`).\n\n2. **Computing \\(\\mathrm{dist0}\\) and Node‐Parity**  \n   We do an iterative DFS from node 1, computing:\n   - `dist0[u] = XOR` of original weights along the path from 1 to \\(u\\).\n   - `parity[u] = depth(u)\\bmod 2`.\n\n3. **Building Two Bit‐Tries**  \n   - **Trie0** holds all `dist0[u]` for `parity[u]==0`.\n   - **Trie1** holds all `dist0[u]` for `parity[u]==1`.\n\n   Each trie‐node has two child pointers (for bit `0` or `1`) and a count of how many values of each parity‐group pass through that node.  Inserting or deleting one value updates those counts along its 30‐bit path.\n\n4. **Global XOR Updates**  \n   We keep `Ytot = 0`.  On query `\"^ y\"` we do `Ytot ^= y`.\n\n5. **Answering “? v x” Queries**  \n   1. Remove `dist0[v]` from the trie of group `parity[v]`.  \n   2. Compute the current distance `curDistV = dist0[v] ^ (parity[v]==1 ? Ytot : 0)`.  \n   3. Let `T = curDistV ^ x`.  \n   4. Query **Trie0** for maximum `(value ^ T)` if nonempty.  \n   5. Query **Trie1** for maximum `(value ^ (T ^ Ytot))` if nonempty.  \n   6. The answer is the max of steps 4 and 5.  \n   7. Re‐insert `dist0[v]`.\n\nAll steps take \\(O(30)\\) per update or query, so the solution runs in time and within memory limits."
  },
  {
    "role": "system",
    "content": "Identify any errors in this response and output a prompt to help the AI resolve said issues. Your response MUST be in one of two formats: 1. If the response looks perfect, return \"Perfect\". Do not return this if there are any issues. Use this very sparingly as any errors in the final output from the AI will be considered a failure on your part. 2. Otherwise, return \"{prompt}\" where {prompt} is replaced with your concise prompt. This should be done most often, even if the AI's response is mostly correct. Ensure the entire response is enclosed in double quotations if it's a prompt. Make sure your prompt asks the AI to return one block of code for submission."
  },
  {
    "role": "assistant",
    "content": "\"Your code reuses the global trie arrays across test cases without clearing them, so data from one case leaks into the next. Please revise the solution to properly reset or reinitialize `nextBit` and `counts` (or use version stamps) before each test case. Return one complete Java code block.\""
  }
]