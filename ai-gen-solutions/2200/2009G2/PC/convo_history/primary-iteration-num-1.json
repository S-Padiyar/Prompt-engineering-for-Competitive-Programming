[
  {
    "role": "user",
    "content": "G2. Yunli's Subarray Queries (hard version)\n\ntime limit per test3 seconds\n\nmemory limit per test512 megabytes\n\nThis is the hard version of the problem. In this version, it is guaranteed that r≥l+k−1\n\n for all queries.\n\n\n\nFor an arbitrary array b\n\n, Yunli can perform the following operation any number of times:\n\n\n\nSelect an index i\n\n. Set bi=x\n\n where x\n\n is any integer she desires (x\n\n is not limited to the interval [1,n]\n\n).\n\nDenote f(b)\n\n as the minimum number of operations she needs to perform until there exists a consecutive subarray∗\n\n of length at least k\n\n in b\n\n.\n\n\n\nYunli is given an array a\n\n of size n\n\n and asks you q\n\n queries. In each query, you must output ∑rj=l+k−1f([al,al+1,…,aj])\n\n.\n\n\n\n∗\n\nIf there exists a consecutive subarray of length k\n\n that starts at index i\n\n (1≤i≤|b|−k+1\n\n), then bj=bj−1+1\n\n for all i<j≤i+k−1\n\n.\n\n\n\nInput\n\nThe first line contains t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nThe first line of each test case contains three integers n\n\n, k\n\n, and q\n\n (1≤k≤n≤2⋅105\n\n, 1≤q≤2⋅105\n\n) — the length of the array, the length of the consecutive subarray, and the number of queries.\n\n\n\nThe following line contains n\n\n integers a1,a2,...,an\n\n (1≤ai≤n\n\n).\n\n\n\nThe following q\n\n lines contain two integers l\n\n and r\n\n (1≤l≤r≤n\n\n, r≥l+k−1\n\n) — the bounds of the query.\n\n\n\nIt is guaranteed the sum of n\n\n over all test cases does not exceed 2⋅105\n\n and the sum of q\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nOutput ∑rj=l+k−1f([al,al+1,…,aj])\n\n for each query on a new line.\n\n\n\nExample\n\nInputCopy\n\n3\n\n7 5 3\n\n1 2 3 2 1 2 3\n\n1 7\n\n2 7\n\n3 7\n\n8 4 2\n\n4 3 1 1 2 4 3 2\n\n3 6\n\n1 5\n\n5 4 2\n\n4 5 1 2 3\n\n1 4\n\n1 5\n\nOutputCopy\n\n6\n\n5\n\n2\n\n2\n\n5\n\n2\n\n3\n\nNote\n\nIn the second query of the first testcase, we calculate the following function values:\n\n\n\nf([2,3,2,1,2])=3\n\n because Yunli can set b3=4\n\n, b4=5\n\n, and b5=6\n\n, making a consecutive subarray of size 5\n\n in 3\n\n moves.\n\nf([2,3,2,1,2,3])=2\n\n because we can set b3=0\n\n and b2=−1\n\n, making a consecutive subarray of size 5\n\n in 2\n\n moves (starting at position 2\n\n)\n\nThe answer to this query is 3+2=5\n\n.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe are given an array a of length n and a fixed window‐size k.  We define for any subarray b\n\n- an operation is to pick a single position i in b and overwrite b_i with any integer of our choice;\n- \\(f(b)\\) = the minimum number of these operations needed so that \\(b\\) contains somewhere a contiguous “consecutive” run of length at least k, i.e. \\(b_s,b_{s+1},\\dots,b_{s+k-1}\\) such that \n\\[\n\\forall j\\in[s,s+k-1]:\\;b_j = b_{j-1} + 1.\n\\]\n\nYunli asks many queries \\((\\ell,r)\\) with \\(r\\ge \\ell + k-1\\).  Each query wants\n\\[\n\\sum_{j=\\ell+k-1}^r f\\bigl(a_\\ell,a_{\\ell+1},\\dots,a_j\\bigr).\n\\]\n\nWe must answer up to \\(2\\times10^5\\) total \\(n\\)-entries and \\(2\\times10^5\\) total queries over all test‐cases in about 3 s.  A straightforward DP over all subarrays is too big.\n\n---\n\n### 1. Reducing \\(f(b)\\) to a “sliding‐mode” problem\n\nFirst observe that to enforce\n\\[\nb_s,b_{s+1},\\dots,b_{s+k-1}\n\\]\nto be exactly an increasing-by‐1 run, we must make\n\\[\nb_{s+j} \\;-\\; (s+j)\n\\quad\\text{all equal for }j=0,\\dots,k-1.\n\\]\nDefine\n\\[\nC_i \\;=\\; a_i - i.\n\\]\nIn any window of length \\(k\\), to make all \\(C_{s},C_{s+1},\\dots,C_{s+k-1}\\) equal we need to overwrite all but the most‐frequent value.  Hence the number of operations in that window is\n\\[\nk \\;-\\;\\bigl(\\text{frequency of the mode of }C\\text{ in that window}\\bigr).\n\\]\nTaking the minimum over all window‐starts \\(s\\) inside our subarray is exactly\n\\[\nf(b)\n=\\min_{s}s\\;-\\;\\bigl(\\max_{s}\\,\\{\\text{mode‐count in window }s\\}\\bigr)\n= k \\;-\\;\\bigl(\\max_{s}\\{\\text{mode‐count in window }s\\}\\bigr).\n\\]\n\nThus, if we let\n\\[\nw_s \n= \\max\\bigl\\{\\text{frequency of any value in }C_s,C_{s+1},\\dots,C_{s+k-1}\\bigr\\},\n\\qquad\ns=1,2,\\dots,n-k+1,\n\\]\nthen any prefix \\((a_\\ell,\\dots,a_j)\\) with \\(j\\ge \\ell+k-1\\) has\n\\[\nf\\bigl(a_\\ell,\\dots,a_j\\bigr)\n= k \\;-\\; \\max_{s=\\ell,\\dots,j-k+1} w_s.\n\\]\nDefine the array \\(W\\) of length \\(M=n-k+1\\) by\n\\[\nW[s]=w_s,\\;s=1,\\dots,M.\n\\]\nThen for a fixed \\(\\ell\\) and \\(j\\ge \\ell+k-1\\) we set\n\\[\nL=\\ell,\\quad\nR=j-k+1,\\quad\nf(\\ell,j)=k \\;-\\;\\max_{s=L}^R W[s].\n\\]\nWe want for each query \\((\\ell,r)\\):\n\\[\n\\sum_{j=\\ell+k-1}^r f(\\ell,j).\n\\]\nLet\n\\[\nS(L,R)\\;=\\;\\sum_{i=L}^R\\max_{s=L}^i W[s]\n\\]\nbe the sum of the running‐maxima of \\(W[L],W[L+1],\\dots,W[R]\\).  Then\n\\[\n\\sum_{j=\\ell+k-1}^r f(\\ell,j)\n=\\sum_{i=L}^R \\bigl(k - \\max_{s=L}^i W[s]\\bigr)\n=(R-L+1)\\,k \\;-\\;S(L,R),\n\\]\nwhere \\(L=\\ell\\) and \\(R=r-k+1\\).\n\nHence each query \\((\\ell,r)\\) reduces to computing\n\\[\n(R-L+1)\\,k \\;-\\; S(L,R),\n\\]\nwhere\n\\[\nS(L,R)=\\sum_{i=L}^R \\bigl(\\max_{s=L}^i W[s]\\bigr).\n\\]\n\n---\n\n### 2. Preprocessing the mode‐counts \\(w_s\\) in \\(O(n)\\)\n\nWe must build \\(W[1..M]\\) quickly.  Notice\n\\[\nC_i = a_i - i,\n\\]\nso \\(C\\) has ~\\-\\(n\\)\\[to\\]n range.  We first compress all \\(C_i\\) to \\(\\{0,1,\\dots,U-1\\}\\).  \n\nThen we run a classic “sliding window mode” of window‐size \\(k\\):\n\n- Maintain an array `cnt[val] =` how many times `val` is in the current window.\n- Also maintain `freqCount[c]` = how many distinct values currently have count exactly \\(c\\).\n- Keep track of `currentMode` = the largest \\(c\\) with `freqCount[c]>0`.\n\nInitialize with the first window \\(C_1,\\dots,C_k\\) in \\(O(k)\\).  Then slide from \\(s=2\\) to \\(M\\), removing \\(C_{s-1}\\), adding \\(C_{s+k-1}\\), each in \\(O(1)\\) updating of `cnt` and `freqCount`, keeping `currentMode`.  At each slide we set\n\\[\nw_s = \\text{currentMode}.\n\\]\nThis whole pass is \\(O(n)\\).\n\n---\n\n### 3. Answering range‐queries \\(\\sum_{i=L}^R\\max(W[L..i])\\) in \\(O(\\log n)\\)\n\nFix the array \\(W[1..M]\\).  We build the “next‐greater‐to‐right” array\n\\[\n\\text{nxt}[i]\n= \\min\\{j>i:W[j]>W[i]\\},\n\\]\nor \\(M+1\\) if none.  This we get in \\(O(M)\\) by a stack.  \n\nConsider the “chain” of prefix‐maxima starting at \\(i\\):\n\\[\ni = u_0 < u_1 < u_2 < \\dots < u_k,\n\\]\nwhere each \\(u_{r+1} = \\text{nxt}[u_r]\\) is the next place the max strictly increases.  \nOn any interval \\([L,R]\\), the sequence \\(\\max_{s=L}^iW[s]\\) is piecewise‐constant on the blocks \\([u_r,\\;u_{r+1}-1]\\).  \nIn particular\n\\[\n\\sum_{i=L}^R \\max_{s=L}^i W[s]\n= \\sum_{r:\\,u_r\\le R} \n   W[u_r]\\; \\bigl(\\min(u_{r+1},R+1)-u_r\\bigr).\n\\]\nWe can simulate walking up the chain of “next‐greater” using binary‐lifting:\n\n- Let `parent[i][0] = nxt[i]` and `fullSum[i][0] = W[i]*(nxt[i]-i)`.\n- Build \\(parent[i][j],\\;fullSum[i][j]\\) for \\(j=1..{\\lfloor\\log M\\rfloor}\\) in the usual doubling way.\n\nTo compute \\(S(L,R)\\), we start `cur=L`, `acc=0`.  We scan \\(j\\) from large to 0 and see if we can jump `2^j` steps without exceeding \\(R\\).  Precisely:\n\n```\nfor (j=LOG-1 down to 0) {\n  if (parent[cur][j] <= R) {\n    acc += fullSum[cur][j]; \n    cur = parent[cur][j];\n  }\n}\n```\nAfter this loop, `cur` is the last block‐start \\(u_k \\le R\\) whose `nxt[cur]` goes *beyond* \\(R\\).  We still owe a “partial block”  \n\\(\\;W[cur]\\times\\bigl(R+1 - cur\\bigr)\\).  Hence\n\\[\nS(L,R)=\\textit{acc}\\;+\\;W[\\textit{cur}]\\times\\bigl(R+1-\\textit{cur}\\bigr).\n\\]\nFinally the query’s answer is\n\\[\n(R-L+1)\\times k \\;-\\; S(L,R).\n\\]\n\nEach query costs \\(O(\\log n)\\).  We have \\(O(n)\\) preprocessing plus \\(O(q\\log n)\\) over all queries, which comfortably fits under the given limits.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int MAXN = 200_000 + 5;\n    static final int LOG = 18;  // enough for 2e5\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        StringTokenizer st;\n\n        int T = Integer.parseInt(br.readLine());\n        // Scratch arrays, reused across test‐cases\n        int[] a = new int[MAXN];\n        int[] C = new int[MAXN];\n        int[] Cvals = new int[MAXN];\n        int[] Cc = new int[MAXN];\n        int[] cnt = new int[MAXN];\n        int[] freqCount = new int[MAXN];\n        int[] w = new int[MAXN];\n        int[][] parent = new int[LOG][MAXN];\n        long[][] fullSum = new long[LOG][MAXN];\n        int[] stack = new int[MAXN];  // for next‐greater\n\n        for (int _case = 0; _case < T; _case++) {\n            st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int k = Integer.parseInt(st.nextToken());\n            int q = Integer.parseInt(st.nextToken());\n\n            // read a[1..n]\n            st = new StringTokenizer(br.readLine());\n            for (int i = 1; i <= n; i++) {\n                a[i] = Integer.parseInt(st.nextToken());\n            }\n            // build C[i] = a[i] - i\n            for (int i = 1; i <= n; i++) {\n                C[i] = a[i] - i;\n            }\n            // compress C to [0..U-1]\n            System.arraycopy(C, 1, Cvals, 1, n);\n            Arrays.sort(Cvals, 1, n + 1);\n            int U = 0;\n            for (int i = 1; i <= n; i++) {\n                if (i == 1 || Cvals[i] != Cvals[i - 1]) {\n                    U++;\n                    Cvals[U] = Cvals[i];\n                }\n            }\n            for (int i = 1; i <= n; i++) {\n                int x = C[i];\n                // binary search in Cvals[1..U]\n                int idx = Arrays.binarySearch(Cvals, 1, U + 1, x);\n                Cc[i] = idx;\n            }\n\n            // Build w[s] = mode‐count of window Cc[s..s+k-1]\n            // reset cnt[0..U-1] = 0\n            for (int i = 1; i <= U; i++) cnt[i] = 0;\n            // freqCount up to k\n            for (int i = 1; i <= k; i++) freqCount[i] = 0;\n\n            int modeFreq = 0;\n            // add function\n            // c_old = cnt[x], c_new = c_old+1,\n            // if c_old>=1 freqCount[c_old]--, freqCount[c_new]++, update modeFreq\n            // remove similarly\n            for (int i = 1; i <= k; i++) {\n                int x = Cc[i];\n                int c0 = cnt[x]++;\n                if (c0 >= 1) freqCount[c0]--;\n                freqCount[c0 + 1]++;\n                if (c0 + 1 > modeFreq) modeFreq = c0 + 1;\n            }\n            int M = n - k + 1;\n            w[1] = modeFreq;\n\n            for (int s = 2; s <= M; s++) {\n                // remove Cc[s-1]\n                {\n                    int x = Cc[s - 1];\n                    int c0 = cnt[x];\n                    freqCount[c0]--;\n                    cnt[x]--;\n                    if (c0 - 1 >= 1) freqCount[c0 - 1]++;\n                    if (freqCount[modeFreq] == 0) modeFreq--;\n                }\n                // add Cc[s+k-1]\n                {\n                    int x = Cc[s + k - 1];\n                    int c0 = cnt[x]++;\n                    if (c0 >= 1) freqCount[c0]--;\n                    freqCount[c0 + 1]++;\n                    if (c0 + 1 > modeFreq) modeFreq = c0 + 1;\n                }\n                w[s] = modeFreq;\n            }\n\n            // Build next‐greater-to-right in w[1..M]\n            int top = 0;\n            for (int i = M; i >= 1; i--) {\n                while (top > 0 && w[stack[top - 1]] <= w[i]) top--;\n                parent[0][i] = (top == 0 ? M + 1 : stack[top - 1]);\n                stack[top++] = i;\n            }\n            // sentinel\n            parent[0][M + 1] = M + 1;\n\n            // build fullSum[0][i] = w[i]*(parent[0][i] - i)\n            for (int i = 1; i <= M; i++) {\n                fullSum[0][i] = (long)w[i] * (parent[0][i] - i);\n            }\n            fullSum[0][M + 1] = 0;\n\n            // binary‐lift\n            for (int lvl = 1; lvl < LOG; lvl++) {\n                for (int i = 1; i <= M + 1; i++) {\n                    int p = parent[lvl - 1][i];\n                    parent[lvl][i] = parent[lvl - 1][p];\n                    fullSum[lvl][i] = fullSum[lvl - 1][i] + fullSum[lvl - 1][p];\n                }\n            }\n\n            // answer queries\n            while (q-- > 0) {\n                st = new StringTokenizer(br.readLine());\n                int L = Integer.parseInt(st.nextToken());\n                int Rbig = Integer.parseInt(st.nextToken());\n                int R = Rbig - k + 1;  // endpoints in w‐space\n                int len = R - L + 1;\n\n                long acc = 0;\n                int cur = L;\n                // jump up the \"next greater\" chain as far as possible\n                for (int lvl = LOG - 1; lvl >= 0; lvl--) {\n                    int p = parent[lvl][cur];\n                    if (p <= R) {\n                        acc += fullSum[lvl][cur];\n                        cur = p;\n                    }\n                }\n                // partial block at the end\n                acc += (long)w[cur] * ( (R + 1L) - cur );\n\n                long ans = (long)len * k - acc;\n                out.append(ans).append('\\n');\n            }\n        }\n\n        System.out.print(out.toString());\n    }\n}\n```\n\n**Explanation of the main steps**\n\n1. **Compute** \\(C_i = a_i - i\\).  \n2. **Compress** the \\(C_i\\) into a small range \\([0..U-1]\\).  \n3. **Sliding‐window “mode‐count”** of length \\(k\\) in \\(O(n)\\):  \n   - Maintain `cnt[val]` = count of each compressed value in the window,  \n   - `freqCount[c]` = how many values appear exactly `c` times,  \n   - `modeFreq` = the current highest `c` with `freqCount[c]>0`.  \n   This gives us  \n   \\[\n     w_s = \\max\\{\\text{freq of any }C\\text{-value in }C_s\\ldots C_{s+k-1}\\}.\n   \\]\n4. **Next‐greater‐to‐right** on the array \\(W[1..M]\\) (\\(M=n-k+1\\)) in \\(O(M)\\) using a stack:\n   \\[\n     \\text{nxt}[i] = \\min\\{j>i: W[j]>W[i]\\} \\quad(\\text{or }M+1).\n   \\]\n5. **Binary‐lifting** on the “nxt” pointers.  We store  \n   \\(\\texttt{parent}[0][i]=\\text{nxt}[i]\\) and\n   \\(\\texttt{fullSum}[0][i] = W[i]\\times(\\text{nxt}[i]-i)\\),  \n   then build up to \\(\\texttt{parent}[j],\\texttt{fullSum}[j]\\) for \\(2^j\\)-steps.  \n6. **Answer query** \\((\\ell,r)\\):  \n   - In terms of \\(W\\), let \\(L=\\ell\\), \\(R=r-k+1\\).  \n   - We need \n     \\(\\sum_{i=L}^R \\max_{s=L}^i W[s]\\).  \n   - We jump up the “next‐greater” chain by largest \\(2^j\\)-steps that stay \\(\\le R\\), summing the full‐blocks in `acc`.  \n   - Finally add the “partial” last block: \\(W[cur]\\times((R+1)-cur)\\).  \n   - The query answer is \\((R-L+1)\\cdot k\\;-\\)\\(that\\_sum\\).  \n\nAll preprocessing is \\(O(n\\!+\\!k)\\), building the `next` array is \\(O(n)\\), binary‐lifting is \\(O(n\\log n)\\), and each of the \\(q\\) queries in \\(O(\\log n)\\), which fits easily under the given constraints."
  }
]