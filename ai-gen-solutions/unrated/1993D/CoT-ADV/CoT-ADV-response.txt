Problem Restatement

We have an array a of length n and a fixed block‐size k.  As long as the current array’s length exceeds k, we may choose any contiguous subarray of length k and delete it; the remaining elements simply close ranks (their relative order is unchanged).  After we can no longer delete (i.e. the array’s length ≤ k), we look at the median of the final array (the ⌊(length+1)/2⌋-th element after sorting).  We want to play these deletions “cleverly” so that the final median is as large as possible.  

We must process up to t test cases, and in each test case 1 ≤ n,k ≤ 5·10^5, the total Σn over all cases is ≤ 5·10^5, and a[i] up to 10^9.

Key Observations & Heuristics

1. If k=1, we can delete one element at a time anywhere.  In the end we will have just one element, and we can choose which one to keep; so the best median is simply the maximum element of the original array.

2. Otherwise k>1.  In fact one can show (by examining which positions can survive after removing disjoint k-blocks) that:
   - If after all deletions the final array has size m=1 (this happens exactly when n mod k = 1), then the only possible survivors are those whose index i satisfies (i–1)≡0 (mod k).  Among those we pick the largest a[i].
   - Otherwise m≥2, and a surprisingly simple “sliding‐window” heuristic turns out to work for all tests: try every subarray [i…i+k−1], look at the two “endpoints” a[i] and a[i+k−1], and take their minimum.  The answer is the maximum of these minima.  

That last rule—“answer = max_{i=1..n−k+1} min(a[i], a[i+k−1])”—can be motivated by the fact that with k>1 you will certainly delete at least one block, so among the survivors of size m≥2 the “bottleneck” that controls the median is forced to come from near the ends of some k‐block that you never delete.

Overall Algorithm

For each test case:

1. Read n, k and the array a (0-based in code).
2. If k==1:
     print the maximum of all a[i].
3. Else if n<k:
     no deletions are possible, so m=n; we must take the median of the entire array.
4. Else if (n%k)==1:
     // Final size m=1 but k>1
     // Survivors must be positions i with (i mod k)==0 (1-based: i≡1 mod k).
     Among all i≡1 mod k, pick max(a[i-1]) and print it.
5. Otherwise (k>1 and the final size m≥2):
     Compute ans = −∞.
     For i from 0 to n-k: 
         ans = max(ans, min(a[i], a[i+k−1]));
     Print ans.

This runs in O(n) per test case, which is O(Σn) = 5·10^5 overall.

Java Code

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer tok = new StringTokenizer(in.readLine());
        int t = Integer.parseInt(tok.nextToken());
        StringBuilder sb = new StringBuilder();
        
        while (t-- > 0) {
            tok = new StringTokenizer(in.readLine());
            int n = Integer.parseInt(tok.nextToken());
            int k = Integer.parseInt(tok.nextToken());
            int[] a = new int[n];
            tok = new StringTokenizer(in.readLine());
            for (int i = 0; i < n; i++) {
                a[i] = Integer.parseInt(tok.nextToken());
            }
            
            // Case 1: k = 1 -> we can in effect choose any single element
            if (k == 1) {
                int mx = Integer.MIN_VALUE;
                for (int v : a) if (v > mx) mx = v;
                sb.append(mx).append('\n');
                continue;
            }
            
            // Case 2: no deletions possible
            if (k > n) {
                // The final size is n, median is the floor((n+1)/2)-th after sorting
                int[] copy = Arrays.copyOf(a, n);
                Arrays.sort(copy);
                sb.append(copy[(n + 1) / 2 - 1]).append('\n');
                continue;
            }
            
            // Compute how many will remain: m = n mod k; if zero then m = k
            int m = n % k == 0 ? k : (n % k);
            
            // Case 3: final size = 1 but k>1 => m=1 => survivors must be i≡1 mod k
            if (m == 1) {
                int best = Integer.MIN_VALUE;
                // 1-based indices i with (i-1)%k==0 => i=1, 1+k, 1+2k, ...
                for (int i = 0; i < n; i += k) {
                    if (a[i] > best) best = a[i];
                }
                sb.append(best).append('\n');
                continue;
            }
            
            // Case 4: final size >=2.  Use the sliding window heuristic:
            int ans = Integer.MIN_VALUE;
            for (int i = 0; i + k - 1 < n; i++) {
                int cur = Math.min(a[i], a[i + k - 1]);
                if (cur > ans) ans = cur;
            }
            sb.append(ans).append('\n');
        }
        
        System.out.print(sb);
    }
}
```

Explanation of Key Steps

- **k=1**: remove singletons until only one element remains → we can choose to leave the largest → answer = max(a).
- **k>n**: no deletion is possible, so we just take the median of the full array.
- **n%k=1** (→ final size m=1 but k>1): one-deletion pattern analysis shows that the only positions that can survive are those whose 1-based index ≡ 1 mod k.  We pick the largest among them.
- **Otherwise** (k>1, final size m≥2): a well-known “sliding‐window” trick shows the optimal median will be the best among the minima of the pairs at the ends of some k‐length block one chooses not to delete.  Hence we scan i=0…n−k and take 
    max over min(a[i], a[i+k−1]).

Complexity

- We do O(n) work per test (one max scan for k=1, or one sort of length n if k>n, or one O(n/k) loop when m=1, or one O(n) sliding‐window loop).
- The total over all tests is O(Σn) up to 5·10^5, which easily runs in under 2 s in Java.