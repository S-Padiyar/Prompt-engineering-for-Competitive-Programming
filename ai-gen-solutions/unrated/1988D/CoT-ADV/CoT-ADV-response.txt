Problem Restatement  
We have a tree of \(n\) vertices, each vertex \(i\) holding a monster with attack power \(a_i\). We fight for “infinitely many” rounds (effectively until all monsters are dead). In each round:

1. All *currently living* monsters deal damage equal to the sum of their attack powers.
2. We may kill any subset of living monsters, subject to the restriction that we cannot kill two monsters that are directly connected by an edge in the same round.

Once killed, a monster never attacks again. We want to schedule our kills so that the *total* damage taken (summed over all rounds) is minimized.

Because killing in later rounds means those monsters inflict more rounds of damage on us, each monster \(v\) with attack power \(a_v\) contributes
\[
   a_v \times (\text{the round in which we kill }v)
\]
to the total damage.  Our task is to assign each vertex \(v\) an integer “kill round” \(k_v\ge1\) so that:

- If \((u,v)\) is an edge, then \(k_u \ne k_v\) (we cannot kill both ends of an edge in the same round).
- We minimize \(\sum_v a_v\cdot k_v\).

Key Observation  
A tree is bipartite.  We can 2-color its vertices (say colors 0 and 1) so that no edge has both ends in the same color class.  That coloring exactly matches the “independent‐set” constraint for each round if we use at most two rounds:  
- In round 1 kill *all* vertices of color 0.  
- In round 2 kill *all* vertices of color 1.  

No edge has both ends in color 0 or both in color 1, so each color‐class is an independent set.  
Thus every monster is dead by the end of round 2.  No benefit can come from using more than 2 rounds (because that would only increase the multipliers for all \(a_v\)).  

Let  
\[
  S_0 = \sum_{\text{vertices }v\text{ with color }0} a_v,\quad
  S_1 = \sum_{\text{vertices }v\text{ with color }1} a_v.
\]
If we kill color‐0 in round 1 and color‐1 in round 2, the total damage is
\[
   S_0\cdot1 \;+\; S_1\cdot2 \;=\; S_0 + 2\,S_1.
\]
If we swap (kill color-1 first), total damage is
\[
   S_1\cdot1 \;+\; S_0\cdot2 \;=\; S_1 + 2\,S_0.
\]
We take the minimum of these two options.

Algorithmic Steps  
1. Read \(t\), the number of test cases.  
2. For each test case:
   - Read \(n\).  
   - Read the array \(a[1\ldots n]\).  
   - Build the adjacency list of the tree.  
   - Do a BFS (or DFS) from node 1 to 2-color the tree; track `color[v]` = 0 or 1.  
   - Accumulate `sum0` = total \(a[v]\) over vertices of color 0, and `sum1` for color 1.  
   - Compute `option1 = sum0 + 2*sum1` and `option2 = 2*sum0 + sum1`.  
   - Answer = `min(option1, option2)`.  
3. Print the answer for each test.

Complexities  
- Time per test:  
  - Building the adjacency list: \(O(n)\).  
  - BFS + summation: \(O(n)\).  
  Overall \(O(n)\).  
- Over all tests the sum of \(n\) is up to \(3\times10^5\), so total time is \(O(\sum n)\).  
- Space: \(O(n)\) for storing the graph, colors, and sums.

Java Implementation  

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        // Use BufferedReader/PrintWriter for fast I/O
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out);
        
        int t = Integer.parseInt(in.readLine().trim());
        while (t-- > 0) {
            int n = Integer.parseInt(in.readLine().trim());
            
            // Read attack powers
            long[] a = new long[n + 1];
            StringTokenizer st = new StringTokenizer(in.readLine());
            for (int i = 1; i <= n; i++) {
                a[i] = Long.parseLong(st.nextToken());
            }
            
            // Build the tree
            List<Integer>[] adj = new ArrayList[n + 1];
            for (int i = 1; i <= n; i++) {
                adj[i] = new ArrayList<>();
            }
            for (int i = 0; i < n - 1; i++) {
                st = new StringTokenizer(in.readLine());
                int u = Integer.parseInt(st.nextToken());
                int v = Integer.parseInt(st.nextToken());
                adj[u].add(v);
                adj[v].add(u);
            }
            
            // BFS to 2-color the tree
            int[] color = new int[n + 1];
            Arrays.fill(color, -1);
            long sum0 = 0, sum1 = 0;
            
            Deque<Integer> queue = new ArrayDeque<>();
            queue.add(1);
            color[1] = 0;
            
            while (!queue.isEmpty()) {
                int u = queue.poll();
                if (color[u] == 0) {
                    sum0 += a[u];
                } else {
                    sum1 += a[u];
                }
                for (int v : adj[u]) {
                    if (color[v] == -1) {
                        color[v] = color[u] ^ 1;  // alternate color 0<->1
                        queue.add(v);
                    }
                }
            }
            
            // Two options: kill color0 in round1 or color1 in round1
            long option1 = sum0 + 2 * sum1;  // color0 first, color1 second
            long option2 = 2 * sum0 + sum1;  // color1 first, color0 second
            long ans = Math.min(option1, option2);
            
            out.println(ans);
        }
        
        out.flush();
    }
}
```

Explanation of Key Parts  
- We only need two rounds because the tree is bipartite (no odd cycles), so two colors suffice to make each color class an independent set.  
- Killing a monster in round \(k\) lets it attack us \(k\) times.  Higher \(k\) means more damage, so we prefer to assign “round 1” to the color class with the larger total attack sum (to eliminate it earlier).  
- We do a BFS from node 1, coloring unvisited neighbors with the opposite color, and accumulate partial sums as we go.

Manual Walkthrough (Second Sample)  
Input tree:
5 nodes, attacks = [47,15,32,29,23]  
Edges: 1–2, 1–3, 2–4, 2–5.  

Bipartition (root=1 with color0):
- color0 nodes: 1,4,5 ⇒ sum0 = 47 + 29 + 23 = 99  
- color1 nodes: 2,3 ⇒ sum1 = 15 + 32 = 47  

Option1 = sum0*1 + sum1*2 = 99 + 94 = 193  
Option2 = sum0*2 + sum1*1 = 198 + 47 = 245  
Answer = 193, which matches the sample output.

Big-O Summary  
- Time: \(O(n)\) per test, total \(O(\sum n)\le O(3\times10^5)\).  
- Space: \(O(n)\) for adjacency lists, color array, and sums.