[
  {
    "role": "user",
    "content": "C. Lazy Narek\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nNarek is too lazy to create the third problem of this contest. His friend Artur suggests that he should use ChatGPT. ChatGPT creates n\n\n problems, each consisting of m\n\n letters, so Narek has n\n\n strings. To make the problem harder, he combines the problems by selecting some of the n\n\n strings possibly none and concatenating them without altering their order. His chance of solving the problem is defined as scoren−scorec\n\n, where scoren\n\n is Narek's score and scorec\n\n is ChatGPT's score.\n\n\n\nNarek calculates scoren\n\n by examining the selected string (he moves from left to right). He initially searches for the letter \"n\"\n\n, followed by \"a\"\n\n, \"r\"\n\n, \"e\"\n\n, and \"k\"\n\n. Upon finding all occurrences of these letters, he increments scoren\n\n by 5\n\n and resumes searching for \"n\"\n\n again (he doesn't go back, and he just continues from where he left off).\n\n\n\nAfter Narek finishes, ChatGPT scans through the array and increments scorec\n\n by 1\n\n for each letter \"n\"\n\n, \"a\"\n\n, \"r\"\n\n, \"e\"\n\n, or \"k\"\n\n that Narek fails to utilize (note that if Narek fails to complete the last occurrence by finding all of the 5\n\n letters, then all of the letters he used are counted in ChatGPT's score scorec\n\n, and Narek doesn't get any points if he doesn't finish finding all the 5 letters).\n\n\n\nNarek aims to maximize the value of scoren−scorec\n\n by selecting the most optimal subset of the initial strings.\n\n\n\nInput\n\nIn the first line of the input, you're given a single integer t\n\n (1≤t≤105\n\n), the number of test cases. Then the description of each test case follows.\n\n\n\nIn the first line of each test case, you're given two integers n,m\n\n (1≤n,m≤103\n\n), the number of strings and the length of each string.\n\n\n\nIn the next n\n\n lines, you're given n\n\n strings, each having a length of m\n\n. The strings only contain lowercase letters of the English alphabet.\n\n\n\nThe sum of values of n⋅m\n\n over all test cases does not exceed 106\n\n.\n\n\n\nOutput\n\nFor each test case, output a single integer: the maximal possible value of scoren−scorec\n\n.\n\n\n\nExample\n\nInputCopy\n\n4\n\n5 2\n\nnn\n\naa\n\nrr\n\nee\n\nkk\n\n1 5\n\nnarek\n\n1 4\n\nnare\n\n5 7\n\nnrrarek\n\nnrnekan\n\nuuuuuuu\n\nppppppp\n\nnkarekz\n\nOutputCopy\n\n0\n\n5\n\n0\n\n7\n\nNote\n\nIn the first test case, one of the optimal answers is when Narek doesn't choose any of the strings, so the answer is 0\n\n. He can alternatively choose all the strings. In this case, the full string becomes \"nnaarreekk\". Narek can choose the first appearances of all letters and add 5\n\n to the score. His opponent will add 1\n\n for all second appearances, which will be 5\n\n in total. So the answer will be 5−5=0\n\n.\n\n\n\nIn the third test case, the only optimal answer is when Narek doesn't choose the string. Note that if he were to choose the string, he wouldn't be able to find the last letter \"k\", so his score would stay at 0\n\n instead of becoming 5\n\n. Then ChatGPT would add 4\n\n for all of the 4\n\n letters, and the answer would become 0−4=−4\n\n.\n\n\n\nIn the last test case, Narek needs to choose the first and the last strings. After putting these two next to each other, he gets \"nrrareknkarekz\n\n\". Narek can choose the letters marked with red and add 10\n\n to his score. Since the black colored letters Narek left behind are eligible for the opponent to claim (they are used in the word \"narek\"), the opponent adds all other letters to the score and gets a score of 3\n\n. Therefore, the answer is 10−3=7\n\n.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have \\(n\\) fixed‐length strings (length \\(m\\)) in a fixed order.  We may pick *any* subset of them (keeping the original relative order) and concatenate those we pick into one long string \\(S\\).  We then run two scorers on \\(S\\):\n\n1. **Narek’s score** counts how many times the pattern  \n   \\[\n     \\texttt{\"narek\"}\n   \\]  \n   can be found *disjointly in order* as a subsequence in \\(S\\).  Each full “narek” gives +5 points.\n\n2. **ChatGPT’s score** counts *every* occurrence of the letters \n   \\(\\{\\texttt{n},\\texttt{a},\\texttt{r},\\texttt{e},\\texttt{k}\\}\\) in \\(S\\)  \n   that Narek did *not* use in those complete matches.  Each such unused letter gives +1 to ChatGPT.\n\nWe want to choose the subset of strings that **maximizes**  \n\\[\n   (\\text{Narek’s score}) \\;-\\; (\\text{ChatGPT’s score}).\n\\]\n\n---\n\n### Reformulating the score\n\n- Let \\(\\displaystyle k\\) be the number of complete “narek” matches Narek finds.\n  Then Narek’s score is \\(5k\\).\n\n- Let \\(\\displaystyle C_\\ell\\) be the total count in \\(S\\) of letter \\(\\ell\\in\\{\\,n,a,r,e,k\\}\\).  \n  Out of those \\(C_\\ell\\) copies, exactly \\(k\\) of each letter get used in the \\(k\\) matches, so\n  \\[\n     \\text{ChatGPT’s score}\n     \\;=\\;\\sum_{\\ell\\in\\{n,a,r,e,k\\}} \\bigl(C_\\ell - k\\bigr)\n     \\;=\\;\\Bigl(\\sum_{\\ell}C_\\ell\\Bigr)\\;-\\;5k.\n  \\]\n  \nHence the overall objective is\n\n\\[\n   5k \\;-\\;\\Bigl[\\sum_{\\ell}C_\\ell \\;-\\;5k\\Bigr]\n   \\;=\\;10\\,k \\;-\\;\\sum_{\\ell}C_\\ell.\n\\]\n\nNote that \\(\\sum_{\\ell}C_\\ell\\) is simply the total number of letters in \\(S\\) that belong to \\(\\{n,a,r,e,k\\}\\).  That depends *only* on which strings we pick, not on how they interact for matching “narek”.  By contrast, \\(k\\) does depend on how the chosen strings concatenate, because the partial matches of the pattern may carry over from one string to the next.\n\n---\n\n### Dynamic programming over string‐selection\n\nWe process the \\(n\\) strings in their given order, and maintain a small DP of size 5, namely\n\n\\[\n  \\texttt{dp}[s] \\;=\\;\n  \\max\\!\\bigl\\{\n    10\\,(\\text{# of full \"narek\" matches so far})\n    \\;-\\;\n    (\\text{total \\{n,a,r,e,k\\} letters so far})\n  \\bigr\\},\n\\]\nwhere \\(s\\in\\{0,1,2,3,4\\}\\) is the *current state* in matching the next character of “narek”.  \n- \\(s=0\\) means “we are looking for ‘n’ next,”  \n- \\(s=1\\) means “we have seen ‘n’ and now look for ‘a’,”  \n- and so on up to \\(s=4\\) (looking for ‘k’).  \nWhenever we reach state \\(5\\), that means we have completed one “narek” and we wrap back to state \\(0\\).\n\nWe initialize\n\\[\n  \\texttt{dp}[0]=0,\\quad\n  \\texttt{dp}[1]=\\texttt{dp}[2]=\\texttt{dp}[3]=\\texttt{dp}[4]=-\\infty,\n\\]\nmeaning we have not yet started matching unless we are in state 0 with score 0.\n\nThen for each string \\(i=1,\\dots,n\\), we have two choices:\n\n1. **Skip** string \\(i\\).  That leaves all states unchanged:\n   \\(\\texttt{dp}_{\\mathrm{new}}[s]=\\max(\\texttt{dp}_{\\mathrm{new}}[s],\\;\\texttt{dp}[s])\\).\n\n2. **Take** string \\(i\\).  Internally, if we enter that string in state \\(s\\),\n   we can scan through its \\(m\\) letters in \\(O(m)\\) time, tracking:\n   - how many *complete* “narek” matches \\(q\\) we finish *within* that string,  \n   - which state \\(t\\in\\{0,\\dots,4\\}\\) we end up in after processing it (the leftover partial match),\n   - and \\(T\\), the total number of letters in that string that belong to \\(\\{n,a,r,e,k\\}\\).\n   \n   Then taking this string from state \\(s\\) yields an *increment* of\n   \\[\n      +\\,10\\,q \\;-\\; T\n   \\]\n   to our running objective, and transitions us to state \\(t\\).  So\n   \\[\n     \\texttt{dp}_{\\mathrm{new}}[t]\n     \\;=\\;\n     \\max\\!\\bigl(\\texttt{dp}_{\\mathrm{new}}[t],\\;\n            \\texttt{dp}[s]\\;+\\;10\\,q\\;-\\;T\n     \\bigr).\n   \\]\n\nAfter processing all \\(n\\) strings, we look at the maximum of \\(\\texttt{dp}[s]\\) over \\(s=0,\\dots,4\\).  Because we are allowed to pick *no* strings at all (yielding overall objective \\(0\\)), the answer is\n\\[\n   \\max\\Bigl(0,\\;\\max_{0\\le s\\le4}\\texttt{dp}[s]\\Bigr).\n\\]\n\nThis DP has only \\(5\\) states and \\(n\\) up to \\(10^3\\) per test, so the per‐test complexity is\n\\[\n  O\\bigl(n\\cdot(m + 5)\\bigr)\n  =O(n\\,m),\n\\]\nwhich is fine when the total of all \\(n\\cdot m\\) over all testcases is \\(\\le10^6\\).\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(in.readLine().trim());\n\n        // The pattern we want to match\n        final char[] PAT = {'n','a','r','e','k'};\n\n        StringBuilder output = new StringBuilder();\n        while (t-- > 0) {\n            String[] nm = in.readLine().split(\" \");\n            int n = Integer.parseInt(nm[0]);\n            int m = Integer.parseInt(nm[1]);\n\n            // dp[s] = best score having consumed some chosen strings so far,\n            //          ending in match-state s (0..4) for the next letter of \"narek\".\n            // Initialize dp.\n            final int NEG_INF = -1_000_000_000;\n            int[] dp = new int[5];\n            for (int s = 1; s < 5; s++) dp[s] = NEG_INF;\n            dp[0] = 0;\n\n            // Process each string\n            for (int i = 0; i < n; i++) {\n                String sline = in.readLine();\n                char[] S = sline.toCharArray();\n\n                // Precompute: T = how many of {n,a,r,e,k} appear in this string\n                int T = 0;\n                for (char c : S) {\n                    for (char pch : PAT) {\n                        if (c == pch) { T++; break; }\n                    }\n                }\n\n                // For each possible input state s_in = 0..4,\n                // compute how many \"narek\" completions q happen inside the string\n                // and what end-state s_out we finish in.\n                int[] qCnt   = new int[5];\n                int[] sOut   = new int[5];\n                for (int s0 = 0; s0 < 5; s0++) {\n                    int state = s0, cnt = 0;\n                    for (char c : S) {\n                        if (c == PAT[state]) {\n                            state++;\n                            if (state == 5) {\n                                cnt++;\n                                state = 0;\n                            }\n                        }\n                    }\n                    qCnt[s0] = cnt;\n                    sOut[s0] = state;\n                }\n\n                // Do the DP transition\n                int[] newDp = new int[5];\n                // Option 1: skip this string\n                for (int s = 0; s < 5; s++) {\n                    newDp[s] = dp[s];\n                }\n                // Option 2: take this string\n                for (int s0 = 0; s0 < 5; s0++) {\n                    if (dp[s0] == NEG_INF) continue;\n                    int got = dp[s0] + 10 * qCnt[s0] - T;\n                    int s1  = sOut[s0];\n                    newDp[s1] = Math.max(newDp[s1], got);\n                }\n                dp = newDp;\n            }\n\n            // The answer is max(0, max_s dp[s])\n            int ans = 0;\n            for (int s = 0; s < 5; s++) {\n                ans = Math.max(ans, dp[s]);\n            }\n            output.append(ans).append('\\n');\n        }\n\n        System.out.print(output);\n    }\n}\n```\n\n**Explanation of the key steps**\n\n1. We reduce the problem to maximizing  \n   \\(\\;\\;10\\,k \\;-\\;\\sum_{\\ell\\in\\{n,a,r,e,k\\}}C_\\ell\\),  \n   where \\(k\\) is the number of times “narek” is found and the sum is how many of those special letters appear in total.\n\n2. We build a small **5-state** DP where the state \\(s\\in\\{0,\\dots,4\\}\\) indicates how many characters of `\"narek\"` we have matched *so far* (modulo 5).  State 0 means we are poised to match the `'n'` of the next copy, state 1 means we matched `n` and next look for `a`, ..., state 4 means we matched `n\\,a\\,r\\,e` and now look for `k`.\n\n3. For each string, we in \\(O(m)\\) compute, *for each possible entering state* \\(s\\):\n   - How many *complete* copies of “narek” we finish **inside** that string, and\n   - Which state \\(s'\\) we end up in (the leftover partial match).\n   - We also count \\(T\\), the total of those five letters that appear in the string.\n\n4. The DP transition is then trivial: either **skip** the string (states unchanged), or **take** it, adding  \n   \\(\\bigl(10\\times \\#\\text{completions}\\bigr)\\;-\\;T\\)  \n   to our current DP value and moving to the new end state.\n\n5. Finally we take the maximum over all 5 states (and also compare with 0, the “pick no strings” option).  \n\nThis runs in \\(O(nm)\\) time per test, which is more than fast enough for \\(\\sum nm \\le 10^6\\)."
  },
  {
    "role": "user",
    "content": "Please provide only the final Java solution code as a single block, with no additional explanation."
  },
  {
    "role": "assistant",
    "content": "```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(in.readLine().trim());\n        final char[] PAT = {'n', 'a', 'r', 'e', 'k'};\n        final int NEG_INF = -1_000_000_000;\n        StringBuilder output = new StringBuilder();\n        while (t-- > 0) {\n            String[] nm = in.readLine().split(\" \");\n            int n = Integer.parseInt(nm[0]), m = Integer.parseInt(nm[1]);\n            int[] dp = new int[5];\n            for (int s = 1; s < 5; s++) dp[s] = NEG_INF;\n            dp[0] = 0;\n            for (int i = 0; i < n; i++) {\n                String sline = in.readLine();\n                char[] S = sline.toCharArray();\n                int T = 0;\n                for (char c : S) {\n                    for (char pch : PAT) {\n                        if (c == pch) { T++; break; }\n                    }\n                }\n                int[] qCnt = new int[5], sOut = new int[5];\n                for (int s0 = 0; s0 < 5; s0++) {\n                    int state = s0, cnt = 0;\n                    for (char c : S) {\n                        if (c == PAT[state]) {\n                            state++;\n                            if (state == 5) {\n                                cnt++;\n                                state = 0;\n                            }\n                        }\n                    }\n                    qCnt[s0] = cnt;\n                    sOut[s0] = state;\n                }\n                int[] newDp = new int[5];\n                for (int s = 0; s < 5; s++) newDp[s] = dp[s];\n                for (int s0 = 0; s0 < 5; s0++) {\n                    if (dp[s0] == NEG_INF) continue;\n                    int got = dp[s0] + 10 * qCnt[s0] - T;\n                    int s1 = sOut[s0];\n                    newDp[s1] = Math.max(newDp[s1], got);\n                }\n                dp = newDp;\n            }\n            int ans = 0;\n            for (int s = 0; s < 5; s++) ans = Math.max(ans, dp[s]);\n            output.append(ans).append('\\n');\n        }\n        System.out.print(output);\n    }\n}\n```"
  }
]