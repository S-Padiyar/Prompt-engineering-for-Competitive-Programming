[
  {
    "timestamp": "2025-07-24T06:00:07.702690",
    "role": "user",
    "content": "Please provide a single, complete Java solution in one code block only, without any extra explanation or markdown formatting."
  },
  {
    "timestamp": "2025-07-24T06:03:14.875329",
    "role": "assistant",
    "content": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class Node {\n        int l, r, len, maxlen, priority;\n        Node left, right;\n        Node(int l, int r, Random rng) {\n            this.l = l; this.r = r;\n            this.len = r - l + 1;\n            this.maxlen = this.len;\n            this.priority = rng.nextInt();\n        }\n    }\n\n    static void update(Node t) {\n        if (t == null) return;\n        t.len = t.r - t.l + 1;\n        int m = t.len;\n        if (t.left != null && t.left.maxlen > m) m = t.left.maxlen;\n        if (t.right != null && t.right.maxlen > m) m = t.right.maxlen;\n        t.maxlen = m;\n    }\n\n    static Node[] split(Node t, int key) {\n        if (t == null) return new Node[]{null, null};\n        if (t.l <= key) {\n            Node[] sr = split(t.right, key);\n            t.right = sr[0];\n            update(t);\n            return new Node[]{t, sr[1]};\n        } else {\n            Node[] sl = split(t.left, key);\n            t.left = sl[1];\n            update(t);\n            return new Node[]{sl[0], t};\n        }\n    }\n\n    static Node merge(Node a, Node b) {\n        if (a == null) return b;\n        if (b == null) return a;\n        if (a.priority > b.priority) {\n            a.right = merge(a.right, b);\n            update(a);\n            return a;\n        } else {\n            b.left = merge(a, b.left);\n            update(b);\n            return b;\n        }\n    }\n\n    static Node removeKey(Node t, int key) {\n        Node[] sp1 = split(t, key);\n        Node[] sp2 = split(sp1[0], key - 1);\n        return merge(sp2[0], sp1[1]);\n    }\n\n    static Node insertNode(Node t, Node nd) {\n        if (t == null) {\n            update(nd);\n            return nd;\n        }\n        if (nd.priority > t.priority) {\n            Node[] sp = split(t, nd.l);\n            nd.left = sp[0];\n            nd.right = sp[1];\n            update(nd);\n            return nd;\n        } else if (nd.l < t.l) {\n            t.left = insertNode(t.left, nd);\n            update(t);\n            return t;\n        } else {\n            t.right = insertNode(t.right, nd);\n            update(t);\n            return t;\n        }\n    }\n\n    static Node findFloor(Node t, int x) {\n        if (t == null) return null;\n        if (t.l > x) {\n            return findFloor(t.left, x);\n        } else {\n            Node cand = findFloor(t.right, x);\n            return (cand != null ? cand : t);\n        }\n    }\n\n    static int findLeftmostGeq(Node t, int k) {\n        Node cur = t;\n        while (true) {\n            if (cur.left != null && cur.left.maxlen >= k) {\n                cur = cur.left;\n                continue;\n            }\n            if (cur.len >= k) {\n                return cur.l;\n            }\n            cur = cur.right;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        int T = Integer.parseInt(br.readLine().trim());\n        Random rng = new Random(1234567);\n\n        for (int tc = 0; tc < T; tc++) {\n            int n = Integer.parseInt(br.readLine().trim());\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(br.readLine().trim());\n            char[] op = new char[m];\n            int[] vx = new int[m];\n            int kmax = 0;\n            for (int i = 0; i < m; i++) {\n                st = new StringTokenizer(br.readLine());\n                op[i] = st.nextToken().charAt(0);\n                vx[i] = Integer.parseInt(st.nextToken());\n                if (op[i] == '?') kmax = Math.max(kmax, vx[i]);\n            }\n\n            final int MAXP = 2_000_000;\n            int INF = MAXP + kmax + 5;\n            Node root = null;\n            if (n == 0 || a[0] > 1) {\n                root = insertNode(root, new Node(1, (n==0? INF : a[0]-1), rng));\n            }\n            for (int i = 0; i+1 < n; i++) {\n                if (a[i+1] - a[i] > 1) {\n                    root = insertNode(root, new Node(a[i]+1, a[i+1]-1, rng));\n                }\n            }\n            if (n > 0 && a[n-1] < INF) {\n                root = insertNode(root, new Node(a[n-1]+1, INF, rng));\n            }\n\n            for (int i = 0; i < m; i++) {\n                int x = vx[i];\n                if (op[i] == '+') {\n                    Node iv = findFloor(root, x);\n                    root = removeKey(root, iv.l);\n                    if (iv.l <= x-1) root = insertNode(root, new Node(iv.l, x-1, rng));\n                    if (x+1 <= iv.r) root = insertNode(root, new Node(x+1, iv.r, rng));\n                } else if (op[i] == '-') {\n                    Node leftIv = findFloor(root, x-1);\n                    boolean leftMerge = leftIv != null && leftIv.r == x-1;\n                    Node rightIv = findFloor(root, x+1);\n                    boolean rightMerge = rightIv != null && rightIv.l == x+1;\n                    if (leftMerge && rightMerge) {\n                        int L = leftIv.l, R = rightIv.r;\n                        root = removeKey(root, leftIv.l);\n                        root = removeKey(root, rightIv.l);\n                        root = insertNode(root, new Node(L, R, rng));\n                    } else if (leftMerge) {\n                        int L = leftIv.l, R = x;\n                        root = removeKey(root, leftIv.l);\n                        root = insertNode(root, new Node(L, R, rng));\n                    } else if (rightMerge) {\n                        int L = x, R = rightIv.r;\n                        root = removeKey(root, rightIv.l);\n                        root = insertNode(root, new Node(L, R, rng));\n                    } else {\n                        root = insertNode(root, new Node(x, x, rng));\n                    }\n                } else {\n                    int ans = findLeftmostGeq(root, x);\n                    out.append(ans).append(' ');\n                }\n            }\n            out.append('\\n');\n        }\n        System.out.print(out.toString());\n    }\n}"
  }
]