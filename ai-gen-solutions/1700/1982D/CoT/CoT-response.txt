**Analysis**

We have an n×m grid of non‐negative heights \(a_{i,j}\) and a corresponding grid of types \(t_{i,j}\in\{0,1\}\) ("0" = snowy cap, "1" = no cap).  Let

\[
S_0 \;=\;\sum_{i,j:t_{i,j}=0} a_{i,j}
\,,\quad
S_1 \;=\;\sum_{i,j:t_{i,j}=1} a_{i,j}
\]

be the current total heights of the two types.  We wish, by a sequence of operations, to make \(S_0=S_1\).  An operation is:

 • Pick a \(k\times k\) submatrix,  
 • Choose any integer \(c\),  
 • Add \(c\) to every height in that submatrix (types are unaffected).

Let
\[
D \;=\; S_0 - S_1
\]
be our current difference.  An operation on a particular \(k\times k\) block \(B\) will add \(c\) to each cell of \(B\).  Among the cells of \(B\), let

\[
\Delta_B \;=\; (\#\text{of cap‐cells in }B)
\;-\;
(\#\text{of non‐cap‐cells in }B).
\]

Then the effect on the difference \(D\) is

\[
\Delta D \;=\; c\;\Delta_B,
\]
since we add \(c\) exactly \(\#\text{cap}(B)\) times to \(S_0\) and \(c\) exactly \(\#\text{non‐cap}(B)\) times to \(S_1\).

Suppose there are \(M\) possible \(k\times k\) blocks \(B_1,\dots,B_M\), with corresponding \(\Delta_i=\Delta_{B_i}\).  Using these operations any integer linear combination

\[
D_{\rm final}
\;=\;
D
\;+\;
\sum_{i=1}^M c_i\,\Delta_i
\]
can be attained (each \(c_i\in\mathbb Z\)).  By elementary number theory, the set of all integer combinations of \(\{\Delta_i\}\) is exactly the set of multiples of
\[
G \;=\;\gcd\bigl(|\Delta_1|,\dots,|\Delta_M|\bigr).
\]
Thus we can make \(D_{\rm final}=0\) (i.e.\ achieve \(S_0=S_1\)) if and only if

  (1) \(\;G>0\) and \(D\equiv 0\pmod G\),  
or (2) \(\;G=0\) (meaning every \(\Delta_i=0\)) and simultaneously \(D=0\).  

In words:

1. Compute the initial difference
   \[
     D=S_0-S_1.
   \]
2. Build an auxiliary array
   \[
     b_{i,j}=
       \begin{cases}
         +1,&t_{i,j}=0,\\
         -1,&t_{i,j}=1.
       \end{cases}
   \]
3. Build its 2D prefix sum.  Then for each top‐left \((r,c)\) of a \(k\times k\) block compute
   \[
     \Delta\;=\;
     \sum_{i=r}^{r+k-1}\sum_{j=c}^{c+k-1}b_{i,j}.
   \]
   Accumulate
   \[
     G\;=\;\gcd\bigl(G,\;|\Delta|\bigr),
   \]
   starting from \(G=0\).
4. At the end, if \(G=0\) then we must have \(D=0\) to answer YES; otherwise we check \(\;|D|\bmod G=0\).

All steps run in \(O(nm)\) time per test, which is fine up to total \(n\,m\le2.5\cdot10^5\).

---

```java
import java.io.*;
import java.util.*;

public class Main {
    static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer tok = new StringTokenizer("");

    static String next() throws IOException {
        while (!tok.hasMoreTokens()) {
            String line = in.readLine();
            if (line == null) return null;
            tok = new StringTokenizer(line);
        }
        return tok.nextToken();
    }
    static int nextInt() throws IOException {
        return Integer.parseInt(next());
    }
    static long nextLong() throws IOException {
        return Long.parseLong(next());
    }
    
    // gcd for nonnegative inputs
    static long gcd(long a, long b) {
        if (a < 0) a = -a;
        if (b < 0) b = -b;
        while (b != 0) {
            long t = a % b;
            a = b;
            b = t;
        }
        return a;
    }

    public static void main(String[] args) throws IOException {
        int t = nextInt();
        StringBuilder sb = new StringBuilder();
        for (int _case = 0; _case < t; _case++) {
            int n = nextInt(), m = nextInt(), k = nextInt();
            long[][] a = new long[n+1][m+1];
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= m; j++) {
                    a[i][j] = nextLong();
                }
            }
            String[] types = new String[n];
            for (int i = 0; i < n; i++) {
                types[i] = next();
            }
            // 1) Compute initial D = sum_caps - sum_noCaps
            long sumCaps = 0, sumNoCaps = 0;
            for (int i = 1; i <= n; i++) {
                String row = types[i-1];
                for (int j = 1; j <= m; j++) {
                    if (row.charAt(j-1) == '0') {
                        sumCaps += a[i][j];
                    } else {
                        sumNoCaps += a[i][j];
                    }
                }
            }
            long D = sumCaps - sumNoCaps;

            // 2) Build b[i][j] = +1 (cap), -1 (noCap)
            int[][] b = new int[n+1][m+1];
            for (int i = 1; i <= n; i++) {
                String row = types[i-1];
                for (int j = 1; j <= m; j++) {
                    b[i][j] = (row.charAt(j-1) == '0' ? 1 : -1);
                }
            }

            // 3) Prefix sums of b
            long[][] ps = new long[n+1][m+1];
            for (int i = 1; i <= n; i++) {
                long running = 0;
                for (int j = 1; j <= m; j++) {
                    running += b[i][j];
                    ps[i][j] = ps[i-1][j] + running;
                }
            }

            // 4) Sweep all k×k blocks, collect gcd of their deltas
            long G = 0;
            for (int i = 1; i + k - 1 <= n; i++) {
                for (int j = 1; j + k - 1 <= m; j++) {
                    int i2 = i + k - 1;
                    int j2 = j + k - 1;
                    long blockSum = ps[i2][j2]
                                  - ps[i-1][j2]
                                  - ps[i2][j-1]
                                  + ps[i-1][j-1];
                    G = gcd(G, blockSum);
                }
            }

            // 5) Decision
            boolean ok;
            if (G == 0) {
                // All block deltas are 0 ⇒ we cannot change D at all
                ok = (D == 0);
            } else {
                // We can shift D by any multiple of G
                ok = (Math.floorMod(D, G) == 0);
            }

            sb.append(ok ? "YES\n" : "NO\n");
        }

        System.out.print(sb);
    }
}
```

**Explanation of the main steps**

1. **Compute**  
   \[
     D \;=\;\sum_{t_{i,j}=0}a_{i,j}\;-\;\sum_{t_{i,j}=1}a_{i,j}
   \]  
   This is how far off the two sums are.

2. **Recode** the type‐grid into  
   \[
     b_{i,j} =
       \begin{cases}
         +1, & t_{i,j}=0\text{ (snowy)},\\
         -1, & t_{i,j}=1\text{ (no cap)}.
       \end{cases}
   \]  

3. **2D prefix‐sum** the array \(b\), so we can in \(O(1)\) compute for any \(k\times k\) block \(B\):
   \[
     \Delta_B
     \;=\;
     \sum_{(i,j)\in B}b_{i,j}
     \;=\;
     (\#\text{snowy in }B)-(\#\text{no cap in }B).
   \]

4. Let \(\{\Delta_i\}\) be the deltas of all \(k\times k\) blocks.  We compute  
   \[
     G \;=\;\gcd(\,|\Delta_1|,|\Delta_2|,\dots\,).
   \]
   An operation on block \(i\) with integer \(c\) changes \(D\) by \(c\Delta_i\).  By the theory of integer linear combinations, one can reach exactly those final differences that are congruent to the original \(D\) modulo \(G\).

5. **Answer** YES if and only if \(D\) is already \(0\) when \(G=0\) (no block can change the difference), or otherwise \(D\equiv 0~(\bmod\,G)\).

This runs in \(O(nm)\) per test, comfortably within limits for \(\sum nm\le2.5\times 10^5\).