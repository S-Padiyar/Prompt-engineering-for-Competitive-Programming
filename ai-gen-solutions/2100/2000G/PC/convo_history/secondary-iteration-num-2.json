[
  {
    "role": "user",
    "content": "G. Call During the Journey\n\ntime limit per test4 seconds\n\nmemory limit per test256 megabytes\n\nYou live in a city consisting of n\n\n intersections and m\n\n streets connecting some pairs of intersections. You can travel in either direction on each street. No two streets connect the same pair of intersections, and no street connects an intersection to itself. You can reach any intersection from any other, possibly passing through some other intersections.\n\n\n\nEvery minute, you can board a bus at intersection ui\n\n and travel for li1\n\n minutes to intersection vi\n\n. Conversely, you can travel from intersection vi\n\n to intersection ui\n\n in li1\n\n minutes. You can only board and exit the bus at intersections. You can only board the bus at an intersection if you are currently there.\n\n\n\nYou can also walk along each street, which takes li2>li1\n\n minutes.\n\n\n\nYou can make stops at intersections.\n\n\n\nYou live at intersection number 1\n\n. Today you woke up at time 0\n\n, and you have an important event scheduled at intersection number n\n\n, which you must reach no later than time t0\n\n. You also have a phone call planned that will last from t1\n\n to t2\n\n minutes (t1<t2<t0\n\n).\n\n\n\nDuring the phone call, you cannot ride the bus, but you can walk along any streets, make stops, or stay at home. You can exit the bus at minute t1\n\n and board the bus again at minute t2\n\n.\n\n\n\nSince you want to get enough sleep, you became curious — how late can you leave home to have time to talk on the phone and still not be late for the event?\n\n\n\nInput\n\nThe first line contains an integer t\n\n (1≤t≤104\n\n) — the number of test cases. The following are the descriptions of the test cases.\n\n\n\nThe first line of each test case contains two integers n\n\n, m\n\n (2≤n≤105,1≤m≤105\n\n) — the number of intersections and streets in the city.\n\n\n\nThe second line of each test case contains three integers t0\n\n, t1\n\n, t2\n\n (1≤t1<t2<t0≤109\n\n) — the start time of the event, the start time of the phone call, and its end time, respectively.\n\n\n\nThe next m\n\n lines of each test case contain descriptions of the streets.\n\n\n\nThe i\n\n-th line contains four integers ui\n\n, vi\n\n, li1\n\n, li2\n\n (1≤ui,vi≤n\n\n, ui≠vi\n\n, 1≤li1<li2≤109\n\n) — the numbers of the intersections connected by the i\n\n-th street, as well as the travel time along the street by bus and on foot. It is guaranteed that no two streets connect the same pair of intersections and that it is possible to reach any intersection from any other.\n\n\n\nIt is guaranteed that the sum of the values of n\n\n across all test cases does not exceed 105\n\n. It is also guaranteed that the sum of the values of m\n\n across all test cases does not exceed 105\n\n.\n\n\n\nOutput\n\nFor each test case, output a single integer — the latest time you can leave home to have time to talk on the phone and not be late for the event. If you cannot reach the event on time, output -1.\n\n\n\nExample\n\nInputCopy\n\n7\n\n5 5\n\n100 20 80\n\n1 5 30 100\n\n1 2 20 50\n\n2 3 20 50\n\n3 4 20 50\n\n4 5 20 50\n\n2 1\n\n100 50 60\n\n1 2 55 110\n\n4 4\n\n100 40 60\n\n1 2 30 100\n\n2 4 30 100\n\n1 3 20 50\n\n3 4 20 50\n\n3 3\n\n100 80 90\n\n1 2 1 10\n\n2 3 10 50\n\n1 3 20 21\n\n3 2\n\n58 55 57\n\n2 1 1 3\n\n2 3 3 4\n\n2 1\n\n12 9 10\n\n2 1 6 10\n\n5 5\n\n8 5 6\n\n2 1 1 8\n\n2 3 4 8\n\n4 2 2 4\n\n5 3 3 4\n\n4 5 2 6\n\nOutputCopy\n\n0\n\n-1\n\n60\n\n80\n\n53\n\n3\n\n2\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have an undirected connected graph of \\(n\\) intersections (nodes) and \\(m\\) streets (edges).  Each edge \\((u,v)\\) carries two travel‐times:\n\n- \\(w_1\\) = time by bus (fast),  \n- \\(w_2\\) = time on foot (slow),  \nwith \\(1 \\le w_1 < w_2\\le10^9\\).  \n\nYou live at node \\(1\\), must end at node \\(n\\) no later than absolute time \\(t_0\\).  You have a phone call on \\([t_1,t_2]\\).  During the call you \\emph{cannot} ride the bus, but you may walk or wait.  You can only board or alight buses at intersections, and you may freely wait at intersections at no cost except time.\n\nYou ask: “How late can I leave home (node \\(1\\)) and still make it to node \\(n\\) by time \\(t_0\\), given the bus‐forbidden interval \\([t_1,t_2]\\)?”\n\nA clean way to solve “latest‐departure‐time under constraints” is to do a **reverse** graph‐search propagating latest‐allowed‐arrival times back from the destination.  In a purely static graph (no time windows), if you must arrive at \\(v\\) by time \\(L[v]\\), and edge \\((u\\to v)\\) takes \\(c\\), then you must leave \\(u\\) no later than \\(L[v]-c\\); so you set\n\n\\[\n  L[u]\\;\\;=\\;\\;\\max\\bigl(L[u],\\;L[v]-c\\bigr),\n\\]\n\nand you can do a “longest‐path” update (in practice a Dijkstra‐style max‐heap).\n\nHere, walking is allowed at any time, so an undirected “walk‐edge” \\((u,v)\\), cost \\(w_2\\), gives\n\\[\n   L[u]\\;=\\;\\max\\bigl(L[u],\\,L[v]-w_2\\bigr).\n\\]\nBuses are allowed only if the entire bus‐ride interval \\([t,t+w_1]\\) avoids the call‐window \\([t_1,t_2]\\).  Equivalently, a departure time \\(t\\) is legal iff\n- \\(t+w_1\\le t_1\\)  (ride completes entirely before the call), or  \n- \\(t\\ge t_2\\)      (ride begins after the call ends),  \n\nand we must also have \\(t+w_1\\le L[v]\\) so that from \\(v\\) we can still make it in time.  \n\nHence in the reverse update from \\(v\\) to \\(u\\) over a bus‐edge of length \\(w_1\\), if \\(L[v]\\) is the latest we may arrive at \\(v\\), we solve\n\n1.  **“pre‐call”** case: we depart so early that the ride finishes by \\(t_1\\) and also by \\(L[v]\\).  Then\n   \\[\n     t\\le \\min\\bigl(t_1 - w_1,\\;L[v]-w_1\\bigr)\n     \\quad\\Longrightarrow\\quad\n     t_{\\rm pre} \\;=\\;\\min(t_1 - w_1,\\;L[v]-w_1).\n   \\]\n   This is only valid if \\(t_{\\rm pre}\\ge0\\).\n\n2.  **“post‐call”** case: we depart no earlier than \\(t_2\\), and still finish by \\(L[v]\\).  That is\n   \\[\n     t\\ge t_2,\\quad t+w_1\\le L[v]\\quad\\Longrightarrow\\quad t\\le L[v]-w_1,\n   \\]\n   so the maximum feasible \\(t\\) in that band is\n   \\[\n     t_{\\rm post}\\;=\\;L[v]-w_1,\n   \\]\n   but only if \\(L[v]-w_1\\ge t_2\\).\n\nWe take\n\\[\n  t_{\\rm new}\\;=\\;\\max\\bigl(\\,t_{\\rm pre}\\;(\\ge0)\\,,\\;t_{\\rm post}\\,\\bigr)\n\\]\nwhenever either exists, and then set\n\\[\n   L[u]\\;=\\;\\max\\bigl(L[u],\\,t_{\\rm new}\\bigr).\n\\]\n\nWe also allow waiting/walking at intersections at no extra “ride‐cost” beyond time, so walking edges simply do\n\n\\[\n   L[u]\\;=\\;\\max\\bigl(L[u],\\,L[v]-w_2\\bigr),\n\\]\nand we only keep updates if \\(L[u]\\) actually increases.\n\nWe initialize\n\\[\n  L[n]=t_0,\n  \\quad\n  L[u]=-1\\quad(\\text{or }-\\infty)\\;\\forall u\\ne n.\n\\]\nWe run a “reverse Dijkstra”‐like propagation, always extracting the node \\(v\\) with the current largest \\(L[v]\\) from a max‐heap, and relaxing all its neighbors (both walking‐ and bus‐cases).  In the end \\(L[1]\\) is the \\emph{latest} time we can depart node \\(1\\) and still arrive by \\(t_0\\).  If \\(L[1]<0\\), even starting at time 0 fails, so we print \\(-1\\).  Otherwise we print \\(\\lfloor L[1]\\rfloor\\).\n\nSince \\(n,m\\le10^5\\) (over all test‐cases) and each edge produces at most two relaxations in each direction, the running time is \\(O((n+m)\\log(n+m))\\), which is plenty fast.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to;\n        long wBus, wWalk;\n        Edge(int t, long b, long w) { to = t; wBus = b; wWalk = w; }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st;\n\n        int T = Integer.parseInt(br.readLine().trim());\n        final long NEG_INF = -1;  // marker for impossible / not yet reached\n\n        StringBuilder output = new StringBuilder();\n        while (T-- > 0) {\n            st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(st.nextToken());\n\n            st = new StringTokenizer(br.readLine());\n            long t0 = Long.parseLong(st.nextToken());\n            long t1 = Long.parseLong(st.nextToken());\n            long t2 = Long.parseLong(st.nextToken());\n\n            // Build adjacency\n            List<List<Edge>> adj = new ArrayList<>(n+1);\n            for (int i = 0; i <= n; i++) adj.add(new ArrayList<>());\n\n            for (int i = 0; i < m; i++) {\n                st = new StringTokenizer(br.readLine());\n                int u = Integer.parseInt(st.nextToken());\n                int v = Integer.parseInt(st.nextToken());\n                long w1 = Long.parseLong(st.nextToken());\n                long w2 = Long.parseLong(st.nextToken());\n                // undirected\n                adj.get(u).add(new Edge(v, w1, w2));\n                adj.get(v).add(new Edge(u, w1, w2));\n            }\n\n            // L[u] = latest time we can leave intersection u and still make the deadline\n            long[] L = new long[n+1];\n            Arrays.fill(L, NEG_INF);\n            L[n] = t0;\n\n            // Max‐heap by latest‐departure‐time\n            PriorityQueue<Integer> pq = new PriorityQueue<>(\n                (a,b) -> Long.compare(L[b], L[a])\n            );\n            pq.add(n);\n\n            boolean[] seen = new boolean[n+1];  // we'll re‐check stale pulls anyway\n\n            while (!pq.isEmpty()) {\n                int v = pq.poll();\n                long curLv = L[v];\n                // stale check\n                if (curLv < 0) break; // nobody else can improve if max < 0\n                // We don't need seen[], we just skip if L[v] changed below\n                // Relax all edges v->u in the reverse sense\n                for (Edge e : adj.get(v)) {\n                    int u = e.to;\n                    // 1) Walk\n                    long candWalk = curLv - e.wWalk;\n                    if (candWalk >= 0 && candWalk > L[u]) {\n                        L[u] = candWalk;\n                        pq.remove(u);  // remove stale\n                        pq.add(u);\n                    }\n                    // 2) Bus\n                    long w1 = e.wBus;\n                    // pre-call departure\n                    long tPre = Math.min(t1 - w1, curLv - w1);\n                    if (tPre < 0) tPre = NEG_INF; \n                    // post-call departure\n                    long tPost = NEG_INF;\n                    long tDepIfPost = curLv - w1;\n                    if (tDepIfPost >= t2) {\n                        tPost = tDepIfPost;\n                    }\n                    long tNew = Math.max(tPre, tPost);\n                    if (tNew >= 0 && tNew > L[u]) {\n                        L[u] = tNew;\n                        pq.remove(u);\n                        pq.add(u);\n                    }\n                }\n            }\n\n            long ans = L[1];\n            if (ans < 0) ans = -1;\n            output.append(ans).append(\"\\n\");\n        }\n\n        System.out.print(output);\n    }\n}\n```\n\n**Explanation of the key steps**\n\n1. **Reverse “latest‐departure” DP**  \n   We keep an array `L[u]` = “the latest absolute time we can depart intersection `u` and still eventually reach node `n` by time `T0` under the call‐window constraints.”  \n\n2. **Initialization**  \n   - `L[n] = t0`, since at node `n` we are already at destination and must be there by `t0`.  \n   - `L[u] = -∞` (we use `-1` to denote impossible) for all other `u`.  \n\n3. **Walking edges**  \n   Walking is always allowed, so if from `u` you walk to `v` in time `w2`, you must leave `u` at latest `L[v] - w2`.  Hence  \n   ```\n     L[u] = max(L[u], L[v] - w2).\n   ```\n\n4. **Bus edges**  \n   A bus‐ride of duration `w1` can only be taken if its entire interval `[t, t+w1]` avoids `[t1,t2]`.  That means either  \n   - it finishes by `t1`, i.e.~`t+w1 ≤ t1`, or  \n   - it starts at or after `t2`, i.e.~`t ≥ t2`.  \n   And we also require that `t + w1 ≤ L[v]` so that after we arrive at `v` we can still make the global deadline `L[v]`.  \n\n   Working backwards from `v` to `u` we get two candidate departure times:\n   - Pre-call: `t ≤ min(t1-w1, L[v]-w1)`.  So the best in that range is  \n     ```\n       tPre = min(t1-w1, L[v]-w1),\n     ```  \n     valid only if `tPre ≥ 0`.\n   - Post-call: `t ≥ t2` and `t ≤ L[v]-w1`.  The best is  \n     ```\n       tPost = L[v]-w1,\n     ```  \n     valid only if `L[v]-w1 ≥ t2`.\n     \n   We then take  \n   ```\n     tNew = max(tPre, tPost)\n   ```\n   (as long as it is ≥ 0) and do  \n   ```\n     L[u] = max(L[u], tNew).\n   ```\n\n5. **Dijkstra‐style propagation**  \n   We use a max‐heap keyed by the current `L[u]`.  Initially we push `n` with key `t0`.  Each time we pop the node `v` with the largest `L[v]`, relax all edges `(v→u)` in the two ways above, update `L[u]` if we get a larger value, and push `u` back into the heap.\n\n6. **Answer**  \n   At the end, `L[1]` is the latest time we can leave home.  If `L[1] < 0` it means even leaving at time 0 fails, so we print `-1`.  Otherwise we print `L[1]`.\n\nThis runs in \\(O((n+m)\\log n)\\) per test (and the sum of \\(n,m\\) over all tests is at most \\(10^5\\)), which easily fits under the 4 second / 256 MB limits."
  },
  {
    "role": "user",
    "content": "Please rewrite the Java solution as a single code block. Use a priority queue of `State { long time; int node; }` objects keyed by `time` (max-heap). On each poll, skip stale entries by checking if `state.time != L[state.node]`. Do *not* call `pq.remove()`. Ensure you handle multiple test cases and meet the required time complexity."
  },
  {
    "role": "assistant",
    "content": "```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to;\n        long bus, walk;\n        Edge(int t, long b, long w) { to = t; bus = b; walk = w; }\n    }\n    static class State {\n        int node;\n        long time;\n        State(int n, long t) { node = n; time = t; }\n    }\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st;\n        int T = Integer.parseInt(br.readLine().trim());\n        StringBuilder sb = new StringBuilder();\n        \n        while (T-- > 0) {\n            st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(st.nextToken());\n            st = new StringTokenizer(br.readLine());\n            long t0 = Long.parseLong(st.nextToken());\n            long t1 = Long.parseLong(st.nextToken());\n            long t2 = Long.parseLong(st.nextToken());\n            \n            List<Edge>[] adj = new ArrayList[n+1];\n            for (int i = 1; i <= n; i++) adj[i] = new ArrayList<>();\n            for (int i = 0; i < m; i++) {\n                st = new StringTokenizer(br.readLine());\n                int u = Integer.parseInt(st.nextToken());\n                int v = Integer.parseInt(st.nextToken());\n                long w1 = Long.parseLong(st.nextToken());\n                long w2 = Long.parseLong(st.nextToken());\n                adj[u].add(new Edge(v, w1, w2));\n                adj[v].add(new Edge(u, w1, w2));\n            }\n            \n            // L[u] = latest departure time from u to still reach n by t0\n            long[] L = new long[n+1];\n            Arrays.fill(L, -1L);\n            L[n] = t0;\n            \n            // Max‐heap on departure time\n            PriorityQueue<State> pq = new PriorityQueue<>(\n                (a, b) -> Long.compare(b.time, a.time)\n            );\n            pq.offer(new State(n, t0));\n            \n            while (!pq.isEmpty()) {\n                State stt = pq.poll();\n                int v = stt.node;\n                long cur = stt.time;\n                // skip stale\n                if (cur != L[v]) continue;\n                // if cur<0, no further positive updates possible\n                if (cur < 0) break;\n                \n                for (Edge e : adj[v]) {\n                    int u = e.to;\n                    // 1) walk\n                    long candWalk = cur - e.walk;\n                    if (candWalk >= 0 && candWalk > L[u]) {\n                        L[u] = candWalk;\n                        pq.offer(new State(u, candWalk));\n                    }\n                    // 2) bus\n                    long w1 = e.bus;\n                    // pre‐call\n                    long tPre = Math.min(t1 - w1, cur - w1);\n                    if (tPre < 0) tPre = -1;\n                    // post‐call\n                    long tPost = -1;\n                    long dep = cur - w1;\n                    if (dep >= t2) tPost = dep;\n                    long tNew = Math.max(tPre, tPost);\n                    if (tNew >= 0 && tNew > L[u]) {\n                        L[u] = tNew;\n                        pq.offer(new State(u, tNew));\n                    }\n                }\n            }\n            \n            long ans = L[1];\n            sb.append(ans < 0 ? -1 : ans).append('\\n');\n        }\n        System.out.print(sb.toString());\n    }\n}\n```"
  },
  {
    "role": "system",
    "content": "Identify any errors in this response and output a prompt to help the AI resolve said issues. Your response MUST be in one of two formats: 1. If the response looks perfect, return \"Perfect\". Do not return this if there are any issues. Use this very sparingly as any errors in the final output from the AI will be considered a failure on your part. 2. Otherwise, return \"{prompt}\" where {prompt} is replaced with your concise prompt. This should be done most often, even if the AI's response is mostly correct. Ensure the entire response is enclosed in double quotations if it's a prompt. Make sure your prompt asks the AI to return one block of code for submission."
  },
  {
    "role": "assistant",
    "content": "Perfect"
  }
]