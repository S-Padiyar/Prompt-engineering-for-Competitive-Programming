[
  {
    "role": "user",
    "content": "F. Non-academic Problem\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nYou are given a connected undirected graph, the vertices of which are numbered with integers from 1\n\n to n\n\n. Your task is to minimize the number of pairs of vertices 1≤u<v≤n\n\n between which there exists a path in this graph. To achieve this, you can remove exactly one edge from the graph.\n\n\n\nFind the smallest number of pairs of vertices!\n\n\n\nInput\n\nEach test consists of several sets of input data. The first line contains a single integer t\n\n (1≤t≤104\n\n) — the number of sets of input data. Then follows their description.\n\n\n\nThe first line of each set of input data contains two integers n\n\n and m\n\n (2≤n≤105\n\n, n−1≤m≤min(105,n⋅(n−1)2)\n\n) — the number of vertices in the graph and the number of edges.\n\n\n\nEach of the next m\n\n lines contains two integers u\n\n and v\n\n (1≤u,v≤n,u≠v\n\n), indicating that there is an undirected edge in the graph between vertices u\n\n and v\n\n.\n\n\n\nIt is guaranteed that the given graph is connected and without multiple edges.\n\n\n\nIt is guaranteed that the sum of n\n\n and the sum of m\n\n over all sets of input data does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each set of input data, output the smallest number of pairs of reachable vertices, if exactly one edge can be removed.\n\n\n\nExample\n\nInputCopy\n\n6\n\n2 1\n\n1 2\n\n3 3\n\n1 2\n\n2 3\n\n1 3\n\n5 5\n\n1 2\n\n1 3\n\n3 4\n\n4 5\n\n5 3\n\n6 7\n\n1 2\n\n1 3\n\n2 3\n\n3 4\n\n4 5\n\n4 6\n\n5 6\n\n5 5\n\n1 2\n\n1 3\n\n2 3\n\n2 4\n\n3 5\n\n10 12\n\n1 2\n\n1 3\n\n2 3\n\n2 4\n\n4 5\n\n5 6\n\n6 7\n\n7 4\n\n3 8\n\n8 9\n\n9 10\n\n10 8\n\nOutputCopy\n\n0\n\n3\n\n4\n\n6\n\n6\n\n21\n\nNote\n\nIn the first set of input data, we will remove the single edge (1,2)\n\n and the only pair of vertices (1,2)\n\n will become unreachable from each other.\n\n\n\nIn the second set of input data, no matter which edge we remove, all vertices will be reachable from each other.\n\n\n\nIn the fourth set of input data, the graph looks like this initially.\n\n\n\n\n\nWe will remove the edge (3,4)\n\n and then the only reachable pairs of vertices will be (1,2)\n\n, (1,3)\n\n, (2,3)\n\n, (4,5)\n\n, (4,6)\n\n, (5,6)\n\n.\n\n\n\n\n\nIn the sixth set of input data, the graph looks like this initially.\n\n\n\n\n\nAfter removing the edge (2,4)\n\n, the graph will look like this. Thus, there will be 21\n\n pairs of reachable vertices.\n\n\n\n\n\n\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have a connected undirected graph on \\(n\\) vertices and \\(m\\) edges.  We may remove exactly one edge.  After removing an edge, the graph may become disconnected; if an edge is not a bridge (i.e.\\ its removal does not increase the number of connected components), the graph stays connected and *every* pair of vertices remains reachable.\n\nWe wish to *minimize* the number of reachable pairs \\(\\bigl\\{u<v\\}\\) that still have a path between them, equivalently to *maximize* the number of newly unreachable pairs.\n\n-   Total number of unordered pairs of \\(n\\) vertices is\n    \\[\n       \\binom n2 \\;=\\;\\frac{n(n-1)}2.\n    \\]\n-   If removing an edge splits the graph into two connected components of sizes \\(s\\) and \\(n-s\\), then exactly\n    \\[\n      s\\,(n-s)\n    \\]\n    pairs cross between the two components and become unreachable.\n-   If the removed edge is *not* a bridge, then the graph remains connected and \\(s=0\\) or \\(n\\), so \\(s(n-s)=0\\)—no lost reachability.\n\nHence the problem reduces to:\n\n1.  Find *all* bridges in the graph.\n2.  For each bridge, determine the sizes \\(s\\) and \\(n-s\\) of the two components created by removing it.\n3.  Choose the bridge whose removal maximizes \\(s(n-s)\\).\n4.  Subtract that from the total \\(\\binom n2\\).\n\nAll we need, then, is a standard DFS-based bridge‐finding (Tarjan) together with tracking subtree sizes in the DFS tree.  Whenever we detect that a tree‐edge \\((u,v)\\) is a bridge (by the test \\(\\mathrm{low}[v]>\\mathrm{tin}[u]\\)), the subtree of \\(v\\) in our DFS has size \\(\\mathrm{sz}[v]\\), and the other side has size \\(n-\\mathrm{sz}[v]\\).  We take \n\\[\n   \\max_{(u,v)\\,\\text{bridge}} \\bigl(\\,\\mathrm{sz}[v]\\times (n-\\mathrm{sz}[v])\\bigr).\n\\]\nOur final answer is\n\\[\n   \\binom n2 \\;-\\;\\max_{bridge}\\bigl(s(n-s)\\bigr).\n\\]\n\nWe implement an *iterative* DFS (to avoid Java recursion‐stack issues) that maintains arrays\n\n-   `tin[v]`, discovery time of \\(v\\);\n-   `low[v]`, low‐link value of \\(v\\);\n-   `sz[v]`, size of the DFS‐subtree rooted at \\(v\\);\n-   `visited[v]`.\n\nWe use an explicit stack of states to simulate the recursive Tarjan DFS.  Each time we finish exploring a child we do the “bridge‐check” and update `low` and `sz` of the parent.  We record the maximum product \\(s(n-s)\\) seen so far.\n\nOverall time per test is \\(O(n+m)\\), and across all tests at most \\(2\\times10^5\\) vertices plus edges, which runs comfortably in 2 s.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class StackEntry {\n        int type;     // 0 = DFS state; 1 = \"post-child\" state\n        int v, parent, iter, u;\n        // For type=0 (DFS): v=vertex, parent=parent, iter=next neighbor index\n        // For type=1 (post): v=parent, u=child\n        StackEntry(int type, int v, int parent, int iter, int u) {\n            this.type = type;\n            this.v = v;\n            this.parent = parent;\n            this.iter = iter;\n            this.u = u;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        int t = Integer.parseInt(in.readLine().trim());\n        while (t-- > 0) {\n            StringTokenizer st = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(st.nextToken());\n\n            // Build adjacency list\n            List<Integer>[] adj = new ArrayList[n+1];\n            for (int i = 1; i <= n; i++) {\n                adj[i] = new ArrayList<>();\n            }\n            for (int i = 0; i < m; i++) {\n                st = new StringTokenizer(in.readLine());\n                int u = Integer.parseInt(st.nextToken());\n                int v = Integer.parseInt(st.nextToken());\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n\n            // Arrays for Tarjan‐bridge + subtree‐sizes\n            int[] tin = new int[n+1], low = new int[n+1], sz = new int[n+1];\n            boolean[] visited = new boolean[n+1];\n            int timer = 0;\n            long bestProduct = 0;\n\n            // We'll do one DFS (the graph is connected)\n            ArrayDeque<StackEntry> stack = new ArrayDeque<>();\n            // Initial DFS state at vertex 1, parent = -1, next-iter = 0\n            stack.push(new StackEntry(0, 1, -1, 0, 0));\n\n            while (!stack.isEmpty()) {\n                StackEntry e = stack.pop();\n                if (e.type == 1) {\n                    // \"Post-child\" state: we've finished child u of parent v\n                    int v = e.v, u = e.u;\n                    // Update low-link and subtree size\n                    low[v] = Math.min(low[v], low[u]);\n                    sz[v] += sz[u];\n                    // Bridge check\n                    if (low[u] > tin[v]) {\n                        long s = sz[u];\n                        long prod = s * (n - s);\n                        if (prod > bestProduct) {\n                            bestProduct = prod;\n                        }\n                    }\n                } else {\n                    // DFS state\n                    int v = e.v, p = e.parent;\n                    if (e.iter == 0) {\n                        // first time we see v\n                        visited[v] = true;\n                        tin[v] = low[v] = ++timer;\n                        sz[v] = 1;\n                    }\n                    if (e.iter < adj[v].size()) {\n                        // Process next neighbor\n                        int u = adj[v].get(e.iter);\n                        e.iter++;  // increment for next time\n                        // Push the current state back (to resume later)\n                        stack.push(e);\n\n                        if (u == p) {\n                            // the edge back to parent; ignore\n                            continue;\n                        }\n                        if (visited[u]) {\n                            // back-edge\n                            low[v] = Math.min(low[v], tin[u]);\n                        } else {\n                            // tree-edge, will recurse into u\n                            // After returning from u, we must do the \"post-child\" update\n                            stack.push(new StackEntry(1, v, 0, 0, u));  // post-child\n                            stack.push(new StackEntry(0, u, v, 0, 0));  // DFS into u\n                        }\n                    }\n                    // else e.iter >= adj[v].size() => all neighbors done, no re-push\n                }\n            }\n\n            // Total pairs minus max unreachable = min reachable\n            long totalPairs = ((long)n * (n - 1)) / 2;\n            long answer = totalPairs - bestProduct;\n            out.println(answer);\n        }\n\n        out.flush();\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. We compute the total number of unordered pairs \\(\\binom n2\\).\n2. We run a DFS/Tarjan bridge‐finding algorithm.  In the DFS tree,\n   - `tin[v]` is the discovery time of \\(v\\).\n   - `low[v]` is the minimum discovery time reachable from \\(v\\) by at most one back‐edge.\n   - `sz[v]` is the size of the subtree of \\(v\\) in the DFS tree.\n3. An edge \\((v,u)\\) (with \\(v\\) the parent of \\(u\\) in the DFS tree) is a bridge exactly if \n   \\[\n     \\mathrm{low}[u] > \\mathrm{tin}[v].\n   \\]\n   Removing that bridge splits off a component of size `sz[u]` on \\(u\\)‘s side and \\(n - \\mathrm{sz}[u]\\) the other.\n4. We maintain the maximum product \\(\\mathrm{sz}[u]\\times\\bigl(n-\\mathrm{sz}[u]\\bigr)\\) over all bridges.  This is the *maximum* number of pairs that become unreachable by removing a single edge.\n5. The minimum number of *reachable* pairs is then\n   \\[\n     \\binom n2 - \\max_{bridge} \\bigl(s(n-s)\\bigr).\n   \\]\n6. We print this value for each test case.\n\nBecause we do the DFS iteratively with an explicit stack (and only \\(O(m+n)\\) work per test), the method runs efficiently under the problem’s constraints."
  },
  {
    "role": "system",
    "content": "Identify any errors in this response and output a prompt to help the AI resolve said issues. Your response MUST be in one of two formats: 1. If the response looks perfect, return \"Perfect\". Do not return this if there are any issues. Use this very sparingly as any errors in the final output from the AI will be considered a failure on your part. 2. Otherwise, return \"{prompt}\" where {prompt} is replaced with your concise prompt. This should be done most often, even if the AI's response is mostly correct. Ensure the entire response is enclosed in double quotations if it's a prompt. Make sure your prompt asks the AI to return one block of code for submission."
  },
  {
    "role": "assistant",
    "content": "Perfect"
  }
]