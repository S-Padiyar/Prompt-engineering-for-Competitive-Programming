**Analysis**

We have an undirected tree on _n_ nodes.  We perform exactly one “shuffle” on the whole tree, which is a recursive procedure that

 1. Picks a node _v_ as the “root” of the current component.
 2. Deletes _v_, which splits the current component into its connected sub‐components.
 3. Recursively shuffles each sub‐component, obtaining a new tree for each.
 4. Attaches each sub‐tree’s root back to _v_ to form the new tree.

We then count leaves in the resulting tree (an undirected tree leaf is any node of degree 1; the very root can also count as a leaf if it ends up with only one child).  We want to choose our single top‐level shuffle (i.e. choose the top‐level root) and all the recursive root‐choices underneath so as to **maximize** the number of leaves in the final tree.

A key observation is that every node that is used as a “root” of a component of size ≥ 2 ends up having degree ≥ 2 in the final tree (and so is _not_ a leaf), _except_ possibly the global root itself: if we choose as global root a node of original degree ≤ 1, then in the final tree it will have degree 1 (one child) and _will_ count as a leaf.  All other nodes used as a root of a larger component are forced to have at least two neighbours (its “parent” plus one or more component‐roots attached), so they cannot be leaves.

On the other hand, every node that _never_ served as a root of a component of size ≥ 2 becomes an “isolated singleton” at some stage of the recursion and hence is _exactly_ a leaf in the final tree.

It follows that the resulting number of leaves can be written as

    (# of nodes that never serve as a non‐singleton root)
   + (1 if the global root we chose has original degree ≤ 1, since then it also ends up as a leaf).

Moreover, one can show (via a small combinatorial argument or by analogy to minimal vertex‐covers versus maximal matchings) that finding the minimum possible number of nodes that _do_ serve as roots of size‐≥2 components is equivalent to finding a **maximum matching** in the tree.  Indeed, if you choose any vertex‐cover of the tree of minimum size, then every edge has at least one endpoint in that cover; one can think of those vertices as the forced internal nodes, and the leftover vertices become singleton components (leaves).  And in any bipartite graph (a tree is bipartite), the size of a minimum vertex‐cover equals the size of a maximum matching.  

Hence one shows:

 1.  If we cut the chosen global root _v_ out, the tree splits into components \(C_1,C_2,\dots,C_d\).  
 2.  In each component \(C_i\) we can force exactly \(\mathrm{MM}(C_i)\) nodes to be “internal” (these correspond to a minimum vertex‐cover in \(C_i\), i.e. the size of a maximum matching in \(C_i\)).  
 3.  All other nodes in \(C_i\) become leaves.  
 4.  Finally, if the global root has original degree ≤ 1, it also ends up as a leaf (otherwise it is not a leaf).

Thus, if we denote by \(\mathrm{MM}(T)\) the size of the maximum matching of a tree \(T\), and if we pick as top‐level root \(v\), then

-  The number of internal nodes used in the shuffle is
     
     1 (for the chosen root, since the top‐level root must be “used”)
     +∑_{i=1}^d MM(C_i) 
     
  (where \(C_1,\dots,C_d\) are the components after deleting \(v\)).

-  Therefore the total leaves in the final tree are
     
     n – [ 1 + ∑ MM(C_i ) ]
     + (1 if deg(v)≤1, else 0).

  If deg(v)≥2, you _cannot_ count the root itself as a leaf, so you do _not_ add the extra 1.  
  If deg(v)≤1, you _can_—so you add the +1 back.

We would like to pick \(v\) so as to _maximize_ that leaf‐count.  Equivalently, we need to _minimize_ the sum of the matchings of its deleted‐components,

   ∑_{u ∈ N(v)} MM( component of T when edge (v,u) is removed )

where \(N(v)\) are the original neighbors of \(v\).  Denote for each directed edge \((u→v)\), \(\mathrm{mm}_{u→v}\) = the maximum matching of the component that contains \(u\) when we delete the edge \(u–v\).  

Then for each node \(v\),

  -  sum_mm_adj[v] = ∑_{u∈N(v)} mm_{u→v}  
  -  if deg(v)≥2, #leaves = n − 1 − sum_mm_adj[v].  
  -  otherwise (deg(v)≤1), #leaves = n − sum_mm_adj[v].  

We pick the maximum over all \(v\).

So the algorithm becomes:

1.  Root the tree arbitrarily at node 1 and do a **tree‐DP** to compute for each node _u_:

   dp0[u] = ∑_{c child of u} dp_best[c],  
   diff[c] = dp0[c] + 1 – dp_best[c],  take the best two such diffs among the children of u,  
   dp_best[u] = max(dp0[u], dp0[u] + max(0, best_child_diff)).

   Here dp_best[u] = the size of the maximum matching in the _subtree_ rooted at _u_ when cut off from its parent.

2.  Then do a classic **reroot‐DP** or one BFS‐pass to propagate the “outside” matching‐size to each child:

   -  We carry for each node _u_ the pair (up_dp0[u], up_best[u]) that describe the matching‐size of the component “above” u (the rest of the tree outside u’s parent‐edge).  
   -  Then for each child _c_ of u we can compute that same pair for _c_ by _excluding_ c’s contribution from the sums at u, and recomputing a local best.  

   After that pass we have, for **every** directed edge \((u→v)\), the matching size of the component on the _u_ side when \((u–v)\) is cut.

3.  Finally we compute for each node v:

     sum_mm_adj[v] = ∑_{u∈N(v)} mm_{u→v}
     if deg(v)≥2, leaves(v) = n – 1 – sum_mm_adj[v]
                else  leaves(v) = n – sum_mm_adj[v].

   Return the maximum of leaves(v) over v.

All steps run in O(n).  The first is a single post‐order pass, the second is essentially one BFS/level‐order pass, and the final is O(n).  Matching‐DP on a tree is standard: dp0[u] = sum of children’s dp_best; then dp_best[u] = either match u to _one_ child (gain = 1 + dp0[that child] – dp_best[that child]) or leave u unmatched.

---

```java
import java.io.*;
import java.util.*;

public class Main {
    static int N;
    static List<Integer>[] adj;
    static int[] parent, deg;
    static int[] order;       // BFS order
    static int[] dp0, dpBest; // dp0[u] = sum dpBest[children], dpBest[u] = best matching in subtree u
    // For each u we keep the two largest "diff" values over its children:
    static int[] diff1, diff2, diff1Id;
    // For reroot:
    static int[] upDp0, upBest, diffParent;
    static long[] sumMmAdj;

    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer tk = new StringTokenizer(in.readLine());
        int t = Integer.parseInt(tk.nextToken());
        StringBuilder sb = new StringBuilder();

        while (t-- > 0) {
            tk = new StringTokenizer(in.readLine());
            N = Integer.parseInt(tk.nextToken());
            // Build adjacency
            adj = new ArrayList[N+1];
            for (int i = 1; i <= N; i++) {
                adj[i] = new ArrayList<>();
            }
            for (int i = 1; i < N; i++) {
                tk = new StringTokenizer(in.readLine());
                int u = Integer.parseInt(tk.nextToken());
                int v = Integer.parseInt(tk.nextToken());
                adj[u].add(v);
                adj[v].add(u);
            }

            // Prepare arrays
            parent = new int[N+1];
            order  = new int[N];
            deg    = new int[N+1];
            for (int i = 1; i <= N; i++) {
                deg[i] = adj[i].size();
            }

            // 1) BFS to get a parent[] and an order[] by increasing depth
            Queue<Integer> q = new ArrayDeque<>();
            q.add(1);
            parent[1] = 0;
            int idx = 0;
            while (!q.isEmpty()) {
                int u = q.poll();
                order[idx++] = u;
                for (int w: adj[u]) {
                    if (w == parent[u]) continue;
                    parent[w] = u;
                    q.add(w);
                }
            }

            // 2) Post‐order DP to compute, for each u, the matching on the subtree rooted at u
            dp0 = new int[N+1];
            dpBest = new int[N+1];
            diff1 = new int[N+1];
            diff2 = new int[N+1];
            diff1Id = new int[N+1];

            // Process in reverse BFS‐order so children come before parent
            for (int i = N-1; i >= 0; i--) {
                int u = order[i];
                // Sum up children's dpBest
                int sum0 = 0;
                int best1 = 0, best2 = 0, best1id = -1;
                for (int w: adj[u]) {
                    if (w == parent[u]) continue;
                    sum0 += dpBest[w];
                }
                // compute diffs for each child
                for (int w: adj[u]) {
                    if (w == parent[u]) continue;
                    int d = dp0[w] + 1 - dpBest[w];
                    // track top two
                    if (d > best1) {
                        best2 = best1;
                        best1 = d;
                        best1id = w;
                    } else if (d > best2) {
                        best2 = d;
                    }
                }
                dp0[u] = sum0;
                diff1[u] = best1;
                diff2[u] = best2;
                diff1Id[u] = best1id >= 0 ? best1id : 0;
                // dpBest[u] = either we match u->one child or not
                int gain = Math.max(0, best1);
                dpBest[u] = Math.max(sum0, sum0 + gain);
            }

            // 3) Reroot (BFS‐style) to compute the matching of the "outside" component at each node
            upDp0 = new int[N+1];
            upBest = new int[N+1];
            diffParent = new int[N+1];

            // Root's outside‐component has no nodes => dp0=0, best=0, diffParent=0
            upDp0[1] = 0;
            upBest[1] = 0;
            diffParent[1] = 0;

            // Process in BFS‐order so parent is processed before children
            for (int ii = 0; ii < N; ii++) {
                int u = order[ii];
                // Sum of all neighbor‐contributions
                int sumAll = dp0[u] + upBest[u];
                int bigDiff = Math.max(diff1[u], diffParent[u]);  // best diff among all neighbors

                for (int w: adj[u]) {
                    if (w == parent[u]) {
                        // we will never BFS back up
                        continue;
                    }
                    // Exclude w's contribution
                    int contribW = dpBest[w];
                    int dp0Excl = sumAll - contribW;
                    // which diff do we drop?
                    int dd;
                    if (diff1Id[u] == w) {
                        // we used w's diff1, drop it
                        dd = Math.max(diff2[u], diffParent[u]);
                    } else {
                        dd = Math.max(diff1[u], diffParent[u]);
                    }
                    if (dd < 0) dd = 0;
                    int bestExcl = Math.max(dp0Excl, dp0Excl + dd);

                    upDp0[w]     = dp0Excl;
                    upBest[w]    = bestExcl;
                    diffParent[w] = dp0Excl + 1 - bestExcl;

                    // continue BFS
                }
            }

            // 4) compute for each v the sum of its adjacent‐component matchings
            sumMmAdj = new long[N+1];
            for (int u = 1; u <= N; u++) {
                long s = upBest[u];
                for (int w: adj[u]) {
                    if (w == parent[u]) continue;
                    s += dpBest[w];
                }
                sumMmAdj[u] = s;
            }

            // 5) finally compute leaves(v) = 
            //       if deg[v]>=2:  (N − 1 − sumMmAdj[v])
            //       else (N − sumMmAdj[v])
            int answer = 0;
            for (int v = 1; v <= N; v++) {
                int leaves;
                if (deg[v] >= 2) {
                    leaves = (int)(N - 1 - sumMmAdj[v]);
                } else {
                    leaves = (int)(N - sumMmAdj[v]);
                }
                if (leaves > answer) answer = leaves;
            }

            sb.append(answer).append('\n');
        }

        System.out.print(sb);
    }
}
```

**How It Works**

1. **BFS + Parent pointers**  
   We root the tree at node 1 purely to simplify later re‐rooting logic.  A BFS pass builds  
   - `parent[u]` = the parent of _u_ in that arbitrary root‐1 tree  
   - `order[]` = the nodes in BFS‐order (by increasing depth)

2. **Postorder DP to compute subtree‐matching**  
   In reverse BFS‐order (i.e. deepest nodes first), we compute for each node _u_  
   - `dp0[u]` = ∑ `dpBest[c]` over all children c of _u_ (the sum of best‐matchings in each child‐subtree)  
   - for each child c, we form a “profit if we match u–c” = `dp0[c] + 1 − dpBest[c]`, and we keep the top two profits for all children.  
   - `dpBest[u]` = max of  
     - *not matching u to any child*: `dp0[u]`  
     - *matching u to exactly one child*: `dp0[u] + max(0, highestProfit)`

   By standard tree‐matching DP, `dpBest[u]` is exactly the size of a maximum matching in the subtree under _u_.

3. **Reroot pass (BFS) to propagate “outside”‐component**  
   We keep for every node _u_ two values describing “the best matching in the component you get if you cut the edge to parent[u]”:  
   - `upDp0[u]`, `upBest[u]` = the analogues of (`dp0[u]`,`dpBest[u]`), but for the outside‐component instead of the subtree.  
   - `diffParent[u]` = the profit of “matching u to its parent‐side” if we chose to.

   Then in BFS‐order we push these values down to each child _c_, by "excluding" _c_'s subtree contribution from the sums at _u_, and recomputing the two‐largest‐profit logic at _u_ as if _c_ weren’t there.  This gives us exactly the matching‐size of the component formed by deleting the edge \((u,c)\) on the side containing c.

4. **Collect match‐sizes and pick best root**  
   For each node _v_, the sum of match‐sizes of its adjacent components is
     \(\sum_{u∈N(v)} mm_{u→v}\)
   which is `sumMmAdj[v]` in the code.  If `deg[v]>=2`, the final leaf‐count is  
     `N - 1 - sumMmAdj[v]`  
   else (i.e. if `deg[v]≤1`), the root itself ends with degree 1 and _is_ a leaf, so the leaf‐count is  
     `N - sumMmAdj[v]`.

We scan all nodes _v_ and take the maximum leaf‐count.

**Complexities**

- Building the graph: O(N)  
- BFS to get parent & level‐order: O(N)  
- Postorder DP (one pass through `order[]`): O(N)  
- Reroot BFS pass: O(N)  
- Final scan: O(N)

Hence the overall time is **O(N)** per test, and since \(\sum N ≤ 3·10^5\), it runs well under typical 2 s limits. Memory is O(N) for adjacency lists plus O(N) for all DP arrays.