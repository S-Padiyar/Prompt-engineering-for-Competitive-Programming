[
  {
    "role": "user",
    "content": "G. Penacony\n\ntime limit per test3 seconds\n\nmemory limit per test512 megabytes\n\nOn Penacony, The Land of the Dreams, there exists n\n\n houses and n\n\n roads. There exists a road between house i\n\n and i+1\n\n for all 1≤i≤n−1\n\n and a road between house n\n\n and house 1\n\n. All roads are bidirectional. However, due to the crisis on Penacony, the overseeing family has gone into debt and may not be able to maintain all roads.\n\n\n\nThere are m\n\n pairs of friendships between the residents of Penacony. If the resident living in house a\n\n is friends with the resident living in house b\n\n, there must be a path between houses a\n\n and b\n\n through maintained roads.\n\n\n\nWhat is the minimum number of roads that must be maintained?\n\n\n\nInput\n\nThe first line contains t\n\n (1≤t≤104\n\n) – the number of test cases.\n\n\n\nThe first line of each test case contains two integers n\n\n and m\n\n (3≤n≤2⋅105,1≤m≤2⋅105\n\n) – the number of houses and the number of friendships.\n\n\n\nThe next m\n\n lines contain two integers a\n\n and b\n\n (1≤a<b≤n\n\n) – the resident in house a\n\n is friends with the resident in house b\n\n. It is guaranteed all (a,b\n\n) are distinct.\n\n\n\nIt is guaranteed the sum of n\n\n and m\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output an integer, the minimum number of roads that must be maintained.\n\n\n\nExample\n\nInputCopy\n\n7\n\n8 3\n\n1 8\n\n2 7\n\n4 5\n\n13 4\n\n1 13\n\n2 12\n\n3 11\n\n4 10\n\n10 2\n\n2 3\n\n3 4\n\n10 4\n\n3 8\n\n5 10\n\n2 10\n\n4 10\n\n4 1\n\n1 3\n\n5 2\n\n3 5\n\n1 4\n\n5 2\n\n2 5\n\n1 3\n\nOutputCopy\n\n4\n\n7\n\n2\n\n7\n\n2\n\n3\n\n3\n\nNote\n\nFor the first test case, the following roads must be maintained:\n\n\n\n8←→1\n\n7←→8\n\n1←→2\n\n4←→5\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have \\(n\\) houses placed in a cycle (house \\(1\\) adjacent to house \\(2\\), …, house \\(n-1\\) adjacent to house \\(n\\), and house \\(n\\) adjacent to house \\(1\\)).  There are \\(n\\) roads, each road between consecutive houses (modulo \\(n\\)).  We are given \\(m\\) friendship‐pairs \\((a_i,b_i)\\), and we must choose a subset of the cycle‐edges (roads) so that for each friendship pair \\((a_i,b_i)\\) the two houses \\(a_i,b_i\\) remain connected in the chosen subgraph.  We wish to minimize the total number of roads kept.\n\nA key observation is that any chosen subgraph on a cycle that connects the required pairs can be viewed as a union of simple paths (possibly overlapping) in the cycle—i.e. a forest plus possibly some extra edges, but extra cycles never help reduce the total number of edges.  Equivalently, one may show the following “dual” perspective:\n\n1.  Label the cycle‐edges \\(0,1,2,\\dots,n-1\\) in cyclic order.\n2.  For each friendship \\((a_i,b_i)\\), consider the two possible paths on the cycle that connect \\(a_i\\) and \\(b_i\\).  Exactly one of those is the *shorter* or *equal*–length path; call its set of edges the **small‐arc** \\(S_i\\).  The other is the **big‐arc**, the complement of \\(S_i\\).\n3.  In any optimal choice of edges, if we were to “remove” (not pick) a particular cycle‐edge \\(c\\), then each friendship \\(i\\) is *forced* to use whichever of its two arcs does *not* pass through \\(c\\).  Hence for a “cut” \\(c\\), all friendships whose small‐arc contains \\(c\\) must switch to their big‐arc, while the rest keep their small‐arc.  The total set of kept edges is thus\n   \\[\n     \\Bigl(\\,\\bigcup_{i: c\\notin S_i} S_i\\Bigr)\\;\\cup\\;\\Bigl(\\,\\bigcup_{i: c\\in S_i} (\\,\\text{compl}\\,S_i)\\Bigr).\n   \\]\n4.  If one tracks, for each cycle‐edge \\(e\\), exactly which of the small‐arcs \\(S_i\\) cover \\(e\\), one finds that an edge \\(e\\) *survives* in the union for cut \\(c\\) if and only if the covering‐pattern of \\(e\\) among the \\(S_i\\) differs from that of \\(c\\).  Hence the total number of kept edges is\n   \\[\n     n \\;-\\;\\bigl|\\{\\;e\\mid\\text{pattern}(e)=\\text{pattern}(c)\\}\\bigr|.\n   \\]\n   Minimizing over \\(c\\) is therefore the same as finding the most‐frequent coverage‐pattern among *all* edges: if a pattern occurs \\(K\\) times, then by choosing \\(c\\) in that pattern‐class we keep exactly \\(n-K\\) edges.\n5.  We only need to record, for each of our \\(n\\) cycle‐edges, a small “hash” of which small‐arcs cover it.  We do a standard “sweep‐line” over the cycle edges \\(0,1,\\dots,n-1\\), building an XOR‐hash: each interval \\(S_i\\) contributes a random 64‐bit value \\(\\rho_i\\), XOR’d in when we enter the interval and XOR’d out when we leave it.  Thus at each edge \\(e\\) we have a 64‐bit `curHash[e]`.  We collect all \\(n\\) hashes, sort them, and find the largest multiplicity \\(M\\).  The answer is\n   \\[\n     n \\;-\\; M.\n   \\]\n   This runs in \\(O((n+m)\\log n)\\) time and \\(O(n+m)\\) space, which is fine for \\(n,m\\le2\\times10^5\\) overall.\n\nBelow is a clean Java implementation.\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int MAXM = 200_000 + 5;\n    static long[] rnd = new long[MAXM]; // random tags for up to MAXM intervals\n    public static void main(String[] args) throws IOException {\n        // Fast I/O\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(new BufferedOutputStream(System.out));\n        StringTokenizer st;\n\n        // Initialize random tags once\n        Random rand = new Random(1234567L);\n        for(int i = 0; i < MAXM; i++){\n            rnd[i] = rand.nextLong();\n        }\n\n        st = new StringTokenizer(br.readLine());\n        int t = Integer.parseInt(st.nextToken());\n        while(t-- > 0){\n            st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(st.nextToken());\n\n            // ev[p] will record XOR-deltas at edge position p\n            long[] ev = new long[n];\n            Arrays.fill(ev, 0L);\n\n            // Read each friendship, compute its \"small arc\" of edges\n            for(int i = 0; i < m; i++){\n                st = new StringTokenizer(br.readLine());\n                int a = Integer.parseInt(st.nextToken()) - 1;\n                int b = Integer.parseInt(st.nextToken()) - 1;\n\n                // Compute clockwise / counterclockwise distances\n                int dCW  = (b - a + n) % n;\n                int dCCW = n - dCW;\n                int L, R;\n\n                if(dCW <= dCCW) {\n                    // Small arc is clockwise from a to b\n                    L = a;\n                    R = (b - 1 + n) % n;\n                } else {\n                    // Small arc is counterclockwise: from a back to b\n                    L = b;\n                    R = (a - 1 + n) % n;\n                }\n\n                // Mark XOR-range [L..R] (circular)\n                long tag = rnd[i];\n                if(L <= R){\n                    // single interval\n                    ev[L] ^= tag;\n                    if(R + 1 < n) ev[R + 1] ^= tag;\n                } else {\n                    // wraps around end of array\n                    ev[L] ^= tag;\n                    ev[0] ^= tag;\n                    if(R + 1 < n) ev[R + 1] ^= tag;\n                }\n            }\n\n            // Build the hash at each edge and collect into an array\n            long[] hashes = new long[n];\n            long cur = 0L;\n            for(int i = 0; i < n; i++){\n                cur ^= ev[i];\n                hashes[i] = cur;\n            }\n\n            // Find the largest multiplicity of any hash\n            Arrays.sort(hashes);\n            int best = 1, cnt = 1;\n            for(int i = 1; i < n; i++){\n                if(hashes[i] == hashes[i-1]){\n                    cnt++;\n                } else {\n                    if(cnt > best) best = cnt;\n                    cnt = 1;\n                }\n            }\n            if(cnt > best) best = cnt;\n\n            // Answer is n - (size of largest pattern-class)\n            pw.println(n - best);\n        }\n\n        pw.flush();\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Small‐arc identification.**  \n   For each friendship \\((a,b)\\) on the \\(n\\)-cycle, there are two ways around the cycle.  We choose the *shorter* (or tie‐breaking in favor of one direction) of those two, calling that set of edges the *small‐arc* \\(S_i\\).  Its length is \\(\\le\\lfloor n/2\\rfloor\\).\n\n2. **“Cut” viewpoint.**  \n   Suppose in the final solution we have deleted (not kept) one cycle‐edge \\(c\\).  Then every friendship whose small‐arc passes through \\(c\\) is _forced_ to use the complementary (“big‐arc”); all others can stick with their small‐arc.  Thus the final chosen edges are just the union of those forced big‐arcs and the remaining small‐arcs.\n\n3. **Pattern‐hash trick.**  \n   One shows that a cycle‐edge \\(e\\) survives in that union exactly if the pattern of which small‐arcs cover \\(e\\) is different from the pattern at the deletion‐edge \\(c\\).  Hence the total #kept edges is  \n   \\[\n     \\#\\{e\\} = n \\;-\\;\\#\\{\\,e\\mid \\text{pattern}(e)=\\text{pattern}(c)\\}.\n   \\]\n   To minimize this, we just need to pick \\(c\\) in the largest‐frequency pattern‐class among all edges.  \n\n4. **Implementation of patterns.**  \n   We sweep once around the cycle‐edges \\(0,1,\\dots,n-1\\).  For each small‐arc \\(S_i\\) we do a standard range‐xor: pick a random 64‐bit tag \\(\\rho_i\\), XOR it in at the start of the interval and XOR it out just after the end.  After we prefix‐XOR, each edge \\(e\\) carries a 64‐bit hash of exactly which arcs cover it.  Sorting those \\(n\\) hashes and finding the largest block of identical values gives us the best pattern‐class size \\(M\\).  Finally the answer is \\(n-M\\).\n\nThis runs in \\(O((n+m)\\log n)\\) time per test (dominated by sorting the \\(n\\) edge‐hashes) and uses \\(O(n+m)\\) memory, well within the problem’s limits."
  },
  {
    "role": "system",
    "content": "Identify any errors in this response and output a prompt to help the AI resolve said issues. Your response MUST be in one of two formats: 1. If the response looks perfect, return \"Perfect\". Do not return this if there are any issues. Use this very sparingly as any errors in the final output from the AI will be considered a failure on your part. 2. Otherwise, return \"{prompt}\" where {prompt} is replaced with your concise prompt. This should be done most often, even if the AI's response is mostly correct. Ensure the entire response is enclosed in double quotations if it's a prompt. Make sure your prompt asks the AI to return one block of code for submission."
  },
  {
    "role": "assistant",
    "content": "\"Please provide a single complete Java code solution (one block of code) for the problem, without any extra explanation.\""
  }
]