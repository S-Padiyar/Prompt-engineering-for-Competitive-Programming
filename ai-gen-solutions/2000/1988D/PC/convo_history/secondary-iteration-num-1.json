[
  {
    "role": "user",
    "content": "D. The Omnipotent Monster Killer\n\ntime limit per test3 seconds\n\nmemory limit per test512 megabytes\n\nYou, the monster killer, want to kill a group of monsters. The monsters are on a tree with n\n\n vertices. On vertex with number i\n\n (1≤i≤n\n\n), there is a monster with ai\n\n attack points. You want to battle with monsters for 10100\n\n rounds.\n\n\n\nIn each round, the following happens in order:\n\n\n\nAll living monsters attack you. Your health decreases by the sum of attack points of all living monsters.\n\nYou select some (possibly all or none) monsters and kill them. After being killed, the monster will not be able to do any attacks in the future.\n\nThere is a restriction: in one round, you cannot kill two monsters that are directly connected by an edge.\n\n\n\nIf you choose what monsters to attack optimally, what is the smallest health decrement you can have after all rounds?\n\n\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n\n (1≤t≤104\n\n). Description of the test cases follows.\n\n\n\nThe first line of each test case contains an integer n\n\n (1≤n≤3⋅105\n\n).\n\n\n\nThe second line of each test case contains n\n\n integers a1,…,an\n\n (1≤ai≤1012\n\n).\n\n\n\nThe following n−1\n\n lines each contain two integers x,y\n\n (1≤x,y≤n\n\n), denoting an edge on the tree connecting vertex x\n\n and y\n\n.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 3⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, print one integer: the minimum possible health decrement.\n\n\n\nExample\n\nInputCopy\n\n3\n\n1\n\n1000000000000\n\n5\n\n47 15 32 29 23\n\n1 2\n\n1 3\n\n2 4\n\n2 5\n\n7\n\n8 10 2 3 5 7 4\n\n1 2\n\n1 4\n\n3 2\n\n5 3\n\n6 2\n\n7 5\n\nOutputCopy\n\n1000000000000\n\n193\n\n57\n\nNote\n\nIn the first test case, an optimal sequence of operations would be:\n\n\n\nIn the first round: first, receive the attack from the monster on vertex 1\n\n, so your health decreases by 1012\n\n. Then kill the monster on vertex 1\n\n.\n\nIn the second round to the 10100\n\n-th round: all monsters have been killed, so nothing happens.\n\nThe total health decrement is 1012\n\n.\n\n\n\nIn the second test case, an optimal sequence of operations would be:\n\n\n\nIn the first round: first, receive the attack from the monster on vertex 1,2,3,4,5\n\n, so your health decreases by 47+15+32+29+23=146\n\n. Then kill the monsters on vertex 1,4,5\n\n.\n\nIn the second round: first, receive the attack from the monster on vertex 2,3\n\n, so your health decreases by 15+32=47\n\n. Then kill the monsters on vertex 2,3\n\n.\n\nIn the third round to the 10100\n\n-th round: all monsters have been killed, so nothing happens.\n\nThe total health decrement is 193\n\n.\n\n\n\nIn the third test case, an optimal sequence of operations would be:\n\n\n\nIn the first round: first, receive the attack from the monster on vertex 1,2,3,4,5,6,7\n\n, so your health decreases by 8+10+2+3+5+7+4=39\n\n. Then kill the monsters on vertex 1,3,6,7\n\n.\n\nIn the second round: first, receive the attack from the monster on vertex 2,4,5\n\n, so your health decreases by 10+3+5=18\n\n. Then kill the monsters on vertex 2,4,5\n\n.\n\nIn the third round to the 10100\n\n-th round: all monsters have been killed, so nothing happens.\n\nThe total health decrement is 57\n\n.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have a tree of _n_ vertices (nodes), each vertex _i_ carries a monster of attack value _aₙ_.\n\nEvery round:  \n\n1. All *still‐alive* monsters jointly deal damage equal to the **sum** of their attack values.\n2. We may kill an arbitrary set of monsters subject to **no two killed in the same round being adjacent** on the tree.\n\nSince we have an astronomically large number of rounds (10¹⁰⁰), we will certainly be able to kill *all* monsters.  Let us decide in which round (an integer ≥ 1) each monster dies.  Call that round _kᵢ_ for monster _i_; then monster _i_ attacks us in rounds 1,2,…,kᵢ, so its total contribution to the damage is\n\n```\n    aᵢ × kᵢ.\n```\n\nWe want to choose all the integers {kᵢ} in a way that\n\n- if two nodes _u_,_v_ are adjacent in the tree, then **kᵤ ≠ kᵥ**, because they cannot both be killed in the same round,\n- and the sum of all aᵢ·kᵢ is as small as possible.\n\nBut a tree is bipartite: we can 2‐color it (say “black” and “white”) so that no edge joins two vertices of the same color.  A proper coloring with distinct round‐numbers for adjacent vertices is exactly the same as a **proper graph coloring**: adjacent vertices must get different colors.  Since a tree is 2‐colorable, we never need more than two “rounds‐lots” (colors).  \n\nHence, without loss of generality, we may choose two distinct integer rounds, call them 1 and 2:\n\n– All black nodes die in round 1 → each black node _i_ contributes aᵢ×1  \n– All white nodes die in round 2 → each white node _i_ contributes aᵢ×2  \n\nPossibly we could also swap (black in round 2, white in round 1).  So the total damage in the first scheme is\n\n```\n   (sum of aᵢ over black) * 1  +  (sum of aᵢ over white) * 2\n = S + (sum of aᵢ over white),\n```\n\nwhere S = total sum of all aᵢ.  If we swap colors (black→round 2, white→round 1), the cost becomes\n\n```\n   S + (sum of aᵢ over black).\n```\n\nWe pick the smaller of these two.  Hence the answer is\n\n```\n   answer = S + min( sum_black, sum_white ).\n```\n\nwhere `sum_black` is the sum of aᵢ on one side of the bipartition, and `sum_white` on the other.\n\nWe just\n\n1. 2‐color the tree by an easy BFS/DFS,\n2. accumulate the sums on each side of the bipartition,\n3. output `S + min(sum_black, sum_white)`.\n\nThis runs in O(n) per test, linear in the size of the tree, which is more than fast enough for n up to 3·10⁵ total over all test cases.\n\n---\n\n**Java Implementation**\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        // Fast input\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int t = Integer.parseInt(st.nextToken());  // number of test cases\n        \n        // We'll reuse buffers for BFS queue, coloring, etc.\n        // but we don't know upfront max n, so we'll recreate per test.\n        \n        StringBuilder output = new StringBuilder();\n        while (t-- > 0) {\n            // Read n\n            st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            \n            // Read attack values a[0..n-1]\n            long[] a = new long[n];\n            st = new StringTokenizer(br.readLine());\n            long totalSum = 0L;\n            for (int i = 0; i < n; i++) {\n                a[i] = Long.parseLong(st.nextToken());\n                totalSum += a[i];\n            }\n            \n            // Build adjacency list\n            List<Integer>[] adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                adj[i] = new ArrayList<>();\n            }\n            for (int i = 0; i < n-1; i++) {\n                st = new StringTokenizer(br.readLine());\n                int u = Integer.parseInt(st.nextToken()) - 1;\n                int v = Integer.parseInt(st.nextToken()) - 1;\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n            \n            // BFS to 2-color the tree\n            boolean[] color = new boolean[n];    // false = \"black\", true = \"white\"\n            boolean[] seen  = new boolean[n];\n            int[] queue = new int[n];\n            \n            int qh = 0, qt = 0;\n            queue[qt++] = 0;\n            seen[0] = true;\n            \n            while (qh < qt) {\n                int u = queue[qh++];\n                for (int v : adj[u]) {\n                    if (!seen[v]) {\n                        seen[v] = true;\n                        color[v] = !color[u];  // opposite color of parent\n                        queue[qt++] = v;\n                    }\n                }\n            }\n            \n            // Sum up each side\n            long sumBlack = 0L, sumWhite = 0L;\n            for (int i = 0; i < n; i++) {\n                if (color[i]) {\n                    sumWhite += a[i];\n                } else {\n                    sumBlack += a[i];\n                }\n            }\n            \n            // Final answer: totalSum + min(sumBlack, sumWhite)\n            long ans = totalSum + Math.min(sumBlack, sumWhite);\n            output.append(ans).append('\\n');\n        }\n        \n        // Write all answers\n        System.out.print(output.toString());\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Bipartition (2‐coloring)**  \n   A tree is always 2‐colorable (it has no odd cycles).  By a simple BFS/DFS from node 0, we assign `color[0] = false` and for each edge (u→v), set `color[v] = !color[u]`.\n\n2. **Cost computation**  \n   If all “black”‐colored vertices die in round 1 and “white”‐colored in round 2, the total damage is  \n   \n       ∑(aᵢ⋅1 over black) + ∑(aⱼ⋅2 over white)\n     = (sum of all aᵢ) + (sum of aⱼ over white).\n   \n   If we swap (white in round 1, black in 2), we get  \n   \n       (sum of all aᵢ) + (sum of aᵢ over black).\n   \n   We take the minimum of these two, i.e.\n   \n       answer = totalSum + min(sumBlack, sumWhite).\n\nThis exactly matches the requirement of killing no two adjacent monsters in the same round, and it is optimal since any proper coloring of a tree uses at most 2 colors, and delaying a monster beyond round 2 only increases its contribution `aᵢ·kᵢ` without allowing any further improvement in reducing a neighbor’s round."
  },
  {
    "role": "system",
    "content": "Identify any errors in this response and output a prompt to help the AI resolve said issues. Your response MUST be in one of two formats: 1. If the response looks perfect, return \"Perfect\". Do not return this if there are any issues. Use this very sparingly as any errors in the final output from the AI will be considered a failure on your part. 2. Otherwise, return \"{prompt}\" where {prompt} is replaced with your concise prompt. This should be done most often, even if the AI's response is mostly correct. Ensure the entire response is enclosed in double quotations if it's a prompt. Make sure your prompt asks the AI to return one block of code for submission."
  },
  {
    "role": "assistant",
    "content": "Perfect"
  }
]