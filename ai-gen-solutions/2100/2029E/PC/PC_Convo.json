[
  {
    "timestamp": "2025-07-24T06:15:15.859556",
    "role": "user",
    "content": "Please provide a single self-contained Java program (no Markdown, no extra explanation) that reads from standard input and writes to standard output and solves the problem within the given constraints."
  },
  {
    "timestamp": "2025-07-24T06:16:25.909976",
    "role": "assistant",
    "content": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    static final int MAXA = 400_000;\n    static ArrayList<Integer>[] divisors = new ArrayList[MAXA+1];\n    static int[] spf = new int[MAXA+1];\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tok;\n        for (int i = 2; i <= MAXA; i++) {\n            if (spf[i] == 0) {\n                for (int j = i; j <= MAXA; j += i) {\n                    if (spf[j] == 0) spf[j] = i;\n                }\n            }\n        }\n        for (int i = 2; i <= MAXA; i++) divisors[i] = new ArrayList<>();\n        for (int d = 2; d <= MAXA; d++) {\n            for (int m = d; m <= MAXA; m += d) {\n                divisors[m].add(d);\n            }\n        }\n        boolean[] isTarget = new boolean[MAXA+1];\n        int[] visited = new int[MAXA+1];\n        int visitMark = 1;\n        tok = new StringTokenizer(br.readLine());\n        int t = Integer.parseInt(tok.nextToken());\n        StringBuilder sb = new StringBuilder();\n        while (t-- > 0) {\n            tok = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(tok.nextToken());\n            int[] a = new int[n];\n            tok = new StringTokenizer(br.readLine());\n            int minVal = MAXA+1, maxVal = 0;\n            for (int i = 0; i < n; i++) {\n                a[i] = Integer.parseInt(tok.nextToken());\n                if (a[i] < minVal) minVal = a[i];\n                if (a[i] > maxVal) maxVal = a[i];\n                isTarget[a[i]] = true;\n            }\n            HashSet<Integer> primeSet = new HashSet<>();\n            int x = minVal;\n            while (x > 1) {\n                int p = spf[x];\n                primeSet.add(p);\n                while (x % p == 0) x /= p;\n            }\n            ArrayList<Integer> cands = new ArrayList<>(primeSet);\n            Collections.sort(cands);\n            int answer = -1;\n            for (int p : cands) {\n                visitMark++;\n                if (visitMark == Integer.MAX_VALUE) {\n                    Arrays.fill(visited, 0);\n                    visitMark = 1;\n                }\n                ArrayDeque<Integer> dq = new ArrayDeque<>();\n                dq.add(p);\n                visited[p] = visitMark;\n                int found = 0;\n                while (!dq.isEmpty()) {\n                    int u = dq.poll();\n                    if (isTarget[u]) {\n                        found++;\n                        if (found == n) break;\n                    }\n                    for (int d : divisors[u]) {\n                        int v = u + d;\n                        if (v <= maxVal && visited[v] != visitMark) {\n                            visited[v] = visitMark;\n                            dq.add(v);\n                        }\n                    }\n                }\n                if (found == n) {\n                    answer = p;\n                    break;\n                }\n            }\n            for (int v : a) isTarget[v] = false;\n            sb.append(answer).append('\\n');\n        }\n        System.out.print(sb);\n    }\n}"
  }
]