[
  {
    "timestamp": "2025-07-24T05:49:18.791342",
    "role": "user",
    "content": "C. Hungry Games\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nYaroslav is playing a computer game, and at one of the levels, he encountered n\n\n mushrooms arranged in a row. Each mushroom has its own level of toxicity; the i\n\n-th mushroom from the beginning has a toxicity level of ai\n\n. Yaroslav can choose two integers 1≤l≤r≤n\n\n, and then his character will take turns from left to right to eat mushrooms from this subsegment one by one, i.e., the mushrooms with numbers l,l+1,l+2,…,r\n\n.\n\n\n\nThe character has a toxicity level g\n\n, initially equal to 0\n\n. The computer game is defined by the number x\n\n — the maximum toxicity level at any given time. When eating a mushroom with toxicity level k\n\n, the following happens:\n\n\n\nThe toxicity level of the character is increased by k\n\n.\n\nIf g≤x\n\n, the process continues; otherwise, g\n\n becomes zero and the process continues.\n\nYaroslav became interested in how many ways there are to choose the values of l\n\n and r\n\n such that the final value of g\n\n is not zero. Help Yaroslav find this number!\n\n\n\nInput\n\nEach test consists of multiple test cases. The first line contains an integer t\n\n (1≤t≤104\n\n) — the number of test cases. Then follows the description of the test cases.\n\n\n\nThe first line of each test case contains two integers n\n\n, x\n\n (1≤n≤2⋅105,1≤x≤109\n\n) — the number of mushrooms and the maximum toxicity level.\n\n\n\nThe second line of each test case contains n\n\n numbers a1,a2,…,an\n\n (1≤ai≤109\n\n).\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output a single number — the number of subsegments such that the final value of g\n\n will not be zero.\n\n\n\nExample\n\nInputCopy\n\n5\n\n4 2\n\n1 1 1 1\n\n3 2\n\n1 2 3\n\n1 6\n\n10\n\n6 3\n\n1 2 1 4 3 8\n\n5 999999999\n\n999999999 999999998 1000000000 1000000000 500000000\n\nOutputCopy\n\n8\n\n2\n\n0\n\n10\n\n7\n\nNote\n\nIn the first test case, the subsegments (1,1)\n\n, (1,2)\n\n, (1,4)\n\n, (2,2)\n\n, (2,3)\n\n, (3,3)\n\n, (3,4)\n\n and (4,4)\n\n are suitable.\n\n\n\nIn the second test case, non-zero g\n\n will remain only on the subsegments (1,1)\n\n and (2,2)\n\n.\n\n\n\nIn the third test case, on the only possible subsegment, g\n\n will be zero.\n\nUse Java."
  },
  {
    "timestamp": "2025-07-24T05:51:37.381598",
    "role": "assistant",
    "content": "**Analysis**\n\nWe have an array of \\(n\\) positive integers \\(a_1,a_2,\\dots,a_n\\), and a threshold \\(x\\).  For any subarray \\([l,r]\\), we simulate\n\n```\ng ← 0\nfor i = l to r:\n    g ← g + a[i]\n    if g> x:\n        g ← 0\n```\n\nand at the end we want \\(g\\neq0\\).  We must count the number of subarrays \\([l,r]\\) whose final \\(g\\) is non‐zero.\n\nA key observation is that whenever at position \\(i\\) the running sum since the last reset exceeds \\(x\\), we reset to zero _at_ \\(i\\).  Thus for a fixed start \\(l\\), the “bad” subarrays \\([l,r]\\) are exactly those \\(r\\) at which a reset occurs when we eat \\(a_r\\).  In other words, if we let\n\n-  \\(S(i,j)=\\sum_{k=i}^j\\,a_k\\),\n-  for each \\(i\\) we define \n   \n   \\[\n     \\text{nxt}[i]\n     =\\min\\{\\,j\\ge i: S(i,j)>x\\}, \n     \\quad\\text{or }n+1\\text{ if no such }j\\le n,\n   \\]\n\nthen starting at \\(l\\), the first reset happens at \\(r_1=\\text{nxt}[l]\\) (if \\(\\le n\\)), then we continue fresh from \\(r_1+1\\), the next reset is at \\(r_2=\\text{nxt}[r_1+1]\\), and so on.  Each such reset position \\((l,r_k)\\) is a subarray whose final \\(g\\) is zero.  Hence the total number of _bad_ subarrays is\n\n\\[\n  \\sum_{l=1}^n\n    \\Bigl(\\text{number of resets when scanning from }l\\Bigr).\n\\]\n\nIf we define a small DP\n\\[\n  \\mathrm{dp}[i]\n  =\n  \\begin{cases}\n    0,&\\text{if }\\text{nxt}[i]>n,\\\\\n    1+\\mathrm{dp}\\bigl(\\text{nxt}[i]+1\\bigr),&\\text{otherwise},\n  \\end{cases}\n\\]\nthen \\(\\mathrm{dp}[i]\\) counts how many resets we will see if we start scanning at \\(i\\).  Therefore\n\n\\[\n  \\text{totalBad}\n  = \\sum_{i=1}^n \\mathrm{dp}[i].\n\\]\n\nSince the total number of subarrays is \\(\\tfrac{n(n+1)}2\\), the answer (number of subarrays with final \\(g\\neq0\\)) is\n\n\\[\n  \\binom{n+1}2 \\;-\\;\\sum_{i=1}^n \\mathrm{dp}[i].\n\\]\n\nAll that remains is to compute \\(\\text{nxt}[i]\\) efficiently.  Note that\n\n\\[\n  S(i,j)=P[j]-P[i-1],\n  \\quad\n  P[k]=\\sum_{r=1}^k a[r],\n\\]\nand we want the smallest \\(j\\ge i\\) with \n\\[\n  P[j]-P[i-1]>x\n  \\;\\Longleftrightarrow\\;\n  P[j]>x+P[i-1].\n\\]\nSince \\(P\\) is strictly increasing (all \\(a_i>0\\)), we can do a single two‐pointer pass in \\(O(n)\\) to build \\(\\text{nxt}[i]\\) for \\(i=1\\ldots n\\).  Then we fill the dp table in \\(O(n)\\) and sum up.\n\nBecause \\(\\sum n\\le2\\cdot10^5\\) over all testcases, the overall complexity \\(O(n)\\) per test is more than fast enough.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        // Fast input\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter   pw = new PrintWriter(new OutputStreamWriter(System.out));\n        \n        int t = Integer.parseInt(br.readLine().trim());\n        while (t-- > 0) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            long x = Long.parseLong(st.nextToken());\n            \n            long[] a = new long[n+1];\n            st = new StringTokenizer(br.readLine());\n            for (int i = 1; i <= n; i++) {\n                a[i] = Long.parseLong(st.nextToken());\n            }\n            \n            // Build prefix sums P\n            long[] P = new long[n+1];\n            P[0] = 0;\n            for (int i = 1; i <= n; i++) {\n                P[i] = P[i-1] + a[i];\n            }\n            \n            // nxt[i] = the first j>=i with P[j] > P[i-1] + x, or n+1 if none\n            int[] nxt = new int[n+2];\n            int r = 1;\n            for (int i = 1; i <= n; i++) {\n                if (r < i) r = i;\n                long limit = P[i-1] + x;\n                while (r <= n && P[r] <= limit) {\n                    r++;\n                }\n                nxt[i] = (r <= n ? r : n+1);\n            }\n            \n            // dp[i] = number of resets if we start scanning from i\n            long[] dp = new long[n+3];\n            for (int i = n; i >= 1; i--) {\n                if (nxt[i] > n) {\n                    dp[i] = 0;\n                } else {\n                    // one reset at nxt[i], then continue from nxt[i]+1\n                    dp[i] = 1 + dp[nxt[i] + 1];\n                }\n            }\n            \n            // totalBad = sum dp[i]\n            long totalBad = 0;\n            for (int i = 1; i <= n; i++) {\n                totalBad += dp[i];\n            }\n            \n            // total subarrays = n*(n+1)/2\n            long totalSub = (long)n * (n + 1) / 2;\n            long answer = totalSub - totalBad;\n            \n            pw.println(answer);\n        }\n        \n        pw.flush();\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Prefix sums**  \n   We form `P[i] = a[1] + a[2] + ... + a[i]`.  Then the sum of any subarray `a[i..j]` is `P[j] - P[i-1]`.\n\n2. **Finding the first reset position**  \n   If we start a “block” at `i`, we reset as soon as the running sum exceeds `x`.  Equivalently, we look for the smallest `j ≥ i` with  \n   \\[\n     P[j] - P[i-1] > x\n     \\quad\\Longleftrightarrow\\quad\n     P[j] > P[i-1] + x.\n   \\]\n   Because the prefix sums `P[]` are strictly increasing (all `a[i] > 0`), we can keep a single pointer `r` that only moves forward, finding for each `i` the minimal such `j`.  If no `j ≤ n` satisfies the condition, we set `nxt[i] = n+1`.\n\n3. **Counting resets with DP**  \n   Once we have `nxt[i]`, we define\n   ```\n     dp[i] = 0           if nxt[i] > n\n           = 1 + dp[nxt[i]+1]  otherwise\n   ```\n   This says: if you start eating at `i`, you will first reset at `nxt[i]` (if it’s within the array), and then continue eating fresh from `nxt[i]+1`, counting recursively.  Summing `dp[1] + dp[2] + ... + dp[n]` gives us the total number of subarrays `(l,r)` for which the final `g` _is_ zero (the “bad” subarrays).\n\n4. **Final result**  \n   The total number of subarrays is `n*(n+1)/2`.  Subtract the number of bad subarrays to get the number whose final `g` is nonzero.\n\nThis runs in \\(O(n)\\) per test case (two‐pointer pass + a single DP pass), which is perfectly efficient for \\(n\\) up to \\(2\\times10^5\\)."
  }
]