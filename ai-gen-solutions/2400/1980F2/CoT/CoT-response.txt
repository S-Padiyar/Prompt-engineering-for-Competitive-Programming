**Analysis**

We have an \(n\times m\) grid, with \(k\) *forbidden* cells (the fountains).  Alice must draw a monotone (down‐or‐right) path \(P\) from the top or left boundary to the right or bottom boundary, so that

- \(P\) itself and the region “below‐and‐to‐the‐left” of \(P\) becomes Alice’s,
- the region “above‐and‐to‐the‐right” becomes Bob’s,
- Bob’s region must contain *all* the fountains *and* the fixed corner \((1,m)\).

Alice maximizes her region size.  Equivalently, Bob’s region is forced to be the **union** of the “up/right closures” of each fountain and of \((1,m)\).  Concretely, each fountain at \((r_i,c_i)\) forces Bob to take the rectangle

\[
  \{1,2,\dots,r_i\}\;\times\;\{c_i,c_i+1,\dots,m\}\,,
\]

and \((1,m)\) forces him to take the 1×1 cell \((1,m)\).  The union of all those rectangles is the **minimum** Bob‐region; call its area \(S\).  Then Alice’s maximum area is

\[
  \alpha \;=\; nm - S.
\]

Moreover, if Bob “gives” Alice the \(i\)-th fountain (so its rectangle no longer needs to be in Bob’s region), the only change in Bob’s union comes from *removing* exactly that one rectangle from the union.  Hence the *gain* in Alice’s region size is
\[
  a_i \;=\; \bigl[\text{area of full union}\bigr]\;-\;\bigl[\text{area of union without rectangle }i\bigr].
\]

Concretely, all those rectangles share the same right edge \(x=m\).  If we sort all rectangles by their left edge \(c_i\), then at each horizontal column \(x\) the union height is simply the maximum
\[
  H(x)\;=\;\max\{\,r_i : c_i\le x\}\,,
\]
and the area of the union is
\[
   S \;=\;\sum_{x=1}^m H(x)
   \;=\;\sum_{\text{segments}}\;(\text{width})\times(\text{max height}).
\]
We can compress the \(x\)-axis to the distinct sorted left‐edges
\[
  d_1<d_2<\cdots<d_T=m,
\]
and for each segment \(x\in [d_j,d_{j+1}-1]\) the union height is the same, namely the maximum \(r\)-value among rectangles whose \(c_i\le d_j\).  We group events at each \(d_j\), maintain the top two \(r\)-values \(\,r_{\max}=r_1\) and the second \(\,r_2\), and also how many rectangles attain \(r_1\).  Then

- the contribution to \(S\) on that segment of width
  \(\ell_j = d_{j+1}-d_j\)  (or \(1\) if \(j=T\))  is
  \(\ell_j\cdot r_1\).
- if exactly one rectangle realizes \(r_1\), and its index is \(i\), then
  removing that rectangle would drop the height on that segment down to \(r_2\),
  so the exclusive area that rectangle alone contributes is
  \(\ell_j\,(r_1-r_2)\).  We add that into \(a_i\).

Finally we output
\[
   \alpha = nm - S,\qquad
   a_1,a_2,\dots,a_k.
\]

This runs in \(O((k+1)\log(k+1))\) for sorting plus \(O(k)\) to sweep, which easily handles \(k\le2\cdot10^5\).

---

```java
import java.io.*;
import java.util.*;

public class Main {
    static class Rect implements Comparable<Rect> {
        int c, r, id;
        Rect(int _c, int _r, int _id) {
            c = _c; r = _r; id = _id;
        }
        public int compareTo(Rect o) {
            return Integer.compare(this.c, o.c);
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new BufferedOutputStream(System.out));
        int t = Integer.parseInt(br.readLine().trim());

        StringTokenizer tok;
        while (t-- > 0) {
            tok = new StringTokenizer(br.readLine());
            long n = Long.parseLong(tok.nextToken());
            long m = Long.parseLong(tok.nextToken());
            int k = Integer.parseInt(tok.nextToken());

            // Read fountains
            Rect[] R = new Rect[k + 1];
            for (int i = 0; i < k; i++) {
                tok = new StringTokenizer(br.readLine());
                int r = Integer.parseInt(tok.nextToken());
                int c = Integer.parseInt(tok.nextToken());
                R[i] = new Rect(c, r, i);
            }
            // Add the "fake" rectangle for (1,m) -> rows [1..1], cols [m..m]
            R[k] = new Rect((int)m, 1, k);

            // Sort by left-edge c
            Arrays.sort(R);

            // We'll sweep the distinct c-values, maintain top two r's
            long S = 0;             // total union area
            long[] a = new long[k+1];  // exclusive contributions
            long top1 = 0, top2 = 0;   // top1 >= top2
            int cntTop1 = 0;          // how many rectangles have r == top1
            int idxTop1 = -1;         // if cntTop1==1, the ID of that rect

            int p = 0, N = k+1;
            while (p < N) {
                int cval = R[p].c;
                // absorb all rectangles starting at c = cval
                while (p < N && R[p].c == cval) {
                    long rr = R[p].r;
                    int id = R[p].id;
                    if (rr > top1) {
                        // new maximum
                        top2 = top1;
                        top1 = rr;
                        cntTop1 = 1;
                        idxTop1 = id;
                    } else if (rr == top1) {
                        cntTop1++;
                    } else if (rr > top2) {
                        top2 = rr;
                    }
                    p++;
                }
                // the next distinct c is at R[p].c (if p<N), otherwise infinite
                long len = (p < N
                    ? (long)R[p].c - cval
                    : 1L);  // last segment is width 1

                // area contribution for this segment
                S += len * top1;

                // if exactly one rect attains top1, it has exclusive height segment
                if (cntTop1 == 1) {
                    // after removing that rectangle, height would fall to top2
                    a[idxTop1] += len * (top1 - top2);
                }
            }

            long alpha = n * m - S;
            pw.println(alpha);
            // Output a[0..k-1]
            for (int i = 0; i < k; i++) {
                pw.print(a[i]);
                if (i+1 < k) pw.print(' ');
            }
            pw.println();
        }

        pw.flush();
    }
}
```

**Explanation of Key Steps**

1. **Reformulation as Rectangle‐Union.**  
   Bob’s region *must* contain every fountain \((r_i,c_i)\) and the fixed corner \((1,m)\).  Each such point forces Bob to include the axis‐aligned rectangle
   \[
     [1..r_i]\times[c_i..m].
   \]
   The *minimal* Bob‐region is the union of those \((k\!+\!1)\) rectangles.  Its area \(S\) is easy to compute if you note that at each column \(x\), the union’s vertical extent is
   \(\max\{\,r_i : c_i\le x\}\).

2. **Compressing Columns.**  
   Let \(d_1<d_2<\cdots<d_T=m\) be the distinct sorted “left‐edges” \(c_i\).  On the interval \(x\in[d_j,d_{j+1}-1]\), the set of active rectangles is exactly those with \(c_i\le d_j\), so the height is
   \(\max r_i\) among those.  We sweep in increasing order of \(c\), maintaining the top two \(r\)-values
   \[
     \text{top1}=\max r_i,\quad
     \text{top2}=\text{second‐largest }r_i,
   \]
   and how many rectangles achieve \(\text{top1}\).  

3. **Computing \(S\) and the “Exclusive” Areas \(a_i\).**  
   - On each segment of width \(\ell_j\), the union area picks up \(\ell_j\cdot \text{top1}\).  
   - If exactly one rectangle attains \(\text{top1}\), say rectangle \(i\), then removing that rectangle drops the height on that segment from \(\text{top1}\) to \(\text{top2}\).  Hence rectangle \(i\) alone contributed
     \(\ell_j\bigl(\text{top1}-\text{top2}\bigr)\) to the union area.  We add that into \(a_i\).

4. **Final Answers.**  
   - \(\displaystyle \alpha = nm - S\).  
   - And \(a_i\) is exactly how much Alice’s area grows if Bob “gives” her fountain \(i\).  

This runs in \(O((k+1)\log(k+1))\) time and \(O(k)\) extra space, easily handling \(k\) up to \(2\cdot10^5\).