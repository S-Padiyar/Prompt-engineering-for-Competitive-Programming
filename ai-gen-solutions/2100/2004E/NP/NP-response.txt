**Analysis**

We have a take‐and‐remove game on \(n\) piles.  On a pile of size \(x\), a legal move is to remove \(y>0\) stones such that
\[
\gcd(x,y)=1,
\]
leaving \(x-y\) stones.  The player who cannot move (all piles empty) loses.

A standard way to solve impartial games is to compute the Sprague–Grundy (“mex”) values \(g(x)\) for a single pile of size \(x\).  One can show, either by direct small‐\(x\) computation or by a theoretical sieve argument, that

- **If \(x\) is even**, then \(g(x)=0\).
- **If \(x=1\)**, then \(g(1)=1\).
- **If \(x>1\) is odd**, let \(\mathrm{spf}(x)\) be the smallest prime factor of \(x\).  Denote by \(\pi(p)\) the index of the prime \(p\) in the ordered list of all primes 
  \[
    2,\,3,\,5,\,7,\,11,\dots
  \]
  (so \(\pi(2)=1\), \(\pi(3)=2\), \(\pi(5)=3\), etc.).  Then
  \[
    g(x)\;=\;\pi\!\bigl(\mathrm{spf}(x)\bigr).
  \]

Once you have the Grundy value \(g(a_i)\) for each pile \(i\), the Grundy value of the disjunctive sum of all piles is
\[
G \;=\; g(a_1)\;\oplus\;g(a_2)\;\oplus\;\cdots\oplus\;g(a_n).
\]
By the Sprague–Grundy theorem, the first player (Alice) wins if and only if \(G\neq 0\); otherwise the second player (Bob) wins.

Thus the algorithm is:

1. Read all test‐cases, keep track of the maximum pile size \(A_{\max}\).
2. Build a “linear sieve” up to \(A_{\max}\) to compute:
   - `spf[x]` = the smallest prime factor of \(x\), for \(x\ge2\).
   - `primeIndex[p]` = \(\pi(p)\), the index of the prime \(p\), for each prime \(p\le A_{\max}\).
3. For each test:
   - Compute the XOR of the pile‐values
     \[
       \bigoplus_{i=1}^n\;g(a_i),
     \]
     where
     \[
       g(a_i)=
       \begin{cases}
         1, & a_i=1,\\
         0, & a_i\text{ even},\\
         \pi\bigl(\mathrm{spf}(a_i)\bigr), & a_i>1\text{ odd}.
       \end{cases}
     \]
   - If the XOR is nonzero, print “Alice”, otherwise print “Bob”.

The sieve runs in \(O(A_{\max})\) time, and processing all piles is \(O(\sum n)\).  Since \(A_{\max}\le10^7\) and \(\sum n\le3\times10^5\), this easily fits in the 2-second limit with Java (using a fast linear sieve plus fast IO).

---

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        FastReader in = new FastReader();
        int t = in.nextInt();

        // Read all test cases into memory, track the global maximum A_i
        int[][] tests = new int[t][];
        int maxA = 1;
        for (int i = 0; i < t; i++) {
            int n = in.nextInt();
            tests[i] = new int[n];
            for (int j = 0; j < n; j++) {
                int a = in.nextInt();
                tests[i][j] = a;
                if (a > maxA) maxA = a;
            }
        }

        // Build a linear sieve up to maxA to compute:
        //   spf[x] = smallest prime factor of x  (for x>=2)
        //   primeIndex[p] = index of prime p in the list 2,3,5,7,...
        int N = maxA;
        int[] spf = new int[N + 1];
        int[] primeIndex = new int[N + 1];
        // Upper bound on #primes up to 1e7 is about 664,579 → we allocate a little extra
        int[] primes = new int[N / 10 + 10];
        int pc = 0;

        for (int i = 2; i <= N; i++) {
            if (spf[i] == 0) {
                // i is prime
                spf[i] = i;
                primes[pc] = i;
                primeIndex[i] = ++pc;  // primeIndex[2]=1, [3]=2, [5]=3, ...
            }
            // mark spf for i * primes[j]
            for (int j = 0; j < pc; j++) {
                int p = primes[j];
                if (p > spf[i] || (long)i * p > N) {
                    break;
                }
                spf[i * p] = p;
            }
        }

        // Process each test
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < t; i++) {
            int xorSum = 0;
            for (int a : tests[i]) {
                int g;
                if (a == 1) {
                    g = 1;            // g(1)=1
                } else if ((a & 1) == 0) {
                    g = 0;            // all even a -> g(a)=0
                } else {
                    // a>1 is odd -> g(a) = primeIndex[spf[a]]
                    g = primeIndex[spf[a]];
                }
                xorSum ^= g;
            }
            sb.append(xorSum != 0 ? "Alice\n" : "Bob\n");
        }

        // Output results
        System.out.print(sb);
    }

    // Fast input reader
    static class FastReader {
        final private BufferedInputStream in;
        private byte[] buf = new byte[1 << 16];
        private int bufLen = 0, bufIdx = 0;

        FastReader() {
            in = new BufferedInputStream(System.in);
        }

        private int read() throws IOException {
            if (bufLen == -1) return -1;
            if (bufIdx >= bufLen) {
                bufIdx = 0;
                bufLen = in.read(buf);
                if (bufLen <= 0) {
                    bufLen = -1;
                    return -1;
                }
            }
            return buf[bufIdx++];
        }

        int nextInt() throws IOException {
            int c, val = 0;
            do {
                c = read();
            } while (c != -1 && (c < '0' || c > '9'));
            if (c == -1) return -1;
            for (; c >= '0' && c <= '9'; c = read()) {
                val = val * 10 + (c - '0');
            }
            return val;
        }
    }
}
```

**Explanation of Key Steps**

1. **Linear Sieve**  
   We maintain an array `spf[]` (smallest prime factor) and an array `primes[]`.  Whenever we find `spf[i]==0`, `i` is prime, so we set `spf[i]=i`, record it in `primes`, and give it the next prime‐index.  Then we iterate through our prime list (up to where `primes[j] <= spf[i]`) to mark composite numbers `i*primes[j]` with `spf[i*primes[j]] = primes[j]`.

2. **Grundy Values**  
   - Even piles always have Grundy \(0\).  
   - A pile of size \(1\) has Grundy \(1\).  
   - A pile of odd size \(>1\) has Grundy equal to the index of its smallest prime factor in the full prime list \(\{2,3,5,7,\dots\}\).

3. **Win /Lose**  
   We XOR all pile‐Grundy values.  If the result is nonzero, the first player (Alice) has a winning strategy; otherwise the second player (Bob) wins.

This runs in \(O(\max A + \sum n)\), which for \(\max A\le10^7\) and \(\sum n\le3\times10^5\) is efficient in 2 seconds with Java.