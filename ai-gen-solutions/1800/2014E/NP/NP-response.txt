**Analysis**

We have an undirected graph of \(n\) vertices and \(m\) edges; every edge has an even weight \(w_i\).  Marian starts at vertex \(1\), Robin starts at vertex \(n\).  There are \(h\) special vertices each of which holds exactly one horse.  A traveler who reaches a horse‐vertex can instantly mount the horse (cost 0 time) and from that point on travels at half the speed (i.e.\ every edge weight is halved). Once mounted, they cannot (and do not need to) dismount.

We want to find the earliest time \(T\) such that there is some vertex \(v\) where both Marian and Robin can arrive (in possibly different modes, on foot or on horse) by time \(T\).  They can wait at vertices, so arriving earlier never hurts.  If the graph is disconnected so that \(1\) and \(n\) lie in different components, the answer is \(-1\).

---

**Key observations / approach**

1.  Each traveler has two “modes” at each vertex \(u\):
   - Mode 0 (“on foot”): has not yet picked up a horse.
   - Mode 1 (“on horse”): has already picked up a horse and from now on travels at half speed.

2.  We build a directed graph on \(2n\) states:

     For \(u=0,1,\dots,n-1\) (using \(0\)-based internally):
     - State \(u\) represents \((\text{vertex }u, \text{on foot})\).
     - State \(u + n\) represents \((\text{vertex }u, \text{on horse})\).

   - For every original undirected edge \((u\leftrightarrow v)\) of weight \(w\):
     - Add edges
       ```
       (u on foot)   -> (v on foot)   with cost w
       (v on foot)   -> (u on foot)   with cost w
       (u on horse)  -> (v on horse)  with cost w/2
       (v on horse)  -> (u on horse)  with cost w/2
       ```
   - For every horse‐vertex \(a\), add a zero‐cost edge
       ```
       (a on foot) -> (a on horse)  with cost 0
       ```
     because you can mount your horse instantly at that vertex.

3.  We then run **two** Dijkstra‐style shortest‐path computations on this \(2n\)‐state directed graph:
   - One from the source state \(0\) (Marian starts at vertex \(1\) = index \(0\) in 0‐based).
   - One from the source state \(n-1\) (Robin starts at vertex \(n\) = index \(n-1\)).

   These yield two distance arrays
   \[
     \mathrm{distM}[\,\cdot\,],\;\mathrm{distR}[\,\cdot\,],
   \]
   each of length \(2n\).

4.  For each original vertex \(u\in\{0,1,\dots,n-1\}\), the time for Marian to get to \(u\) is
   \[
     T_M(u) \;=\;\min\bigl(\mathrm{distM}[u],\,\mathrm{distM}[u+n]\bigr),
   \]
   and similarly for Robin
   \[
     T_R(u) \;=\;\min\bigl(\mathrm{distR}[u],\,\mathrm{distR}[u+n]\bigr).
   \]
   They can meet at \(u\) by time 
   \(\max\{T_M(u),T_R(u)\}\), 
   since they may have to wait for the slower of the two.

5.  We take 
   \[
     T = \min_{u=0\ldots n-1}\,\max\{T_M(u),T_R(u)\}.
   \]
   If \(T\) remains “infinite” for all \(u\), the answer is \(-1\).  Otherwise, we output \(T\).

Because \(n,m\le2\times10^5\) overall and each edge produces 4 arcs in our state‐graph (plus \(h\) zero‐cost arcs), the total number of arcs never exceeds about \(4m+h\le10^6\).  Two Dijkstra’s on 2\(n\) nodes and \(O(m)\) arcs runs in \(O\bigl((n+m)\log(n+m)\bigr)\), which is fine in 5 seconds in Java if carefully implemented.

---

```java
import java.io.*;
import java.util.*;

public class Main {
    static final long INF = (long)9e18;
    // We'll have at most 2*n states and about 4*m + h edges per test.
    // Over all tests n <= 2e5, m <= 2e5, so we'll allocate generously:
    static final int MAXN2 = 400_005;      // 2 * max n
    static final int MAXE  = 1_200_000;    // up to ~4*m + h ~ 1e6
    
    static int[] head = new int[MAXN2];
    static int[] to   = new int[MAXE];
    static int[] wgt  = new int[MAXE];
    static int[] nxt  = new int[MAXE];
    static int edgeCnt;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        StringBuilder sb = new StringBuilder();
        
        int T = Integer.parseInt(br.readLine().trim());
        while (T-- > 0) {
            st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            int m = Integer.parseInt(st.nextToken());
            int h = Integer.parseInt(st.nextToken());

            // Read horse vertices (1-based in input, convert to 0-based)
            st = new StringTokenizer(br.readLine());
            int[] horses = new int[h];
            for (int i = 0; i < h; i++) {
                horses[i] = Integer.parseInt(st.nextToken()) - 1;
            }

            // Initialize adjacency list for 2n states
            int N2 = 2 * n; 
            edgeCnt = 0;
            Arrays.fill(head, 0, N2, -1);

            // Read the edges and add 4 directed arcs per undirected edge
            for (int i = 0; i < m; i++) {
                st = new StringTokenizer(br.readLine());
                int u = Integer.parseInt(st.nextToken()) - 1;
                int v = Integer.parseInt(st.nextToken()) - 1;
                int w = Integer.parseInt(st.nextToken());
                // on foot <-> on foot
                addEdge(u,   v,   w);
                addEdge(v,   u,   w);
                // on horse <-> on horse  (half the time)
                addEdge(u+n, v+n, w/2);
                addEdge(v+n, u+n, w/2);
            }

            // Add zero-cost arcs for mounting horse
            for (int a : horses) {
                addEdge(a, a + n, 0);
            }

            // Dijkstra from Marian's start = state 0 (vertex 0 on foot)
            long[] distM = new long[N2];
            dijkstra(0, N2, distM);

            // Dijkstra from Robin's start = state (n-1 on foot)
            long[] distR = new long[N2];
            dijkstra(n - 1, N2, distR);

            // Compute answer = min over all original vertices of max(arrive times)
            long ans = INF;
            for (int u = 0; u < n; u++) {
                long tM = Math.min(distM[u],     distM[u + n]);
                long tR = Math.min(distR[u],     distR[u + n]);
                if (tM < INF && tR < INF) {
                    ans = Math.min(ans, Math.max(tM, tR));
                }
            }
            sb.append(ans == INF ? -1 : ans).append('\n');
        }
        
        System.out.print(sb);
    }

    // Add a directed edge u -> v of cost w
    static void addEdge(int u, int v, int w) {
        to[edgeCnt]  = v;
        wgt[edgeCnt] = w;
        nxt[edgeCnt] = head[u];
        head[u]      = edgeCnt++;
    }

    // We store (distance<<20) | node in the PQ to avoid building a custom class.
    // We must ensure distance<<20 stays within 63 bits (it does, since dist<=2e11).
    static final int SHIFT = 20;
    static final int MASK  = (1 << SHIFT) - 1;

    static void dijkstra(int src, int N, long[] dist) {
        Arrays.fill(dist, 0, N, INF);
        dist[src] = 0L;
        PriorityQueue<Long> pq = new PriorityQueue<>();
        pq.add((0L << SHIFT) | src);

        while (!pq.isEmpty()) {
            long c = pq.poll();
            int u       = (int)(c & MASK);
            long d_u    = c >>> SHIFT;
            if (d_u != dist[u]) continue;   // stale entry

            // Relax all out‐edges
            for (int e = head[u]; e != -1; e = nxt[e]) {
                int v     = to[e];
                long ndist = d_u + wgt[e];
                if (ndist < dist[v]) {
                    dist[v] = ndist;
                    pq.add((ndist << SHIFT) | v);
                }
            }
        }
    }
}
```

**Explanation of key parts**

1. **State‐graph construction**  
   We create a \(2n\)-node directed graph.  For each original undirected edge \((u,v,w)\) we add
   - \((u,{\rm foot})\to(v,{\rm foot})\) cost \(w\) and the reverse,
   - \((u,{\rm horse})\to(v,{\rm horse})\) cost \(w/2\) and the reverse.

   For each horse‐vertex \(a\), we add a single zero‐cost arc \((a,{\rm foot})\to(a,{\rm horse})\).

2. **Dijkstra on 2n states**  
   We run two separate Dijkstra’s, one from Marian’s start \((1,{\rm foot})\equiv 0\) and one from Robin’s start \((n,{\rm foot})\equiv n-1\).  Each run yields an array `dist[...]` of length \(2n\).

3. **Meeting time**  
   For original vertex \(u\in[0..n-1]\), Marian’s best arrival time is 
   \(\min(\mathrm{distM}[u],\,\mathrm{distM}[u+n])\),
   and similarly for Robin.  They meet by 
   \(\max(\text{Marian time},\text{Robin time})\).  
   Taking the minimum over all \(u\) gives the final answer.

4. **Complexities**  
   - Building the graph is \(O(m + h)\).  
   - Each Dijkstra on \(2n\) nodes, \(\approx4m+h\) arcs, costs \(O\bigl((n+m)\log(n+m)\bigr)\).  
   - Overall across all test cases (with \(\sum n,\sum m\le2\cdot10^5\)) fits well within 5 seconds in Java.

If no meeting is possible (all distances infinite), we print `-1`.