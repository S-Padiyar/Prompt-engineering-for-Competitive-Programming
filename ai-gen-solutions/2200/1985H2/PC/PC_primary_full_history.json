[
  {
    "role": "user",
    "content": "H2. Maximize the Largest Component (Hard Version)\n\ntime limit per test2 seconds\n\nmemory limit per test512 megabytes\n\nEasy and hard versions are actually different problems, so read statements of both problems completely and carefully. The only difference between the two versions is the operation.\n\n\n\nAlex has a grid with n\n\n rows and m\n\n columns consisting of '.' and '#' characters. A set of '#' cells forms a connected component if from any cell in this set, it is possible to reach any other cell in this set by only moving to another cell in the set that shares a common side. The size of a connected component is the number of cells in the set.\n\n\n\nIn one operation, Alex selects any row r\n\n (1≤r≤n\n\n) and any column c\n\n (1≤c≤m\n\n), then sets every cell in row r\n\n and column c\n\n to be '#'. Help Alex find the maximum possible size of the largest connected component of '#' cells that he can achieve after performing the operation at most once.\n\n\n\nInput\n\nThe first line of the input contains a single integer t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nThe first line of each test case contains two integers n\n\n and m\n\n (1≤n⋅m≤106\n\n) — the number of rows and columns of the grid.\n\n\n\nThe next n\n\n lines each contain m\n\n characters. Each character is either '.' or '#'.\n\n\n\nIt is guaranteed that the sum of n⋅m\n\n over all test cases does not exceed 106\n\n.\n\n\n\nOutput\n\nFor each test case, output a single integer — the maximum possible size of a connected component of '#' cells that Alex can achieve.\n\n\n\nExample\n\nInputCopy\n\n6\n\n1 1\n\n.\n\n4 2\n\n..\n\n#.\n\n#.\n\n.#\n\n3 5\n\n.#.#.\n\n..#..\n\n.#.#.\n\n5 5\n\n#...#\n\n....#\n\n#...#\n\n.....\n\n...##\n\n6 6\n\n.#..#.\n\n#..#..\n\n.#...#\n\n#.#.#.\n\n.#.##.\n\n###..#\n\n6 8\n\n..#....#\n\n.####.#.\n\n###.#..#\n\n.##.#.##\n\n.#.##.##\n\n#..##.#.\n\nOutputCopy\n\n1\n\n7\n\n11\n\n16\n\n22\n\n36\n\nNote\n\nIn the fourth test case, it is optimal for Alex to set all cells in row 4\n\n and column 2\n\n to be '#'. Doing so will lead to the largest connected component of '#' having a size of 16\n\n.\n\n\n\nIn the fifth test case, it is optimal for Alex to set all cells in row 2\n\n and column 4\n\n to be '#'. Doing so will lead to the largest connected component of '#' having a size of 22\n\n.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have an \\(n\\times m\\) grid of `'#'` (black) and `'.'` (white) cells.  We may do at most one operation:\n\n– Choose a row \\(r\\) and a column \\(c\\).  \n– Paint every cell in row \\(r\\) and every cell in column \\(c\\) black (`'#'`).\n\nAfter that (or doing nothing), we look at the sizes of connected components of black cells (4-connected) and want the size of the largest component.\n\nEven with a single operation, it is not obvious which row/column to pick, nor how to quickly evaluate the resulting component size for every \\((r,c)\\).  A brute force scanning all \\(n\\cdot m\\) possibilities and doing a graph traversal each time would be far too expensive when \\(n\\cdot m\\) can be up to \\(10^6\\).\n\nInstead we observe:\n\n1.  **Initial components**  \n    First we find the connected components of `'#'` in the original grid by a single union-find (DSU) pass.  Let\n    \\[\n      \\text{compSize}[i]=\\text{size of component }i,\\quad i=1\\ldots K.\n    \\]\n    We also record the maximum of these initial sizes, call it \\(\\text{bestNoOp}\\), because we always have the *option* to do no operation.\n\n2.  **Contribution of an operation**  \n    Suppose we do pick row \\(r\\) and column \\(c\\).  Then every cell in that entire row and column becomes black.  Let\n    \\[\n       S_r=\\{(r,0),(r,1),\\dots,(r,m-1)\\},\\quad\n       S_c=\\{(0,c),(1,c),\\dots,(n-1,c)\\}.\n    \\]\n    The new black cells can connect some original components together (and also add brand-new black cells where there were dots).\n\n3.  **Counting efficiently**  \n    It turns out one can show that the size of the merged component that contains all of \\(S_r\\cup S_c\\) is\n    \\[\n      \\sum_{\\substack{\\text{original comp }i\\\\\\text{that touches}\\\\(S_r\\cup S_c)}} \\!\\!\\!\\text{compSize}[i]\n      \\;+\\;\n      \\bigl(\\#\\hbox{ of originally-white cells in }S_r\\cup S_c\\bigr).\n    \\]\n    We must be careful not to double-count the cells of an original component that happen to lie *in* \\(S_r\\cup S_c\\); those are already counted in \\(\\text{compSize}[i]\\).  Instead we simply add in the *number of dots* in row \\(r\\) plus the number of dots in column \\(c\\), minus one if the \\((r,c)\\) cell was a dot (so as not to double-count that intersection).\n\n4.  **Data structures**  \n   - Let\n     \\[\n       s_r[r]\\;=\\;\\sum_{\\substack{\\text{comp }i\\\\\\text{ that has a cell}\\\\\\text{in row }r\\pm1}}\n                     \\!\\!\\!\\text{compSize}[i],\n       \\]\n     i.e.\\ the total size of all original components that touch row \\(r\\), row \\(r-1\\), or row \\(r+1\\).  \n     \n     Similarly define\n     \\[\n       s_c[c]\\;=\\;\\sum_{\\substack{\\text{comp }i\\\\\\text{ that has a cell}\\\\\\text{in col }c\\pm1}}\n                     \\!\\!\\!\\text{compSize}[i].\n     \\]\n   - Let \\(\\text{dotRow}[r]\\) = # of dots in row \\(r\\), and \\(\\text{dotCol}[c]\\) = # of dots in column \\(c\\).\n   - If we naïvely added \\(s_r[r]+s_c[c]\\) we would double-count exactly the sum of those components that touch *both* row \\(r\\pm1\\) and column \\(c\\pm1\\).  We call that overlap \\(\\text{cross}[r][c]\\).  \n   - Finally\n     \\[\n       \\text{result}(r,c)\n         =\\;s_r[r]+s_c[c]\n          +(\\hbox{dotRow}[r]+\\hbox{dotCol}[c] - [\\hbox{grid}[r][c]=='.'?1:0])\n         \\;-\\;\\text{cross}[r][c].\n     \\]\n     We maximize this over all \\((r,c)\\), and also compare with the no‐op answer \\(\\text{bestNoOp}\\).\n\n5.  **Building \\(\\text{cross}[\\,]\\)**  \n   Let each component \\(i\\) “influences” the set of rows\n   \\[\n     R_i=\\{\\,r-1,r,r+1\\;\\mid\\text{component \\(i\\) has any cell in row }r\\}\\cap[0,n-1],\n   \\]\n   and the set of columns\n   \\[\n     C_i=\\{\\,c-1,c,c+1\\;\\mid\\text{component \\(i\\) has any cell in col }c\\}\\cap[0,m-1].\n   \\]\n   Then for every \\((r,c)\\in R_i\\times C_i\\) we add \\(\\text{compSize}[i]\\) to \\(\\text{cross}[r][c]\\).  \n   \n   Concretely, we collect all raw pairs \\((i,r')\\) and \\((i,c')\\) as 64-bit keys, sort & unique them, then for each component gather its small list \\(R_i\\) and \\(C_i\\) and do the double loop \\(\\forall r\\in R_i,\\forall c\\in C_i:\\)\n   ```  \n      cross[r*m + c] += compSize[i];\n   ```\n   This total work sums over all components of \\(|R_i|\\times|C_i|\\), which in the worst case is still \\(O(nm)\\) or a few times \\(nm\\).  Since \\(nm\\le10^6\\), it runs in time.\n\nOverall time per test is\n     – one DSU pass: \\(O(nm)\\).  \n     – computing \\(s_r,s_c,\\text{dotRow},\\text{dotCol}\\): \\(O(nm)\\).  \n     – sorting the raw “row‐pairs” and “col‐pairs”: each of size up to \\(3\\cdot(\\#\\text{black cells})\\le3nm\\), so \\(O(nm\\log(nm))\\).  \n     – filling the cross array by “per‐component double loops” \\(\\sum_i|R_i|\\cdot|C_i|\\), again \\(O(nm)\\).  \n     – final scan of all \\((r,c)\\) in \\(O(nm)\\).  \n\nSince \\(\\sum nm\\le10^6\\) over all test cases, this comfortably fits in 2 s in Java.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static int[] parent, sz, rootToComp;\n    static int findRoot(int x) {\n        // path compression\n        if (parent[x] != x) parent[x] = findRoot(parent[x]);\n        return parent[x];\n    }\n    static void union(int a, int b) {\n        a = findRoot(a);\n        b = findRoot(b);\n        if (a == b) return;\n        // union by size\n        if (sz[a] < sz[b]) {\n            parent[a] = b;\n            sz[b] += sz[a];\n        } else {\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        BufferedReader   br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter   bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        StringTokenizer  st = new StringTokenizer(br.readLine());\n        int t = Integer.parseInt(st.nextToken());\n        while (t-- > 0) {\n            // read n, m\n            st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(st.nextToken());\n            int N = n*m;\n\n            // read grid into a flat char array\n            char[] grid = new char[N];\n            int[] dotRow = new int[n], dotCol = new int[m];\n            int cellCount = 0;  // number of '#' cells\n            for (int i=0; i<n; i++) {\n                String row = br.readLine();\n                for (int j=0; j<m; j++) {\n                    char c = row.charAt(j);\n                    grid[i*m + j] = c;\n                    if (c == '.') {\n                        dotRow[i]++;\n                        dotCol[j]++;\n                    } else {\n                        cellCount++;\n                    }\n                }\n            }\n\n            // 1) Build DSU of all '#' cells\n            parent = new int[N];\n            sz     = new int[N];\n            for (int i=0; i<N; i++) {\n                if (grid[i]=='#') {\n                    parent[i] = i;\n                    sz[i]     = 1;\n                } else {\n                    parent[i] = -1;  // mark white cells\n                }\n            }\n            // union horizontally and vertically\n            for (int i=0; i<n; i++) {\n                for (int j=0; j<m; j++) {\n                    if (grid[i*m+j]=='#') {\n                        int p = i*m+j;\n                        if (i+1<n && grid[(i+1)*m+j]=='#') union(p,(i+1)*m+j);\n                        if (j+1<m && grid[i*m+(j+1)]=='#') union(p,i*m+(j+1));\n                    }\n                }\n            }\n\n            // 2) remap each root to a component index 1..K\n            rootToComp = new int[N];\n            int compCnt=0;\n            // compSizes[1..compCnt]\n            int[] compSize = new int[N+1];\n            int bestNoOp = 0;\n            for (int i=0; i<N; i++) {\n                if (grid[i]=='#') {\n                    int r = findRoot(i);\n                    if (rootToComp[r]==0) {\n                        rootToComp[r] = ++compCnt;\n                        compSize[compCnt] = sz[r];\n                        bestNoOp = Math.max(bestNoOp, sz[r]);\n                    }\n                }\n            }\n\n            // 3) We will build 2 big arrays of raw (compID, row') and (compID, col')\n            //    Each '#' cell contributes up to 3 row' and 3 col' entries.\n            long[] rowRaw = new long[3*cellCount];\n            long[] colRaw = new long[3*cellCount];\n            int rptr=0, cptr=0;\n\n            // We'll also compute s_r, s_c in one pass\n            int[] s_r = new int[n], s_c = new int[m];\n            int[] lastR = new int[n], lastC = new int[m];\n            // lastR[r] == compID means we already added compID to s_r[r]\n\n            for (int i=0; i<n; i++) {\n                for (int j=0; j<m; j++) {\n                    if (grid[i*m+j]=='#') {\n                        int compID = rootToComp[ findRoot(i*m+j) ];\n                        // mark row-range\n                        for (int dr=-1; dr<=1; dr++) {\n                            int rr = i+dr;\n                            if (rr>=0 && rr<n) {\n                                if (lastR[rr]!=compID) {\n                                    lastR[rr] = compID;\n                                    s_r[rr] += compSize[compID];\n                                }\n                                // also record the raw pair\n                                rowRaw[rptr++] = (((long)compID)<<32) | (rr & 0xffffffffL);\n                            }\n                        }\n                        // mark col-range\n                        for (int dc=-1; dc<=1; dc++) {\n                            int cc = j+dc;\n                            if (cc>=0 && cc<m) {\n                                if (lastC[cc]!=compID) {\n                                    lastC[cc] = compID;\n                                    s_c[cc] += compSize[compID];\n                                }\n                                // raw pair\n                                colRaw[cptr++] = (((long)compID)<<32) | (cc & 0xffffffffL);\n                            }\n                        }\n                    }\n                }\n            }\n\n            // 4) Sort & unique rowRaw[0..rptr) and colRaw[0..cptr)\n            Arrays.sort(rowRaw, 0, rptr);\n            {\n                int w=0;\n                for (int i=0; i<rptr; i++){\n                    if (i==0 || rowRaw[i]!=rowRaw[i-1])\n                        rowRaw[w++] = rowRaw[i];\n                }\n                rptr = w;\n            }\n\n            Arrays.sort(colRaw, 0, cptr);\n            {\n                int w=0;\n                for (int i=0; i<cptr; i++){\n                    if (i==0 || colRaw[i]!=colRaw[i-1])\n                        colRaw[w++] = colRaw[i];\n                }\n                cptr = w;\n            }\n\n            // 5) Build the cross array by walking each compID's chunk\n            int[] cross = new int[N];  // cross[r*m + c]\n            int pR=0, pC=0;\n\n            for (int compID=1; compID<=compCnt; compID++){\n                // gather that comp's row-list\n                ArrayList<Integer> rowsList = new ArrayList<>();\n                while (pR<rptr && (int)(rowRaw[pR]>>>32) < compID) pR++;\n                while (pR<rptr && (int)(rowRaw[pR]>>>32) == compID){\n                    int rr = (int)(rowRaw[pR] & 0xffffffffL);\n                    rowsList.add(rr);\n                    pR++;\n                }\n                // gather that comp's col-list\n                ArrayList<Integer> colsList = new ArrayList<>();\n                while (pC<cptr && (int)(colRaw[pC]>>>32) < compID) pC++;\n                while (pC<cptr && (int)(colRaw[pC]>>>32) == compID){\n                    int cc = (int)(colRaw[pC] & 0xffffffffL);\n                    colsList.add(cc);\n                    pC++;\n                }\n\n                // do the double loop\n                int add = compSize[compID];\n                for (int rr: rowsList) {\n                    int base = rr*m;\n                    for (int cc: colsList) {\n                        cross[base + cc] += add;\n                    }\n                }\n            }\n\n            // 6) Precompute F[r]=s_r[r]+dotRow[r], G[c]=s_c[c]+dotCol[c]\n            int[] F = new int[n], G = new int[m];\n            for (int i=0; i<n; i++) F[i] = s_r[i] + dotRow[i];\n            for (int j=0; j<m; j++) G[j] = s_c[j] + dotCol[j];\n\n            // 7) Scan all (r,c), compute\n            //    val = F[r] + G[c] - cross[r*m+c] - (grid[r*m+c]=='.'?1:0)\n            //    and keep max\n            int answer = bestNoOp;\n            for (int i=0; i<n; i++){\n                int rowBase = i*m;\n                for (int j=0; j<m; j++){\n                    int v = F[i] + G[j] - cross[rowBase+j]\n                                - (grid[rowBase+j]=='.' ? 1 : 0);\n                    if (v>answer) answer=v;\n                }\n            }\n\n            // output\n            bw.write(answer+\"\\n\");\n        }\n\n        bw.flush();\n    }\n}\n```\n\n**Explanation of the Key Steps**\n\n1. **Union‐Find (DSU)**  \n   We first merge all adjacent `'#'` cells into components in one pass (looking right and down only).  After that we compress and give each root a small index `1..K`.\n\n2. **Row/Column Influence**  \n   A component of size \\(S\\) that has any cell in row \\(r\\) will, after the operation, connect to the cross formed by row \\(r-1,r,r+1\\).  Hence it contributes \\(S\\) to `s_r[r-1]`, `s_r[r]`, and `s_r[r+1]` (if in range).  We do exactly the same for columns to build `s_c[c]`.\n\n3. **Dots Count**  \n   We also count how many dots lie in each row/column; those will become newly painted black if we paint that row/column.\n\n4. **Avoiding Double Counting**  \n   If we simply added `s_r[r] + s_c[c]`, any component appearing in both would be counted twice.  We subtract out exactly those overlaps into a matrix `cross[r][c]`, computed by  \n   \\[\n     \\text{for each component }i:\\quad\n       \\forall r'\\in\\{r-1,r,r+1\\},\\forall c'\\in\\{c-1,c,c+1\\}: \n       \\quad\n       \\text{cross}[\\,r'\\,,\\,c'\\,] \\;+=\\;\\text{compSize}[i].\n   \\]\n   Implementing that naïvely for each component’s full set of row\\(×\\)col pairs is still \\(O(nm)\\) overall, since each component’s row‐set and column‐set are small (at most 3 times the number of distinct rows or columns it originally touched).\n\n5. **Final Scan**  \n   At the end\n   \\[\n     \\text{result}(r,c)\n       =\\;s_r[r]+s_c[c]\n        +( \\mathrm{dotRow}[r]+\\mathrm{dotCol}[c]\n           -[\\text{if }(r,c)\\text{ was a dot }?1:0] )\n        -\\text{cross}[r][c].\n   \\]\n   We maximize this over all \\(0\\le r<n,\\;0\\le c<m\\), and also compare with the best “no operation” size.\n\nThis runs in \\(O(nm\\log(nm))\\) overall and easily fits under the given limits for \\(\\sum nm\\le10^6\\)."
  }
]