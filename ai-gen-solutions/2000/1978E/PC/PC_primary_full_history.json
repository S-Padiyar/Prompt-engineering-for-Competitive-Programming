[
  {
    "role": "user",
    "content": "E. Computing Machine\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nSasha has two binary strings s\n\n and t\n\n of the same length n\n\n, consisting of the characters 0 and 1.\n\n\n\nThere is also a computing machine that can perform two types of operations on binary strings a\n\n and b\n\n of the same length k\n\n:\n\n\n\nIf ai=ai+2=\n\n 0, then you can assign bi+1:=\n\n 1 (1≤i≤k−2\n\n).\n\nIf bi=bi+2=\n\n 1, then you can assign ai+1:=\n\n 1 (1≤i≤k−2\n\n).\n\nSasha became interested in the following: if we consider the string a=slsl+1…sr\n\n and the string b=tltl+1…tr\n\n, what is the maximum number of 1 characters in the string a\n\n that can be obtained using the computing machine. Since Sasha is very curious but lazy, it is up to you to answer this question for several pairs (li,ri)\n\n that interest him.\n\n\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single integer t\n\n (1≤t≤104\n\n) — the number of test cases. The description of the test cases follows.\n\n\n\nThe first line of each test case contains a single integer n\n\n (1≤n≤2⋅105\n\n) — the length of the strings s\n\n and t\n\n.\n\n\n\nThe second line of each test case contains a binary string s\n\n of length n\n\n, consisting of the characters 0 and 1.\n\n\n\nThe third line of each test case contains a binary string t\n\n of length n\n\n, consisting of the characters 0 and 1.\n\n\n\nThe fourth line of each test case contains a single integer q\n\n (1≤q≤2⋅105\n\n) — the number of queries.\n\n\n\nThe i\n\n-th of the following lines contains two integers li\n\n and ri\n\n (1≤li≤ri≤n\n\n) — the boundaries of the i\n\n-th pair of substrings that interest Sasha.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2⋅105\n\n and the sum of q\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output q\n\n integers — the answers to all queries.\n\n\n\nExample\n\nInputCopy\n\n3\n\n4\n\n1111\n\n0000\n\n2\n\n1 2\n\n2 4\n\n4\n\n1010\n\n1101\n\n2\n\n1 3\n\n1 4\n\n6\n\n010101\n\n011010\n\n5\n\n2 3\n\n1 6\n\n2 5\n\n4 4\n\n3 6\n\nOutputCopy\n\n2\n\n3\n\n2\n\n3\n\n1\n\n4\n\n3\n\n1\n\n2\n\nNote\n\nIn the first test case:\n\n\n\nIn the first query, a=\n\n 11, so the maximum number of 1 characters is 2\n\n.\n\nIn the second query, a=\n\n 111, so the maximum number of 1 characters is 3\n\n.\n\nIn the second test case:\n\n\n\nIn the first query, a=\n\n 101 and b=\n\n 110. No operations can be performed, so the maximum number of 1 characters is 2\n\n.\n\nIn the second query, a=\n\n 1010 and b=\n\n 1101. Since a2=a4=\n\n 0, we can assign b3:=\n\n 1. Now b1=b3=\n\n 1, so we can assign a2:=\n\n 1. The string a\n\n becomes 1110, so the maximum number of 1 characters is 3\n\n.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have two binary strings \\(s\\) and \\(t\\) of the same length \\(n\\).  We extract substrings  \n\\[\na = s_{\\,l..r},\\quad b = t_{\\,l..r}\n\\]\nand we are allowed two kinds of “infection” operations on these length-\\(k=r-l+1\\) strings \\(a,b\\):\n\n 1. If \\(a_i = a_{i+2}=0\\) then you may set \\(b_{i+1}:=1\\).\n 2. If \\(b_i = b_{i+2}=1\\) then you may set \\(a_{i+1}:=1\\).\n\nWe may apply these in any order, any number of times, but once a bit is turned to `1` it never goes back to `0`.  We wish to maximize the number of 1's in \\(a\\).\n\nA key observation is that “making new 1’s in \\(a\\)” (with operation 2) only uses *existing* 1’s in \\(b\\), whereas “making new 1’s in \\(b\\)” (with operation 1) only uses *existing* 0’s in \\(a\\).  Moreover turning a 0 in \\(a\\) into a 1 can only *reduce* the supply of 0’s for further \\(b\\)-infections, never increase it.  Hence to maximize final 1’s in \\(a\\), one should\n\n 1. **First** do *all* possible infections of \\(b\\) from **the original** zeros of \\(a\\).  (We never want to turn an \\(a\\)-zero into 1 *until* we have used it to infect as many \\(b\\)-positions as possible.)\n 2. **Then** do all possible infections of \\(a\\) from the †final—now maximal† 1’s in \\(b\\).\n\nBoth steps can be done in just one pass because\n\n- Infecting \\(b\\) only depends on *original* zero–pairs in \\(a\\), and\n- Infecting \\(a\\) only depends on the resulting 1’s in \\(b\\).\n\nConcretely, if we index the substring \\(l..r\\) by the same absolute indices \\(j = l\\ldots r\\), then\n\n1.  Build an array\n   \\[\n     \\mathrm{zeroPair}[j]\n     \\;=\\;\n     \\begin{cases}\n       1, & j\\in[l+1..r-1]\\text{ and }s_{j-1}=0,\\;s_{j+1}=0,\\\\\n       0, & \\text{otherwise.}\n     \\end{cases}\n   \\]\n   Whenever \\(\\mathrm{zeroPair}[j]=1\\), we can infect \\(b_j\\) to 1.\n\n2.  Define\n   \\[\n     B_1[j] \\;=\\; \\bigl(t_j==1\\bigr)\\;\\lor\\;\\mathrm{zeroPair}[j].\n   \\]\n   Now \\(B_1[j]\\) is 1 exactly if the final \\(b_j\\) (after phase 1) is 1.\n\n3.  We can infect \\(a_i\\) at position \\(i\\) precisely if \n   \\[\n     B_1[i-1]=1\n     \\quad\\text{and}\\quad\n     B_1[i+1]=1,\n   \\]\n   **and** originally \\(s_i=0\\).  Thus we add up all such new positions.\n\nPutting it all together for a query \\([l,r]\\):\n\n- Let\n  \\[\n    \\mathrm{onesA} = \\#\\{j\\in[l..r]\\bigm|s_j=1\\}.\n  \\]\n- We wish to count\n  \\[\n    \\mathrm{newA}\n    = \\#\\{\\,i\\in[l..r]\\mid s_i=0,\\;B_1[i-1]=1,\\;B_1[i+1]=1\\}.\n  \\]\n- The answer is \\(\\mathrm{onesA} + \\mathrm{newA}.\\)\n\nWe must take care of boundaries (positions \\(i=l\\) or \\(i=r\\) cannot be infected because they lack two neighbors inside the substring).  One can implement the interior count (from \\(i=l+1\\) to \\(i=r-1\\)) using a prefix–sum array in \\(O(1)\\) per query, after an \\(O(n)\\) preprocessing of\n\n 1. prefix sums of \\(\\mathbf{1}_{s_j=1}\\),\n 2. the boolean `zeroPair[j]`, and\n 3. the boolean array `C[i] = 1` exactly when \\(\\,s_i=0\\) and `B1[i-1]=1` and `B1[i+1]=1`.\n\nEach query is then answered in \\(O(1)\\).  Since the total \\(n\\) and total queries over all test–cases do not exceed \\(2\\!\\times10^5\\), this is perfectly fast.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        FastReader in = new FastReader();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n        int T = in.nextInt();\n        while (T-- > 0) {\n            int n = in.nextInt();\n            String s = in.next();\n            String t = in.next();\n            int q = in.nextInt();\n\n            // 1-based for convenience\n            char[] S = new char[n+2], Tt = new char[n+2];\n            for (int i = 1; i <= n; i++) {\n                S[i] = s.charAt(i-1);\n                Tt[i] = t.charAt(i-1);\n            }\n\n            // prefA[i] = # of ones in s[1..i]\n            int[] prefA = new int[n+1];\n            for (int i = 1; i <= n; i++) {\n                prefA[i] = prefA[i-1] + (S[i]=='1' ? 1 : 0);\n            }\n\n            // zeroPair[j] = 1 iff j in [2..n-1] and S[j-1]=S[j+1]=0\n            int[] zeroPair = new int[n+1];\n            for (int j = 2; j <= n-1; j++) {\n                if (S[j-1]=='0' && S[j+1]=='0') {\n                    zeroPair[j] = 1;\n                }\n            }\n\n            // B0[j] = initial t[j]==1 ? 1 : 0\n            int[] B0 = new int[n+1];\n            for (int i = 1; i <= n; i++) {\n                B0[i] = (Tt[i]=='1' ? 1 : 0);\n            }\n\n            // B1[j] = B0[j] OR zeroPair[j]\n            int[] B1 = new int[n+1];\n            for (int i = 1; i <= n; i++) {\n                B1[i] = (B0[i] | zeroPair[i]);\n            }\n\n            // C[i] = 1 iff we can infect a[i] from neighbors\n            //        = 1 iff S[i]=='0' and B1[i-1]==1 and B1[i+1]==1\n            int[] C = new int[n+1];\n            for (int i = 2; i <= n-1; i++) {\n                if (S[i]=='0' && B1[i-1]==1 && B1[i+1]==1) {\n                    C[i] = 1;\n                }\n            }\n            // prefix sums of C\n            int[] prefC = new int[n+1];\n            for (int i = 1; i <= n; i++) {\n                prefC[i] = prefC[i-1] + C[i];\n            }\n\n            // handle queries\n            while (q-- > 0) {\n                int l = in.nextInt();\n                int r = in.nextInt();\n\n                // initial count of ones in a = s[l..r]\n                int ans = prefA[r] - prefA[l-1];\n\n                // if substring shorter than 3, no new infections possible\n                if (r - l < 2) {\n                    out.println(ans);\n                    continue;\n                }\n\n                // count all C[i] for i in [l+1..r-1] except the boundaries,\n                // i.e. i in [l+2..r-2]\n                int leftMid = l + 2, rightMid = r - 2;\n                if (leftMid <= rightMid) {\n                    ans += (prefC[rightMid] - prefC[leftMid-1]);\n                }\n\n                // boundary positions i = l+1 and i = r-1 need special careful checks\n                // (their non-infected neighbor disallows zeroPair there).\n                // We do i = l+1 always (it exists because r-l>=2),\n                // and i = r-1 only if distinct (r-l>=3).\n\n                // i = l+1\n                {\n                    int i = l+1;\n                    // left neighbor must be originally 1 in t\n                    if (S[i]=='0' && B0[l]==1) {\n                        // right neighbor\n                        boolean rightOk;\n                        if (i+1 <= r-1) {\n                            // can use B1\n                            rightOk = (B1[i+1] == 1);\n                        } else {\n                            // i+1 == r, can only use initial t[r]\n                            rightOk = (B0[i+1] == 1);\n                        }\n                        if (rightOk) ans++;\n                    }\n                }\n\n                // i = r-1 (only if r-l>=3 so it's different from l+1)\n                if (r - l >= 3) {\n                    int i = r-1;\n                    // right neighbor must be originally 1 in t\n                    if (S[i]=='0' && B0[r]==1) {\n                        // left neighbor\n                        boolean leftOk;\n                        if (i-1 >= l+1) {\n                            // can use B1\n                            leftOk = (B1[i-1] == 1);\n                        } else {\n                            // i-1 == l\n                            leftOk = (B0[i-1] == 1);\n                        }\n                        if (leftOk) ans++;\n                    }\n                }\n\n                out.println(ans);\n            }\n        }\n\n        out.flush();\n        out.close();\n    }\n\n    // fast input reader\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() throws IOException {\n            while (st==null || !st.hasMoreTokens()) {\n                String line = br.readLine();\n                if (line==null) return null;\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Phase 1 (“maximal” \\(b\\)-infection)**  \n   We precompute  \n   \\[\n     \\mathrm{zeroPair}[j] = \n     \\begin{cases}\n       1, & 2\\le j\\le n-1\\text{ and }s_{j-1}=0,\\;s_{j+1}=0,\\\\\n       0, & \\text{otherwise}.\n     \\end{cases}\n   \\]\n   Then\n   \\[\n     B1[j]\n     = \\bigl(t_j==1\\bigr)\n       \\;\\lor\\;\n       \\mathrm{zeroPair}[j].\n   \\]\n   After we do *all* infections using rule (1), exactly those indices \\(j\\) with \\(B1[j]=1\\) have \\(b_j=1\\).\n\n2. **Phase 2 (infecting \\(a\\))**  \n   A zero in \\(a\\) at position \\(i\\) can be turned to 1 iff both neighbors in \\(b\\) are 1, i.e.\n   \\[\n     B1[i-1] = 1\n     \\quad\\text{and}\\quad\n     B1[i+1] = 1,\n     \\quad\\text{and originally }s_i=0.\n   \\]\n   We form an array\n   \\[\n     C[i] = \n     \\begin{cases} \n       1,& 2\\le i\\le n-1,\\;s_i=0,\\;B1[i-1]=1,\\;B1[i+1]=1,\\\\\n       0,&\\text{otherwise,}\n     \\end{cases}\n   \\]\n   and take prefix sums of \\(C\\).  Then each query \\([l,r]\\) simply adds up\n   \\[\n     \\sum_{i=l+1}^{r-1} C[i],\n   \\]\n   plus boundary checks for \\(i=l+1\\) and \\(i=r-1\\) (which lack the full two-side “zeroPair” permission).  \n\nSince all preprocessing is \\(O(n)\\) and each query is \\(O(1)\\), the solution runs in \\(O(n + Q)\\) per test and comfortably handles the constraints."
  },
  {
    "role": "user",
    "content": "Please provide a clean, self-contained Java solution in one code block (a single Main class) that reads input, processes all test cases, and prints the answers, without extra explanation."
  },
  {
    "role": "assistant",
    "content": "```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        FastReader in = new FastReader();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int T = in.nextInt();\n        while (T-- > 0) {\n            int n = in.nextInt();\n            String s = in.next();\n            String t = in.next();\n            int q = in.nextInt();\n            \n            // 1-based arrays\n            char[] S = new char[n+2], Tt = new char[n+2];\n            for (int i = 1; i <= n; i++) {\n                S[i] = s.charAt(i-1);\n                Tt[i] = t.charAt(i-1);\n            }\n            \n            // prefix sums of ones in S\n            int[] prefA = new int[n+1];\n            for (int i = 1; i <= n; i++) {\n                prefA[i] = prefA[i-1] + (S[i]=='1' ? 1 : 0);\n            }\n            \n            // zeroPair[j] = 1 if S[j-1]=S[j+1]=0\n            int[] zeroPair = new int[n+1];\n            for (int j = 2; j <= n-1; j++) {\n                if (S[j-1]=='0' && S[j+1]=='0') {\n                    zeroPair[j] = 1;\n                }\n            }\n            \n            // B1[j] = final b[j] bit: t[j]==1 or zeroPair[j]==1\n            int[] B1 = new int[n+1];\n            for (int i = 1; i <= n; i++) {\n                B1[i] = (Tt[i]=='1' ? 1 : 0) | zeroPair[i];\n            }\n            \n            // C[i] = 1 if S[i]==0 and B1[i-1]==1 and B1[i+1]==1\n            int[] prefC = new int[n+1];\n            for (int i = 1; i <= n; i++) {\n                int c = 0;\n                if (i >= 2 && i <= n-1) {\n                    if (S[i]=='0' && B1[i-1]==1 && B1[i+1]==1) {\n                        c = 1;\n                    }\n                }\n                prefC[i] = prefC[i-1] + c;\n            }\n            \n            while (q-- > 0) {\n                int l = in.nextInt(), r = in.nextInt();\n                int ones = prefA[r] - prefA[l-1];\n                if (r - l < 2) {\n                    out.println(ones);\n                } else {\n                    int add = prefC[r-1] - prefC[l];\n                    out.println(ones + add);\n                }\n            }\n        }\n        out.flush();\n    }\n    \n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        FastReader() { br = new BufferedReader(new InputStreamReader(System.in)); }\n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) {\n                String line = br.readLine();\n                if (line == null) return null;\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n        int nextInt() throws IOException { return Integer.parseInt(next()); }\n    }\n}\n```"
  }
]