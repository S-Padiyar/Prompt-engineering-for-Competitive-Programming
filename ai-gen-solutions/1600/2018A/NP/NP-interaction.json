[
    {
        "request_timestamp": "2025-07-23T18:22:35.180213",
        "response_timestamp": "2025-07-23T18:23:37.050589",
        "sent_messages": [
            {
                "role": "user",
                "content": "Codeforces Problem:\n\nA. Cards Partition\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nDJ Genki vs Gram - Einherjar Joker\n\n⠀\n\nYou have some cards. An integer between 1\n\n and n\n\n is written on each card: specifically, for each i\n\n from 1\n\n to n\n\n, you have ai\n\n cards which have the number i\n\n written on them.\n\n\n\nThere is also a shop which contains unlimited cards of each type. You have k\n\n coins, so you can buy at most k\n\n new cards in total, and the cards you buy can contain any integer between 1\n\n and n\n\n, inclusive.\n\n\n\nAfter buying the new cards, you must partition all your cards into decks, according to the following rules:\n\n\n\nall the decks must have the same size;\n\nthere are no pairs of cards with the same value in the same deck.\n\nFind the maximum possible size of a deck after buying cards and partitioning them optimally.\n\n\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n\n (1≤t≤104\n\n). The description of the test cases follows.\n\n\n\nThe first line of each test case contains two integers n\n\n, k\n\n (1≤n≤2⋅105\n\n, 0≤k≤1016\n\n) — the number of distinct types of cards and the number of coins.\n\n\n\nThe second line of each test case contains n\n\n integers a1,a2,…,an\n\n (0≤ai≤1010\n\n, ∑ai≥1\n\n) — the number of cards of type i\n\n you have at the beginning, for each 1≤i≤n\n\n.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output a single integer: the maximum possible size of a deck if you operate optimally.\n\n\n\nExample\n\nInputCopy\n\n9\n\n3 1\n\n3 2 2\n\n5 4\n\n2 6 1 2 4\n\n2 100\n\n1410065408 10000000000\n\n10 8\n\n7 4 6 6 9 3 10 2 8 7\n\n2 12\n\n2 2\n\n2 70\n\n0 1\n\n1 0\n\n1\n\n3 0\n\n2 1 2\n\n3 1\n\n0 3 3\n\nOutputCopy\n\n2\n\n3\n\n1\n\n7\n\n2\n\n2\n\n1\n\n1\n\n2\n\nNote\n\nIn the first test case, you can buy one card with the number 1\n\n, and your cards become [1,1,1,1,2,2,3,3]\n\n. You can partition them into the decks [1,2],[1,2],[1,3],[1,3]\n\n: they all have size 2\n\n, and they all contain distinct values. You can show that you cannot get a partition with decks of size greater than 2\n\n, so the answer is 2\n\n.\n\n\n\nIn the second test case, you can buy two cards with the number 1\n\n and one card with the number 3\n\n, and your cards become [1,1,1,1,2,2,2,2,2,2,3,3,4,4,5,5,5,5]\n\n, which can be partitioned into [1,2,3],[1,2,4],[1,2,5],[1,2,5],[2,3,5],[2,4,5]\n\n. You can show that you cannot get a partition with decks of size greater than 3\n\n, so the answer is 3\n\n.\n\n---\n\nUse Java."
            }
        ],
        "received_response": "{\n  \"id\": \"chatcmpl-Bwc966MrlGbOSEGFDwTGqzRFrw87p\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"**Analysis**\\n\\nWe have n types of cards. For each type i we already have a_i cards (0≤a_i≤10¹⁰), and we may buy up to k more cards (k≤10¹⁶), of any types we wish.  After buying, we must split _all_ our cards (the originals plus the ones purchased) into decks so that:\\n\\n1. All decks have the same size, say x.\\n2. No deck has two cards of the same type.\\n\\nWe wish to make x as large as possible.\\n\\n---\\n\\nKey observations:\\n\\n1. **Deck‐size ≤ n.**  \\n   Each deck has x distinct cards, and there are only n types, so obviously 0 < x ≤ n.\\n\\n2. **Number of decks t and type‐counts ≤ t.**  \\n   Let after buying we have new counts \\\\(b_i\\\\ge a_i\\\\).  We will have some integer number of decks \\\\(t\\\\), each of size \\\\(x\\\\).  Hence total cards\\n   \\\\[\\n     \\\\sum_i b_i \\\\;=\\\\; t\\\\cdot x.\\n   \\\\]\\n   Furthermore, since in each deck you can use at most one card of type i, you must have\\n   \\\\[\\n     b_i \\\\;\\\\le\\\\; t\\n     \\\\quad\\\\text{for every }i,\\n   \\\\]\\n   otherwise you would have `b_i>t` cards of type i but only \\\\(t\\\\) decks, so you couldn't place them all without repeating a type in some deck.\\n\\n3. **No discarding, only buying.**  \\n   We cannot discard cards, so \\\\(b_i\\\\ge a_i\\\\).  Buying costs are\\n   \\\\[\\n     \\\\sum_i (b_i - a_i)\\\\;\\\\le\\\\;k.\\n   \\\\]\\n\\nPutting these together, for a chosen deck‐size x we look for some integer number of decks t for which all conditions can be met:\\n\\n- \\\\(t\\\\) must be large enough that no original pile \\\\(a_i\\\\) exceeds it:\\n  \\n  \\\\[\\n    t \\\\;\\\\ge\\\\; \\\\max_i\\\\,a_i =: M.\\n  \\\\]\\n\\n- We must have enough total cards (original + bought) to fill \\\\(t\\\\) decks of size \\\\(x\\\\):\\n  \\n  \\\\[\\n    t\\\\cdot x \\\\;-\\\\;\\\\sum_i a_i \\\\;\\\\ge 0\\n    \\\\quad\\\\text{(buy nonnegative number of cards)}\\n  \\\\]\\n  \\n  and\\n  \\\\[\\n    t\\\\cdot x \\\\;-\\\\;\\\\sum_i a_i \\\\;\\\\le k\\n    \\\\quad\\\\text{(we cannot spend more than \\\\(k\\\\) coins).}\\n  \\\\]\\n\\n- Finally \\\\(x\\\\le n\\\\).\\n\\nThus for a fixed \\\\(x\\\\in[1,n]\\\\) define\\n\\n\\\\[\\n  \\\\mathrm{SA} = \\\\sum_{i=1}^n a_i,\\n  \\\\quad\\n  M = \\\\max_{i=1}^n a_i.\\n\\\\]\\n\\nWe need an integer \\\\(t\\\\) satisfying\\n\\n1. \\\\(t\\\\ge M\\\\),\\n2. \\\\(t\\\\,x \\\\ge \\\\mathrm{SA}\\\\),\\n3. \\\\(t\\\\,x \\\\le \\\\mathrm{SA} + k\\\\).\\n\\nThat is,\\n\\n\\\\[\\n  t \\\\;\\\\ge\\\\; \\\\max\\\\!\\\\bigl(M,\\\\;\\\\lceil \\\\tfrac{\\\\mathrm{SA}}{x}\\\\rceil \\\\bigr),\\n  \\\\quad\\n  t \\\\;\\\\le\\\\; \\\\Bigl\\\\lfloor \\\\tfrac{\\\\mathrm{SA}+k}{x}\\\\Bigr\\\\rfloor.\\n\\\\]\\n\\nIf there is any integer \\\\(t\\\\) in that range, then deck‐size \\\\(x\\\\) is _achievable_; otherwise it is not.\\n\\nSince \\\\(x\\\\le n\\\\le 2\\\\cdot10^5\\\\), we can binary‐search on \\\\(x\\\\) in \\\\([1,n]\\\\).  For each candidate \\\\(x\\\\) we compute\\n\\n- \\\\(\\\\mathrm{low}_t = \\\\max\\\\bigl(M,\\\\;\\\\lceil\\\\mathrm{SA}/x\\\\rceil\\\\bigr)\\\\),\\n- \\\\(\\\\mathrm{high}_t = \\\\lfloor(\\\\mathrm{SA}+k)/x\\\\rfloor\\\\).\\n\\nIf \\\\(\\\\mathrm{low}_t\\\\le \\\\mathrm{high}_t\\\\), then \\\\(x\\\\) is feasible; otherwise it is not.  We pick the maximum feasible \\\\(x\\\\).  Each feasibility check is \\\\(O(1)\\\\), so the total per test is \\\\(O(n + \\\\log n)\\\\), and over all tests still fits well within the limits.\\n\\n---\\n\\n**Implementation in Java**\\n\\n```java\\nimport java.io.*;\\nimport java.util.*;\\n\\npublic class Main {\\n    public static void main(String[] args) throws IOException {\\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\\n        StringBuilder sb = new StringBuilder();\\n        \\n        int t = Integer.parseInt(in.readLine().trim());\\n        while (t-- > 0) {\\n            StringTokenizer st = new StringTokenizer(in.readLine());\\n            int n = Integer.parseInt(st.nextToken());\\n            long k = Long.parseLong(st.nextToken());\\n            \\n            long[] a = new long[n];\\n            st = new StringTokenizer(in.readLine());\\n            long sumA = 0, maxA = 0;\\n            for (int i = 0; i < n; i++) {\\n                a[i] = Long.parseLong(st.nextToken());\\n                sumA += a[i];\\n                if (a[i] > maxA) {\\n                    maxA = a[i];\\n                }\\n            }\\n            \\n            // Binary search for the largest deck-size x in [1..n]\\n            int lo = 1, hi = n;\\n            while (lo < hi) {\\n                int mid = (lo + hi + 1) >>> 1;  // upper middle\\n                if (can(mid, sumA, maxA, k)) {\\n                    lo = mid;\\n                } else {\\n                    hi = mid - 1;\\n                }\\n            }\\n            \\n            sb.append(lo).append('\\\\n');\\n        }\\n        \\n        System.out.print(sb);\\n    }\\n    \\n    /**\\n     * Check if deck-size x is feasible.\\n     * We need an integer t such that:\\n     *   t >= maxA\\n     *   t >= ceil(sumA / x)\\n     *   t <= floor((sumA + k) / x)\\n     */\\n    static boolean can(int x, long sumA, long maxA, long k) {\\n        // minimal t we require\\n        long need1 = maxA;\\n        long need2 = (sumA + x - 1) / x;   // ceil(sumA / x)\\n        long lowT = Math.max(need1, need2);\\n        // maximal t allowed by our budget\\n        long highT = (sumA + k) / x;\\n        return lowT <= highT;\\n    }\\n}\\n```\\n\\n**Explanation of Key Steps**\\n\\n1. **Reading Input**  \\n   We read the number of test cases \\\\(t\\\\).  For each test we read:\\n   - \\\\(n\\\\), the number of card‐types.\\n   - \\\\(k\\\\), the maximum number of cards we may buy.\\n   - An array \\\\(a_1,\\\\dots,a_n\\\\) giving the current counts of each type.\\n\\n2. **Precompute \\\\(\\\\mathrm{sumA}\\\\), \\\\(\\\\mathrm{maxA}\\\\)**  \\n   We compute\\n   \\\\[\\n     \\\\mathrm{sumA} = \\\\sum_i a_i,\\\\quad\\n     \\\\mathrm{maxA} = \\\\max_i a_i.\\n   \\\\]\\n\\n3. **Binary‐Search over \\\\(x\\\\in[1,n]\\\\)**  \\n   We want the maximum deck‐size \\\\(x\\\\).  For each trial \\\\(x\\\\) we check feasibility in \\\\(O(1)\\\\) by seeing if there exists\\n   \\\\[\\n     t \\\\;\\\\in\\\\; \\\\Bigl[\\\\max\\\\!\\\\bigl(\\\\maxA,\\\\lceil\\\\mathrm{sumA}/x\\\\rceil\\\\bigr)\\\\,,\\\\;\\n                       \\\\bigl\\\\lfloor(\\\\mathrm{sumA}+k)/x\\\\bigr\\\\rfloor\\\\Bigr].\\n   \\\\]\\n   If that interval is nonempty, \\\\(x\\\\) is feasible, otherwise it is not.\\n\\n4. **Why This Works**  \\n   - We must have exactly \\\\(t\\\\) decks, each of size \\\\(x\\\\), so total cards \\\\(\\\\sum b_i = t\\\\,x\\\\).  \\n   - We cannot exceed \\\\(k\\\\) purchases, so \\\\(t\\\\,x - \\\\mathrm{sumA} \\\\le k\\\\).  \\n   - Also no deck may contain two cards of the same type, and we must use _all_ cards we own (we cannot discard).  Hence for each type \\\\(i\\\\) with final count \\\\(b_i\\\\ge a_i\\\\), we need \\\\(b_i \\\\le t\\\\).  In particular \\\\(a_i \\\\le t\\\\) for each \\\\(i\\\\), so \\\\(t\\\\ge\\\\maxA\\\\).  \\n   - Finally, to use all original cards we must have \\\\(t\\\\,x\\\\ge \\\\mathrm{sumA}\\\\).  \\n\\nThat leads precisely to the two‐sided bound on \\\\(t\\\\).  Binary‐search on \\\\(x\\\\) is efficient because \\\\(n\\\\le2\\\\cdot10^5\\\\) and the sum of all \\\\(n\\\\)'s over all tests is also \\\\(\\\\le2\\\\cdot10^5\\\\).\\n\\nThis solves the problem in \\\\(O((\\\\sum n)\\\\log n)\\\\) time, well within the limits.\",\n        \"refusal\": null,\n        \"role\": \"assistant\",\n        \"annotations\": [],\n        \"audio\": null,\n        \"function_call\": null,\n        \"tool_calls\": null\n      },\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"protected_material_code\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"protected_material_text\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ],\n  \"created\": 1753309356,\n  \"model\": \"o4-mini-2025-04-16\",\n  \"object\": \"chat.completion\",\n  \"service_tier\": null,\n  \"system_fingerprint\": null,\n  \"usage\": {\n    \"completion_tokens\": 9862,\n    \"prompt_tokens\": 784,\n    \"total_tokens\": 10646,\n    \"completion_tokens_details\": {\n      \"accepted_prediction_tokens\": 0,\n      \"audio_tokens\": 0,\n      \"reasoning_tokens\": 7808,\n      \"rejected_prediction_tokens\": 0\n    },\n    \"prompt_tokens_details\": {\n      \"audio_tokens\": 0,\n      \"cached_tokens\": 0\n    }\n  },\n  \"prompt_filter_results\": [\n    {\n      \"prompt_index\": 0,\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"jailbreak\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ]\n}"
    }
]