[
  {
    "timestamp": "2025-07-24T05:49:14.372792",
    "role": "user",
    "content": "F1. Dyn-scripted Robot (Easy Version)\n\ntime limit per test3 seconds\n\nmemory limit per test256 megabytes\n\nThis is the easy version of the problem. The only difference is that in this version k≤n\n\n. You can make hacks only if both versions of the problem are solved.\n\n\n\nGiven a w×h\n\n rectangle on the Oxy\n\n plane, with points (0,0)\n\n at the bottom-left and (w,h)\n\n at the top-right of the rectangle.\n\n\n\nYou also have a robot initially at point (0,0)\n\n and a script s\n\n of n\n\n characters. Each character is either L, R, U, or D, which tells the robot to move left, right, up, or down respectively.\n\n\n\nThe robot can only move inside the rectangle; otherwise, it will change the script s\n\n as follows:\n\n\n\nIf it tries to move outside a vertical border, it changes all L characters to R's (and vice versa, all R's to L's).\n\nIf it tries to move outside a horizontal border, it changes all U characters to D's (and vice versa, all D's to U's).\n\nThen, it will execute the changed script starting from the character which it couldn't execute.\n\n\n\nAn example of the robot's movement process, s=\"ULULURD\"\n\nThe script s\n\n will be executed for k\n\n times continuously. All changes to the string s\n\n will be retained even when it is repeated. During this process, how many times will the robot move to the point (0,0)\n\n in total? Note that the initial position does NOT count.\n\n\n\nInput\n\nThe first line contains a single integer t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nThe first line of each test case contains four integers n\n\n, k\n\n, w\n\n, and h\n\n (1≤n,w,h≤106\n\n; 1≤k≤n\n\n).\n\n\n\nThe second line contains a single string s\n\n of size n\n\n (si∈{L,R,U,D}\n\n) — the script to be executed.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 106\n\n.\n\n\n\nOutput\n\nFor each test case, print a single integer — the number of times the robot reaches (0,0)\n\n when executing script s\n\n for k\n\n times continuously.\n\n\n\nExample\n\nInputCopy\n\n5\n\n2 2 2 2\n\nUR\n\n4 2 1 1\n\nLLDD\n\n6 3 3 1\n\nRLRRRL\n\n5 5 3 3\n\nRUURD\n\n7 5 3 4\n\nRRDLUUU\n\nOutputCopy\n\n0\n\n4\n\n3\n\n0\n\n1\n\nNote\n\nIn the first test case, the robot only moves up and right. In the end, it occupies the position (2,2)\n\n but never visits (0,0)\n\n. So the answer is 0\n\n.\n\n\n\nIn the second test case, each time executing the script the robot visits the origin twice. And since k=2\n\n, it visits the origin 2⋅2=4\n\n times overall.\n\n\n\n\n\nIn the third test case, the visualization is shown as below:\n\n\n\n\n\n\n\nUse Java."
  },
  {
    "timestamp": "2025-07-24T05:53:44.632040",
    "role": "assistant",
    "content": "**Analysis**\n\nWe have a robot moving on the integer grid inside the rectangle \\([0,w]\\times[0,h]\\), starting at the origin \\((0,0)\\).  We are given a script \\(s\\) of length \\(n\\), consisting of moves \\(L,R,U,D\\).  When the robot is about to step out of the rectangle across a vertical wall (\\(x<0\\) or \\(x>w\\)), the entire script has its horizontal moves \\(L\\leftrightarrow R\\) flipped (and the robot does *not* move on that step, it retries the same instruction in its new flipped form).  Likewise, stepping outside across a horizontal wall (\\(y<0\\) or \\(y>h\\)) causes a global flip \\(U\\leftrightarrow D\\).  All those flips persist for the remainder of the script and into subsequent repetitions.  We repeat the *possibly‐mutated* script \\(k\\) times in a row, and we wish to count how many times the robot visits \\((0,0)\\) (not counting the very start).\n\nA key observation is that reflecting the script’s moves on each wall‐hit is exactly equivalent to imagining that the robot is moving on the infinite integer line, but each time it crosses a multiple of \\(w\\) (resp. \\(h\\)) in the raw coordinate it “folds back” by a reflection.  Concretely, define the *raw cumulative* sums\n\n\\[\n  X_{\\mathrm{raw}}(t)\\;=\\;\\sum_{j=1}^t \\Delta x_j,\\quad\n  Y_{\\mathrm{raw}}(t)\\;=\\;\\sum_{j=1}^t \\Delta y_j,\n\\]\n\nwhere \\((\\Delta x_j,\\Delta y_j)\\) is \\((+1,0)\\) for an \\(R\\), \\((-1,0)\\) for an \\(L\\), \\((0,+1)\\) for a \\(U\\), \\((0,-1)\\) for a \\(D\\).  Then the *actual* position after \\(t\\) instructions is\n\n\\[\n  x(t)=\\mathrm{reflect}\\bigl(X_{\\mathrm{raw}}(t),w\\bigr),\\quad\n  y(t)=\\mathrm{reflect}\\bigl(Y_{\\mathrm{raw}}(t),h\\bigr),\n\\]\n\nwhere\n\n\\[\n  \\mathrm{reflect}(z,w)=\n    \\begin{cases}\n      z\\bmod(2w),&\\text{if }z\\bmod(2w)\\le w\\;,\\\\\n      2w-(z\\bmod(2w)),&\\text{otherwise}.\n    \\end{cases}\n\\]\n\nOne checks immediately that \\(x(t)=0\\) exactly when \\(X_{\\mathrm{raw}}(t)\\equiv 0\\pmod{2w}\\), and similarly \\(y(t)=0\\) exactly when \\(Y_{\\mathrm{raw}}(t)\\equiv 0\\pmod{2h}\\).\n\nWe repeat the script \\(k\\) times.  Let\n\\[\n  A=X_{\\mathrm{raw}}(n),\\quad B=Y_{\\mathrm{raw}}(n)\n\\]\nbe the net raw displacement of one full pass of the script.  Then after \\((r-1)\\) full runs plus the \\(i\\)th instruction of the \\(r\\)-th run, the raw sums are\n\\[\n  X_{\\mathrm{raw}}=(r-1)\\,A \\;+\\;\\bigl(\\text{prefix‐sum of }\\Delta x\\text{ up to }i\\bigr),\n\\]\nand similarly for \\(Y_{\\mathrm{raw}}\\).  We must count all pairs \\((r,i)\\), \\(1\\le r\\le k\\), \\(1\\le i\\le n\\), for which simultaneously\n\n  \\((r-1)\\,A + X_i \\equiv 0 \\pmod{2w}\\),  \n  \\((r-1)\\,B + Y_i \\equiv 0 \\pmod{2h}\\),\n\nwhere \\(X_i=\\sum_{j=1}^i\\Delta x_j\\), \\(Y_i=\\sum_{j=1}^i\\Delta y_j\\).  This reduces to solving two linear congruences in the one variable \\(r\\), then counting how many \\(r\\in[1,k]\\) satisfy them.  \n\nWe distinguish three cases according to whether \\(A\\equiv0\\pmod{2w}\\) and \\(B\\equiv0\\pmod{2h}\\):\n\n1. **Both zero mod**.  If \\(A\\equiv0\\pmod{2w}\\) *and* \\(B\\equiv0\\pmod{2h}\\), then the two congruences become\n   \\[\n     X_i\\equiv0\\pmod{2w},\\quad Y_i\\equiv0\\pmod{2h},\n   \\]\n   independently of \\(r\\).  Let \\(C\\) be the number of indices \\(i\\) in \\([1..n]\\) satisfying those.  Then *each* of the \\(k\\) runs visits the origin in exactly those \\(C\\) steps, for a total \\(C\\cdot k\\).\n\n2. **One zero, one nonzero**.  Suppose w.l.o.g. \\(A\\equiv0\\pmod{2w}\\) but \\(B\\not\\equiv0\\pmod{2h}\\).  Then the \\(x\\)-congruence forces \\(X_i\\equiv0\\pmod{2w}\\).  For those \\(i\\), one solves the *single* linear congruence\n   \\[\n     (r-1)\\,B \\;\\equiv\\; -\\,Y_i\\pmod{2h}\n   \\]\n   and counts how many of those solutions \\(r\\) lie in \\([1,k]\\).\n\n3. **Neither zero**.  Then each \\(i\\) yields two linear congruences\n   \\[\n     (r-1)A \\equiv -X_i\\pmod{2w},\\quad (r-1)B \\equiv -Y_i\\pmod{2h}.\n   \\]\n   We solve each (when solvable) to get\n   \\[\n     r \\equiv u_i\\pmod{T_x},\\quad r\\equiv v_i\\pmod{T_y},\n   \\]\n   with \\(T_x=2w/\\gcd(A,2w)\\), \\(T_y=2h/\\gcd(B,2h)\\).  Then apply the Chinese Remainder Theorem to combine these two congruences into a single\n   \\[\n     r\\equiv r_i\\pmod{\\mathrm{lcm}(T_x,T_y)},\n   \\]\n   count how many \\(r\\in[1,k]\\) lie in that arithmetic progression, and add that to the answer.\n\nBecause \\(n\\) can be up to \\(10^6\\) (over all test cases) and \\(k\\) can be as large as \\(n\\), we must do \\(\\mathcal O(n)\\) or \\(\\mathcal O(n\\log w)\\) work per test.  The above breakdown leads to a single pass over \\(i=1\\ldots n\\), each time doing \\(\\mathcal O(1)\\) arithmetic (plus a small number of \\(\\gcd\\) or \\(\\mathrm{extgcd}\\) calls done once per test).  This runs in time.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    // extended GCD: returns (g,x,y) so that a*x + b*y = g = gcd(a,b)\n    static long[] extgcd(long a, long b) {\n        if(b==0) return new long[]{a,1,0};\n        long[] r = extgcd(b, a%b);\n        long g = r[0], x = r[2], y = r[1] - (a/b)*r[2];\n        return new long[]{g, x, y};\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st;\n\n        int t = Integer.parseInt(br.readLine());\n        while(t-- > 0) {\n            st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            long k = Long.parseLong(st.nextToken());\n            long w = Long.parseLong(st.nextToken());\n            long h = Long.parseLong(st.nextToken());\n            String s = br.readLine();\n\n            // Mx = 2w, My = 2h\n            long Mx = 2*w, My = 2*h;\n\n            // Build prefix sums X[i], Y[i]\n            int[] X = new int[n], Y = new int[n];\n            long cx=0, cy=0;\n            for(int i=0; i<n; i++){\n                char c = s.charAt(i);\n                if(c=='L') cx--;\n                else if(c=='R') cx++;\n                else if(c=='U') cy++;\n                else cy--;\n                X[i] = (int)cx;\n                Y[i] = (int)cy;\n            }\n            // total displacement of one full script\n            long Araw = cx, Braw = cy;\n\n            // reduce mod Mx, My to decide periodicity\n            long A = ((Araw % Mx) + Mx) % Mx;\n            long B = ((Braw % My) + My) % My;\n\n            // gcds for the linear congruences\n            long dx = extgcd(A, Mx)[0];\n            long dy = extgcd(B, My)[0];\n\n            // We'll need A'=A/dx, Mx'=Mx/dx, and similarly for B\n            long Ax = (dx==0 ? 0 : A/dx), MxP = (dx==0 ? 1 : Mx/dx);\n            long By = (dy==0 ? 0 : B/dy), MyP = (dy==0 ? 1 : My/dy);\n\n            // see if A≡0 mod Mx, B≡0 mod My\n            boolean Azero = (A==0);\n            boolean Bzero = (B==0);\n\n            // Precompute inverses when needed\n            long invA = 0, invB = 0;\n            if(!Azero) {\n                // invert Ax mod MxP\n                long[] e = extgcd(Ax, MxP);\n                invA = ((e[1] % MxP) + MxP) % MxP;\n            }\n            if(!Bzero) {\n                long[] e = extgcd(By, MyP);\n                invB = ((e[1] % MyP) + MyP) % MyP;\n            }\n\n            long answer = 0;\n\n            if(Azero && Bzero) {\n                // both coordinates must individually hit 0 mod Mx, My\n                int cnt = 0;\n                for(int i=0; i<n; i++){\n                    long xm = ((X[i] % Mx)+Mx)%Mx;\n                    long ym = ((Y[i] % My)+My)%My;\n                    if(xm==0 && ym==0) cnt++;\n                }\n                answer = cnt * k;\n            }\n            else if(Azero) {\n                // require Xprefix ≡ 0 mod Mx, and solve the one congruence in r for Y\n                for(int i=0; i<n; i++){\n                    long xm = ((X[i] % Mx)+Mx)%Mx;\n                    if(xm!=0) continue;\n                    long ym = ((Y[i] % My)+My)%My;\n                    if(ym % dy != 0) continue;\n                    // solve (r-1)*B ≡ -Y[i] (mod My)\n                    long Rhs = (My - ym) % My;  // ≡ -ym mod My\n                    Rhs /= dy;                  // divides cleanly\n                    long r0 = (1 + (Rhs * invB) % MyP) % MyP;\n                    if(r0==0) r0 = MyP;\n                    if(r0 <= k) {\n                        answer += 1 + (k - r0)/MyP;\n                    }\n                }\n            }\n            else if(Bzero) {\n                // symmetric\n                for(int i=0; i<n; i++){\n                    long ym = ((Y[i] % My)+My)%My;\n                    if(ym!=0) continue;\n                    long xm = ((X[i] % Mx)+Mx)%Mx;\n                    if(xm % dx != 0) continue;\n                    long Rhs = (Mx - xm) % Mx;\n                    Rhs /= dx;\n                    long r0 = (1 + (Rhs * invA) % MxP) % MxP;\n                    if(r0==0) r0 = MxP;\n                    if(r0 <= k) {\n                        answer += 1 + (k - r0)/MxP;\n                    }\n                }\n            }\n            else {\n                // general case: two congruences → CRT\n                // we'll need lcm(Tx,Ty) and also an inverse to merge x->y\n                long gT = gcd(MxP, MyP);\n                long lcmT = (MxP/gT) * MyP;  // watch overflow fits in 64-bit\n                long k1 = MxP/gT, k2 = MyP/gT;\n                // invert k1 mod k2\n                long invK1 = 0;\n                {\n                    long[] e = extgcd(k1, k2);\n                    invK1 = ((e[1] % k2) + k2) % k2;\n                }\n\n                for(int i=0; i<n; i++){\n                    long xm = ((X[i] % Mx)+Mx)%Mx;\n                    if(xm % dx != 0) continue;\n                    long ym = ((Y[i] % My)+My)%My;\n                    if(ym % dy != 0) continue;\n\n                    // solve (r-1)*A ≡ -xm (mod Mx)  →  r ≡ u (mod MxP)\n                    long Rx = ((Mx - xm)%Mx)/dx;  // cleanly divisible\n                    long ux = (1 + (Rx * invA) % MxP) % MxP;\n                    if(ux==0) ux = MxP;\n\n                    // similarly for y\n                    long Ry = ((My - ym)%My)/dy;\n                    long uy = (1 + (Ry * invB) % MyP) % MyP;\n                    if(uy==0) uy = MyP;\n\n                    // now we have r≡ux (mod MxP), r≡uy (mod MyP)\n                    if((ux - uy) % gT != 0) continue;  // no CRT solution\n\n                    // CRT: r0 = ux + MxP * t,  t ≡ (uy - ux)/gT * inv(k1)  (mod k2)\n                    long diff = (uy - ux) / gT;  // integer\n                    diff %= k2; \n                    if(diff<0) diff += k2;\n                    long t0 = (diff * invK1) % k2;\n                    long r0 = ux + MxP * t0;\n                    // bring into [1..lcmT]\n                    r0 %= lcmT;\n                    if(r0<=0) r0 += lcmT;\n\n                    if(r0 <= k) {\n                        answer += 1 + (k - r0)/lcmT;\n                    }\n                }\n            }\n\n            System.out.println(answer);\n        }\n    }\n\n    // simple gcd\n    static long gcd(long a, long b) {\n        while(b!=0) {\n            long t = a%b;\n            a=b;  b=t;\n        }\n        return a;\n    }\n}\n```\n\n**Explanation of the Main Steps**\n\n1. **Unfolding the reflections**  \n   We reformulate the “flip‐on‐wall‐hit” rule by instead keeping track of a *raw* walk on the infinite line (summing \\(+1, -1\\) for \\(R/L\\) or \\(U/D\\)), and then folding it back into the segment \\([0,w]\\) (or \\([0,h]\\)) by the classic “reflect at multiples of \\(2w\\)” rule.  One checks that this exactly matches the original wall‐reflection semantics.\n\n2. **Periodic structure**  \n   Over one execution of the script, the raw \\(x\\)-sum moves by\n   \\[\n     A = \\sum_{j=1}^n \\Delta x_j,\n   \\]\n   and similarly \\(B = \\sum_{j=1}^n \\Delta y_j\\).  When we repeat the script \\(r\\) times, the *raw* sum before the \\(i\\)th instruction of the \\(r\\)th run is\n   \\[\n     (r-1)\\,A + X_i,\n   \\]\n   where \\(X_i\\) is the prefix sum up to \\(i\\).  The actual (folded) position is \\(0\\) exactly when that raw sum is \\(0\\) mod \\(2w\\).  \n\n3. **Counting visits to the origin**  \n   We need\n   \\[\n     (r-1)A + X_i\\equiv 0\\pmod{2w},\\quad\n     (r-1)B + Y_i\\equiv 0\\pmod{2h},\n   \\]\n   with \\(1\\le r\\le k\\), \\(1\\le i\\le n\\).  Each of these is a linear congruence in \\(r\\).  We handle three cases:\n   - **Both \\(A\\equiv0\\pmod{2w}\\) and \\(B\\equiv0\\pmod{2h}\\)**: then \\(X_i\\) must already be \\(0\\pmod{2w}\\) and \\(Y_i\\) must be \\(0\\pmod{2h}\\), for *every* \\(r\\).  If there are \\(C\\) indices \\(i\\) that satisfy those, the answer is simply \\(C\\cdot k\\).\n   - **One is zero** (say \\(A\\equiv0\\) but \\(B\\not\\equiv0\\)): then the \\(x\\)-condition forces which \\(i\\)'s are admissible, and for each such \\(i\\) you solve one congruence in \\(r\\) and count how many solutions lie in \\([1,k]\\).\n   - **Neither is zero**: for each \\(i\\) you get two nontrivial congruences in \\(r\\), combine them with the Chinese Remainder Theorem (CRT), and then count how many \\(r\\in[1,k]\\) lie in the resulting arithmetic progression.\n\nEach test we do one pass of length \\(n\\), do \\(\\gcd\\) or extended–GCD a small constant number of times, and so overall runs in \\(\\mathcal O(n+\\log w+\\log h)\\) per test.  Since \\(\\sum n\\le10^6\\), this easily fits within the time and memory limits."
  }
]