[
  {
    "timestamp": "2025-07-24T05:52:23.537769",
    "role": "user",
    "content": "D. Cases\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nYou're a linguist studying a mysterious ancient language. You know that\n\n\n\nIts words consist only of the first c\n\n letters of the Latin alphabet.\n\nEach word has a case which can be unambiguously determined by its last letter (different letters correspond to different cases). For example, words \"ABACABA\" and \"ABA\" (if they exist) have the same case in this language because they both have the same ending 'A', whereas \"ALICE\" and \"BOB\" have different cases. If the language does not have a case corresponding to some letter, it means that the word cannot end with this letter.\n\nThe length of each word is k\n\n or less.\n\nYou have a single text written in this language. Unfortunately, as the language is really ancient, spaces between words are missing and all letters are uppercase. You wonder what is the minimum number of cases the language can have. Can you find this out?\n\n\n\nInput\n\nEach test consists of several test cases. The first line contains a single integer t\n\n (1≤t≤10000\n\n) — the number of test cases. It is followed by descriptions of the test cases.\n\n\n\nThe first line of each test case contains three integers n\n\n, c\n\n, k\n\n (1≤k≤n≤218\n\n, 1≤c≤18\n\n) — the length of the text, the number of letters in the language, and the maximum length of the word.\n\n\n\nThe second line contains a string of n\n\n characters — the text itself. Each character is one of the first c\n\n uppercase letters of the Latin alphabet.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 218\n\n and the sum of 2c\n\n over all test cases does not exceed 218\n\n.\n\n\n\nOutput\n\nFor each test case, output a single line consisting of a single integer — the minimum number of cases in the language.\n\n\n\nExample\n\nInputCopy\n\n7\n\n5 5 1\n\nABCDE\n\n3 1 2\n\nAAA\n\n3 2 2\n\nAAB\n\n10 2 2\n\nABABABABAB\n\n4 4 4\n\nDCBA\n\n1 17 1\n\nQ\n\n9 3 2\n\nABCABCABC\n\nOutputCopy\n\n5\n\n1\n\n2\n\n1\n\n1\n\n1\n\n2\n\nNote\n\nIn the first test case, there must be five cases in the language (for each of the letters 'A', 'B', 'C', 'D', and 'E' there must be a case that has a corresponding ending).\n\n\n\nIn the fourth test case, one case with ending 'B' is sufficient.\n\nUse Java."
  },
  {
    "timestamp": "2025-07-24T05:54:46.321410",
    "role": "assistant",
    "content": "**Analysis**\n\nWe are given\n\n- A text string \\(s\\) of length \\(n\\), consisting of the first \\(c\\) letters of the Latin alphabet (so letters \\(\\mathrm{A},\\dots,\\mathrm{A}+c-1\\)).\n- In the unknown language each word has length at most \\(k\\) and ends in exactly one special \"case\" letter; different letters are different cases, and a word cannot end in a letter for which the language has no case.\n- The text is written *without* spaces, so we must chop the string \\(s\\) into blocks (words) of length \\(\\le k\\), each block ending in a letter chosen from some subset \\(S\\subseteq\\{\\text{A},\\dots\\}\\).  We want to find the smallest possible size of that subset \\(S\\).\n\nEquivalently, if we think of \\(S\\) as the set of letters that *are* valid word‐endings, then to be able to chop \\(s\\) into pieces of length \\(\\le k\\) each ending in one of the letters of \\(S\\), it is necessary and sufficient that\n\n1. **Every length‐\\(k\\) window of the text must contain at least one letter from \\(S\\).**  \n   Indeed, if you ever had \\(k\\) consecutive letters none of which is in \\(S\\), you would be forced to end a word only *after* those \\(k\\) letters (or before), and that would create a word of length \\(>k\\) or leave the string uncovered.\n2. **The very last character \\(s_{n}\\) must itself be in \\(S\\),** because the last word must end exactly at position \\(n\\).\n\nThus the problem becomes:\n\n  - We form all length‐\\(k\\) substrings (\"windows\") of \\(s\\).  Record for each window the set \\(U\\) of distinct letters that appear in that window.\n  - We want to choose a set \\(S\\) of letters so that\n    1. \\(S\\cap U\\neq\\emptyset\\) for *every* window \\(U\\).\n    2. \\(s_n\\in S\\).\n  - Among all \\(S\\) satisfying these two conditions, we want \\(\\lvert S\\rvert\\) as small as possible.\n\nThat is a classic *hitting‐set* condition: each window \\(U\\) demands \"hit\" by \\(S\\).  The universe of letters has size \\(c\\le18\\), so we can afford a \\(2^c\\)‐style DP.  Let us index letters by \\(0,1,\\dots,c-1\\).  We will represent any subset of letters by a bitmask of up to \\(c\\) bits.\n\n**Step 1.  Build the frequency table of window‐masks.**\n\n- If \\(k\\ge n\\), there are no length‐\\(k\\) windows (or you can think of it as a single window of length \\(n<k\\)), and the only requirement is that \\(s_n\\in S\\).  Hence the answer is 1.\n- Otherwise, we slide a window of length \\(k\\) over all positions \\(i=0,1,\\dots,n-k\\).  We maintain a letter‐count array `cnt[0..c-1]` and a bitmask `wmask` recording which letters have positive counts.  Each time we slide, we decrement the count of the letter leaving the window, increment the count of the letter entering, update `wmask`, and then do `g[wmask]++`.  Here `g[mask]` will count how many windows have *exactly* that letter‐set `mask`.\n\n**Step 2.  Do a subset‐sum (SOS) DP to detect which masks of letters fail to hit some window.**\n\nA mask \\(S\\) *fails* if there is *some* window whose letter‐set \\(U\\) is disjoint from \\(S\\).  Equivalently, \\(U\\subseteq \\overline S\\).  Let\n\n- `g[u]` = number of windows whose set of letters is exactly `u`.\n- We define `h[t] = sum_{s ⊆ t} g[s]`.  \n\nThen if we take `t = (allLettersMask) ^ S` (the complement of `S`), `h[t]` counts how many windows have letter‐set disjoint from `S`.  We only accept `S` if `h[complement_of_S] == 0`.\n\nThe SOS DP to compute all `h[t]` from `g` is standard and takes \\(O(c\\cdot 2^c)\\).\n\n**Step 3.  Scan all masks \\(S\\) that contain the final letter \\(s_n\\) and pick the one of minimum popcount for which `h[comp] == 0`.**\n\nBecause \\(\\sum 2^c\\le2\\cdot10^5\\) over all test cases and \\(\\sum n\\le2\\cdot10^5\\), the total cost\n\\[\n  \\sum_{\\text{tests}}\\bigl(O(n) + O(c\\,2^c)\\bigr)\n\\]\nis perfectly safe within a 2‐second limit.\n\nBelow is a complete Java implementation.\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(in.readLine().trim());\n        StringBuilder out = new StringBuilder();\n\n        while (t-- > 0) {\n            String[] line = in.readLine().split(\" \");\n            int n = Integer.parseInt(line[0]);\n            int c = Integer.parseInt(line[1]);\n            int k = Integer.parseInt(line[2]);\n            String s = in.readLine().trim();\n\n            // Convert letters to 0-based indices\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = s.charAt(i) - 'A';\n            }\n\n            // If k >= n, there are no length-k windows.\n            // We only need S to contain the last letter.\n            if (k >= n) {\n                out.append(1).append('\\n');\n                continue;\n            }\n\n            // Build g[mask] = number of windows of length k whose letter-set = mask.\n            int maxMask = 1 << c;\n            int[] g = new int[maxMask];\n\n            int[] cnt = new int[c];\n            int wmask = 0;\n            // Initialize first window [0..k-1]\n            for (int i = 0; i < k; i++) {\n                if (cnt[a[i]]++ == 0) {\n                    wmask |= (1 << a[i]);\n                }\n            }\n            g[wmask]++;\n\n            // Slide window from i=1..n-k\n            for (int i = 1; i + k - 1 < n; i++) {\n                int outLetter = a[i - 1];\n                if (--cnt[outLetter] == 0) {\n                    wmask &= ~(1 << outLetter);\n                }\n                int inLetter = a[i + k - 1];\n                if (cnt[inLetter]++ == 0) {\n                    wmask |= (1 << inLetter);\n                }\n                g[wmask]++;\n            }\n\n            // SOS DP: h[mask] = sum_{sub ⊆ mask} g[sub]\n            int[] h = Arrays.copyOf(g, maxMask);\n            for (int b = 0; b < c; b++) {\n                int bit = 1 << b;\n                for (int m = 0; m < maxMask; m++) {\n                    if ((m & bit) != 0) {\n                        h[m] += h[m ^ bit];\n                    }\n                }\n            }\n\n            int allMask = maxMask - 1;\n            int lastLetterMask = 1 << a[n - 1];\n            int ans = c;  // worst‐case we might need all c letters\n\n            // Try all S that contain the last letter\n            for (int S = 0; S < maxMask; S++) {\n                if ((S & lastLetterMask) == 0) continue;  // must include final letter\n                int comp = allMask ^ S;\n                // h[comp] > 0 means there is some window U with U ⊆ comp\n                // i.e. U ∩ S = ∅, so S fails.  We need h[comp]==0.\n                if (h[comp] == 0) {\n                    int pc = Integer.bitCount(S);\n                    if (pc < ans) {\n                        ans = pc;\n                    }\n                }\n            }\n\n            out.append(ans).append('\\n');\n        }\n\n        System.out.print(out);\n    }\n}\n```\n\n**Explanation of key steps**\n\n1.  **Sliding‐window mask construction**  \n    We maintain `cnt[letter]` = how many times `letter` appears in the current window of length `k`.  Whenever `cnt[x]` goes from 0→1 we set the bit for `x`; whenever it goes from 1→0 we clear that bit.  In `g[mask]` we count how many windows have *exactly* that mask of letters.\n\n2.  **SOS (subset‐sum) transform**  \n    We build `h[mask] = sum_{sub ⊆ mask} g[sub]`.  Then for any chosen set of cases `S`, let `comp = (~S) & ((1<<c)-1)`.  If `h[comp] > 0`, that means there was a window whose letter‐set `U` was a subset of `comp`, i.e.\\ disjoint from `S`, so `S` fails.  We keep only those `S` with `h[comp] == 0`.\n\n3.  **Minimal popcount**  \n    Among all valid `S` that also include the final letter `s[n-1]`, we take the one with smallest bit‐count.  That is the answer.\n\nThis runs in \\(O(n + c\\,2^c)\\) per test, and the constraints guarantee \\(\\sum n\\le2\\cdot10^5\\), \\(\\sum2^c\\le2\\cdot10^5\\), so we stay within time and memory limits."
  }
]