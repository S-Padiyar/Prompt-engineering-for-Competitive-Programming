**Analysis**

We want to count, over all choices of an enclosing interval \([l,r]\) and all sub‐intervals \([x,y]\) with \(l\le x\le y\le r\), how many of those \([x,y]\) have exactly as many ‘0’ ’s as ‘1’ ’s.  Equivalently:

1. We interpret each character `'1'` as \(+1\) and each `'0'` as \(-1\).
2. We form the prefix‐sum array \(P\) of length \(n+1\), with
   \[
     P[0]=0,\quad
     P[i]=P[i-1]+(\,s_i{=}\texttt{'1'}\ ?\,+1 : -1\,)\quad\text{for }1\le i\le n.
   \]
3. A substring \(s_{x}\dots s_{y}\) has equal numbers of 0’s and 1’s exactly when
   \[
     P[y]-P[x-1]=0
     \quad\Longleftrightarrow\quad
     P[y]=P[x-1].
   \]
4. We need to sum, over all balanced sub‐intervals \([x,y]\), the number of ways to choose \(l\le x\) and \(r\ge y\).  If \(y\) is fixed, then \(r\) can be any integer from \(y\) up to \(n\), i.e.\ \(n-y+1\) choices; if \(x\) is fixed, then \(l\) can be any integer from \(1\) up to \(x\), i.e.\ \(x\) choices.  Hence each balanced \([x,y]\) contributes
   \[
     x\;\times\;(n-y+1)
   \]
   to our grand total.

But every balanced \([x,y]\) corresponds to a pair of indices \(0\le i<j\le n\) with \(j=y\) and \(i=x-1\), such that \(P[i]=P[j]\).  Therefore we can group all indices \(0,1,2,\dots,n\) by their prefix‐sum value, and within each group of size \(m\) with positions
\[
  pos[0]<pos[1]<\cdots<pos[m-1],
\]
we form all pairs \((i,j)\) with \(i<j\).  Writing
\[
  A_k = pos[k]+1,\quad B_k = n - pos[k] + 1,
\]
we want
\[
  \sum_{0\le i<j<m} A_i\;B_j.
\]
A well‐known way to compute \(\sum_{i<j}A_iB_j\) in \(O(m)\) time is:

  - Maintain a running prefix‐sum \(S=0\) of the \(A_i\)’s seen so far.
  - Traverse \(j=0,1,\dots,m-1\).  Before adding the \(A_j\) into \(S\), you add \(S\times B_j\) to your answer, then add \(A_j\) into \(S\).

Doing this for every same‐prefix‐sum group and summing over all groups gives the total number of balanced sub‐intervals \([x,y]\) weighted by \(x\,(n-y+1)\).  Taking that sum modulo \(10^9+7\) is the required answer.

Since the string length \(n\) can be up to \(2\cdot10^5\) (over all test cases), we implement each test case in \(O(n\log n)\) by:

1. Building the prefix sums in \(O(n)\).
2. Storing the pairs \((P[i],i)\) for \(i=0\ldots n\) in an array of length \(n+1\).
3. Sorting that array by first key \(P[i]\), then by index \(i\).  This costs \(O(n\log n)\).
4. Scanning the sorted array to process each maximal block of equal \(P\)–values in one linear pass.

Overall this easily runs in time for \(n\le2\cdot10^5\).

---

```java
import java.io.*;
import java.util.*;

public class Main {
    static final int MOD = 1_000_000_007;

    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out);

        int t = Integer.parseInt(in.readLine());
        while (t-- > 0) {
            String s = in.readLine().trim();
            int n = s.length();

            // Build prefix sums P[0..n]
            // P[0] = 0; P[i] = P[i-1] + (1 if s.charAt(i-1)=='1' else -1)
            int[] P = new int[n+1];
            for (int i = 1; i <= n; i++) {
                P[i] = P[i-1] + (s.charAt(i-1) == '1' ? +1 : -1);
            }

            // Pair (prefixSum, index) for all i in [0..n]
            // We'll sort by prefixSum, then by index
            Pair[] arr = new Pair[n+1];
            for (int i = 0; i <= n; i++) {
                arr[i] = new Pair(P[i], i);
            }
            Arrays.sort(arr);

            // Now scan sorted array, grouping by equal prefix sums
            long answer = 0;
            int start = 0;
            while (start <= n) {
                int end = start + 1;
                while (end <= n && arr[end].sum == arr[start].sum) {
                    end++;
                }
                // We have a block arr[start..end-1] all with the same prefixSum
                // Process them in one sweep
                long sumA = 0;  // will accumulate A_i = (pos_i + 1)
                for (int k = start; k < end; k++) {
                    int idx = arr[k].index;
                    long A = idx + 1L;         // x = pos + 1
                    long B = (n - idx) + 1L;   // (n - y + 1), here y = idx
                    // Add all contributions A_i * B_j for i<j
                    answer = (answer + sumA * B) % MOD;
                    sumA = (sumA + A) % MOD;
                }
                start = end;
            }

            out.println(answer);
        }

        out.flush();
    }

    // A small helper class to store (prefix sum, index) and sort by them
    static class Pair implements Comparable<Pair> {
        int sum, index;
        Pair(int s, int i) { sum = s; index = i; }
        public int compareTo(Pair other) {
            if (this.sum != other.sum) {
                return Integer.compare(this.sum, other.sum);
            }
            return Integer.compare(this.index, other.index);
        }
    }
}
```

**Explanation of Key Steps**

1. **Prefix‐sum tagging**  
   We map `'1'→+1`, `'0'→−1` and build the running sum \(P[i]\).  
   Substrings \(s_{x}\dots s_{y}\) with equal numbers of 0’s and 1’s satisfy
   \[
     P[y] - P[x-1] = 0 \quad\Longleftrightarrow\quad P[y] = P[x-1].
   \]

2. **Counting contributions**  
   For each balanced substring \([x,y]\), any \(l\le x\) and \(r\ge y\) yields the same count towards the final answer, giving a factor of \(x\,(n - y + 1)\).  But \([x,y]\) balanced is equivalent to a pair of prefix‐sum indices
   \[
     (i,j)\quad\text{with}\quad 0\le i<j\le n,\quad P[i]=P[j]\quad\text{and}\quad x=i+1,\;y=j.
   \]

3. **Grouping by prefix‐sum**  
   We gather all indices \(0\le i\le n\) having the same \(P[i]\).  Suppose a fixed sum \(v\) occurs at indices
   \[
     pos[0]<pos[1]<\cdots<pos[m-1].
   \]
   Then every pair \(0\le a<b<m\) yields a balanced substring \([x,y]\) with \(x=pos[a]+1\), \(y=pos[b]\), contributing
   \[
     (pos[a]+1)\,\bigl(n - pos[b] + 1\bigr).
   \]
   Summing this over \(a<b\) can be done in \(O(m)\) time by a running prefix–sum trick:
   let
   \[
     A_k = pos[k]+1,\quad B_k = n - pos[k] + 1.
   \]
   As we scan \(k=0,1,\dots,m-1\), we keep a rolling sum \(\Sigma = \sum_{i<k} A_i\).  Then the contribution from pairing any earlier \(i\) with the current \(k\) is \(\Sigma \times B_k\).  

Since \(n\) can be up to \(2\times10^5\) (over all testcases), we sort the \((n+1)\) prefix‐sum/index pairs in \(O(n\log n)\), then do one linear pass to accumulate our answer in \(O(n)\).  This easily fits within time and memory limits.