**Problem Restatement**

We have \(n\) cities in a line, numbered \(1\) through \(n\). Each city \(i\) has exactly two portals, each portal is one of four colors \(\{B,G,R,Y\}\), and the two portals in the same city are guaranteed to be of different colors. You may teleport between any two cities \(i\) and \(j\) **only** if they share **at least one** portal color, and the cost of teleporting directly is \(\lvert i - j\rvert\).

We are given \(q\) queries \((x,y)\); for each query we must find the minimum cost to get from city \(x\) to city \(y\) by possibly using several teleports, or report \(-1\) if it is impossible.

Constraints summary:

- \(1 \le t \le 10^4\) total test cases.
- Over all test cases, \(\sum n \le 2\cdot10^5\) and \(\sum q \le 2\cdot10^5\).
- Each city’s portals are one of the six distinct unordered color‐pairs: BG, BR, BY, GR, GY, or RY.
- Each query gives \(1\le x,y\le n\).

---

**Solution Outline**

1. **Key Observation:**
   - If cities \(x\) and \(y\) share a color, you can teleport directly for cost \(\lvert x - y\rvert\).  
   - Otherwise, any shortest path from \(x\) to \(y\) uses exactly one *intermediate* city \(p\).  Why?  Because each city has exactly two different colors.  To “switch” from one color (from \(x\)) to another color (to reach \(y\)), you need at most one city that has exactly that pair of colors.  A longer chain of intermediate cities can always be shortcut to a single intermediate city without increasing cost, thanks to the metric \(\lvert i-j\rvert\).

2. **Intermediate City Criterion:**
   - If \(x\) has colors \(\{c_1,c_2\}\) and \(y\) has colors \(\{d_1,d_2\}\), then a useful intermediate city must have one color in common with \(x\) (say \(c_i\)) and one color in common with \(y\) (say \(d_j\)), \(c_i\neq d_j\).  
   - That intermediate city \(p\) is exactly one that has the unordered pair of colors \(\{c_i,d_j\}\).  
   - The total cost via \(p\) is \(\lvert x-p\rvert+\lvert p-y\rvert\).

3. **Preprocessing:**
   - There are only six unordered color‐pairs: BG, BR, BY, GR, GY, RY.  
   - For each of these six pairs we build (and sort) a list of all city‐indices which have exactly that pair of colors.  

4. **Answering a Query \((x,y)\):**
   - If \(x=y\), answer \(0\).  
   - If cities \(x\) and \(y\) share a color, answer \(\lvert x-y\rvert\).  
   - Otherwise, let \(\ell=\min(x,y)\) and \(r=\max(x,y)\).  For each choice of \(c\in\{\text{colors of }x\}\) and \(d\in\{\text{colors of }y\}\) with \(c\neq d\):
     - Look up the list `positions[c,d]` (the sorted city indices having the pair \(\{c,d\}\)).  
     - Binary‐search to find the insertion point of \(\ell\).  
     - Check if there is an index in the range \([\ell,r]\) — if yes, cost \(=r-\ell\).  
     - Otherwise compare the closest city to the left of \(\ell\) and the closest to the right of \(r\), computing  
        \[
          \min\bigl[(\ell - p_{\text{left}}) + (r - p_{\text{left}})\,,\;
                  (p_{\text{right}}-\ell) + (p_{\text{right}} - r)\bigr].
        \]
   - Take the overall minimum.  If no intermediate city was found at all, output \(-1\).

Time complexity per test case:
- Building the six lists: \(O(n)\).
- Each query does \(O(1)\) color‐checks plus up to \(4\) binary searches in lists of total size \(n\) ⇒ \(O(\log n)\).
- Overall per test file: \(O\bigl(\sum n + \sum q\log n\bigr)\), which is fine for \(2\times 10^5\).

---

```java
import java.io.*;
import java.util.*;

public class Main {
    // Map each color character to an integer 0..3
    // B=0, G=1, R=2, Y=3
    static int code(char c) {
        switch(c) {
            case 'B': return 0;
            case 'G': return 1;
            case 'R': return 2;
            case 'Y': return 3;
        }
        return -1;
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        int t = Integer.parseInt(br.readLine().trim());
        
        // We'll need a quick mapping from unordered color-pair (c1,c2) to 0..5
        int[][] pairIndex = new int[4][4];
        // the six valid pairs and their assigned indices
        int[][] pairs = {
            {0,1}, // BG
            {0,2}, // BR
            {0,3}, // BY
            {1,2}, // GR
            {1,3}, // GY
            {2,3}  // RY
        };
        for(int i = 0; i < 6; i++) {
            int a = pairs[i][0], b = pairs[i][1];
            pairIndex[a][b] = pairIndex[b][a] = i;
        }
        
        StringBuilder out = new StringBuilder();
        while(t-- > 0) {
            st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            int q = Integer.parseInt(st.nextToken());
            
            // Read the portal-pairs for each city
            String[] cityPortals = br.readLine().split(" ");
            // For each of the 6 unordered pairs, collect the city-indices that have exactly that pair
            List<Integer>[] pos = new ArrayList[6];
            for(int i = 0; i < 6; i++) pos[i] = new ArrayList<>();
            
            // Also store the two color-codes for each city
            int[][] cityCols = new int[n][2];
            
            for(int i = 0; i < n; i++) {
                char c1 = cityPortals[i].charAt(0);
                char c2 = cityPortals[i].charAt(1);
                int x1 = code(c1), x2 = code(c2);
                cityCols[i][0] = x1;
                cityCols[i][1] = x2;
                int idx = pairIndex[x1][x2];
                pos[idx].add(i+1);  // store 1-based city index
            }
            
            // The insertion always came in increasing order, so lists are sorted already.
            // But to be safe, we can skip an explicit sort.
            
            while(q-- > 0) {
                st = new StringTokenizer(br.readLine());
                int x = Integer.parseInt(st.nextToken());
                int y = Integer.parseInt(st.nextToken());
                
                if(x == y) {
                    out.append("0\n");
                    continue;
                }
                
                int colX1 = cityCols[x-1][0], colX2 = cityCols[x-1][1];
                int colY1 = cityCols[y-1][0], colY2 = cityCols[y-1][1];
                
                // If they share a color, direct teleport is possible
                boolean share = (colX1 == colY1 || colX1 == colY2
                              || colX2 == colY1 || colX2 == colY2);
                if(share) {
                    out.append(Math.abs(x - y)).append('\n');
                    continue;
                }
                
                int lo = Math.min(x, y), hi = Math.max(x, y);
                int ans = Integer.MAX_VALUE;
                
                // Try each combination c in {colX1,colX2}, d in {colY1,colY2}, c!=d
                int[] pickX = {colX1, colX2};
                int[] pickY = {colY1, colY2};
                
                for(int cx : pickX) {
                    for(int cy : pickY) {
                        if(cx == cy) continue; // can't happen anyway
                        int pi = pairIndex[cx][cy];
                        List<Integer> list = pos[pi];
                        if(list.isEmpty()) continue;
                        
                        // Binary search for the first index >= lo
                        int idx = Collections.binarySearch(list, lo);
                        if(idx < 0) idx = -idx - 1;
                        
                        // If there's an entry in [lo, hi], cost = hi-lo
                        if(idx < list.size() && list.get(idx) <= hi) {
                            ans = Math.min(ans, hi - lo);
                        } else {
                            // Check the nearest on the left
                            if(idx > 0) {
                                int p = list.get(idx - 1);
                                int cost = (lo - p) + (hi - p);
                                ans = Math.min(ans, cost);
                            }
                            // Check the nearest on the right
                            if(idx < list.size()) {
                                int p = list.get(idx);
                                int cost = (p - lo) + (p - hi);
                                ans = Math.min(ans, cost);
                            }
                        }
                    }
                }
                
                if(ans == Integer.MAX_VALUE) ans = -1;
                out.append(ans).append('\n');
            }
        }
        
        System.out.print(out);
    }
}
```

**Explanation of Key Steps**

1. We map each of the four colors to integers 0–3 to work with arrays easily.
2. We identify the six possible unordered pairs of distinct colors, and we give each such pair a small index \(0\ldots5\).
3. As we read each city’s portal‐pair, we record its index (1‐based) into the corresponding list for that color‐pair.
4. For a query \((x,y)\):
   - If \(x=y\), cost is \(0\).
   - If they share a color, cost is \(\lvert x-y\rvert\).
   - Otherwise, any optimal route must go \(x\to p \to y\) for some city \(p\) that shares one portal color with \(x\) and the other with \(y\).  We check all 4 combinations of “one color of \(x\), one of \(y\)”.  
     - We retrieve the sorted list of cities having exactly that unordered pair of colors.
     - Binary‐search for the insertion point of \(\min(x,y)\).  
     - If a city lies in the interval \([\min(x,y),\max(x,y)]\), it yields cost \(\max(x,y)-\min(x,y)\).  
     - Otherwise, compare the closest city just left of \(\min(x,y)\) and just right of \(\max(x,y)\), computing the two‐step cost \(|x-p|+|y-p|\).  
   - Take the minimum over all four possible color‐pair lists.
5. If no valid intermediate city is found, answer \(-1\).

**Complexity Analysis**

- We read and distribute \(n\) cities into six small lists in \(O(n)\).
- Each query does at most 4 binary‐searches in lists of total size \(n\), so \(O(\log n)\) per query.  
- Total over all test cases is
  \[
    O\Bigl(\sum n + \sum q \log n\Bigr)
    \le O\bigl(2\cdot10^5 + 2\cdot10^5 \log(2\cdot10^5)\bigr),
  \]
  which easily runs under the 2-second limit.