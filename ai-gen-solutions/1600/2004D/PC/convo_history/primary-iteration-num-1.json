[
  {
    "role": "user",
    "content": "D. Colored Portals\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nThere are n\n\n cities located on a straight line. The cities are numbered from 1\n\n to n\n\n.\n\n\n\nPortals are used to move between cities. There are 4\n\n colors of portals: blue, green, red, and yellow. Each city has portals of two different colors. You can move from city i\n\n to city j\n\n if they have portals of the same color (for example, you can move between a \"blue-red\" city and a \"blue-green\" city). This movement costs |i−j|\n\n coins.\n\n\n\nYour task is to answer q\n\n independent queries: calculate the minimum cost to move from city x\n\n to city y\n\n.\n\n\n\nInput\n\nThe first line contains a single integer t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nThe first line of each test case contains two integers n\n\n and q\n\n (1≤n,q≤2⋅105\n\n) — the number of cities and the number of queries, respectively.\n\n\n\nThe second line contains n\n\n strings of the following types: BG, BR, BY, GR, GY, or RY; the i\n\n-th of them describes the portals located in the i\n\n-th city; the symbol B indicates that there is a blue portal in the city, G — green, R — red, and Y — yellow.\n\n\n\nThe j\n\n-th of the next q\n\n lines contains two integers xj\n\n and yj\n\n (1≤xj,yj≤n\n\n) — the description of the j\n\n-th query.\n\n\n\nAdditional constraints on the input:\n\n\n\nthe sum of n\n\n over all test cases does not exceed 2⋅105\n\n;\n\nthe sum of q\n\n over all test cases does not exceed 2⋅105\n\n.\n\nOutput\n\nFor each query, print a single integer — the minimum cost to move from city x\n\n to city y\n\n (or −1\n\n if it is impossible).\n\n\n\nExample\n\nInputCopy\n\n2\n\n4 5\n\nBR BR GY GR\n\n1 2\n\n3 1\n\n4 4\n\n1 4\n\n4 2\n\n2 1\n\nBG RY\n\n1 2\n\nOutputCopy\n\n1\n\n4\n\n0\n\n3\n\n2\n\n-1\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have \\(n\\) cities on a line (numbered \\(1\\) through \\(n\\)), each city equipped with exactly two different-colored portals chosen from \\(\\{\\text{B},\\text{G},\\text{R},\\text{Y}\\}\\).  A move is allowed between city \\(i\\) and city \\(j\\) if they share at least one portal color, at cost \\(\\lvert i-j\\rvert\\).  We must answer \\(q\\) queries, each asking for the minimum cost to move from city \\(x\\) to city \\(y\\) (or \\(-1\\) if impossible).\n\nA direct graph approach would have potentially \\(\\mathcal O(n^2)\\) edges (since within each color the cities form a clique), which is too large for \\(n\\) up to \\(2\\times10^5\\).  Instead we exploit the fact that there are only 4 colors \\(\\{\\text{B},\\text{G},\\text{R},\\text{Y}\\}\\), hence only \\(\\binom{4}{2}=6\\) distinct pairs of colors.  Each city belongs to exactly one of those 6 pairs. \n\nLet us label the colors by integers:\n\\[\n\\text{B}\\mapsto 0,\\quad\n\\text{G}\\mapsto 1,\\quad\n\\text{R}\\mapsto 2,\\quad\n\\text{Y}\\mapsto 3.\n\\]\nThere are \\(\\{0,1\\},\\{0,2\\},\\{0,3\\},\\{1,2\\},\\{1,3\\},\\{2,3\\}\\) as the six possible unordered pairs.  We maintain, for each pair \\(p\\), a sorted list of all city‐indices whose portal‐pair is exactly \\(p\\).\n\nTo answer a query \\((x,y)\\):\n\n1.  **Direct check.**  If cities \\(x\\) and \\(y\\) share a portal color, we can go straight at cost \\(\\lvert x-y\\rvert\\).\n\n2.  **Two‐step via a city that “bridges” one color of \\(x\\) with one color of \\(y\\).**  \n    - City \\(x\\) has two colors \\(c_1,c_2\\).  \n    - City \\(y\\) has two colors \\(d_1,d_2\\).  \n    - If we do not have a direct move, we try all four cross‐pairs \\((c_i,d_j)\\), \\(i,j\\in\\{1,2\\}\\), with \\(c_i\\neq d_j\\).  \n    - For each such unordered color‐pair \\(p=\\{c_i,d_j\\}\\), let \\(S_p\\) be the sorted list of city‐indices of that pair.  \n      We look for a position \\(k\\in S_p\\) minimizing\n      \\[\n         |x-k| + |k-y|.\n      \\]\n      By sorting \\(x\\le y\\), one shows that the minimum comes from one of at most three candidates:\n      - any \\(k\\in S_p\\cap [x,y]\\), which gives cost \\(y-x\\), or\n      - the largest \\(k\\le x\\) in \\(S_p\\), giving cost \\((x-k)+(y-k)=x+y-2k\\), or\n      - the smallest \\(k\\ge y\\) in \\(S_p\\), giving cost \\((k-x)+(k-y)=2k-x-y\\).\n\n   Each of these can be found by one binary‐search (lower bound) in the list \\(S_p\\).  Since there are at most 4 cross‐pairs we check, each query costs \\(O(\\log n)\\).  With up to \\(2\\times 10^5\\) queries total, this is efficient enough.\n\nOverall preprocessing is \\(O(n)\\) per test to build and store the 6 lists of city‐indices, and each query is \\(O(\\log n)\\).  Across all tests the sum of \\(n\\) and of \\(q\\) is at most \\(2\\times10^5\\), so this passes easily in time.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int INF = 1_000_000_000;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        // Map unordered color-pairs to IDs 0..5\n        int[][] pairID = new int[4][4];\n        for (int i = 0; i < 4; i++)\n            Arrays.fill(pairID[i], -1);\n        int id = 0;\n        int[][] pairs = {{0,1},{0,2},{0,3},{1,2},{1,3},{2,3}};\n        for (int i = 0; i < 6; i++) {\n            int c1 = pairs[i][0], c2 = pairs[i][1];\n            pairID[c1][c2] = pairID[c2][c1] = i;\n        }\n\n        // Read number of testcases\n        int t = Integer.parseInt(br.readLine().trim());\n        while (t-- > 0) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int q = Integer.parseInt(st.nextToken());\n\n            // For each of the 6 color-pairs, store a sorted list of city-indices\n            List<Integer>[] pos = new ArrayList[6];\n            for (int i = 0; i < 6; i++) {\n                pos[i] = new ArrayList<>();\n            }\n\n            // Record each city's two colors\n            int[] c1 = new int[n+1], c2 = new int[n+1];\n\n            // Read the n portal-strings\n            st = new StringTokenizer(br.readLine());\n            for (int i = 1; i <= n; i++) {\n                String s = st.nextToken();\n                int colA = charToColor(s.charAt(0));\n                int colB = charToColor(s.charAt(1));\n                c1[i] = colA;\n                c2[i] = colB;\n                int pid = pairID[colA][colB];\n                pos[pid].add(i);\n            }\n\n            // The lists are filled in increasing order of i, so they are already sorted.\n\n            // Process queries\n            while (q-- > 0) {\n                st = new StringTokenizer(br.readLine());\n                int x = Integer.parseInt(st.nextToken());\n                int y = Integer.parseInt(st.nextToken());\n\n                // Gather colors of x and y\n                int ax = c1[x], bx = c2[x];\n                int ay = c1[y], by = c2[y];\n\n                int best = INF;\n\n                // 1) Direct move if they share a color\n                if (ax == ay || ax == by || bx == ay || bx == by) {\n                    best = Math.abs(x - y);\n                }\n\n                // 2) Two-step via a city that bridges one color of x to one color of y\n                // We will normalize so x <= y\n                if (x > y) {\n                    int tmp = x; x = y; y = tmp;\n                    // swap the color pairs of x,y too\n                    tmp = ax; ax = ay; ay = tmp;\n                    tmp = bx; bx = by; by = tmp;\n                }\n\n                // Try all 4 cross-pairs (c in {ax,bx}, d in {ay,by}) with c!=d\n                int[] xcols = {ax, bx};\n                int[] ycols = {ay, by};\n\n                for (int cx : xcols) {\n                    for (int cy : ycols) {\n                        if (cx == cy) continue;  // would be direct, already handled\n                        int pid = pairID[cx][cy];\n                        List<Integer> list = pos[pid];\n                        if (list.isEmpty()) continue;\n\n                        // lowerBound for x\n                        int idx = lowerBound(list, x);\n                        // 2a) If there's an element in [x, y], cost = y-x\n                        if (idx < list.size() && list.get(idx) <= y) {\n                            best = Math.min(best, y - x);\n                        } else {\n                            // 2b) Predecessor <= x\n                            if (idx > 0) {\n                                int k = list.get(idx - 1);\n                                int cost = (x - k) + (y - k); // = x+y -2k\n                                best = Math.min(best, cost);\n                            }\n                            // 2c) Successor >= y (if idx < size, and list.get(idx)>y or idx==size)\n                            if (idx < list.size()) {\n                                int k = list.get(idx);\n                                int cost = (k - x) + (k - y); // = 2k - x - y\n                                best = Math.min(best, cost);\n                            }\n                        }\n                    }\n                }\n\n                out.println((best == INF) ? -1 : best);\n            }\n        }\n\n        out.flush();\n        out.close();\n    }\n\n    // Map portal letter to integer 0..3\n    static int charToColor(char c) {\n        switch (c) {\n            case 'B': return 0;\n            case 'G': return 1;\n            case 'R': return 2;\n            case 'Y': return 3;\n        }\n        return -1;\n    }\n\n    // Classic lower_bound in an ArrayList<Integer>\n    static int lowerBound(List<Integer> list, int key) {\n        int lo = 0, hi = list.size();\n        while (lo < hi) {\n            int mid = (lo + hi) >>> 1;\n            if (list.get(mid) < key) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n        return lo;\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Color‐Pair Indexing**  \n   We only have 4 colors, so there are \\(\\binom{4}{2}=6\\) distinct unordered pairs.  We assign each pair an ID from 0 to 5, and for each city we parse its two‐letter code (e.g.\\ “BG”) into the corresponding pair‐ID.  \n\n2. **Building Position Lists**  \n   For pair‐ID \\(p\\), we keep a sorted list of all city‐indices \\(i\\) whose portals form exactly that pair.  Since we read in increasing \\(i\\), the list is automatically sorted.\n\n3. **Answering a Query**  \n   - **Direct move**: If city \\(x\\) and city \\(y\\) share a color, cost is \\(\\lvert x-y\\rvert\\).  \n   - **Two‐step bridge**: Otherwise, pick one color \\(c\\in\\{\\text{colors of }x\\}\\) and one \\(d\\in\\{\\text{colors of }y\\}\\) with \\(c\\neq d\\).  Look up the list \\(S\\) of cities whose pair is \\(\\{c,d\\}\\).  We want\n     \\[\n        \\min_{k\\in S}\\bigl(|x-k| + |k-y|\\bigr).\n     \\]\n     If \\(x\\le y\\), one shows the minimum occurs either at\n     - some \\(k\\in [x,y]\\) (giving cost \\(y-x\\)),\n     - the largest \\(k\\le x\\) in \\(S\\), or\n     - the smallest \\(k\\ge y\\) in \\(S\\).\n     We locate those by a single binary‐search (lowerBound) each time.\n\nOverall each query does a constant (\\(\\le4\\)) number of binary searches on lists of total length \\(n\\).  Thus the solution runs in \\(O((n + q)\\log n)\\) time, which is efficient for \\(n,q\\) up to \\(2\\times10^5\\)."
  }
]