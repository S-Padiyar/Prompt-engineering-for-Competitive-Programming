[
    {
        "request_timestamp": "2025-07-23T23:10:18.325221",
        "response_timestamp": "2025-07-23T23:12:55.547822",
        "sent_messages": [
            {
                "role": "user",
                "content": "Codeforces Problem:\n\nE. Range Minimum Sum\n\ntime limit per test4 seconds\n\nmemory limit per test512 megabytes\n\nFor an array [a1,a2,…,an]\n\n of length n\n\n, define f(a)\n\n as the sum of the minimum element over all subsegments. That is,\n\nf(a)=∑l=1n∑r=lnminl≤i≤rai.\n\n\n\nA permutation is a sequence of integers from 1\n\n to n\n\n of length n\n\n containing each number exactly once. You are given a permutation [a1,a2,…,an]\n\n. For each i\n\n, solve the following problem independently:\n\n\n\nErase ai\n\n from a\n\n, concatenating the remaining parts, resulting in b=[a1,a2,…,ai−1,ai+1,…,an]\n\n.\n\nCalculate f(b)\n\n.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n\n (1≤t≤105\n\n). Description of the test cases follows.\n\n\n\nThe first line of each test case contains an integer n\n\n (1≤n≤5⋅105\n\n).\n\n\n\nThe second line of each test case contains n\n\n distinct integers a1,…,an\n\n (1≤ai≤n\n\n).\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 106\n\n.\n\n\n\nOutput\n\nFor each test case, print one line containing n\n\n integers. The i\n\n-th integer should be the answer when erasing ai\n\n.\n\n\n\nExample\n\nInputCopy\n\n4\n\n1\n\n1\n\n3\n\n3 1 2\n\n5\n\n4 2 1 5 3\n\n8\n\n8 1 4 6 7 3 5 2\n\nOutputCopy\n\n0 \n\n4 7 5 \n\n19 21 27 17 19 \n\n79 100 72 68 67 80 73 80 \n\nNote\n\nIn the second test case, a=[3,1,2]\n\n.\n\n\n\nWhen removing a1\n\n, b=[1,2]\n\n. f(b)=1+2+min{1,2}=4\n\n.\n\nWhen removing a2\n\n, b=[3,2]\n\n. f(b)=3+2+min{3,2}=7\n\n.\n\nWhen removing a3\n\n, b=[3,1]\n\n. f(b)=3+1+min{3,1}=5\n\n.\n\n---\n\nYou are a competitive programming assistant solving Codeforces problems using Java. First, carefully read and restate the problem in your own words to ensure full understanding. Identify the input and output formats, list the constraints, and consider any edge cases that might affect the logic. Next, determine which algorithmic pattern the problem fits best—such as greedy, binary search, two pointers, dynamic programming, or graph traversal—and briefly explain why that pattern applies. Then, plan your solution step by step, describing the key ideas, data structures, or mathematical insights you’ll use. Once your plan is clear, write a clean and fully working Java program. Use import java.util.*; and include a Main class with a main method, using Scanner or BufferedReader for input depending on the constraints. Add comments to explain important logic in the code. After coding, walk through a sample input manually to show how your solution works in practice. Finally, analyze the time and space complexity of your approach using Big-O notation, justifying your answer. Think step by step and only write code once the logic is sound and complete."
            }
        ],
        "received_response": "{\n  \"id\": \"chatcmpl-BwgdWjhbqdACqEfdYLvzECjvL9OD1\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"**Problem Restatement**\\n\\nYou are given a permutation a of size n.  Define  \\n    f(a) = ∑_{1 ≤ l ≤ r ≤ n} min(a[l..r])  \\n\\nFor each position i (1≤i≤n), you form a new array b by removing a[i] and concatenating the two sides:\\n\\n    b = [a[1],…,a[i−1],a[i+1],…,a[n]]  \\n\\nYou must compute f(b) for each i from 1 to n.\\n\\n**Input**\\n\\nt — number of test cases, up to 10^5  \\nFor each test case:  \\n    n — size of the permutation (1≤n≤5⋅10^5, sum of n over all test cases ≤10^6)  \\n    a₁…aₙ — a permutation of 1..n\\n\\n**Output**\\n\\nFor each test case, output n integers: the i-th integer is f(b) when you remove a[i].\\n\\n---\\n\\n**Constraints & Observations**\\n\\n- n up to 5⋅10^5 per test, total ≤10^6 ⇒ we need O(n) or O(n log n) per test.\\n- We must answer all n “removal” queries for one array very fast.\\n\\nA standard fact: for any array x[1..m],\\n\\n    f(x) = ∑_{j=1..m} x[j] ⋅ (# of subarrays for which x[j] is the minimum).  \\n\\nOne can compute, in O(m), for each j its “previous smaller” index PL[j] and “next smaller” index NL[j], and then\\n\\n    count_j = (j−PL[j]) ⋅ (NL[j]−j)  \\n    f(x) = ∑ x[j]⋅count_j.  \\n\\nBut here we remove one element and want to re-compute f on the size-(n−1) array.  Naively re-computing all PL/NL for each removal is too slow.\\n\\n---\\n\\n**Key Idea (Difference-of-prefixes derivation)**\\n\\nIt turns out that if you look at the original array a[1..n], and define\\n\\n  Sᵢ = Sum of min(a[l..r]) over all subsegments [l..r] **that cover** position i \\n\\nthen one can prove (by a careful double‐sum reorganization) that\\n\\n  answer[i] = f(b) = f(a) − Sᵢ.  \\n\\nMoreover Sᵢ itself can be computed for all i in O(n) by observing that\\n\\n  Sᵢ = \\n    ∑_{j≥i} a[j]·(NL[j]−j)·max(0, i−PL[j])  \\n   +∑_{j≤i} a[j]·(j−PL[j])·max(0, NL[j]−i)\\n   −  a[i]·(i−PL[i])·(NL[i]−i).\\n\\nEach of those two big sums can in turn be handled by a simple “range‐add + prefix‐sum” trick in O(n).  \\n\\n---\\n\\n**Overall Algorithm**\\n\\nFor each test case:\\n\\n1. Read n and the permutation a[1..n].\\n2. Compute PL[ ] and NL[ ] (previous‐smaller and next‐smaller) in O(n) with a monotonic stack.\\n3. Precompute for each j:\\n     W1[j] = a[j] * (NL[j] − j)\\n     W2[j] = a[j] * (j − PL[j])\\n   and also X[j] = a[j]⋅(j−PL[j])⋅(NL[j]−j).  \\n4. Let totalF = ∑_{j=1..n} X[j]  (that is f(a)).\\n5. We want Sᵢ = termLeft[i] + termRight[i] − X[i], where\\n     termLeft[i]  = ∑_{j≥i} W1[j] * max(0, i − PL[j])\\n     termRight[i] = ∑_{j≤i} W2[j] * max(0, NL[j] − i)\\n   We build both arrays (for i=1..n) by standard difference‐array + prefix‐sum in O(n):\\n   - For termLeft, for each j we add W1[j] to indices i=PL[j]+1..j (since only there i−PL[j]>0), and also add −PL[j]*W1[j] to the same range; then termLeft[i] = i*Sum1[i] − Sum2[i].\\n   - For termRight analogous.\\n6. Then for each i:\\n      Sᵢ = termLeft[i] + termRight[i] − X[i]\\n      answer[i] = totalF − Sᵢ.\\n7. Print answer[1..n].\\n\\nThe overall complexity is O(n) per test (dominated by the two passes of stack and a handful of prefix‐sums) and O(n) memory.\\n\\n---\\n\\n**Java Implementation**\\n\\n```java\\nimport java.io.*;\\nimport java.util.*;\\n\\npublic class Main {\\n    public static void main(String[] args) throws IOException {\\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\\n        PrintWriter out = new PrintWriter(System.out);\\n\\n        int T = Integer.parseInt(in.readLine().trim());\\n        // We will re-use arrays up to total N ≤ 10^6 over all tests.\\n        // We'll allocate them lazily per test.\\n        while (T-- > 0) {\\n            int n = Integer.parseInt(in.readLine().trim());\\n            int[] a = new int[n+2];\\n            StringTokenizer st = new StringTokenizer(in.readLine());\\n            for (int i = 1; i <= n; i++) {\\n                a[i] = Integer.parseInt(st.nextToken());\\n            }\\n\\n            // 1) Compute PL[] (previous smaller) and NL[] (next smaller)\\n            int[] PL = new int[n+2], NL = new int[n+2];\\n            // values a[0] = a[n+1] = +∞ sentinel\\n            a[0] = a[n+1] = Integer.MAX_VALUE;\\n\\n            // compute PL with a stack\\n            {\\n                Deque<Integer> stk = new ArrayDeque<>();\\n                stk.push(0);\\n                for (int i = 1; i <= n; i++) {\\n                    while (a[stk.peek()] > a[i]) {\\n                        stk.pop();\\n                    }\\n                    PL[i] = stk.peek();\\n                    stk.push(i);\\n                }\\n            }\\n            // compute NL with a stack\\n            {\\n                Deque<Integer> stk = new ArrayDeque<>();\\n                stk.push(n+1);\\n                for (int i = n; i >= 1; i--) {\\n                    while (a[stk.peek()] > a[i]) {\\n                        stk.pop();\\n                    }\\n                    NL[i] = stk.peek();\\n                    stk.push(i);\\n                }\\n            }\\n\\n            // 2) Precompute W1, W2, X and totalF = sum X\\n            long[] W1 = new long[n+2], W2 = new long[n+2], X = new long[n+2];\\n            long totalF = 0;\\n            for (int j = 1; j <= n; j++) {\\n                long leftCnt = j - PL[j];\\n                long rightCnt = NL[j] - j;\\n                long xj = (long) a[j] * leftCnt * rightCnt;\\n                X[j] = xj;\\n                totalF += xj;\\n\\n                W1[j] = (long) a[j] * rightCnt;   // for termLeft\\n                W2[j] = (long) a[j] * leftCnt;    // for termRight\\n            }\\n\\n            // 3) Build termLeft and termRight by difference-arrays + prefix-sum\\n            long[] diffA = new long[n+3], diffB = new long[n+3];\\n            // termLeft[i] = i * A[i] - B[i],\\n            // where A[i] = sum of W1[j] over j>=i with PL[j]<i<=j,\\n            // and   B[i] = sum of W1[j]*PL[j] over same j-range.\\n\\n            // Range update for each j: i runs from (PL[j]+1) to j.\\n            for (int j = 1; j <= n; j++) {\\n                int L = PL[j] + 1, R = j;\\n                if (L <= R) {\\n                    diffA[L] += W1[j];\\n                    diffA[R+1] -= W1[j];\\n                    diffB[L] += W1[j] * PL[j];\\n                    diffB[R+1] -= W1[j] * PL[j];\\n                }\\n            }\\n            long[] termLeft = new long[n+2];\\n            long curA = 0, curB = 0;\\n            for (int i = 1; i <= n; i++) {\\n                curA += diffA[i];\\n                curB += diffB[i];\\n                termLeft[i] = (long)i * curA - curB;\\n            }\\n\\n            // Now build termRight similarly\\n            Arrays.fill(diffA, 0);\\n            Arrays.fill(diffB, 0);\\n            // termRight[i] = U[i] - i*V[i],\\n            // where U[i] = sum W2[j]*NL[j] over j≤i with i<NL[j],\\n            //       V[i] = sum W2[j]      over same j-range.\\n            // So each j updates i in [j..NL[j]-1].\\n            for (int j = 1; j <= n; j++) {\\n                int L = j, R = NL[j] - 1;\\n                if (L <= R) {\\n                    diffA[L] += W2[j] * NL[j];\\n                    diffA[R+1] -= W2[j] * NL[j];\\n                    diffB[L] += W2[j];\\n                    diffB[R+1] -= W2[j];\\n                }\\n            }\\n            long[] termRight = new long[n+2];\\n            curA = curB = 0;\\n            for (int i = 1; i <= n; i++) {\\n                curA += diffA[i];\\n                curB += diffB[i];\\n                termRight[i] = curA - (long)i * curB;\\n            }\\n\\n            // 4) Now for each i, S_i = termLeft[i] + termRight[i] - X[i],\\n            //    answer = totalF - S_i\\n            StringBuilder ans = new StringBuilder();\\n            for (int i = 1; i <= n; i++) {\\n                long Si = termLeft[i] + termRight[i] - X[i];\\n                long fi = totalF - Si;\\n                ans.append(fi).append(' ');\\n            }\\n            out.println(ans);\\n        }\\n        out.flush();\\n    }\\n}\\n```\\n\\n**Explanation of Key Steps**\\n\\n1. **Previous/Next Smaller**  \\n   We compute for each index j:\\n   - PL[j] = the index of the previous strictly smaller element (0 if none)\\n   - NL[j] = the index of the next strictly smaller element (n+1 if none)  \\n   This is done in two O(n) scans with a monotonic stack.\\n\\n2. **Contribution of Each Element in the Original Array**  \\n   It is well known that  \\n     f(a) = ∑_{j=1..n} a[j]⋅(j−PL[j])⋅(NL[j]−j).  \\n   We store  \\n     X[j] = a[j]⋅(j−PL[j])⋅(NL[j]−j),  \\n   so that `totalF = ∑ X[j]` in O(n).\\n\\n3. **Sum of Minimums Over Subarrays Covering i, Sᵢ**  \\n   One can reorganize the double sum for “all intervals [l..r] that cover i” by grouping according to which element j is the minimum, and count only those intervals that include i.  After some algebra one proves\\n\\n     Sᵢ =  \\n       ∑_{j≥i} a[j]·(NL[j]−j)·max(0, i−PL[j])  \\n       + ∑_{j≤i} a[j]·(j−PL[j])·max(0, NL[j]−i)  \\n       −  a[i]·(i−PL[i])·(NL[i]−i).\\n\\n   We split that into two terms (left part and right part) that both look like  \\n     A[i] = ∑ W1[j]·max(0, i−PL[j])  \\n     B[i] = ∑ W2[j]·max(0, NL[j]−i)\\n\\n   which can be computed in O(n) by doing two range-add/point-query passes (or equivalently difference array + prefix sums).\\n\\n4. **Final Answer**  \\n   Since every subarray of b either was already counted in f(a) (if it didn’t use position i) or was counted in Sᵢ for f(a) (if it did use i), one shows\\n\\n     f(b) = f(a) − Sᵢ.\\n\\n   We thus compute each answer[i] = totalF − Sᵢ in O(1) once Sᵢ is known.\\n\\n---\\n\\n**Complexity**\\n\\n- Each test: O(n) time (two monotonic‐stack passes, a few O(n) difference‐array sweeps, O(n) final loop).  \\n- Overall O(∑n) ≤ 10⁶.  \\n- Uses O(n) extra arrays per test.\",\n        \"refusal\": null,\n        \"role\": \"assistant\",\n        \"annotations\": [],\n        \"audio\": null,\n        \"function_call\": null,\n        \"tool_calls\": null\n      },\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"protected_material_code\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"protected_material_text\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ],\n  \"created\": 1753326618,\n  \"model\": \"o4-mini-2025-04-16\",\n  \"object\": \"chat.completion\",\n  \"service_tier\": null,\n  \"system_fingerprint\": null,\n  \"usage\": {\n    \"completion_tokens\": 24225,\n    \"prompt_tokens\": 726,\n    \"total_tokens\": 24951,\n    \"completion_tokens_details\": {\n      \"accepted_prediction_tokens\": 0,\n      \"audio_tokens\": 0,\n      \"reasoning_tokens\": 21248,\n      \"rejected_prediction_tokens\": 0\n    },\n    \"prompt_tokens_details\": {\n      \"audio_tokens\": 0,\n      \"cached_tokens\": 0\n    }\n  },\n  \"prompt_filter_results\": [\n    {\n      \"prompt_index\": 0,\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"jailbreak\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ]\n}"
    }
]