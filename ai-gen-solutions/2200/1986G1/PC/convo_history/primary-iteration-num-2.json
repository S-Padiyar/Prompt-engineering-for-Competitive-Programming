[
  {
    "role": "user",
    "content": "G1. Permutation Problem (Simple Version)\n\ntime limit per test3 seconds\n\nmemory limit per test128 megabytes\n\nThis is a simple version of the problem. The only difference is that in this version n≤105\n\n and the sum of n\n\n for all sets of input data does not exceed 105\n\n.\n\n\n\nYou are given a permutation p\n\n of length n\n\n. Calculate the number of index pairs 1≤i<j≤n\n\n such that pi⋅pj\n\n is divisible by i⋅j\n\n without remainder.\n\n\n\nA permutation is a sequence of n\n\n integers, where each integer from 1\n\n to n\n\n occurs exactly once. For example, [1]\n\n, [3,5,2,1,4]\n\n, [1,3,2]\n\n are permutations, while [2,3,2]\n\n, [4,3,1]\n\n, [0]\n\n are not.\n\n\n\nInput\n\nEach test consists of multiple sets of input data. The first line contains a single integer t\n\n (1≤t≤104\n\n) — the number of sets of input data. Then follows their description.\n\n\n\nThe first line of each set of input data contains a single integer n\n\n (1≤n≤105\n\n) — the length of the permutation p\n\n.\n\n\n\nThe second line of each set of input data contains n\n\n distinct integers p1,p2,…,pn\n\n (1≤pi≤n\n\n) — the permutation p\n\n.\n\n\n\nIt is guaranteed that the sum of n\n\n for all sets of input data does not exceed 105\n\n.\n\n\n\nOutput\n\nFor each set of input data, output the number of index pairs 1≤i<j≤n\n\n such that pi⋅pj\n\n is divisible by i⋅j\n\n without remainder.\n\n\n\nExample\n\nInputCopy\n\n6\n\n1\n\n1\n\n2\n\n1 2\n\n3\n\n2 3 1\n\n5\n\n2 4 1 3 5\n\n12\n\n8 9 7 12 1 10 6 3 2 4 11 5\n\n15\n\n1 2 4 6 8 10 12 14 3 9 15 5 7 11 13\n\nOutputCopy\n\n0\n\n1\n\n1\n\n3\n\n9\n\n3\n\nNote\n\nIn the first set of input data, there are no index pairs, as the size of the permutation is 1\n\n.\n\n\n\nIn the second set of input data, there is one index pair (1,2)\n\n and it is valid.\n\n\n\nIn the third set of input data, the index pair (1,2)\n\n is valid.\n\n\n\nIn the fourth set of input data, the index pairs (1,2)\n\n, (1,5)\n\n, and (2,5)\n\n are valid.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe want, for a given permutation \\(p\\) of length \\(n\\), to count the number of index–pairs \\((i,j)\\) with \\(1\\le i<j\\le n\\) such that\n\n\\[\ni\\,j \\quad\\bigm|\\quad p_i\\,p_j\n\\]\n\ni.e.\\ \\(p_i\\,p_j\\) is divisible by \\(i\\,j\\).\n\nA direct \\(O(n^2)\\) check of all pairs would be too large when \\(n\\) is up to \\(10^5\\).  Instead, one can derive a pair of elementary divisibility conditions that are both necessary and sufficient for\n\n\\[\ni\\,j \\mid p_i\\,p_j.\n\\]\n\nWe sketch the key algebraic step.  Write\n\\[\nx = i,\\quad a = p_i,\\quad y = j,\\quad b = p_j.\n\\]\nLet\n\\[\nd_1 = \\gcd(a,x), \n\\quad x_1 = \\frac{x}{d_1}, \n\\quad a_1 = \\frac{a}{d_1}.\n\\]\nThen\n\\[\ni\\,j \\mid p_i\\,p_j\n\\quad\\Longleftrightarrow\\quad\nx\\,y \\mid a\\,b\n\\quad\\Longleftrightarrow\\quad\nx_1\\,y \\mid a_1\\,b.\n\\]\nSince \\(\\gcd(x_1,a_1)=1\\), the condition \\(x_1\\,y\\mid a_1\\,b\\) is equivalent to\n\n1.  \\(x_1\\mid b\\),  and\n2.  \\(y\\mid a_1\\cdot (b/x_1)\\).\n\nFurthermore, if we set \\(g=\\gcd(a_1,y)\\) and \\(y'=y/g\\), then the second condition becomes\n\\[\ny' \\;|\\;\\frac{b}{x_1}.\n\\]\nHence the two equivalent tests for a pair \\((i,j)\\) are:\n\n 1.  \\(x_1 = i/\\gcd(i,p_i)\\) must divide \\(b = p_j\\).\n 2.  If \\(b = x_1 \\cdot k\\), then \\(k\\) must be divisible by \n     \\(\\;y' = j/\\gcd(a_1,j)\\), where \\(a_1 = p_i/d_1\\).\n\nSince \\(p\\) is a permutation of \\(\\{1,\\dots,n\\}\\), each value \\(v\\in[1,n]\\) occurs exactly once; we build an inverse array \\(\\mathrm{pos}[v]\\) so that\n\\[\n\\mathrm{pos}[v] = \\text{the unique index }j\\text{ with }p_j=v.\n\\]\n\nThen for each fixed \\(i\\) we compute\n\\[\nd_1=\\gcd(p_i,i),\\quad \nx_1=\\frac{i}{d_1},\\quad\na_1=\\frac{p_i}{d_1},\n\\]\nand we loop over all multiples of \\(x_1\\) in the range \\([1\\ldots n]\\):\n\\[\nv = x_1\\cdot k,\\quad k=1,2,\\dots,\\lfloor n/x_1\\rfloor.\n\\]\nWe look up \\(j=\\mathrm{pos}[v]\\).  If \\(j>i\\) and\n\\[\nk \\;\\bmod\\;\\Bigl(\\frac{j}{\\gcd(a_1,j)}\\Bigr)\\;=\\;0,\n\\]\nwe increment our count.  In total, each \\(i\\) contributes about \\(\\frac{n}{x_1}\\) steps, and\n\\(\\sum_{i=1}^n \\tfrac{n}{x_1}\\) runs in \\(O(n\\log n)\\), which is\nfast enough for \\(n\\le10^5\\).\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    // Fast I/O helpers\n    static BufferedReader in;\n    static StringTokenizer tok;\n\n    static String nextToken() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            String line = in.readLine();\n            if (line == null) return null;\n            tok = new StringTokenizer(line);\n        }\n        return tok.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    // Euclidean GCD\n    static int gcd(int a, int b) {\n        while (b != 0) {\n            int t = a % b;\n            a = b;\n            b = t;\n        }\n        return a;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        tok = null;\n\n        int t = nextInt();\n        StringBuilder out = new StringBuilder();\n\n        while (t-- > 0) {\n            int n = nextInt();\n            int[] p = new int[n+1];\n            for (int i = 1; i <= n; i++) {\n                p[i] = nextInt();\n            }\n\n            // Build inverse: pos[value] = index j where p[j]=value\n            int[] pos = new int[n+1];\n            for (int i = 1; i <= n; i++) {\n                pos[p[i]] = i;\n            }\n\n            long answer = 0;\n\n            // Main loop over i = 1..n\n            for (int i = 1; i <= n; i++) {\n                int a = p[i], x = i;\n                int d1 = gcd(a, x);\n                int x1 = x / d1;\n                int a1 = a / d1;\n\n                // Loop over all multiples of x1 up to n\n                for (int v = x1; v <= n; v += x1) {\n                    int j = pos[v];\n                    if (j <= i) continue;  // we only count i<j\n\n                    // v = x1 * k\n                    int k = v / x1;\n\n                    // second divisibility test\n                    int g = gcd(a1, j);\n                    int yPrime = j / g;\n                    if (k % yPrime == 0) {\n                        answer++;\n                    }\n                }\n            }\n\n            out.append(answer).append('\\n');\n        }\n\n        // Print all answers at once\n        System.out.print(out);\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1.  **Inversion array**  \n    We create an array `pos[]` of size \\(n+1\\) so that `pos[v]` tells us the unique index \\(j\\) with `p[j]=v`.  \n    This lets us quickly find, for any multiple `v = x1*k`, the corresponding index \\(j\\).\n\n2.  **The two-step divisibility check**  \n    -  We first compute  \n       \\[\n         d_1 = \\gcd(p_i,i),\\quad\n         x_1 = \\frac{i}{d_1},\\quad\n         a_1 = \\frac{p_i}{d_1}.\n       \\]\n    -  We require \\(x_1 \\mid p_j\\).  So we loop over all multiples `v = x1*k` with `v ≤ n`.  \n    -  Let that multiple satisfy `v = x1*k`; we find its index `j = pos[v]`.  \n      We must also have `j > i`.  \n    -  The remaining requirement is\n      \\[\n        k\\;\\bmod\\;\\Bigl(\\frac{j}{\\gcd(a_1,j)}\\Bigr)\\;=\\;0,\n      \\]\n      which we check in \\(O(\\log n)\\) time via one more `gcd`.\n\n3.  **Complexity**  \n    Each \\(i\\) loops over about \\(n/x_1\\) multiples, and \\(\\sum_{i=1}^n (n/x_1)\\) is \\(O(n\\log n)\\).  Since \\(n\\le10^5\\) in this “simple” version (and the total over all test cases also \\(\\le10^5\\)), this runs easily under time/memory limits."
  },
  {
    "role": "user",
    "content": "Please provide a single complete Java solution (no markdown fences or extra explanation), ready for submission."
  },
  {
    "role": "assistant",
    "content": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static BufferedReader in;\n    static StringTokenizer tok;\n\n    static String nextToken() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            String line = in.readLine();\n            if (line == null) return null;\n            tok = new StringTokenizer(line);\n        }\n        return tok.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    static int gcd(int a, int b) {\n        while (b != 0) {\n            int t = a % b;\n            a = b;\n            b = t;\n        }\n        return a;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        tok = null;\n\n        int t = nextInt();\n        StringBuilder out = new StringBuilder();\n\n        while (t-- > 0) {\n            int n = nextInt();\n            int[] p = new int[n+1];\n            for (int i = 1; i <= n; i++) {\n                p[i] = nextInt();\n            }\n\n            int[] pos = new int[n+1];\n            for (int i = 1; i <= n; i++) {\n                pos[p[i]] = i;\n            }\n\n            long answer = 0;\n            for (int i = 1; i <= n; i++) {\n                int a = p[i], x = i;\n                int d1 = gcd(a, x);\n                int x1 = x / d1;\n                int a1 = a / d1;\n\n                for (int v = x1; v <= n; v += x1) {\n                    int j = pos[v];\n                    if (j <= i) continue;\n                    int k = v / x1;\n                    int g = gcd(a1, j);\n                    int yPrime = j / g;\n                    if (k % yPrime == 0) {\n                        answer++;\n                    }\n                }\n            }\n\n            out.append(answer).append('\\n');\n        }\n\n        System.out.print(out);\n    }\n}"
  }
]