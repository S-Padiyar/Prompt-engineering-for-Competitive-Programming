**Analysis**

We have \(n\) weapon‐classes and \(m\) metal‐types.  You start with \(c_j\) ingots of metal \(j\).  For each class \(i\) you

- spend \(a_i\) ingots to **craft** a weapon of class \(i\), gaining 1 XP,
- later you may **melt** it for \(b_i\) ingots back, gaining 1 XP,
- and \(0\le b_i<a_i\), so each craft+ melt “cycle” of class \(i\) consumes net
  \[
     d_i \;=\; a_i - b_i >0
  \]
  ingots and gives 2 XP.

You can choose any class on any metal‐type repeatedly, so each metal‐type is an identical independent “pool” of ingots.  The problem is thus:

> For a single pool of size \(C\), what is the maximum
> \[
>    \underbrace{(\#\hbox{crafts} + \#\hbox{melts})}_{\rm total\ XP}
> \]
> you can get by picking an arbitrary sequence of classes to craft/melt (never melting more than you’ve crafted) and ending finally by maybe one or more “un‐melted” crafts (each such craft gives 1 XP but leaves the weapon un‐melted, spending \(a_i\) ingots, with no return)?  

A known monotonic/greedy structure shows that at each inventory level \(x\) one should pick the class \(i\) of minimal net‐cost \(d_i\) among those whose craft‐cost \(a_i\) is \(\le x\).  As you cycle that class until your inventory falls below its threshold \(a_i\), you then pick the next best (remaining) class, etc.  Finally, when no more craft+melts fit you may still do plain crafts of the class of smallest \(a_i\) to squeeze out +1 XP each.

Because \(a_i\) and \(d_i\) are up to \(10^6\), we can preprocess in \(O(\max a_i)\) (i.e.\ up to \(10^6\)):

1.  Compute for every \(x\) from \(0\) to \(\max a_i\) the quantity
   \[
     \mathit{bestDelta}[x]\;=\;\min\,\{\,a_i-b_i : a_i\le x\}\,,
   \]
   or infinity if no class has \(a_i\le x\).
2.  Read off the *breakpoints* \(p_0<p_1<\cdots<p_{K}\) where \(\mathit{bestDelta}[x]\) *changes*.  Between two consecutive breakpoints \([p_k,p_{k+1}-1]\) the best net‐cost is a constant \(\Delta_k\).  
3.  Also record \(\mathtt{amin}=\min_i a_i\).  Once our inventory \(x\) drops below \(\mathtt{amin}\), no more craft+melts are possible, so we do at most
   \[
     \left\lfloor\frac{x}{\mathtt{amin}}\right\rfloor
   \]
   final “pure‐craft” operations (each +1 XP) and stop.

To run one metal‐type of size \(C\) we

- binary‐search which segment \(k\) has \(p_k \le C< p_{k+1}\),
- let \(d\gets \Delta_k\), \(b\gets p_k\).  We can do
  \[
     t \;=\;\Big\lfloor\frac{C-b}{d}\Big\rfloor \;+\;1
  \]
  consecutive craft‐and‐melt operations of that best class, gaining \(2t\) XP and reducing \(C\) by \(t\cdot d\).  
- with the new (smaller) \(C\), re‐locate its segment \(k\) (it must drop to \(k-1\) or below), repeat until \(C<\mathtt{amin}\).
- Finally add \(\lfloor C/\mathtt{amin}\rfloor\) and we are done.

Each metal‐type costs “one binary‐search + a handful of segment‐downs,” which in practice is very fast.  We sum over all \(m\) metals in \(O\bigl(m\log(\max a_i)+\max a_i\bigr)\), easily under the limits.

Below is the complete Java solution.

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer tok = new StringTokenizer(in.readLine());
        int n = Integer.parseInt(tok.nextToken());
        int m = Integer.parseInt(tok.nextToken());

        // Read a_i
        tok = new StringTokenizer(in.readLine());
        int[] a = new int[n];
        int maxA = 0;
        for (int i = 0; i < n; i++) {
            a[i] = Integer.parseInt(tok.nextToken());
            if (a[i] > maxA) maxA = a[i];
        }

        // Read b_i and form d_i = a_i - b_i
        tok = new StringTokenizer(in.readLine());
        final int INF = 0x3f3f3f3f;
        int[] minDeltaAtA = new int[maxA + 1];
        Arrays.fill(minDeltaAtA, INF);

        int amin = maxA;
        for (int i = 0; i < n; i++) {
            int b = Integer.parseInt(tok.nextToken());
            int d = a[i] - b;
            // record the minimal d at index a[i]
            if (d < minDeltaAtA[a[i]]) {
                minDeltaAtA[a[i]] = d;
            }
            if (a[i] < amin) amin = a[i];
        }

        // Build bestDelta[x] = min net-cost of any class with a_i <= x
        int[] bestDelta = new int[maxA + 1];
        int cur = INF;
        for (int x = 0; x <= maxA; x++) {
            if (minDeltaAtA[x] < cur) {
                cur = minDeltaAtA[x];
            }
            bestDelta[x] = cur;
        }

        // Build the "breakpoints" pos[] where bestDelta changes, starting at pos[0]=amin
        // We'll have an extra pos at maxA+1 to mark the end.
        ArrayList<Integer> posList = new ArrayList<>(1000000);
        ArrayList<Integer> deltaList = new ArrayList<>(1000000);

        // We only care about x >= amin (below that no craft+melts are possible).
        int last = INF;
        for (int x = amin; x <= maxA; x++) {
            if (bestDelta[x] != last) {
                posList.add(x);
                deltaList.add(bestDelta[x]);
                last = bestDelta[x];
            }
        }
        // Finally mark the end
        posList.add(maxA + 1);
        // We will have posList.size() = #breakpoints+1, deltaList.size() = #breakpoints

        // Copy into arrays
        int S = posList.size();
        int[] pos = new int[S];
        for (int i = 0; i < S; i++) pos[i] = posList.get(i);
        int segCount = S - 1; // we have segCount segments, indexed 0..segCount-1
        int[] dseg = new int[segCount];
        for (int i = 0; i < segCount; i++) dseg[i] = deltaList.get(i);

        // Now process each metal-type c_j
        tok = new StringTokenizer(in.readLine());
        long ans = 0;

        for (int j = 0; j < m; j++) {
            long x = Long.parseLong(tok.nextToken());
            if (x < amin) {
                // Not enough for ANY craft+melts; we can only do final crafts of size 'amin'
                ans += x / amin;
                continue;
            }
            // find the segment k where pos[k] <= x < pos[k+1]
            // binary search among [0..segCount-1]
            int lo = 0, hi = segCount - 1, k = 0;
            while (lo <= hi) {
                int mid = (lo + hi) >>> 1;
                if (pos[mid] <= x) {
                    k = mid;
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }
            long xp = 0;
            // repeatedly do bulk cycles in each segment
            while (x >= amin) {
                int d = dseg[k];
                int bound = pos[k];
                // we can do t = floor((x - bound)/d) + 1 cycles of this best class
                long t = (x - bound) / d + 1;
                xp += 2L * t;
                x  -= t * d;
                // now drop to the segment that covers the new x
                // i.e. the largest index k' < k with pos[k'] <= x
                while (k > 0 && x < pos[k]) k--;
                // if x<amin we'll exit
            }
            // final crafts of size amin
            xp += x / amin;
            ans += xp;
        }

        // Print the total
        System.out.println(ans);
    }
}
```

**Explanation of the Key Steps**

1. **Compute `bestDelta[x]`**  
   We build an array `bestDelta[0..maxA]` where  
   \[
     \text{bestDelta}[x] = \min\{\,a_i - b_i : a_i \le x\},
   \]  
   or “infinity” if no class has \(a_i\le x\).  We do this in a simple prefix‐min pass in \(O(\max A)\).

2. **Extract Breakpoints**  
   As \(x\) grows from `amin` to `maxA`, `bestDelta[x]` is a nonincreasing step‐function.  We record each point `pos[k]` where it “steps” to a new smaller value `dseg[k]`.  Between `pos[k]` and `pos[k+1]-1` the best net‐cost remains `dseg[k]`.

3. **Per‐Metal Simulation**  
   For each metal‐pool of size \(C\):

   a.  If \(C<\text{amin}\), we cannot do any craft+melts, only “pure‐crafts” with cost \(\mathtt{amin}\), yielding \(\lfloor C/\mathtt{amin}\rfloor\) XP.  
   b.  Otherwise, we binary‐search the segment \(k\) so that `pos[k] ≤ C < pos[k+1]`.  We bulk‐apply as many craft+melts of that class as we can, i.e.
      \[
         t = \Bigl\lfloor\frac{C - \text{pos}[k]}{dseg[k]}\Bigr\rfloor \;+\;1,
      \]
      which gives \(2t\) XP and reduces \(C\) by \(t\,dseg[k]\).  
   c.  We repeat in the (lower) segment that covers the new \(C\), until \(C<\text{amin}\).  
   d.  Finally we do \(\lfloor C/\mathtt{amin}\rfloor\) pure‐crafts at +1 XP each.

Each metal‐type runs in \(O(\log(\max A) + \#\text{segments\_visited})\).  Empirically (and by the problem’s design) the total cost easily fits in time for \(n,m\le10^6\), \(\max a_i\le10^6\).

Memory is \(O(\max a_i)\) for the big arrays plus \(O(n+m)\) for input/output, all under the 256 MB limit.