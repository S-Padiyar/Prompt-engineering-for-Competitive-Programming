[
  {
    "timestamp": "2025-07-24T06:10:22.405508",
    "role": "user",
    "content": "The interval‐overlap sweep in `feasible()` can go out‐of‐bounds when `iEnd == cnt`. Please fix the loop to use:\n\n```\nwhile (iStart < cnt) {\n    if (iEnd == cnt || start[iStart] < end[iEnd]) {\n        // start event\n        ...\n    } else {\n        // end event\n        ...\n    }\n}\n```\n\nand then output the full corrected Java solution as one block of code ready for submission."
  },
  {
    "timestamp": "2025-07-24T06:11:16.004307",
    "role": "assistant",
    "content": "```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    // Fast input reader\n    static class FastInput {\n        BufferedInputStream in = new BufferedInputStream(System.in);\n        byte[] buf = new byte[1 << 15];\n        int len, pos;\n\n        int read() throws IOException {\n            if (len == pos) {\n                len = in.read(buf);\n                pos = 0;\n                if (len == -1) return -1;\n            }\n            return buf[pos++];\n        }\n\n        int nextInt() throws IOException {\n            int c, x = 0;\n            do {\n                c = read();\n                if (c == -1) return -1;\n            } while (c <= ' ');\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            for (; c >= '0' && c <= '9'; c = read()) {\n                x = x * 10 + (c - '0');\n            }\n            return neg ? -x : x;\n        }\n\n        long nextLong() throws IOException {\n            int c;\n            long x = 0;\n            do {\n                c = read();\n                if (c == -1) return -1;\n            } while (c <= ' ');\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            for (; c >= '0' && c <= '9'; c = read()) {\n                x = x * 10 + (c - '0');\n            }\n            return neg ? -x : x;\n        }\n    }\n\n    static int n, k;\n    static long m;\n    static long[] h, x;\n\n    // Check if with t attacks we can kill at least k enemies\n    static boolean feasible(long t) {\n        int cnt = 0;\n        int[] start = new int[n], end = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            long need = (h[i] + t - 1) / t;  // ceil(h[i]/t)\n            if (need > m) continue;          // can't kill this one\n            long w = m - need;\n            int L = (int)(x[i] - w);\n            int R = (int)(x[i] + w);\n            start[cnt] = L;\n            end[cnt]   = R + 1;  // end event at R+1\n            cnt++;\n        }\n\n        if (cnt < k) return false;\n\n        Arrays.sort(start, 0, cnt);\n        Arrays.sort(end,   0, cnt);\n\n        int iStart = 0, iEnd = 0, covered = 0;\n        // Sweep through events\n        while (iStart < cnt) {\n            if (iEnd == cnt || start[iStart] < end[iEnd]) {\n                // a new interval starts\n                covered++;\n                if (covered >= k) return true;\n                iStart++;\n            } else {\n                // an interval ends\n                covered--;\n                iEnd++;\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) throws IOException {\n        FastInput in = new FastInput();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int tcs = in.nextInt();\n        while (tcs-- > 0) {\n            n = in.nextInt();\n            m = in.nextLong();\n            k = in.nextInt();\n\n            h = new long[n];\n            x = new long[n];\n            long maxH = 0;\n            for (int i = 0; i < n; i++) {\n                h[i] = in.nextLong();\n                maxH = Math.max(maxH, h[i]);\n            }\n            for (int i = 0; i < n; i++) {\n                x[i] = in.nextLong();\n            }\n\n            // Binary search on the number of attacks\n            long left = 1, right = maxH, ans = -1;\n            while (left <= right) {\n                long mid = (left + right) >>> 1;\n                if (feasible(mid)) {\n                    ans = mid;\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n\n            out.println(ans);\n        }\n\n        out.flush();\n    }\n}\n```\n\n**Explanation of the Fix**\n\nIn the sweep‐line inside `feasible(...)`, we must ensure we do not access `end[iEnd]` once `iEnd == cnt`.  \nWe therefore first check `if (iEnd == cnt || start[iStart] < end[iEnd])` to decide whether the next event is a start or an end."
  }
]