[
  {
    "timestamp": "2025-07-24T06:01:10.163951",
    "role": "user",
    "content": "Please provide a complete, efficient Java solution in a single code block that reads t test cases, each with n and a permutation a, and for each position i outputs f(b) after removing a[i]. Your code should run in O(n log n) or better per test (total n up to 1e6), use fast I/O, and rely on monotonic stacks plus a Fenwick tree (or segment tree) to handle the required contributions. Ensure it compiles as-is."
  },
  {
    "timestamp": "2025-07-24T06:03:35.575225",
    "role": "assistant",
    "content": "Here is an O(n log n)–time Java solution using monotonic stacks to find for each i its nearest smaller to left/right, then a pair of Fenwick (BIT) structures to accumulate the contribution of all subarrays containing each position k. Remove a[k] by subtracting the sum of minima over all subarrays that include k.  \n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int T = Integer.parseInt(br.readLine().trim());\n        StringBuilder sb = new StringBuilder();\n        while (T-- > 0) {\n            int n = Integer.parseInt(br.readLine().trim());\n            int[] a = new int[n+1];\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            for (int i = 1; i <= n; i++) {\n                a[i] = Integer.parseInt(st.nextToken());\n            }\n            // 1) find for each i: l[i]=prev smaller index, r[i]=next smaller index\n            int[] l = new int[n+1], r = new int[n+1];\n            Deque<Integer> stack = new ArrayDeque<>();\n            for (int i = 1; i <= n; i++) {\n                while (!stack.isEmpty() && a[stack.peek()] > a[i]) {\n                    stack.pop();\n                }\n                l[i] = stack.isEmpty() ? 0 : stack.peek();\n                stack.push(i);\n            }\n            stack.clear();\n            for (int i = n; i >= 1; i--) {\n                while (!stack.isEmpty() && a[stack.peek()] >= a[i]) {\n                    stack.pop();\n                }\n                r[i] = stack.isEmpty() ? n+1 : stack.peek();\n                stack.push(i);\n            }\n            // 2) total sum of minima f(a)\n            long total = 0;\n            for (int i = 1; i <= n; i++) {\n                long leftCount = i - l[i];\n                long rightCount = r[i] - i;\n                total += (long)a[i] * leftCount * rightCount;\n            }\n            // 3) we will build F[k] = sum of minima of all subarrays that include k.\n            //    Then answer[k] = total - F[k].\n            //    We decompose F[k] into two linear‐in‐k range‐adds over i.\n            Fenwick bitC = new Fenwick(n+2);\n            Fenwick bitD = new Fenwick(n+2);\n            for (int i = 1; i <= n; i++) {\n                int Li = l[i] + 1;\n                int Ri = r[i] - 1;\n                // part A: ranges k in [Li .. i]\n                if (Li <= i) {\n                    // contribution = a[i] * (R_i - i + 1) * (k - (L_i-1))\n                    long coef = (long)a[i] * (Ri - i + 1);      // multiplies k\n                    long cons = - coef * (Li - 1);               // constant term\n                    // add coef*k + cons over k ∈ [Li..i]\n                    bitC.rangeAdd(Li, i, coef);\n                    bitD.rangeAdd(Li, i, cons);\n                }\n                // part B: ranges k in [i+1 .. Ri]\n                if (i + 1 <= Ri) {\n                    // contribution = a[i] * (i - L_i + 1) * ((R_i+1) - k)\n                    long coef = - (long)a[i] * (i - Li + 1);    // multiplies k\n                    long cons =  (long)a[i] * (i - Li + 1) * (Ri + 1);\n                    // add coef*k + cons over k ∈ [i+1..Ri]\n                    bitC.rangeAdd(i+1, Ri, coef);\n                    bitD.rangeAdd(i+1, Ri, cons);\n                }\n            }\n            // 4) answer for each k\n            for (int k = 1; k <= n; k++) {\n                long C = bitC.pointQuery(k);\n                long D = bitD.pointQuery(k);\n                long Fk = C * k + D;\n                long ans = total - Fk;\n                sb.append(ans).append(' ');\n            }\n            sb.append('\\n');\n        }\n        System.out.print(sb);\n    }\n\n    // Fenwick supporting range-add, point-query\n    static class Fenwick {\n        int n;\n        long[] bit;\n        Fenwick(int size) {\n            n = size;\n            bit = new long[n+1];\n        }\n        // add v to index i\n        void add(int i, long v) {\n            for (; i <= n; i += i & -i) bit[i] += v;\n        }\n        // prefix sum [1..i]\n        long sum(int i) {\n            long s = 0;\n            for (; i > 0; i -= i & -i) s += bit[i];\n            return s;\n        }\n        // range add v on [l..r]\n        void rangeAdd(int l, int r, long v) {\n            if (l > r) return;\n            add(l, v);\n            add(r+1, -v);\n        }\n        // point query at i after range-adds\n        long pointQuery(int i) {\n            return sum(i);\n        }\n    }\n}\n```\n\nExplanation of key steps:\n\n1.  We compute for each position `i` the indices `l[i] < i < r[i]` of the nearest smaller element to the left/right.  \n2.  The total `f(a)` is `Σ a[i] * (i−l[i]) * (r[i]−i)`.  \n3.  When removing element `k`, we lose exactly all subarrays that contained `k`.  Let `F[k]` be the sum of minima of those subarrays.  Then answer at `k` is `f(a) − F[k]`.  \n4.  One shows that each `a[i]` contributes to `F[k]` piecewise–linearly in `k` on two intervals `[l[i]+1..i]` and `[i+1..r[i]−1]`.  We do two range‐adds of linear functions (coefficient of `k` and constant) via two Fenwicks.  \n5.  Finally, for each `k`, `F[k] = C[k]·k + D[k]` is retrieved by point‐query, and subtracted from `f(a)`.  \n\nThis runs in O(n log n) per test, and overall O((Σ n) log n), comfortably within the given limits."
  }
]