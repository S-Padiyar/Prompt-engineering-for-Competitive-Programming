[
  {
    "role": "user",
    "content": "E. Decode\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nIn a desperate attempt to obtain your waifu favorite character, you have hacked into the source code of the game. After days of struggling, you finally find the binary string that encodes the gacha system of the game. In order to decode it, you must first solve the following problem.\n\n\n\nYou are given a binary string s\n\n of length n\n\n. For each pair of integers (l,r)\n\n (1≤l≤r≤n)\n\n, count the number of pairs (x,y)\n\n (l≤x≤y≤r)\n\n such that the amount of 0\n\n equals the amount of 1\n\n in the substring sxsx+1...sy\n\n.\n\n\n\nOutput the sum of counts over all possible (l,r)\n\n modulo 109+7\n\n.\n\n\n\nInput\n\nThe first line contains t\n\n (1≤t≤1000\n\n) — the number of test cases.\n\n\n\nEach test case contains a binary string s\n\n (1≤|s|≤2⋅105\n\n). It is guaranteed s\n\n only contains characters 0\n\n and 1\n\n.\n\n\n\nIt is guaranteed the sum of |s|\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output an integer, the answer modulo 109+7\n\n.\n\n\n\nExample\n\nInputCopy\n\n4\n\n0000\n\n01010101\n\n1100111001\n\n11000000111\n\nOutputCopy\n\n0\n\n130\n\n147\n\n70\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe want to count, over all choices of an enclosing interval \\([l,r]\\) and all sub‐intervals \\([x,y]\\) with \\(l\\le x\\le y\\le r\\), how many of those \\([x,y]\\) have exactly as many ‘0’ ’s as ‘1’ ’s.  Equivalently:\n\n1. We interpret each character `'1'` as \\(+1\\) and each `'0'` as \\(-1\\).\n2. We form the prefix‐sum array \\(P\\) of length \\(n+1\\), with\n   \\[\n     P[0]=0,\\quad\n     P[i]=P[i-1]+(\\,s_i{=}\\texttt{'1'}\\ ?\\,+1 : -1\\,)\\quad\\text{for }1\\le i\\le n.\n   \\]\n3. A substring \\(s_{x}\\dots s_{y}\\) has equal numbers of 0’s and 1’s exactly when\n   \\[\n     P[y]-P[x-1]=0\n     \\quad\\Longleftrightarrow\\quad\n     P[y]=P[x-1].\n   \\]\n4. We need to sum, over all balanced sub‐intervals \\([x,y]\\), the number of ways to choose \\(l\\le x\\) and \\(r\\ge y\\).  If \\(y\\) is fixed, then \\(r\\) can be any integer from \\(y\\) up to \\(n\\), i.e.\\ \\(n-y+1\\) choices; if \\(x\\) is fixed, then \\(l\\) can be any integer from \\(1\\) up to \\(x\\), i.e.\\ \\(x\\) choices.  Hence each balanced \\([x,y]\\) contributes\n   \\[\n     x\\;\\times\\;(n-y+1)\n   \\]\n   to our grand total.\n\nBut every balanced \\([x,y]\\) corresponds to a pair of indices \\(0\\le i<j\\le n\\) with \\(j=y\\) and \\(i=x-1\\), such that \\(P[i]=P[j]\\).  Therefore we can group all indices \\(0,1,2,\\dots,n\\) by their prefix‐sum value, and within each group of size \\(m\\) with positions\n\\[\n  pos[0]<pos[1]<\\cdots<pos[m-1],\n\\]\nwe form all pairs \\((i,j)\\) with \\(i<j\\).  Writing\n\\[\n  A_k = pos[k]+1,\\quad B_k = n - pos[k] + 1,\n\\]\nwe want\n\\[\n  \\sum_{0\\le i<j<m} A_i\\;B_j.\n\\]\nA well‐known way to compute \\(\\sum_{i<j}A_iB_j\\) in \\(O(m)\\) time is:\n\n  - Maintain a running prefix‐sum \\(S=0\\) of the \\(A_i\\)’s seen so far.\n  - Traverse \\(j=0,1,\\dots,m-1\\).  Before adding the \\(A_j\\) into \\(S\\), you add \\(S\\times B_j\\) to your answer, then add \\(A_j\\) into \\(S\\).\n\nDoing this for every same‐prefix‐sum group and summing over all groups gives the total number of balanced sub‐intervals \\([x,y]\\) weighted by \\(x\\,(n-y+1)\\).  Taking that sum modulo \\(10^9+7\\) is the required answer.\n\nSince the string length \\(n\\) can be up to \\(2\\cdot10^5\\) (over all test cases), we implement each test case in \\(O(n\\log n)\\) by:\n\n1. Building the prefix sums in \\(O(n)\\).\n2. Storing the pairs \\((P[i],i)\\) for \\(i=0\\ldots n\\) in an array of length \\(n+1\\).\n3. Sorting that array by first key \\(P[i]\\), then by index \\(i\\).  This costs \\(O(n\\log n)\\).\n4. Scanning the sorted array to process each maximal block of equal \\(P\\)–values in one linear pass.\n\nOverall this easily runs in time for \\(n\\le2\\cdot10^5\\).\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        int t = Integer.parseInt(in.readLine());\n        while (t-- > 0) {\n            String s = in.readLine().trim();\n            int n = s.length();\n\n            // Build prefix sums P[0..n]\n            // P[0] = 0; P[i] = P[i-1] + (1 if s.charAt(i-1)=='1' else -1)\n            int[] P = new int[n+1];\n            for (int i = 1; i <= n; i++) {\n                P[i] = P[i-1] + (s.charAt(i-1) == '1' ? +1 : -1);\n            }\n\n            // Pair (prefixSum, index) for all i in [0..n]\n            // We'll sort by prefixSum, then by index\n            Pair[] arr = new Pair[n+1];\n            for (int i = 0; i <= n; i++) {\n                arr[i] = new Pair(P[i], i);\n            }\n            Arrays.sort(arr);\n\n            // Now scan sorted array, grouping by equal prefix sums\n            long answer = 0;\n            int start = 0;\n            while (start <= n) {\n                int end = start + 1;\n                while (end <= n && arr[end].sum == arr[start].sum) {\n                    end++;\n                }\n                // We have a block arr[start..end-1] all with the same prefixSum\n                // Process them in one sweep\n                long sumA = 0;  // will accumulate A_i = (pos_i + 1)\n                for (int k = start; k < end; k++) {\n                    int idx = arr[k].index;\n                    long A = idx + 1L;         // x = pos + 1\n                    long B = (n - idx) + 1L;   // (n - y + 1), here y = idx\n                    // Add all contributions A_i * B_j for i<j\n                    answer = (answer + sumA * B) % MOD;\n                    sumA = (sumA + A) % MOD;\n                }\n                start = end;\n            }\n\n            out.println(answer);\n        }\n\n        out.flush();\n    }\n\n    // A small helper class to store (prefix sum, index) and sort by them\n    static class Pair implements Comparable<Pair> {\n        int sum, index;\n        Pair(int s, int i) { sum = s; index = i; }\n        public int compareTo(Pair other) {\n            if (this.sum != other.sum) {\n                return Integer.compare(this.sum, other.sum);\n            }\n            return Integer.compare(this.index, other.index);\n        }\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Prefix‐sum tagging**  \n   We map `'1'→+1`, `'0'→−1` and build the running sum \\(P[i]\\).  \n   Substrings \\(s_{x}\\dots s_{y}\\) with equal numbers of 0’s and 1’s satisfy\n   \\[\n     P[y] - P[x-1] = 0 \\quad\\Longleftrightarrow\\quad P[y] = P[x-1].\n   \\]\n\n2. **Counting contributions**  \n   For each balanced substring \\([x,y]\\), any \\(l\\le x\\) and \\(r\\ge y\\) yields the same count towards the final answer, giving a factor of \\(x\\,(n - y + 1)\\).  But \\([x,y]\\) balanced is equivalent to a pair of prefix‐sum indices\n   \\[\n     (i,j)\\quad\\text{with}\\quad 0\\le i<j\\le n,\\quad P[i]=P[j]\\quad\\text{and}\\quad x=i+1,\\;y=j.\n   \\]\n\n3. **Grouping by prefix‐sum**  \n   We gather all indices \\(0\\le i\\le n\\) having the same \\(P[i]\\).  Suppose a fixed sum \\(v\\) occurs at indices\n   \\[\n     pos[0]<pos[1]<\\cdots<pos[m-1].\n   \\]\n   Then every pair \\(0\\le a<b<m\\) yields a balanced substring \\([x,y]\\) with \\(x=pos[a]+1\\), \\(y=pos[b]\\), contributing\n   \\[\n     (pos[a]+1)\\,\\bigl(n - pos[b] + 1\\bigr).\n   \\]\n   Summing this over \\(a<b\\) can be done in \\(O(m)\\) time by a running prefix–sum trick:\n   let\n   \\[\n     A_k = pos[k]+1,\\quad B_k = n - pos[k] + 1.\n   \\]\n   As we scan \\(k=0,1,\\dots,m-1\\), we keep a rolling sum \\(\\Sigma = \\sum_{i<k} A_i\\).  Then the contribution from pairing any earlier \\(i\\) with the current \\(k\\) is \\(\\Sigma \\times B_k\\).  \n\nSince \\(n\\) can be up to \\(2\\times10^5\\) (over all testcases), we sort the \\((n+1)\\) prefix‐sum/index pairs in \\(O(n\\log n)\\), then do one linear pass to accumulate our answer in \\(O(n)\\).  This easily fits within time and memory limits."
  }
]