[
  {
    "role": "user",
    "content": "E. Prefix GCD\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nSince Mansur is tired of making legends, there will be no legends for this task.\n\n\n\nYou are given an array of positive integer numbers a1,a2,…,an\n\n. The elements of the array can be rearranged in any order. You need to find the smallest possible value of the expression\n\ngcd(a1)+gcd(a1,a2)+…+gcd(a1,a2,…,an),\n\nwhere gcd(a1,a2,…,an)\n\n denotes the greatest common divisor (GCD) of a1,a2,…,an\n\n.\n\n\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n\n (1≤t≤104\n\n). The description of the test cases follows.\n\n\n\nThe first line of each test case contains a single number n\n\n (1≤n≤105\n\n) — the size of the array.\n\n\n\nThe second line of each test case contains n\n\n numbers a1,a2,…,an\n\n (1≤ai≤105\n\n) — the initial array.\n\n\n\nThe sum of n\n\n over all test cases does not exceed 105\n\n.\n\n\n\nThe sum of max(a1,a2,…,an)\n\n over all test cases does not exceed 105\n\n.\n\n\n\nOutput\n\nFor each test case, output a single number on a separate line — the answer to the problem.\n\n\n\nExample\n\nInputCopy\n\n5\n\n3\n\n4 2 2\n\n2\n\n6 3\n\n3\n\n10 15 6\n\n5\n\n6 42 12 52 20\n\n4\n\n42 154 231 66\n\nOutputCopy\n\n6\n\n6\n\n9\n\n14\n\n51\n\nNote\n\nIn the first test case, the elements can be rearranged as follows: [2,4,2]\n\n. Then the answer will be gcd(2)+gcd(2,4)+gcd(2,4,2)=2+2+2=6\n\n.\n\n\n\nIn the third test case, the elements can be rearranged as follows: [6,10,15]\n\n. Then the answer will be gcd(6)+gcd(6,10)+gcd(6,10,15)=6+2+1=9\n\n.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe are given \\(n\\) positive integers \\(a_1,\\dots,a_n\\).  We may reorder them arbitrarily, and we want to minimize the sum\n\n\\[\n\\gcd(b_1)\n\\;+\\;\n\\gcd(b_1,b_2)\n\\;+\\;\\cdots+\\;\n\\gcd(b_1,\\dots,b_n),\n\\]\n\nwhere \\(\\{b_1,\\dots,b_n\\}\\) is a permutation of \\(\\{a_1,\\dots,a_n\\}\\).\n\nCall\n\\[\nG_k = \\gcd(b_1,b_2,\\dots,b_k).\n\\]\nObserve that\n\\[\nG_1 \\;\\ge\\; G_2\\;\\ge\\;\\cdots\\;\\ge\\;G_n,\n\\]\nsince adding another number can only keep or lower the gcd.  Hence in order to make the sum\n\\(\\sum_{k=1}^n G_k\\)\nas small as possible, we would like the gcd to drop as quickly as possible toward 1.  \n\nA simple greedy strategy works:\n\n1.  **Pick the smallest element** first, say \\(b_1 = \\min_i a_i\\).  That forces \\(G_1\\) as small as it can possibly be.\n\n2.  Maintain the current running gcd \\(g\\).  Initially \\(g = b_1\\).  \n    For step \\(k=2\\) to \\(n\\), choose among the unused \\(a_i\\) the one which makes \\(\\gcd(g, a_i)\\) as small as possible.  Call that minimum value \\(g_{\\text{next}}\\).  \n    Append that element as \\(b_k\\), set \\(g \\leftarrow g_{\\text{next}}\\), and mark that element as used.\n\n3.  Once the running gcd \\(g\\) becomes 1, all remaining prefixes will contribute 1 each, so you can add \\((n - k)\\times 1\\) to the sum in one shot and stop.\n\nBecause each step except the final run‐to‐1 scan costs \\(O(n)\\) gcd‐computations, but the gcd drops through at most the number of prime factors of the first element (which is at most about 6 or 7 for numbers up to \\(10^5\\)), the total cost is \\(O(n\\log n + n\\cdot\\text{(few)}\\times \\log A)\\).  With \\(\\sum n\\le10^5\\) and \\(A\\le10^5\\), this runs comfortably in time.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    static int gcd(int a, int b) {\n        while (b != 0) {\n            int t = b;\n            b = a % b;\n            a = t;\n        }\n        return a;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in  = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        int t = Integer.parseInt(in.readLine().trim());\n        while (t-- > 0) {\n            int n = Integer.parseInt(in.readLine().trim());\n            int[] a = new int[n];\n            tok = new StringTokenizer(in.readLine());\n            for (int i = 0; i < n; i++) {\n                a[i] = Integer.parseInt(tok.nextToken());\n            }\n\n            Arrays.sort(a);  // put the smallest element first\n\n            boolean[] used = new boolean[n];\n            long sum = 0;\n\n            // Step 1: pick the smallest as b1\n            int g = a[0];\n            sum += g;\n            used[0] = true;\n\n            // Steps 2 & 3: greedily pick next to minimize gcd\n            for (int k = 1; k < n; k++) {\n                if (g == 1) {\n                    // from now on each prefix gcd is 1\n                    sum += (n - k);\n                    break;\n                }\n                int bestG = Integer.MAX_VALUE;\n                int bestIdx = -1;\n                // scan the unused elements\n                for (int i = 1; i < n; i++) {\n                    if (used[i]) continue;\n                    int g2 = gcd(g, a[i]);\n                    if (g2 < bestG) {\n                        bestG = g2;\n                        bestIdx = i;\n                        if (bestG == 1) break;  // can't do better than 1\n                    }\n                }\n                // add that best gcd to the sum, mark used, update current gcd\n                sum += bestG;\n                g = bestG;\n                used[bestIdx] = true;\n            }\n\n            out.println(sum);\n        }\n\n        out.flush();\n    }\n}\n```\n\n**Explanation of key steps**\n\n1. We sort the array and pick the smallest element first.  This guarantees the first term of the sum, \\(\\gcd(b_1)\\), is as small as possible.\n2. We maintain the \"running gcd\" \\(g = \\gcd(b_1,\\dots,b_{k-1})\\).  To choose \\(b_k\\), we look for the unused \\(a_i\\) that makes \\(\\gcd(g,a_i)\\) **minimal**.\n3.  Since the gcd sequence \\(G_1, G_2,\\dots\\) cannot increase, once it hits 1, all remaining terms of the sum are 1 and we can add them in one batch.\n\nThis greedy scheme runs in \\(O(n\\log n)\\) for sorting plus \\(O(n\\,d\\,\\log A)\\) in the worst case (where \\(d\\) is the number of times the gcd can strictly drop, typically bounded by the number of prime divisors of the first element).  Given \\(\\sum n\\le10^5\\) and values up to \\(10^5\\), it is efficient for the problem constraints."
  }
]