[
  {
    "role": "user",
    "content": "D. Connect the Dots\n\ntime limit per test2 seconds\n\nmemory limit per test512 megabytes\n\nOne fine evening, Alice sat down to play the classic game \"Connect the Dots\", but with a twist.\n\n\n\nTo play the game, Alice draws a straight line and marks n\n\n points on it, indexed from 1\n\n to n\n\n. Initially, there are no arcs between the points, so they are all disjoint. After that, Alice performs m\n\n operations of the following type:\n\n\n\nShe picks three integers ai\n\n, di\n\n (1≤di≤10\n\n), and ki\n\n.\n\nShe selects points ai,ai+di,ai+2di,ai+3di,…,ai+ki⋅di\n\n and connects each pair of these points with arcs.\n\nAfter performing all m\n\n operations, she wants to know the number of connected components†\n\n these points form. Please help her find this number.\n\n\n\n†\n\n Two points are said to be in one connected component if there is a path between them via several (possibly zero) arcs and other points.\n\n\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n\n (1≤t≤105\n\n). The description of the test cases follows.\n\n\n\nThe first line of each test case contains two integers n\n\n and m\n\n (1≤n≤2⋅105\n\n, 1≤m≤2⋅105\n\n).\n\n\n\nThe i\n\n-th of the following m\n\n lines contains three integers ai\n\n, di\n\n, and ki\n\n (1≤ai≤ai+ki⋅di≤n\n\n, 1≤di≤10\n\n, 0≤ki≤n\n\n).\n\n\n\nIt is guaranteed that both the sum of n\n\n and the sum of m\n\n over all test cases do not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output the number of connected components.\n\n\n\nExample\n\nInputCopy\n\n3\n\n10 2\n\n1 2 4\n\n2 2 4\n\n100 1\n\n19 2 4\n\n100 3\n\n1 2 5\n\n7 2 6\n\n17 2 31\n\nOutputCopy\n\n2\n\n96\n\n61\n\nNote\n\nIn the first test case, there are n=10\n\n points. The first operation joins the points 1\n\n, 3\n\n, 5\n\n, 7\n\n, and 9\n\n. The second operation joins the points 2\n\n, 4\n\n, 6\n\n, 8\n\n, and 10\n\n. There are thus two connected components: {1,3,5,7,9}\n\n and {2,4,6,8,10}\n\n.\n\n\n\nIn the second test case, there are n=100\n\n points. The only operation joins the points 19\n\n, 21\n\n, 23\n\n, 25\n\n, and 27\n\n. Now all of them form a single connected component of size 5\n\n. The other 95\n\n points form single-point connected components. Thus, the answer is 1+95=96\n\n.\n\n\n\nIn the third test case, there are n=100\n\n points. After the operations, all odd points from 1\n\n to 79\n\n will be in one connected component of size 40\n\n. The other 60\n\n points form single-point connected components. Thus, the answer is 1+60=61\n\n.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have \\(n\\) points labelled \\(1\\ldots n\\) on a line and \\(m\\) “connect‐the‐dots” operations.  In the \\(i\\)-th operation we are given three integers\n\\[\na_i,\\; d_i,\\; k_i,\n\\]\nand we connect by arcs *each* pair of the arithmetic‐progression of points\n\\[\na_i,\\; a_i+d_i,\\; a_i+2d_i,\\;\\dots,\\;a_i+k_i\\,d_i.\n\\]\nAfter doing *all* \\(m\\) operations, we must report the number of connected components of the resulting undirected graph.\n\nA direct way to connect a clique of \\(L\\) vertices is to union each consecutive pair in the clique; that is, to perform \\(\\bigl(L-1\\bigr)\\) union‐operations in a DSU (Disjoint‐Set Union) data structure which would already guarantee the whole set is in one connected component.  However, \\(L\\) can be as large as \\(O(n)\\) in a single operation and there can be up to \\(m=O(n)\\) operations, so a naive “union every consecutive pair in each AP” can become \\(O(n^2)\\) in the worst case.\n\nThe key observation is that each operation for fixed \\((d,a,k)\\) actually lives inside one residue‐class modulo \\(d\\).  Indeed, all points in\n\\[\na,\\,a+d,\\,a+2d,\\,\\dots,a+k\\,d\n\\]\nare congruent to \\(a\\pmod d\\).  If we take all integers \\(1\\ldots n\\) that are \\(\\equiv r\\pmod d\\), they form a small “chain” (a one‐dimensional path) whose vertices are\n\\[\n\\{\\,r,\\;r+d,\\;r+2d,\\dots\\}\n\\]\nup to the largest that does not exceed \\(n\\).  What the operation does is to connect *all* of those AP‐points into a clique.  But in a path graph, the edges that suffice to make the whole subinterval connected are just *the edges between consecutive points in that subinterval*.  \n\nHence if our AP runs from index\n\\[\np_0=\\tfrac{a-r}{d},\\quad p_1=\\tfrac{a-r}{d}+1,\\dots,\\;p_k=\\tfrac{a-r}{d}+k\n\\]\ninside that residue‐class chain, we only need to union\n\\[\n\\bigl(\\,r+p_i\\,d\\,,\\,r+p_{i+1}d\\bigr)\n\\quad(0\\le i<k)\n\\]\nto link the entire block.\n\nWhat remains is to do *range‐union* of all such consecutive‐edge unions *without* explicitly walking each of the \\(k\\) steps per operation.  Since \\(d\\le10\\), there are at most\n\\[\n\\sum_{d=1}^{10} d \\;=\\;55\n\\]\ndistinct residue‐chains to worry about.  If in one chain of length \\(L\\) we have several intervals \\([p_i,p_i+k_i]\\) to connect consecutively, we simply mark those intervals in a difference array of length \\(L\\).  After we have processed *all* operations in that chain, we sweep once from left to right, form the prefix‐sum, and wherever that prefix‐sum is strictly positive we know there is at least one operation demanding the edge between positions \\(j\\) and \\(j+1\\).  We do exactly one DSU‐union for that edge.  Summing over all chains and all tests this is linear (up to the factor \\(\\sum_{d=1}^{10}(n/d)\\le n\\cdot H_{10}\\)), which is \\(O(n)\\) for each test.\n\nFinally, we use a classic DSU over the \\(n\\) points.  After we have added (via the difference‐array sweep) all the necessary “consecutive‐position” unions, the DSU partitions \\(\\{1,\\dots,n\\}\\) into its connected components.  We simply count how many DSU‐roots remain.\n\nOverall time per test is \\(O(n+m)\\), and since \\(\\sum n,\\sum m\\le2\\cdot10^5\\) globally, this easily runs in time.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class DSU {\n        int[] p, sz;\n        DSU(int n) {\n            p = new int[n+1];\n            sz = new int[n+1];\n            for(int i = 1; i <= n; i++){\n                p[i] = i;\n                sz[i] = 1;\n            }\n        }\n        int find(int x) {\n            return p[x] == x ? x : (p[x] = find(p[x]));\n        }\n        void unite(int a, int b) {\n            a = find(a);\n            b = find(b);\n            if (a == b) return;\n            // union by size\n            if (sz[a] < sz[b]) {\n                p[a] = b;\n                sz[b] += sz[a];\n            } else {\n                p[b] = a;\n                sz[a] += sz[b];\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st;\n        int t = Integer.parseInt(br.readLine().trim());\n        StringBuilder sb = new StringBuilder();\n        while (t-- > 0) {\n            st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(st.nextToken());\n\n            // Prepare DSU\n            DSU dsu = new DSU(n);\n\n            // We'll only need d up to min(10, n).\n            int maxD = Math.min(10, n);\n\n            // diff[d][r] will be the difference-array for residue-class r mod d.\n            // We first allocate each chain's array according to its length.\n            int[][][] diff = new int[maxD+1][][];\n            int[][] chainLen = new int[maxD+1][ ];\n            for(int d = 1; d <= maxD; d++){\n                diff[d] = new int[d][ ];\n                chainLen[d] = new int[d];\n                for(int r = 0; r < d; r++){\n                    // The smallest number >=1 which is congruent to r mod d:\n                    //   if r==0, that number is d; else it is r.\n                    int base = (r==0 ? d : r);\n                    if (base > n) {\n                        chainLen[d][r] = 0;\n                        diff[d][r] = new int[0];\n                    } else {\n                        int len = (n - base) / d + 1;\n                        chainLen[d][r] = len;\n                        diff[d][r] = new int[len];\n                        // initially all zero\n                    }\n                }\n            }\n\n            // Read operations, populate difference arrays\n            for(int i = 0; i < m; i++){\n                st = new StringTokenizer(br.readLine());\n                int a = Integer.parseInt(st.nextToken());\n                int d = Integer.parseInt(st.nextToken());\n                int k = Integer.parseInt(st.nextToken());\n\n                if (d > maxD) {\n                    // d>n or >10 cannot connect anything meaningful\n                    continue;\n                }\n\n                int r = a % d;\n                int base = (r == 0 ? d : r);\n                int startIdx = (a - base) / d;\n                int endIdx = startIdx + k; // inclusive for vertex indices\n\n                // We only want to connect consecutive pairs in [startIdx .. endIdx].\n                // The edges are between positions j and j+1 for j in [startIdx..endIdx-1].\n                // So we mark diff[startIdx] +=1, diff[endIdx] -=1.\n                // Later prefix-sum>0 at position j means there is an edge (j, j+1).\n                diff[d][r][startIdx]++;\n                if (endIdx < chainLen[d][r]) {\n                    diff[d][r][endIdx]--;\n                }\n            }\n\n            // Now sweep each chain, build prefix sums, and perform DSU-union on covered edges\n            for(int d = 1; d <= maxD; d++){\n                for(int r = 0; r < d; r++){\n                    int len = chainLen[d][r];\n                    if (len <= 1) continue;  // no edges in a chain of length 0 or 1\n                    int cur = 0;\n                    int base = (r == 0 ? d : r);\n                    for(int j = 0; j < len - 1; j++){\n                        cur += diff[d][r][j];\n                        if (cur > 0) {\n                            int u = base + j*d;\n                            int v = u + d;\n                            dsu.unite(u, v);\n                        }\n                    }\n                }\n            }\n\n            // Finally count how many distinct DSU-roots among 1..n\n            int comps = 0;\n            for(int i = 1; i <= n; i++){\n                if (dsu.find(i) == i) comps++;\n            }\n            sb.append(comps).append('\\n');\n        }\n\n        System.out.print(sb);\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Disjoint‐Set Union (DSU).**  \n   We keep an array `parent[]` and `size[]`.  `find(x)` finds the representative of \\(x\\), and `unite(a,b)` merges the two sets if they are different.\n\n2. **Residue‐Chains.**  \n   For each \\(d\\in[1,\\min(10,n)]\\) and residue \\(r=0,\\dots,d-1\\), the nodes congruent to \\(r\\pmod d\\) form a *chain* in ascending order:\n   \\[\n     base,\\; base+d,\\; base+2d,\\;\\dots\n   \\]\n   where \\(base=(r==0\\ ?\\ d : r)\\).  Its length is \\(L=\\lfloor (n-base)/d\\rfloor+1\\).\n\n3. **Range Marking via a Difference Array.**  \n   An operation\n   \\[\n     a,\\;d,\\;k\n   \\]\n   picks exactly the chain for residue \\(r=a\\%d\\) and connects the block of \\(k+1\\) consecutive vertices in that chain:\n   \\[\n     p_0 = \\tfrac{a-base}{d},\\quad\n     p_1=p_0+1,\\dots,\\;p_k=p_0+k.\n   \\]\n   To connect them all, it suffices to union each consecutive pair\n   \\(\\,(p_j,p_{j+1})\\).  We do *not* loop \\(k\\) times per operation: we only note that positions \\(p_j\\) for \\(j\\in[p_0,p_0+k-1]\\) must have their “edge” to \\(p_j+1\\).  \n   \n   We maintain an integer array `diff[]` of length \\(L\\).  For an interval \\([p_0,p_0+k]\\) we do\n     diff[p₀]++  \n     diff[p₀+k]--  \n   Later a single prefix‐sum pass tells us exactly which positions carry an edge (where the prefix‐sum is >0).\n\n4. **Applying the Edges.**  \n   After prefix‐summing, wherever the sum at index \\(j\\) is positive, we know there must be an edge between the chain nodes \\(j\\) and \\(j+1\\).  We translate those into an actual DSU‐`unite(u,v)` where  \n   \\[\n     u = base + j\\,d,\\quad\n     v = u + d.\n   \\]\n\n5. **Counting Components.**  \n   In the end each integer \\(1\\le i \\le n\\) belongs to exactly one DSU set.  We simply count how many \\(i\\) are their own parent (i.e.\\ roots).  That is the number of connected components.\n\nBecause \\(d\\le10\\), the total length of *all* chains is only\n\\[\n   \\sum_{d=1}^{10}\\sum_{r=0}^{d-1}\\bigl\\lfloor\\tfrac{n - base}{d}\\bigr\\rfloor+1\n   \\;=\\;O(n\\sum_{d=1}^{10}\\tfrac1d)\\;=\\;O(n),\n\\]\nand each operation becomes \\(O(1)\\) to mark the difference arrays, plus one linear sweep per chain.  This yields an overall \\(O((n+m)\\cdot\\alpha(n))\\) solution (where \\(\\alpha\\) is the inverse‐Ackermann function buried in DSU), which is perfectly fast for \\(n,m\\le2\\cdot10^5\\)."
  }
]