[
  {
    "role": "user",
    "content": "E. Shuffle\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nTwo hungry red pandas, Oscar and Lura, have a tree T\n\n with n\n\n nodes. They are willing to perform the following shuffle procedure on the whole tree T\n\n exactly once. With this shuffle procedure, they will create a new tree out of the nodes of the old tree.\n\n\n\nChoose any node V\n\n from the original tree T\n\n. Create a new tree T2\n\n, with V\n\n as the root.\n\nRemove V\n\n from T\n\n, such that the original tree is split into one or more subtrees (or zero subtrees, if V\n\n is the only node in T\n\n).\n\nShuffle each subtree with the same procedure (again choosing any node as the root), then connect all shuffled subtrees' roots back to V\n\n to finish constructing T2\n\n.\n\nAfter this, Oscar and Lura are left with a new tree T2\n\n. They can only eat leaves and are very hungry, so please find the maximum number of leaves over all trees that can be created in exactly one shuffle.\n\n\n\nNote that leaves are all nodes with degree 1\n\n. Thus, the root may be considered as a leaf if it has only one child.\n\n\n\nInput\n\nThe first line contains a single integer t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nThe first line of every test case contains a single integer n\n\n (2≤n≤2⋅105\n\n) — the number of nodes within the original tree T\n\n.\n\n\n\nThe next n−1\n\n lines each contain two integers u\n\n and v\n\n (1≤u,v≤n\n\n) — an edge within the original tree T\n\n. The given edges form a tree.\n\n\n\nThe sum of n\n\n over all test cases does not exceed 3⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output a single integer — the maximum number of leaves achievable with exactly one shuffle procedure on the whole tree.\n\n\n\nExample\n\nInputCopy\n\n4\n\n5\n\n1 2\n\n1 3\n\n2 4\n\n2 5\n\n5\n\n1 2\n\n2 3\n\n3 4\n\n4 5\n\n6\n\n1 2\n\n1 3\n\n1 4\n\n1 5\n\n1 6\n\n10\n\n9 3\n\n8 1\n\n10 6\n\n8 5\n\n7 8\n\n4 6\n\n1 3\n\n10 1\n\n2 7\n\nOutputCopy\n\n4\n\n3\n\n5\n\n6\n\nNote\n\nIn the first test case, it can be shown that the maximum number of leaves is 4\n\n. To accomplish this, we can start our shuffle with selecting node 3\n\n as the new root.\n\n\n\n\n\nNext, we are left only with one subtree, in which we can select node 2\n\n to be the new root of that subtree.\n\n\n\nThis will force all 3\n\n remaining nodes to be leaves, and once we connect them back to our new root, the shuffled subtree looks like this:\n\n\n\nWe connect the shuffled subtree back to our new root of our new tree. Our final tree has four leaves (including the root), and looks like this:\n\n\n\nIn our second test case, we have a line of five nodes. It can be shown that the maximum number of leaves after one shuffle is 3\n\n. We can start off with node 2\n\n, which forces node 1\n\n to become a leaf. Then, if we select node 4\n\n on the right side, we will also have nodes 3\n\n and 5\n\n as leaves.\n\n\n\nThe third test case is a star graph with six nodes. The number of leaves cannot increase, thus our answer will be 5\n\n (if we start the shuffling with the original root node).\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have a tree \\(T\\) on \\(n\\) vertices.  We perform exactly one \"shuffle\" on \\(T\\), which turns out to be equivalent to choosing an ordering (a permutation) of the vertices and then building a new tree \\(T_2\\) in which a vertex \\(u\\) becomes a leaf if and only if, in our permutation, \\(u\\) appears **after** all of its neighbors.  (Equivalently, if we orient each edge \\((u,v)\\) toward the later‐in‐the‐permutation vertex, then a leaf in the new tree is exactly a **sink** of that orientation.)\n\nIt is easy to see that in any orientation of a tree, the sinks form an independent set, and conversely **any** independent set can be realized as the set of sinks by an appropriate acyclic orientation (just direct every edge toward the chosen independent–set vertex).  Hence\n\n\\[\n\\max_{\\text{shuffle}}(\\#\\text{leaves in }T_2)\n\\;=\\;\n\\max_{\\text{acyclic orientation}}(\\#\\text{sinks})\n\\;=\\;\n\\alpha(T),\n\\]\n\nthe size of a maximum independent set of the tree \\(T\\).\n\nHowever, there is one extra subtlety:  if we choose a leaf of \\(T\\) as the very first vertex in the permutation (so it is the \"root\" of the shuffle), it will end up having exactly one child in \\(T_2\\) and so **also** count as a leaf in \\(T_2\\).  That gives us an extra “\\(+1\\)” if and only if we can choose a leaf \\(v\\) of \\(T\\) that **does not** appear in *every* maximum independent set of \\(T\\).  Equivalently, removing \\(v\\) from \\(T\\) does **not** decrease \\(\\alpha(T)\\).  In that case we lose nothing from \\(\\alpha(T)\\) by refusing to pick \\(v\\) in our independent set, and then we get to “use” \\(v\\) as the root leaf—adding one more leaf in \\(T_2\\).\n\nPutting it all together, the answer is\n\n\\[\n\\max_{\\text{shuffle}}(\\#\\text{leaves in }T_2)\n\\;=\\;\n\\alpha(T)\n\\;+\\;\n\\bigl[\\exists\\text{ a leaf }v\\text{ with }\\alpha(T\\setminus\\{v\\})=\\alpha(T)\\bigr],\n\\]\n\nwhere \\(\\alpha(\\cdot)\\) denotes the size of a maximum independent set and \\([P]\\) is the Iverson bracket (1 if \\(P\\) is true, 0 otherwise).\n\nWe can compute \\(\\alpha(T)\\) by the usual tree‐DP:\n\n- Root the tree arbitrarily, say at vertex 1.\n- Define\n  \\[\n     \\text{dp0}[u] = \\max(\\text{independent set in the subtree of }u\\text{ if }u\\notin S),\n     \\quad\n     \\text{dp1}[u] = 1 + \\sum_{\\text{child }w}\\text{dp0}[w].\n  \\]\n- Then \n  \\(\\displaystyle \\alpha(T)=\\max(\\text{dp0}[1],\\,\\text{dp1}[1])\\).\n\nTo decide whether there is a leaf \\(v\\) with \\(\\alpha(T\\setminus\\{v\\})=\\alpha(T)\\), we need to check whether \\(v\\) can be *excluded* from *some* maximum independent set of \\(T\\).  We do a second DP (a “reconstruction of choices”) which tracks for each node \\(u\\) whether it is possible, *in some maximum‐size solution*, to have \\(u\\notin S\\).  We call these boolean arrays `poss0[u]` (can \\(u\\) be 0/excluded?) and `poss1[u]` (can \\(u\\) be 1/included?).  We initialize these at the root according to which of \\(\\text{dp0}[1],\\text{dp1}[1]\\) achieve the overall maximum, and then propagate *down* the tree:\n\n- If at a node \\(u\\) we *did* include \\(u\\) in the MIS (`state=1`), then *all* children must be in state 0.\n- If at a node \\(u\\) we did *not* include \\(u\\) (`state=0`), then each child \\(w\\) must choose whichever of \\(\\text{dp0}[w]\\) or \\(\\text{dp1}[w]\\) was used in computing \\(\\text{dp0}[u]\\), and if they are equal the child can be in either state.\n\nAfter this “down‐pass,” for every leaf \\(v\\) of the original tree we check `poss0[v]`.  If it is true for *any* leaf \\(v\\), that means \\(v\\) can be left out of a maximum independent set (so removing \\(v\\) does not decrease \\(\\alpha\\)), and hence we get the extra +1.\n\nTotal time per test is \\(O(n)\\), so with \\(\\sum n\\le3\\cdot10^5\\) it runs in time.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        FastReader() { br = new BufferedReader(new InputStreamReader(System.in)); }\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try { st = new StringTokenizer(br.readLine()); }\n                catch (IOException e) { throw new RuntimeException(e); }\n            }\n            return st.nextToken();\n        }\n        int nextInt() { return Integer.parseInt(next()); }\n    }\n\n    public static void main(String[] args) {\n        FastReader in = new FastReader();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int t = in.nextInt();\n        while (t-- > 0) {\n            int n = in.nextInt();\n            // Read tree\n            List<Integer>[] g = new ArrayList[n+1];\n            for (int i = 1; i <= n; i++) {\n                g[i] = new ArrayList<>();\n            }\n            for (int i = 0; i < n-1; i++) {\n                int u = in.nextInt(), v = in.nextInt();\n                g[u].add(v);\n                g[v].add(u);\n            }\n\n            // 1) Root the tree at 1, build a postorder\n            int[] parent = new int[n+1];\n            parent[1] = 0;\n            List<Integer> post = new ArrayList<>(n);\n\n            // Iterative DFS to get parent[] and postorder\n            Deque<int[]> stack = new ArrayDeque<>();\n            stack.push(new int[]{1, 0, 0}); // {node, parent, state=0:pre,1:post}\n            while (!stack.isEmpty()) {\n                int[] cur = stack.pop();\n                int u = cur[0], p = cur[1], st = cur[2];\n                if (st == 0) {\n                    parent[u] = p;\n                    // push post‐state\n                    stack.push(new int[]{u, p, 1});\n                    for (int w : g[u]) {\n                        if (w == p) continue;\n                        stack.push(new int[]{w, u, 0});\n                    }\n                } else {\n                    post.add(u);\n                }\n            }\n\n            // Build child lists\n            List<Integer>[] children = new ArrayList[n+1];\n            for (int i = 1; i <= n; i++) {\n                children[i] = new ArrayList<>();\n            }\n            for (int v = 2; v <= n; v++) {\n                children[parent[v]].add(v);\n            }\n\n            // 2) DP for maximum independent set\n            int[] dp0 = new int[n+1], dp1 = new int[n+1];\n            for (int u : post) {\n                // dp1[u] = 1 + sum dp0[child]\n                dp1[u] = 1;\n                for (int w : children[u]) {\n                    dp1[u] += dp0[w];\n                }\n                // dp0[u] = sum of max(dp0[child], dp1[child])\n                int s = 0;\n                for (int w : children[u]) {\n                    s += Math.max(dp0[w], dp1[w]);\n                }\n                dp0[u] = s;\n            }\n            // Best MIS size on the whole tree:\n            int alpha = Math.max(dp0[1], dp1[1]);\n\n            // 3) We now do a \"possible states\" DP to see which nodes can be 0/excluded\n            //    or 1/included in *some* optimum solution.\n            boolean[] poss0 = new boolean[n+1], poss1 = new boolean[n+1];\n\n            // We'll push (node,state) into a queue\n            Deque<int[]> q = new ArrayDeque<>();\n            // Initialize at root = 1\n            if (dp0[1] == alpha) {\n                poss0[1] = true;\n                q.add(new int[]{1,0});\n            }\n            if (dp1[1] == alpha) {\n                poss1[1] = true;\n                q.add(new int[]{1,1});\n            }\n\n            // Propagate down\n            while (!q.isEmpty()) {\n                int[] cur = q.poll();\n                int u = cur[0], st = cur[1];\n                if (st == 1) {\n                    // u is included => all children must be 0\n                    for (int w : children[u]) {\n                        if (!poss0[w]) {\n                            poss0[w] = true;\n                            q.add(new int[]{w, 0});\n                        }\n                    }\n                } else {\n                    // u is excluded => for each child we must match\n                    // whichever of dp0[w], dp1[w] was used\n                    for (int w : children[u]) {\n                        if (dp0[w] > dp1[w]) {\n                            // dp0[w] was used\n                            if (!poss0[w]) {\n                                poss0[w] = true;\n                                q.add(new int[]{w,0});\n                            }\n                        } else if (dp1[w] > dp0[w]) {\n                            // dp1[w] was used\n                            if (!poss1[w]) {\n                                poss1[w] = true;\n                                q.add(new int[]{w,1});\n                            }\n                        } else {\n                            // equal => child can be either 0 or 1\n                            if (!poss0[w]) {\n                                poss0[w] = true;\n                                q.add(new int[]{w,0});\n                            }\n                            if (!poss1[w]) {\n                                poss1[w] = true;\n                                q.add(new int[]{w,1});\n                            }\n                        }\n                    }\n                }\n            }\n\n            // 4) Now check if there is any *leaf* v (degree == 1) with poss0[v] == true.\n            //    If so, we can do alpha+1; otherwise just alpha.\n            int ans = alpha;\n            for (int v = 1; v <= n; v++) {\n                if (g[v].size() == 1) {\n                    if (poss0[v]) {\n                        ans = alpha + 1;\n                        break;\n                    }\n                }\n            }\n\n            out.println(ans);\n        }\n        out.flush();\n    }\n}\n```\n\n**Explanation of key steps**\n\n1. **Tree‐DP for \\(\\alpha(T)\\).**  \n   We root the tree at node 1 (arbitrary), do a post‐order, and set\n   \\[\n     \\text{dp1}[u] \\;=\\; 1 \\;+\\;\\sum_{w\\in\\text{children}(u)}\\text{dp0}[w],\\quad\n     \\text{dp0}[u] \\;=\\;\\sum_{w\\in\\text{children}(u)}\\max(\\text{dp0}[w],\\text{dp1}[w]).\n   \\]\n   Then \\(\\alpha(T)=\\max(\\text{dp0}[1],\\text{dp1}[1])\\).\n\n2. **Reconstructing choice‐possibilities.**  \n   We build two boolean arrays `poss0[u], poss1[u]`, meaning “in *some* maximum‐size independent set of the entire tree, can \\(u\\) be excluded (0) / included (1)?”  \n   We start at the root: if `dp0[1]` achieves \\(\\alpha(T)\\) we mark `poss0[1]=true`, and if `dp1[1]` does we mark `poss1[1]=true`.  \n   Then we do a BFS/DFS *down* the tree enforcing the DP‐choice constraints:\n   - If \\(u\\) is included (`state=1`), then *all* children must be excluded (`0`) because you cannot pick adjacent vertices.\n   - If \\(u\\) is excluded (`state=0`), then each child \\(w\\) must choose whichever of \\(\\text{dp0}[w]\\) or \\(\\text{dp1}[w]\\) actually contributed to \\(\\text{dp0}[u]\\).  If \\(\\text{dp0}[w]\\) and \\(\\text{dp1}[w]\\) are equal, the child can be either.\n\n3. **The “+1 leaf” trick.**  \n   In the shuffle, if we pick a *leaf* \\(v\\) of the original tree to be the very first (the root of the shuffle), that vertex ends up having exactly one child in \\(T_2\\), and hence **it** is also a leaf in \\(T_2\\).  We only get that extra leaf if we can afford *not* to pick \\(v\\) in a maximum independent set of \\(T\\).  Concretely, we check if `poss0[v]` is true for some leaf \\(v\\).  If so, our final answer is\n   \\[\n     \\alpha(T)\\;+\\;1,\n   \\]\n   otherwise it is just \\(\\alpha(T)\\).\n\nTotal complexity is \\(O(n)\\) per test, easily fitting the constraint \\(\\sum n\\le3\\times10^5\\)."
  },
  {
    "role": "system",
    "content": "Identify any errors in this response and output a prompt to help the AI resolve said issues. Your response MUST be in one of two formats: 1. If the response looks perfect, return \"Perfect\". Do not return this if there are any issues. Use this very sparingly as any errors in the final output from the AI will be considered a failure on your part. 2. Otherwise, return \"{prompt}\" where {prompt} is replaced with your concise prompt. This should be done most often, even if the AI's response is mostly correct. Ensure the entire response is enclosed in double quotations if it's a prompt. Make sure your prompt asks the AI to return one block of code for submission."
  },
  {
    "role": "assistant",
    "content": "Perfect"
  }
]