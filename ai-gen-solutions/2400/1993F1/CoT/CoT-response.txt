**Analysis**

We have a rectangular board of width _w_ and height _h_ (coordinates go from (0,0) at the lower‐left to (w,h) at the upper‐right).  A robot starts at (0,0) and is given a single “script” _s_ of length _n_, consisting of the four characters `L,R,U,D`.  We must execute that script _k_ times in succession (so the total number of logical steps is _n·k_), but with a twist:

- Whenever the robot tries a step that would take it strictly outside the horizontal borders x=0 or x=w, **all** future `L`↔`R` in the script (the entire script) is toggled, and then we _do_ execute that (originally failing) step in its new, toggled form.
- Similarly if the robot tries a move outside the vertical borders y=0 or y=h, we toggle **all** future `U`↔`D` in the script, and then execute the step (now reflected).

We must count **how many times** the robot (strictly after a step) lands exactly on (0,0).  The very initial position does _not_ count.

Brute‐forcing all _n·k_ steps is impossible for _n,k_ up to 10^6 each.  We must exploit structure:

1.  Separate the horizontal (`L`/`R`) and vertical (`U`/`D`) motions.  They never interact except that the moment either would go out of bounds, we globally reflect that axis in the script.

2.  Keep track of two “flags” `fx, fy` in {+1, –1} that say whether the script is currently “normal” (+1) or “flipped” (–1) for the horizontal axis and vertical axis respectively.  
   -  If `fx=+1`, then an `'R'` in the script moves +1 in x, an `'L'` moves –1.  
   -  If `fx=–1`, then we have globally flipped `L`↔`R`, so an original `'R'` now acts like –1, an original `'L'` acts like +1.

3.  Precompute the ordinary prefix sums
      `px[i] = #R − #L` in `s[1..i]`  
      `py[i] = #U − #D` in `s[1..i]`  
   and build two segment trees (one on `px[]`, one on `py[]`) that can in O(log n) find the earliest index _j_ ≥ some _l_ at which `px[j]` goes below or above any given thresholds.  This lets us binary‐search for the _first_ step in the _remaining_ suffix of the script that would cross the x‐ or y‐border, without simulating step by step.

4.  Also build a hash‐map from each pair `(px[i],py[i]) →` a sorted list of all indices _i_ where the robot’s _net_ (unflipped) prefix is exactly that pair.  Then in any “safe block” of the script (where no border‐crossing occurs, so `fx,fy` remain constant), the robot’s **absolute** position after step _i_ is

  xᵢ = x₀ + fx·(px[i]−px[l−1])  
  yᵢ = y₀ + fy·(py[i]−py[l−1])  

   If we want xᵢ=yᵢ=0 in that block, we solve for `(px[i],py[i])` and look up how many prefix‐indices in the block match that pair (via two binary‐searches into our sorted‐list).

5.  We iterate “block by block”:

   - Maintain current run‐count `runs_left` (initially = k), current script‐index `pos` (initially 1), current position `(x0,y0)` (initially (0,0)), and flags `fx,fy` (+1/–1).
   - In the current block we look up (via our two segment‐trees) the earliest index jₓ≥pos that would cross x=0 or x=w, and the earliest jᵧ≥pos that would cross y=0 or y=h.  Let `j0 = min(jₓ, jᵧ)`.  
     • If neither axis crosses in [pos..n], then we can finish the rest of **this** script‐run safely (no reflection), count visits to (0,0) in that suffix, then update `(x0,y0)` to the end of the run, do `runs_left–`, and reset `pos=1` for the next run.  
     • Otherwise, we safely run from `pos` to `j0−1` (count visits there), then at step `j0` we know which axis (or both) violated → flip `fx` and/or `fy`, compute the one step from `j0` under the **new** flags, update `(x0,y0)`, and set `pos=j0+1` (or if that exceeds _n_, finish the run, decrement `runs_left`, reset `pos=1`).

6.  Whenever we identify a “safe” interval [pos..R] in one go, we compute how many indices _i_ in that range satisfy the exact condition for landing at (0,0), by a single hash‐lookup of the net‐prefix pair and two binary‐searches into its sorted‐list of occurrences.  Each block costs O(log n) for the segment‐tree queries + O(log n) for the two binary‐searches.  Since _k_ ≤ _n_, even if we break the overall _n·k_ steps into as many as O(n) small blocks, the total work is O(n log n).  With ∑ n ≤ 10^6 over all tests, this runs in a few seconds.

---

```java
import java.io.*;
import java.util.*;

public class Main {
    static int N;
    static int[] px, py;    // prefix sums
    static int[] dx, dy;    // original deltas per character
    static NodeTX[] segx;
    static NodeTY[] segy;
    static String s;
    static int n, k, w, h;

    // A little segment-tree node for px[]
    static class NodeTX {
        int mn, mx;
    }
    // A little segment-tree node for py[]
    static class NodeTY {
        int mn, mx;
    }

    // Build segment tree on px[] in segx[1..4n]
    static void buildX(int idx, int l, int r) {
        if (l == r) {
            segx[idx].mn = segx[idx].mx = px[l];
        } else {
            int mid = (l + r) >>> 1;
            buildX(idx<<1, l, mid);
            buildX(idx<<1|1, mid+1, r);
            segx[idx].mn = Math.min(segx[idx<<1].mn, segx[idx<<1|1].mn);
            segx[idx].mx = Math.max(segx[idx<<1].mx, segx[idx<<1|1].mx);
        }
    }
    // Build segment tree on py[] in segy[1..4n]
    static void buildY(int idx, int l, int r) {
        if (l == r) {
            segy[idx].mn = segy[idx].mx = py[l];
        } else {
            int mid = (l + r) >>> 1;
            buildY(idx<<1, l, mid);
            buildY(idx<<1|1, mid+1, r);
            segy[idx].mn = Math.min(segy[idx<<1].mn, segy[idx<<1|1].mn);
            segy[idx].mx = Math.max(segy[idx<<1].mx, segy[idx<<1|1].mx);
        }
    }

    // Find the minimal j in [ql..qr] such that px[j]<Tlo or px[j]>Thi, or -1 if none.
    static int queryX(int idx, int l, int r, int ql, int qr, int Tlo, int Thi) {
        if (r < ql || l > qr) return -1;
        if (ql <= l && r <= qr) {
            if (segx[idx].mn >= Tlo && segx[idx].mx <= Thi) {
                return -1; // no violation here
            }
        }
        if (l == r) {
            // l==r is inside [ql..qr] and either <Tlo or >Thi
            return l;
        }
        int mid = (l + r) >>> 1;
        int res = queryX(idx<<1, l, mid, ql, qr, Tlo, Thi);
        if (res != -1) return res;
        return queryX(idx<<1|1, mid+1, r, ql, qr, Tlo, Thi);
    }

    // Same for py[]
    static int queryY(int idx, int l, int r, int ql, int qr, int Tlo, int Thi) {
        if (r < ql || l > qr) return -1;
        if (ql <= l && r <= qr) {
            if (segy[idx].mn >= Tlo && segy[idx].mx <= Thi) {
                return -1;
            }
        }
        if (l == r) return l;
        int mid = (l + r) >>> 1;
        int res = queryY(idx<<1, l, mid, ql, qr, Tlo, Thi);
        if (res != -1) return res;
        return queryY(idx<<1|1, mid+1, r, ql, qr, Tlo, Thi);
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);

        int t = Integer.parseInt(br.readLine().trim());
        while (t-- > 0) {
            String[] parts = br.readLine().trim().split(" ");
            n = Integer.parseInt(parts[0]);
            k = Integer.parseInt(parts[1]);
            w = Integer.parseInt(parts[2]);
            h = Integer.parseInt(parts[3]);
            s = br.readLine().trim();

            // Build dx, dy
            dx = new int[n+1];
            dy = new int[n+1];
            for (int i = 0; i < n; i++) {
                char c = s.charAt(i);
                if (c == 'L') dx[i+1] = -1;
                else if (c == 'R') dx[i+1] = +1;
                else dx[i+1] = 0;
                if (c == 'D') dy[i+1] = -1;
                else if (c == 'U') dy[i+1] = +1;
                else dy[i+1] = 0;
            }

            // Prefix sums
            px = new int[n+1];
            py = new int[n+1];
            for (int i = 1; i <= n; i++) {
                px[i] = px[i-1] + dx[i];
                py[i] = py[i-1] + dy[i];
            }

            // Build segment trees
            segx = new NodeTX[4*(n+1)];
            for (int i = 0; i < segx.length; i++) segx[i] = new NodeTX();
            buildX(1, 0, n);

            segy = new NodeTY[4*(n+1)];
            for (int i = 0; i < segy.length; i++) segy[i] = new NodeTY();
            buildY(1, 0, n);

            // Map from (px[i],py[i]) to list of i
            HashMap<Long, ArrayList<Integer>> map = new HashMap<>();
            for (int i = 1; i <= n; i++) {
                long key = (((long)px[i])<<32) ^ (py[i] & 0xffffffffL);
                map.computeIfAbsent(key, z->new ArrayList<>()).add(i);
            }
            long ans = 0;

            // State
            int runsLeft = k;
            int pos = 1;          // next script-index
            int x0 = 0, y0 = 0;   // current physical coords
            int fx = +1, fy = +1; // flags (+1=normal, -1=flipped)

            while (runsLeft > 0) {
                // We are at the start of a block, script-index = pos, physical = (x0,y0), flags=(fx,fy).
                // We want the earliest violation in x or y.
                int baseX = px[pos-1], baseY = py[pos-1];

                // compute thresholds Tlo/T_hi for x
                int TloX, ThiX;
                if (fx == +1) {
                    TloX = baseX - x0;           // px[j] < TloX => x<0
                    ThiX = baseX + (w - x0);     // px[j] > ThiX => x>w
                } else {
                    // x0 - (px[j]-baseX) <0 <=> px[j] > baseX + x0
                    // x0 - (px[j]-baseX) >w <=> px[j] < baseX + x0 - w
                    TloX = baseX + x0 - w;
                    ThiX = baseX + x0;
                }
                int i1 = queryX(1, 0, n, pos, n, TloX, ThiX);
                if (i1<0) i1 = n+1;

                // same for y
                int TloY, ThiY;
                if (fy == +1) {
                    TloY = baseY - y0;
                    ThiY = baseY + (h - y0);
                } else {
                    TloY = baseY + y0 - h;
                    ThiY = baseY + y0;
                }
                int i2 = queryY(1, 0, n, pos, n, TloY, ThiY);
                if (i2<0) i2 = n+1;

                int j0 = Math.min(i1, i2);

                if (j0 > n) {
                    // no violation in [pos..n], we can finish this run safely
                    int len = n - pos + 1;
                    if (len > 0) {
                        // count how many i in [pos..n] land at (0,0)
                        // solve x0 + fx*(px[i]-baseX)=0 => px[i]=baseX - fx*x0
                        // likewise py[i]= baseY - fy*y0
                        int tx = baseX - fx*x0;
                        int ty = baseY - fy*y0;
                        long key = (((long)tx)<<32) ^ (ty & 0xffffffffL);
                        ArrayList<Integer> lst = map.get(key);
                        if (lst != null) {
                            // count indices in lst that lie in [pos..n]
                            int low = Collections.binarySearch(lst, pos);
                            if (low<0) low = -low-1;
                            ans += (lst.size() - low);
                        }
                    }
                    // update the robot's final (x,y) after the whole run:
                    x0 += fx * (px[n] - baseX);
                    y0 += fy * (py[n] - baseY);
                    // next run
                    pos = 1;
                    runsLeft--;
                    // flags fx,fy stay the same
                } else {
                    // violation at j0, so we first do [pos..j0-1] safely
                    int seglen = j0 - pos;
                    if (seglen > 0) {
                        int tx = baseX - fx*x0;
                        int ty = baseY - fy*y0;
                        long key = (((long)tx)<<32) ^ (ty & 0xffffffffL);
                        ArrayList<Integer> lst = map.get(key);
                        if (lst != null) {
                            // count in [pos..j0-1]
                            int low = Collections.binarySearch(lst, pos);
                            if (low<0) low = -low-1;
                            int up = Collections.binarySearch(lst, j0);
                            if (up<0) up = -up-1;
                            ans += (up - low);
                        }
                    }
                    // now apply step j0 under reflection
                    boolean rx = (i1 == j0);
                    boolean ry = (i2 == j0);
                    // position _before_ step j0 is
                    int xprev = x0 + fx*(px[j0-1] - baseX);
                    int yprev = y0 + fy*(py[j0-1] - baseY);
                    // the raw dx,dy = dx[j0], dy[j0]
                    int ddx = dx[j0], ddy = dy[j0];
                    int effdx = (rx ? -fx : fx)*ddx;
                    int effdy = (ry ? -fy : fy)*ddy;
                    int xnew = xprev + effdx;
                    int ynew = yprev + effdy;
                    x0 = xnew;
                    y0 = ynew;
                    if (rx) fx = -fx;
                    if (ry) fy = -fy;
                    // advance pos
                    pos = j0 + 1;
                    if (pos > n) {
                        // that ended a run
                        pos = 1;
                        runsLeft--;
                    }
                }
            }

            pw.println(ans);
        }

        pw.flush();
        pw.close();
    }
}
```

**Explanation of the main ideas**

1.  **Separating axes**  
    Horizontal (`L`/`R`) reflections never affect vertical moves, and vertical reflections never affect horizontal moves.  We keep two flags `fx,fy` that say whether the script is currently “normal” (`+1`) or “flipped” (`–1`) in each axis.

2.  **Prefix sums + segment‐tree**  
    Let  
      `px[i] =` net horizontal move in `s[1..i]` (`+1` for `R`, `–1` for `L`),  
      `py[i] =` net vertical move (`+1` for `U`, `–1` for `D`).  
    We build two segment‐trees that can in O(log n) find the earliest index _j_ ≥ some _l_ at which `px[j]` goes below or above any chosen thresholds.  These thresholds come from the current position `(x0,y0)`, the flag `fx`, and the borders `0,w`.

3.  **Blocks of “no‐reflection”**  
    Each time we look up the next violation index `j0` in the suffix of the script.  
    - If there is no violation in `[pos..n]`, we can safely run that entire suffix without flipping either flag.  We then do one hash‐lookup to count how many steps in that suffix land us on (0,0), update `(x0,y0)` by the net delta of the suffix, decrement the number of runs left, and loop.  
    - Otherwise, we safely run `[pos..j0−1]`, count (0,0) visits there, then at step `j0` we flip exactly the axis (or both) that would have hit a wall, execute that single step in its _reflected_ direction, update `(x0,y0)`, update `fx,fy`, advance `pos` to `j0+1`, and continue.

4.  **Counting visits to (0,0)**  
    In a “safe block” `[pos..R]` where `fx,fy` stay fixed, the absolute position after step _i_ is
    
        X(i) = x0 + fx·(px[i] − px[pos−1])
        Y(i) = y0 + fy·(py[i] − py[pos−1])
    
    We want X(i)=Y(i)=0.  This is a linear condition on `(px[i],py[i])`, so it picks out exactly one pair `(tx,ty)`.  We pre‐stored, for each pair `(px[i],py[i])`, the sorted list of all _i_ where it occurs.  We do a single hash‐lookup and then two binary‐searches to count how many of those _i_ land in `[pos..R]`.  That is O(log n) per block.

5.  **Overall complexity**  
    We do at most _k_ runs, and each run may be split into a small number of blocks (each block ends with a reflection or the end of the run).  Even in the worst case _k_≤_n_≤10^6, we only spend O(log n) per block, so O(n log n) total over all _k_ runs.  This easily fits under the 3 s/256 MB limits with careful implementation.