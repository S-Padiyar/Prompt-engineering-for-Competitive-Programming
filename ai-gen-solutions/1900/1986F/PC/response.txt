**Analysis**

We have a connected undirected graph on \(n\) vertices and \(m\) edges.  We may remove exactly one edge.  After removing an edge, the graph may become disconnected; if an edge is not a bridge (i.e.\ its removal does not increase the number of connected components), the graph stays connected and *every* pair of vertices remains reachable.

We wish to *minimize* the number of reachable pairs \(\bigl\{u<v\}\) that still have a path between them, equivalently to *maximize* the number of newly unreachable pairs.

-   Total number of unordered pairs of \(n\) vertices is
    \[
       \binom n2 \;=\;\frac{n(n-1)}2.
    \]
-   If removing an edge splits the graph into two connected components of sizes \(s\) and \(n-s\), then exactly
    \[
      s\,(n-s)
    \]
    pairs cross between the two components and become unreachable.
-   If the removed edge is *not* a bridge, then the graph remains connected and \(s=0\) or \(n\), so \(s(n-s)=0\)—no lost reachability.

Hence the problem reduces to:

1.  Find *all* bridges in the graph.
2.  For each bridge, determine the sizes \(s\) and \(n-s\) of the two components created by removing it.
3.  Choose the bridge whose removal maximizes \(s(n-s)\).
4.  Subtract that from the total \(\binom n2\).

All we need, then, is a standard DFS-based bridge‐finding (Tarjan) together with tracking subtree sizes in the DFS tree.  Whenever we detect that a tree‐edge \((u,v)\) is a bridge (by the test \(\mathrm{low}[v]>\mathrm{tin}[u]\)), the subtree of \(v\) in our DFS has size \(\mathrm{sz}[v]\), and the other side has size \(n-\mathrm{sz}[v]\).  We take 
\[
   \max_{(u,v)\,\text{bridge}} \bigl(\,\mathrm{sz}[v]\times (n-\mathrm{sz}[v])\bigr).
\]
Our final answer is
\[
   \binom n2 \;-\;\max_{bridge}\bigl(s(n-s)\bigr).
\]

We implement an *iterative* DFS (to avoid Java recursion‐stack issues) that maintains arrays

-   `tin[v]`, discovery time of \(v\);
-   `low[v]`, low‐link value of \(v\);
-   `sz[v]`, size of the DFS‐subtree rooted at \(v\);
-   `visited[v]`.

We use an explicit stack of states to simulate the recursive Tarjan DFS.  Each time we finish exploring a child we do the “bridge‐check” and update `low` and `sz` of the parent.  We record the maximum product \(s(n-s)\) seen so far.

Overall time per test is \(O(n+m)\), and across all tests at most \(2\times10^5\) vertices plus edges, which runs comfortably in 2 s.

---

```java
import java.io.*;
import java.util.*;

public class Main {
    static class StackEntry {
        int type;     // 0 = DFS state; 1 = "post-child" state
        int v, parent, iter, u;
        // For type=0 (DFS): v=vertex, parent=parent, iter=next neighbor index
        // For type=1 (post): v=parent, u=child
        StackEntry(int type, int v, int parent, int iter, int u) {
            this.type = type;
            this.v = v;
            this.parent = parent;
            this.iter = iter;
            this.u = u;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out);

        int t = Integer.parseInt(in.readLine().trim());
        while (t-- > 0) {
            StringTokenizer st = new StringTokenizer(in.readLine());
            int n = Integer.parseInt(st.nextToken());
            int m = Integer.parseInt(st.nextToken());

            // Build adjacency list
            List<Integer>[] adj = new ArrayList[n+1];
            for (int i = 1; i <= n; i++) {
                adj[i] = new ArrayList<>();
            }
            for (int i = 0; i < m; i++) {
                st = new StringTokenizer(in.readLine());
                int u = Integer.parseInt(st.nextToken());
                int v = Integer.parseInt(st.nextToken());
                adj[u].add(v);
                adj[v].add(u);
            }

            // Arrays for Tarjan‐bridge + subtree‐sizes
            int[] tin = new int[n+1], low = new int[n+1], sz = new int[n+1];
            boolean[] visited = new boolean[n+1];
            int timer = 0;
            long bestProduct = 0;

            // We'll do one DFS (the graph is connected)
            ArrayDeque<StackEntry> stack = new ArrayDeque<>();
            // Initial DFS state at vertex 1, parent = -1, next-iter = 0
            stack.push(new StackEntry(0, 1, -1, 0, 0));

            while (!stack.isEmpty()) {
                StackEntry e = stack.pop();
                if (e.type == 1) {
                    // "Post-child" state: we've finished child u of parent v
                    int v = e.v, u = e.u;
                    // Update low-link and subtree size
                    low[v] = Math.min(low[v], low[u]);
                    sz[v] += sz[u];
                    // Bridge check
                    if (low[u] > tin[v]) {
                        long s = sz[u];
                        long prod = s * (n - s);
                        if (prod > bestProduct) {
                            bestProduct = prod;
                        }
                    }
                } else {
                    // DFS state
                    int v = e.v, p = e.parent;
                    if (e.iter == 0) {
                        // first time we see v
                        visited[v] = true;
                        tin[v] = low[v] = ++timer;
                        sz[v] = 1;
                    }
                    if (e.iter < adj[v].size()) {
                        // Process next neighbor
                        int u = adj[v].get(e.iter);
                        e.iter++;  // increment for next time
                        // Push the current state back (to resume later)
                        stack.push(e);

                        if (u == p) {
                            // the edge back to parent; ignore
                            continue;
                        }
                        if (visited[u]) {
                            // back-edge
                            low[v] = Math.min(low[v], tin[u]);
                        } else {
                            // tree-edge, will recurse into u
                            // After returning from u, we must do the "post-child" update
                            stack.push(new StackEntry(1, v, 0, 0, u));  // post-child
                            stack.push(new StackEntry(0, u, v, 0, 0));  // DFS into u
                        }
                    }
                    // else e.iter >= adj[v].size() => all neighbors done, no re-push
                }
            }

            // Total pairs minus max unreachable = min reachable
            long totalPairs = ((long)n * (n - 1)) / 2;
            long answer = totalPairs - bestProduct;
            out.println(answer);
        }

        out.flush();
    }
}
```

**Explanation of Key Steps**

1. We compute the total number of unordered pairs \(\binom n2\).
2. We run a DFS/Tarjan bridge‐finding algorithm.  In the DFS tree,
   - `tin[v]` is the discovery time of \(v\).
   - `low[v]` is the minimum discovery time reachable from \(v\) by at most one back‐edge.
   - `sz[v]` is the size of the subtree of \(v\) in the DFS tree.
3. An edge \((v,u)\) (with \(v\) the parent of \(u\) in the DFS tree) is a bridge exactly if 
   \[
     \mathrm{low}[u] > \mathrm{tin}[v].
   \]
   Removing that bridge splits off a component of size `sz[u]` on \(u\)‘s side and \(n - \mathrm{sz}[u]\) the other.
4. We maintain the maximum product \(\mathrm{sz}[u]\times\bigl(n-\mathrm{sz}[u]\bigr)\) over all bridges.  This is the *maximum* number of pairs that become unreachable by removing a single edge.
5. The minimum number of *reachable* pairs is then
   \[
     \binom n2 - \max_{bridge} \bigl(s(n-s)\bigr).
   \]
6. We print this value for each test case.

Because we do the DFS iteratively with an explicit stack (and only \(O(m+n)\) work per test), the method runs efficiently under the problem’s constraints.