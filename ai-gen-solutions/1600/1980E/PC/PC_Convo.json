[
  {
    "timestamp": "2025-07-24T05:45:59.307848",
    "role": "user",
    "content": "E. Permutation of Rows and Columns\n\ntime limit per test3 seconds\n\nmemory limit per test256 megabytes\n\nYou have been given a matrix a\n\n of size n\n\n by m\n\n, containing a permutation of integers from 1\n\n to n⋅m\n\n.\n\n\n\nA permutation of n\n\n integers is an array containing all numbers from 1\n\n to n\n\n exactly once. For example, the arrays [1]\n\n, [2,1,3]\n\n, [5,4,3,2,1]\n\n are permutations, while the arrays [1,1]\n\n, [100]\n\n, [1,2,4,5]\n\n are not.\n\n\n\nA matrix contains a permutation if, when all its elements are written out, the resulting array is a permutation. Matrices [[1,2],[3,4]]\n\n, [[1]]\n\n, [[1,5,3],[2,6,4]]\n\n contain permutations, while matrices [[2]]\n\n, [[1,1],[2,2]]\n\n, [[1,2],[100,200]]\n\n do not.\n\n\n\nYou can perform one of the following two actions in one operation:\n\n\n\nchoose columns c\n\n and d\n\n (1≤c,d≤m\n\n, c≠d\n\n) and swap these columns;\n\nchoose rows c\n\n and d\n\n (1≤c,d≤n\n\n, c≠d\n\n) and swap these rows.\n\nYou can perform any number of operations.\n\n\n\nYou are given the original matrix a\n\n and the matrix b\n\n. Your task is to determine whether it is possible to transform matrix a\n\n into matrix b\n\n using the given operations.\n\n\n\nInput\n\nThe first line contains an integer t\n\n (1≤t≤104\n\n) — the number of test cases. The descriptions of the test cases follow.\n\n\n\nThe first line of each test case description contains 2\n\n integers n\n\n and m\n\n (1≤n,m≤n⋅m≤2⋅105\n\n) — the sizes of the matrix.\n\n\n\nThe next n\n\n lines contain m\n\n integers aij\n\n each (1≤aij≤n⋅m\n\n). It is guaranteed that matrix a\n\n is a permutation.\n\n\n\nThe next n\n\n lines contain m\n\n integers bij\n\n each (1≤bij≤n⋅m\n\n). It is guaranteed that matrix b\n\n is a permutation.\n\n\n\nIt is guaranteed that the sum of the values n⋅m\n\n for all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output \"YES\" if the second matrix can be obtained from the first, and \"NO\" otherwise.\n\n\n\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\n\n\n\nExample\n\nInputCopy\n\n7\n\n1 1\n\n1\n\n1\n\n2 2\n\n1 2\n\n3 4\n\n4 3\n\n2 1\n\n2 2\n\n1 2\n\n3 4\n\n4 3\n\n1 2\n\n3 4\n\n1 5 9 6\n\n12 10 4 8\n\n7 11 3 2\n\n1 5 9 6\n\n12 10 4 8\n\n7 11 3 2\n\n3 3\n\n1 5 9\n\n6 4 2\n\n3 8 7\n\n9 5 1\n\n2 4 6\n\n7 8 3\n\n2 3\n\n1 2 6\n\n5 4 3\n\n6 1 2\n\n3 4 5\n\n1 5\n\n5 1 2 3 4\n\n4 2 5 1 3\n\nOutputCopy\n\nYES\n\nYES\n\nNO\n\nYES\n\nYES\n\nNO\n\nYES\n\nNote\n\nIn the second example, the original matrix looks like this:\n\n\n\n(1324)\n\n\n\nBy swapping rows 1\n\n and 2\n\n, it becomes:\n\n\n\n(3142)\n\n\n\nBy swapping columns 1\n\n and 2\n\n, it becomes equal to matrix b\n\n:\n\n\n\n(4231)\n\nUse Java."
  },
  {
    "timestamp": "2025-07-24T05:46:33.608126",
    "role": "assistant",
    "content": "**Analysis**\n\nWe have two \\(n\\times m\\) matrices \\(A\\) and \\(B\\), each containing a permutation of the integers \\(1\\) through \\(n\\cdot m\\).  We are allowed only to swap entire rows or entire columns of \\(A\\).  Swapping rows arbitrarily generates the full symmetric group \\(S_n\\) on the rows, and swapping columns arbitrarily generates \\(S_m\\) on the columns.  Thus the final matrix we can reach from \\(A\\) looks like\n\n\\[\n    A' \\;=\\; \\bigl(\\, \\text{row‐permute}_R\\,\\bigr)\\; \\bigl(\\, \\text{col‐permute}_C\\,\\bigr)(A)\n\\]\n\nfor some row‐permutation \\(R\\in S_n\\) and column‐permutation \\(C\\in S_m\\).  Concretely, each entry \\(A[i][j]\\) ends up in\n\\[\n   A'\\bigl(R(i),\\,C(j)\\bigr),\n\\]\nand we want that to equal \\(B\\bigl(R(i),\\,C(j)\\bigr)\\).  Since each integer from \\(1\\) to \\(nm\\) appears exactly once in both \\(A\\) and \\(B\\), we can track for each value \\(v\\) its position in \\(A\\) and in \\(B\\):\n\n- Let \\(\\mathrm{arow}[v]\\) and \\(\\mathrm{acol}[v]\\) be the row and column of value \\(v\\) in \\(A\\).\n- Let \\(\\mathrm{brow}[v]\\) and \\(\\mathrm{bcol}[v]\\) be the row and column of value \\(v\\) in \\(B\\).\n\nIf there is a valid row‐permutation \\(R\\) and column‐permutation \\(C\\) taking \\(A\\) to \\(B\\), then for every \\(v\\)\n\n\\[\n   \\mathrm{brow}[v] = R\\bigl(\\mathrm{arow}[v]\\bigr),\\quad\n   \\mathrm{bcol}[v] = C\\bigl(\\mathrm{acol}[v]\\bigr).\n\\]\n\nThus for all values \\(v\\) that lie in the same row \\(i\\) of \\(A\\), the target rows \\(\\mathrm{brow}[v]\\) must all be the _same_ (this will be \\(R(i)\\)).  Likewise, for all values in the same column \\(j\\) of \\(A\\), the target columns \\(\\mathrm{bcol}[v]\\) must all coincide (this will be \\(C(j)\\)).  Finally \\(R\\) must be a bijection on \\(\\{1,\\dots,n\\}\\) and \\(C\\) a bijection on \\(\\{1,\\dots,m\\}\\).\n\nConcretely the algorithm is:\n\n1. Read \\(n,m\\) and the two matrices \\(A\\) and \\(B\\).\n2. Build arrays\n   \\[\n     \\mathrm{arow}[v],\\;\\mathrm{acol}[v],\\;\n     \\mathrm{brow}[v],\\;\\mathrm{bcol}[v]\n   \\]\n   for \\(v=1\\ldots n\\cdot m\\).\n3. Try to build a row‐mapping array \\(\\mathrm{Rmap}[1..n]\\).  Initialize it to zero.  \n   For each \\(v\\):\n   - Let \\(i = \\mathrm{arow}[v]\\), \\(t = \\mathrm{brow}[v]\\).\n   - If \\(\\mathrm{Rmap}[i]=0\\), set \\(\\mathrm{Rmap}[i]=t\\).  \n     Otherwise if \\(\\mathrm{Rmap}[i]\\ne t\\), fail immediately.\n4. Similarly build a column‐mapping \\(\\mathrm{Cmap}[1..m]\\) from \\(\\mathrm{acol}[v]\\mapsto \\mathrm{bcol}[v]\\).\n5. Finally check \\(\\mathrm{Rmap}\\) is a bijection on \\(\\{1..n\\}\\) and \\(\\mathrm{Cmap}\\) is a bijection on \\(\\{1..m\\}\\).  If all tests pass, answer YES, otherwise NO.\n\nThis runs in \\(O(n\\,m)\\) per test, and since \\(\\sum(nm)\\le2\\cdot10^5\\), it is efficient.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        int t = Integer.parseInt(in.readLine().trim());\n        while (t-- > 0) {\n            StringTokenizer st = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(st.nextToken());\n            int N = n * m;\n\n            // Positions of each value in A\n            int[] arow = new int[N+1];\n            int[] acol = new int[N+1];\n            // Read matrix A\n            for (int i = 1; i <= n; i++) {\n                st = new StringTokenizer(in.readLine());\n                for (int j = 1; j <= m; j++) {\n                    int v = Integer.parseInt(st.nextToken());\n                    arow[v] = i;\n                    acol[v] = j;\n                }\n            }\n\n            // Positions of each value in B\n            int[] brow = new int[N+1];\n            int[] bcol = new int[N+1];\n            // Read matrix B\n            for (int i = 1; i <= n; i++) {\n                st = new StringTokenizer(in.readLine());\n                for (int j = 1; j <= m; j++) {\n                    int v = Integer.parseInt(st.nextToken());\n                    brow[v] = i;\n                    bcol[v] = j;\n                }\n            }\n\n            // Attempt to build row‐mapping Rmap: A‐row -> B‐row\n            int[] Rmap = new int[n+1];\n            boolean ok = true;\n            for (int v = 1; v <= N && ok; v++) {\n                int ar = arow[v], br = brow[v];\n                if (Rmap[ar] == 0) {\n                    Rmap[ar] = br;\n                } else if (Rmap[ar] != br) {\n                    ok = false;\n                }\n            }\n            // Attempt to build column‐mapping Cmap: A‐col -> B‐col\n            int[] Cmap = new int[m+1];\n            for (int v = 1; v <= N && ok; v++) {\n                int ac = acol[v], bc = bcol[v];\n                if (Cmap[ac] == 0) {\n                    Cmap[ac] = bc;\n                } else if (Cmap[ac] != bc) {\n                    ok = false;\n                }\n            }\n\n            // Check both maps are bijections\n            if (ok) {\n                boolean[] usedRow = new boolean[n+1];\n                for (int i = 1; i <= n; i++) {\n                    int r = Rmap[i];\n                    if (r < 1 || r > n || usedRow[r]) {\n                        ok = false;\n                        break;\n                    }\n                    usedRow[r] = true;\n                }\n            }\n            if (ok) {\n                boolean[] usedCol = new boolean[m+1];\n                for (int j = 1; j <= m; j++) {\n                    int c = Cmap[j];\n                    if (c < 1 || c > m || usedCol[c]) {\n                        ok = false;\n                        break;\n                    }\n                    usedCol[c] = true;\n                }\n            }\n\n            out.println(ok ? \"YES\" : \"NO\");\n        }\n\n        out.flush();\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Invert the matrices.**  \n   We record for each integer \\(v\\) where it sits in \\(A\\) (\\(\\mathrm{arow}[v],\\mathrm{acol}[v]\\)) and in \\(B\\) (\\(\\mathrm{brow}[v],\\mathrm{bcol}[v]\\)).\n\n2. **Build the row‐mapping** \\(Rmap\\).  \n   All entries in the same row \\(i\\) of \\(A\\) must move to one and the same row of \\(B\\).  So as we scan each \\(v\\), if \\(v\\) is in row \\(i=\\mathrm{arow}[v]\\) of \\(A\\) and row \\(t=\\mathrm{brow}[v]\\) of \\(B\\), we demand\n   \\[\n     Rmap[i] = t.\n   \\]\n   If there is a conflict (two different target rows for the same \\(i\\)), we declare failure.\n\n3. **Build the column‐mapping** \\(Cmap\\) similarly.\n\n4. **Ensure bijectivity.**  \n   Finally, we must check that \\(Rmap\\) is a one‐to‐one correspondence between \\(\\{1,\\dots,n\\}\\) and itself (no two \\(i\\) map to the same row in \\(B\\), and every row in \\(B\\) is used).  Likewise for \\(Cmap\\).  If all tests pass, we can indeed find a row‐permutation and column‐permutation taking \\(A\\) to \\(B\\).\n\nThis solves each test in \\(O(n\\,m)\\), and overall in \\(O\\bigl(\\sum n\\,m\\bigr)\\le O(2\\times10^5)\\), which is efficient for the given limits."
  }
]