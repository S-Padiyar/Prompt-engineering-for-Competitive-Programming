Problem Restatement

We have an undirected graph whose vertices are labeled 1 through n.  There is an edge between vertices \(u\) and \(v\) if and only if \(u \oplus v\) is prime.  We must color the vertices with as few colors as possible so that no two adjacent vertices share the same color.  For each test case (different \(n\)) we must output:

- The minimum number of colors \(k\).
- A valid coloring \(c_1, c_2, \dots, c_n\), where each \(c_i\) is in \(\{1,\dots,k\}\) and adjacent vertices get different colors.

Constraints

- Number of test cases \(t \le 500\).
- Sum of all \(n\) over all test cases \(\le 2\times 10^5\).
- \(1 \le n \le 2\times 10^5\).

We need an \(O(n)\) or \(O(n\log n)\) solution per test to run in time.

Key Observations and Algorithmic Idea

1.  **Edges come from XOR being prime.**  Note that all primes except 2 are odd.  If \(p\) is an odd prime, then \(u\oplus v = p\) is odd, which implies the least‐significant bits of \(u\) and \(v\) differ.  Hence all “odd prime” edges go between numbers of opposite parity.  That subgraph is bipartite (we can 2‐color it by parity).

2.  **The only even prime is 2.**  If \(u\oplus v=2\), their LSBs must be the same but their second bit (the “2’s bit”) differs.  Thus those edges form a disjoint matching separately inside the even group and inside the odd group.

3.  **Putting these together,** the full graph is “bipartite edges (odd primes) plus two matchings (one inside the evens, one inside the odds).”  One can show the largest clique size in this graph is 4 (for example the vertices \(\{1,3,4,6\}\) form a 4‐clique once \(n\ge6\)).  So \(\chi(G)\le4\).  In fact one can prove \(\chi(G)=4\) for all \(n\ge6\), \(\chi(G)=3\) for \(4\le n\le5\), \(\chi(G)=2\) for \(2\le n\le3\), and \(\chi(G)=1\) for \(n=1\).

4.  **Explicit 4‐coloring for large \(n\):**  Label each vertex \(i\) by its two lowest bits:
     - bit0 = \(i\&1\) (the LSB)
     - bit1 = \((i>>1)\&1\) (the 2’s bit)
   Then assign
     ```
     color(i) = bit1*2 + bit0 + 1
     ```
   This produces colors \(1,2,3,4\) in a cycle:
     - numbers with low‐bits “00” → color 1
     - “01” → color 2
     - “10” → color 3
     - “11” → color 4
   One checks easily that:
     - Any odd‐prime edge connects vertices of opposite bit0, so they get different colors.
     - Any “2”‐prime edge connects vertices that differ only in bit1 (with same bit0), so their colors also differ.

5.  **Putting it all together**  
   - For \(n=1\), we need 1 color: \([1]\).  
   - For \(n=2,3\), you can check \(\chi(G)=2\); one valid 2‐coloring is
     - \(n=2\): \([1,2]\)  
     - \(n=3\): \([1,2,2]\)  (you can also do \([1,2,1]\), etc.)  
   - For \(n=4,5\), \(\chi(G)=3\); one can use
     - \(n=4\): \([1,2,2,3]\)  
     - \(n=5\): \([1,2,2,3,3]\)  
   - For \(n\ge6\), \(\chi(G)=4\); use the two‐bit recipe above.

Time Complexity

- We do \(O(1)\) work per vertex to compute its color.  
- Summing over all test cases, \(\sum n \le 2\cdot 10^5\), so overall \(O(n_{\rm total})\).

Space Complexity

- We store an array of size \(n\) for the colors and output it.  So \(O(n)\) per test case.

Implementation in Java

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        // Fast I/O
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder out = new StringBuilder();

        int t = Integer.parseInt(in.readLine().trim());
        while (t-- > 0) {
            int n = Integer.parseInt(in.readLine().trim());
            int k;
            int[] color = new int[n+1];  // 1-based

            if (n == 1) {
                // Only one vertex needs color 1
                k = 1;
                color[1] = 1;
            }
            else if (n == 2) {
                // Two vertices, edge(1,2) since 1^2=3 prime => 2 colors
                k = 2;
                color[1] = 1;
                color[2] = 2;
            }
            else if (n == 3) {
                // Graph on {1,2,3} has edges 1-2 (3),1-3(2), but not 2-3(1)
                // Needs 2 colors
                k = 2;
                // One valid coloring: 1->1, 2->2, 3->2
                color[1] = 1;
                color[2] = 2;
                color[3] = 2;
            }
            else if (n == 4) {
                // Known chi=3
                k = 3;
                // Valid: [1,2,2,3]
                color[1] = 1;
                color[2] = 2;
                color[3] = 2;
                color[4] = 3;
            }
            else if (n == 5) {
                // Known chi=3
                k = 3;
                // Valid: [1,2,2,3,3]
                color[1] = 1;
                color[2] = 2;
                color[3] = 2;
                color[4] = 3;
                color[5] = 3;
            }
            else {
                // For n >= 6, we need 4 colors
                k = 4;
                for (int i = 1; i <= n; i++) {
                    int bit0 = i & 1;
                    int bit1 = (i >> 1) & 1;
                    color[i] = bit1 * 2 + bit0 + 1;
                }
            }

            // Output
            out.append(k).append('\n');
            for (int i = 1; i <= n; i++) {
                out.append(color[i]).append(i == n ? '\n' : ' ');
            }
        }
        System.out.print(out);
    }
}
```

Explanation of Key Steps

1. We handle the very small cases \(n\le5\) by direct enumeration or from known sample colorings.  
2. For \(n\ge6\), we produce a 4-coloring based on the two lowest bits of each vertex label.  
   - This coloring guarantees that no two vertices whose XOR is prime get the same color.  
3. We print the minimum color count \(k\), then the coloring array.  

By the reasoning above, this is both correct and runs in \(O(\sum n)\), which is fast enough for \(n\) up to \(2\times10^5\).