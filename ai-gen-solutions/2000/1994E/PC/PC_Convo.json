[
  {
    "timestamp": "2025-07-24T05:55:41.439084",
    "role": "user",
    "content": "Your recursive DFS may overflow the Java call stack on a chain of up to 1e6 nodes. Please provide one block of Java code that replaces recursion with an explicit stack (iterative post-order) to compute subtree sizes, handles the k=1 special case and the k>=2 OR-all-subtrees case, and is ready for submission without any extra explanation."
  },
  {
    "timestamp": "2025-07-24T05:56:30.206628",
    "role": "assistant",
    "content": "```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int MAXN = 1000005;\n    static int[] head = new int[MAXN];\n    static int[] to   = new int[MAXN];\n    static int[] nxt  = new int[MAXN];\n    static int   ec;\n    static int[] size = new int[MAXN];\n    static int[] stackNode  = new int[MAXN];\n    static int[] stackState = new int[MAXN];\n\n    static void addEdge(int u, int v) {\n        to[ec] = v;\n        nxt[ec] = head[u];\n        head[u] = ec++;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        int t = Integer.parseInt(in.readLine().trim());\n        while (t-- > 0) {\n            int k = Integer.parseInt(in.readLine().trim());\n            boolean multiple = (k >= 2);\n            long globalOR = 0;\n            long bestSingle = 0L;\n\n            for (int ti = 0; ti < k; ti++) {\n                int n = Integer.parseInt(in.readLine().trim());\n                // init adjacency\n                for (int i = 1; i <= n; i++) head[i] = -1;\n                ec = 0;\n\n                if (n > 1) {\n                    StringTokenizer st = new StringTokenizer(in.readLine());\n                    for (int i = 2; i <= n; i++) {\n                        int p = Integer.parseInt(st.nextToken());\n                        addEdge(p, i);\n                    }\n                } else {\n                    // single node tree: no parents line or empty\n                    if (n == 1) {\n                        String line = in.readLine().trim();\n                        if (!line.isEmpty()) {\n                            // in case there's an extra blank\n                        }\n                    }\n                }\n\n                // iterative post-order DFS from root=1\n                int sp = 0;\n                stackNode[sp] = 1;\n                stackState[sp] = 0;\n                sp++;\n                while (sp > 0) {\n                    sp--;\n                    int u = stackNode[sp];\n                    int stt = stackState[sp];\n                    if (stt == 0) {\n                        // pre\n                        stackNode[sp] = u;\n                        stackState[sp] = 1;\n                        sp++;\n                        // push children\n                        for (int e = head[u]; e != -1; e = nxt[e]) {\n                            int v = to[e];\n                            stackNode[sp] = v;\n                            stackState[sp] = 0;\n                            sp++;\n                        }\n                    } else {\n                        // post\n                        int s = 1;\n                        for (int e = head[u]; e != -1; e = nxt[e]) {\n                            s += size[to[e]];\n                        }\n                        size[u] = s;\n                    }\n                }\n\n                int N = size[1];\n                if (multiple) {\n                    for (int i = 1; i <= n; i++) {\n                        globalOR |= size[i];\n                    }\n                } else {\n                    long best = N; \n                    for (int i = 2; i <= n; i++) {\n                        long s = size[i];\n                        long cand = s | (N - s);\n                        if (cand > best) best = cand;\n                    }\n                    bestSingle = best;\n                }\n            }\n\n            long ans = multiple ? globalOR : bestSingle;\n            out.append(ans).append('\\n');\n        }\n        System.out.print(out.toString());\n    }\n}\n```"
  }
]