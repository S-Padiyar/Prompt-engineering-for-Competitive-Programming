[
    {
        "request_timestamp": "2025-07-23T23:08:23.768782",
        "response_timestamp": "2025-07-23T23:13:50.920677",
        "sent_messages": [
            {
                "role": "user",
                "content": "Codeforces Problem:\n\nB. Make It Equal\n\ntime limit per test2 seconds\n\nmemory limit per test512 megabytes\n\nYou are given an integer array a\n\n of size n\n\n. The elements of the array are numbered from 1\n\n to n\n\n.\n\n\n\nYou can perform the following operation any number of times (possibly, zero): choose an index i\n\n from 1\n\n to n\n\n; decrease ai\n\n by 2\n\n and increase a(imodn)+1\n\n by 1\n\n.\n\n\n\nAfter you perform the operations, all elements of the array should be non-negative equal integers.\n\n\n\nYour task is to calculate the minimum number of operations you have to perform.\n\n\n\nInput\n\nThe first line contains a single integer t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nThe first line of each test case contains a single integer n\n\n (2≤n≤2⋅105\n\n).\n\n\n\nThe second line of each test case contains n\n\n integers a1,a2,…,an\n\n (1≤ai≤109\n\n).\n\n\n\nAdditional constraint on the input: the sum of n\n\n over all test cases doesn't exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, print a single integer — the minimum number of operations you have to perform. If it is impossible to make all elements of the array equal, print -1.\n\n\n\nExample\n\nInputCopy\n\n3\n\n2\n\n1 1\n\n3\n\n1 3 2\n\n4\n\n2 1 2 6\n\nOutputCopy\n\n0\n\n-1\n\n3\n\n---\n\nYou are a competitive programming assistant solving Codeforces problems using Java. First, carefully read and restate the problem in your own words to ensure full understanding. Identify the input and output formats, list the constraints, and consider any edge cases that might affect the logic. Next, determine which algorithmic pattern the problem fits best—such as greedy, binary search, two pointers, dynamic programming, or graph traversal—and briefly explain why that pattern applies. Then, plan your solution step by step, describing the key ideas, data structures, or mathematical insights you’ll use. Once your plan is clear, write a clean and fully working Java program. Use import java.util.*; and include a Main class with a main method, using Scanner or BufferedReader for input depending on the constraints. Add comments to explain important logic in the code. After coding, walk through a sample input manually to show how your solution works in practice. Finally, analyze the time and space complexity of your approach using Big-O notation, justifying your answer. Think step by step and only write code once the logic is sound and complete."
            }
        ],
        "received_response": "{\n  \"id\": \"chatcmpl-BwgeaSK3X0m2d0x9txQ3UUhw3YHZO\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"Below is a complete Java solution that runs in O(n) time per test and O(1) extra space (beyond the input array).  The key idea is to set up the elementary linear system that describes how many times \\\\(x_i\\\\) we operate at position \\\\(i\\\\), observe that there is exactly one real solution, and then check whether that solution is in fact a non‐negative integer solution.  If it is, its sum\\n\\\\[\\n  m \\\\;=\\\\; \\\\sum_{i=1}^n x_i\\n\\\\]\\nis exactly the minimum number of operations required; otherwise it is impossible and we print \\\\(-1\\\\).\\n\\n### 1. Restatement\\n\\nWe have an array \\\\(a\\\\) of length \\\\(n\\\\).  An operation at index \\\\(i\\\\) does:\\n  - \\\\(a[i]\\\\) decreases by 2,\\n  - \\\\(a[i+1]\\\\) increases by 1  (where \\\\(i+1\\\\) wraps around to 1 when \\\\(i=n\\\\)).\\n\\nWe wish, after some number of operations, for all entries of \\\\(a\\\\) to become the same nonnegative integer \\\\(k\\\\).  Since each operation reduces the total sum of the array by exactly 1, if we start with sum\\n\\\\[\\n   S \\\\;=\\\\;\\\\sum_{i=1}^n a_i,\\n\\\\]\\nand end with all \\\\(n\\\\) entries equal to \\\\(k,\\\\) the final sum is \\\\(n\\\\cdot k\\\\).  Thus the total number of operations\\n\\\\[\\n   m \\\\;=\\\\; S - n\\\\,k.\\n\\\\]\\nWe want to choose \\\\(k\\\\) (an integer \\\\(\\\\ge0\\\\)) so that the transformation is actually feasible, and among all feasible \\\\(k\\\\) pick the largest (to make \\\\(m=S-nk\\\\) minimal).\\n\\n### 2. Linear‐algebraic formulation\\n\\nCall \\\\(x_i\\\\) the number of times we apply the operation at position \\\\(i\\\\).  Then each such operation removes 2 from \\\\(a_i\\\\) and adds 1 to \\\\(a_{i+1}\\\\).  Hence in total\\n\\\\[\\n   a_i^\\\\text{(final)} \\n     \\\\;=\\\\; a_i^\\\\text{(initial)} \\\\;-\\\\;2\\\\,x_i \\\\;+\\\\; x_{i-1},\\n\\\\]\\nwhere we interpret \\\\(x_0\\\\) as \\\\(x_n\\\\).  We demand \\\\(a_i^\\\\text{(final)}=k\\\\) for all \\\\(i\\\\).  If we put\\n\\\\[\\n   b_i \\\\;=\\\\; a_i^{(\\\\text{init})}-k,\\n\\\\]\\nthen the requirement is\\n\\\\[\\n   -\\\\,x_{i-1} \\\\;+\\\\;2\\\\,x_i \\\\;=\\\\; b_i,\\n    \\\\qquad i=1,\\\\dots,n,\\n\\\\]\\nin a cyclic sense.  \\n\\nOne can check this \\\\(n\\\\times n\\\\) system has exactly one real solution \\\\((x_1,\\\\dots,x_n)\\\\).  We only accept it if\\n1. every \\\\(x_i\\\\) is an integer, and  \\n2. every \\\\(x_i\\\\ge0\\\\).  \\n\\nIn that case, the total number of ops is\\n\\\\[\\n   m \\\\;=\\\\;\\\\sum_{i=1}^n x_i \\\\;=\\\\; S - n\\\\,k,\\n\\\\]\\nand by choosing the largest feasible \\\\(k\\\\) we minimize \\\\(m\\\\).\\n\\n### 3. Algorithm outline\\n\\n1.  Compute \\\\(S=\\\\sum a_i\\\\).  \\n2.  Let \\\\(k=\\\\lfloor S/n\\\\rfloor\\\\).  \\n3.  Form the right‐hand side \\\\(b_i=a_i-k\\\\).\\n4.  Solve the cyclic tridiagonal system\\n       \\\\[\\n         -x_{i-1} + 2\\\\,x_i = b_i,\\\\quad i=1\\\\ldots n,\\\\quad x_0=x_n,\\n       \\\\]\\n   by imposing the cycle‐closure in one pass (see code).  This can be done in \\\\(O(n)\\\\).  \\n5.  Check that all the resulting \\\\(x_i\\\\) are\\n     (a) integral  \\n     (b) \\\\(\\\\ge0\\\\).  \\n   If so, output \\\\(m=S-n\\\\,k\\\\).  Otherwise print \\\\(-1\\\\).\\n\\nBoth the derivation of the one‐pass solver and the proof that there is a unique real solution are standard for cyclic tridiagonal systems.  In fact one shows in one forward/backward sweep that\\n\\\\[\\n   x_i = \\\\alpha_i\\\\,x_1 + \\\\beta_i\\n\\\\]\\nfor \\\\(i=1\\\\ldots n\\\\), and then the equation for \\\\(i=1\\\\) itself closes the cycle and pins down \\\\(x_1\\\\) in closed form.  We then simply check integrality and nonnegativity.\\n\\n### 4. Java Implementation\\n\\n```java\\nimport java.io.*;\\nimport java.util.*;\\n\\npublic class Main {\\n  public static void main(String[] args) throws IOException {\\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\\n    PrintWriter out = new PrintWriter(System.out);\\n\\n    int t = Integer.parseInt(in.readLine().trim());\\n    while (t-- > 0) {\\n      int n = Integer.parseInt(in.readLine().trim());\\n      long[] a = new long[n];\\n      StringTokenizer st = new StringTokenizer(in.readLine());\\n      long S = 0;\\n      for (int i = 0; i < n; i++) {\\n        a[i] = Long.parseLong(st.nextToken());\\n        S += a[i];\\n      }\\n\\n      // 1) The only possible target k is at most floor(S/n).\\n      long k = S / n;\\n\\n      // 2) Build b[i] = a[i] - k.\\n      long[] b = new long[n];\\n      for (int i = 0; i < n; i++) {\\n        b[i] = a[i] - k;\\n      }\\n\\n      // 3) Solve the cyclic system:\\n      //      - x[i-1] + 2*x[i] = b[i],  for i=0..n-1  (with x[-1] = x[n-1]).\\n      //\\n      // We'll do the standard trick:\\n      //   x[i] = alpha[i] * x[0] + beta[i],\\n      // then enforce the i=0 equation to find x[0].\\n\\n      double[] alpha = new double[n];\\n      double[] beta  = new double[n];\\n\\n      // i = 0 row: 2*x[0] - x[n-1] = b[0]\\n      // treat x[n-1] as if it were an unknown multiple of x[0], we start\\n      // the forward sweep at i=1.\\n      alpha[0] = 1.0;   // x[0] = 1*x[0] + 0\\n      beta[0]  = 0.0;\\n\\n      // Forward sweep for i=1..n-1\\n      //    -x[i-1] + 2 x[i] = b[i]\\n      // =>  x[i] = ( b[i] + x[i-1] ) / 2\\n      for (int i = 1; i < n; i++) {\\n        alpha[i] = alpha[i-1] / 2.0;\\n        beta[i]  = (beta[i-1] + b[i]) / 2.0;\\n      }\\n\\n      // Now the closure at i=0 gives:\\n      //    2*x[0] - x[n-1] = b[0]\\n      //    2*x0 - [ alpha[n-1]*x0 + beta[n-1] ] = b[0]\\n      // => x0 * (2 - alpha[n-1]) = b[0] + beta[n-1]\\n      double denom = 2.0 - alpha[n-1];\\n      double numer = b[0] + beta[n-1];\\n\\n      // If denom is zero or numer/denom not an integer => no integral solution.\\n      if (Math.abs(denom) < 1e-14) {\\n        out.println(-1);\\n        continue;\\n      }\\n      double x0d = numer / denom;\\n\\n      // Check x0d is very close to an integer:\\n      long x0 = Math.round(x0d);\\n      if (Math.abs(x0d - x0) > 1e-8) {\\n        // Not integral\\n        out.println(-1);\\n        continue;\\n      }\\n\\n      // Reconstruct all x's and check nonnegativity + integer\\n      boolean ok = true;\\n      long[] x = new long[n];\\n      x[0] = x0;\\n      for (int i = 1; i < n; i++) {\\n        double xd = alpha[i] * x0 + beta[i];\\n        long xi = Math.round(xd);\\n        if (Math.abs(xd - xi) > 1e-8 || xi < 0) {\\n          ok = false;\\n          break;\\n        }\\n        x[i] = xi;\\n      }\\n      if (!ok || x[n-1] < 0) {\\n        out.println(-1);\\n      } else {\\n        // Everything is fine: the minimal m = sum x[i].\\n        long m = 0;\\n        for (long xi : x) m += xi;\\n        out.println(m);\\n      }\\n    }\\n    out.flush();\\n  }\\n}\\n```\\n\\n### 5. Walk‐through on the sample\\n\\nInput:\\n```\\n3\\n2\\n1 1\\n3\\n1 3 2\\n4\\n2 1 2 6\\n```\\n\\nCase 1) \\\\(n=2,\\\\;a=[1,1],\\\\;S=2\\\\).  Then \\\\(\\\\lfloor S/n\\\\rfloor=1\\\\).  We set \\\\(k=1\\\\), so \\\\(b=[0,0]\\\\).  The cyclic system\\n\\\\[\\n  -x_1 + 2x_0 = 0,\\\\quad -x_0+2x_1=0\\n\\\\]\\nclearly has unique real solution \\\\(x_0=x_1=0,\\\\) which is integral and \\\\(\\\\ge0\\\\).  Sum is \\\\(0\\\\), so output `0`.\\n\\nCase 2) \\\\(n=3,\\\\;a=[1,3,2],\\\\;S=6\\\\).  Then \\\\(\\\\lfloor S/n\\\\rfloor=2,\\\\) so \\\\(k=2\\\\) and\\n\\\\[\\n   b = [-1,\\\\,1,\\\\,0].\\n\\\\]\\nOne finds the unique real solution \\\\(x_0,x_1,x_2\\\\) to\\n\\\\[\\n   2x_0 - x_2 = -1,\\\\quad -x_0+2x_1=1,\\\\quad -x_1+2x_2=0\\n\\\\]\\nis \\\\emph{not} integral (indeed it has denominator \\\\(7\\\\) and gives a non‐integral \\\\(x\\\\)).  So we print `-1`.\\n\\nCase 3) \\\\(n=4,\\\\;a=[2,1,2,6],\\\\;S=11\\\\).  Then \\\\(\\\\lfloor 11/4\\\\rfloor=2,\\\\) \\\\(k=2\\\\), and\\n\\\\[\\n   b=[0,\\\\,-1,\\\\,0,\\\\,4].\\n\\\\]\\nThe solver finds exactly\\n\\\\[\\n   x=[1,0,0,2], \\n\\\\]\\nall integers \\\\(\\\\ge0\\\\).  Their sum is \\\\(1+0+0+2=3\\\\).  That matches \\\\(S-nk=11-8=3\\\\).  So we print `3`.\\n\\n### 6. Complexity\\n\\n- We do exactly one pass to compute the sum \\\\(S\\\\).  \\n- We build \\\\(b_i\\\\) in \\\\(O(n)\\\\).  \\n- We do one forward sweep of length \\\\(n\\\\) to build \\\\(\\\\alpha,\\\\beta\\\\).  \\n- Then one backward (implicit) check of the closure and a second sweep to rebuild all \\\\(x_i\\\\).  \\n\\nHence each test is \\\\(O(n)\\\\).  Since \\\\(\\\\sum n\\\\le2\\\\cdot10^5\\\\), the total work is \\\\(O\\\\bigl(\\\\sum n\\\\bigr)=O(2\\\\cdot10^5)\\\\), comfortably within time limits.  Memory overhead is \\\\(O(n)\\\\) per test for arrays, again within the 512 MB limit.\",\n        \"refusal\": null,\n        \"role\": \"assistant\",\n        \"annotations\": [],\n        \"audio\": null,\n        \"function_call\": null,\n        \"tool_calls\": null\n      },\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"protected_material_code\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"protected_material_text\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ],\n  \"created\": 1753326684,\n  \"model\": \"o4-mini-2025-04-16\",\n  \"object\": \"chat.completion\",\n  \"service_tier\": null,\n  \"system_fingerprint\": null,\n  \"usage\": {\n    \"completion_tokens\": 15851,\n    \"prompt_tokens\": 546,\n    \"total_tokens\": 16397,\n    \"completion_tokens_details\": {\n      \"accepted_prediction_tokens\": 0,\n      \"audio_tokens\": 0,\n      \"reasoning_tokens\": 13184,\n      \"rejected_prediction_tokens\": 0\n    },\n    \"prompt_tokens_details\": {\n      \"audio_tokens\": 0,\n      \"cached_tokens\": 0\n    }\n  },\n  \"prompt_filter_results\": [\n    {\n      \"prompt_index\": 0,\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"jailbreak\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ]\n}"
    }
]