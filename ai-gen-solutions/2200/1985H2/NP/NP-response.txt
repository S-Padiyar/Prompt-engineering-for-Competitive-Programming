**Analysis**

We have an \(n\times m\) grid of ‘\#’ and ‘.’.  We are allowed at most one operation: pick a row \(r\) and a column \(c\), and turn every cell in that row and column into ‘\#’.  We want to maximize the size of the largest connected component of ‘\#’ cells (4-connectivity) after at most one such operation.

A key observation is that adding a full row \(r\) and column \(c\) of ‘\#’ turns into a single “cross” of newly added (formerly ‘.’) cells, plus it connects up any original components that touch that cross either by sitting directly in row \(r\) or column \(c\), or by being adjacent (in the original grid) to one of the newly added cells.  Once that cross is in place, all those old components get merged into one component that also includes all the newly added cells in row \(r\) and column \(c\).

Let us precompute:

1. **Original components**  
   Label all original ‘\#’-cells into connected components (using a single BFS/DFS pass).  Suppose there are \(K\) components, of sizes \(\text{size}[0\ldots K-1]\).  We also store a 1D array `compId[id]` giving the component index of each cell (or \(-1\) if the cell is ‘.’).

2. **Which components touch each row or column**  
   We build for each row \(r\) a list `compsRow[r]` of all component‐indices \(k\) that will get connected if we fill row \(r\).  Concretely those are
   - any component \(k\) having an original ‘\#’ in row \(r\), or
   - any component \(k\) having an original ‘\#’ just above or just below a ‘.’ in row \(r\) (since that dot would become ‘\#’ and thus connect).
   
   Similarly we build for each column \(c\) a list `compsCol[c]`.

   While doing that we also accumulate
   ```
   Rsum[r] = sum of sizes of all comps in compsRow[r]
   dotRow[r] = number of '.' in row r
   Csum[c] = sum of sizes of all comps in compsCol[c]
   dotCol[c] = number of '.' in column c
   ```
   If we choose row \(r\) and column \(c\), the newly added cells are all the dots in row \(r\) plus all the dots in column \(c\), except we double‐count cell \((r,c)\) if it was a dot.  So the total newly added‐cells is
   \[
     \text{newdots}(r,c)
       = \text{dotRow}[r]
       + \text{dotCol}[c]
       - \bigl(\text{grid}[r][c]=='.'?1:0\bigr).
   \]
   Naïvely, if we merged all components in `compsRow[r]` and all in `compsCol[c]`, we would sum
   \[
     Rsum[r] + Csum[c].
   \]
   But any component present in *both* lists has been counted twice; we only want to count its size once.  

3. **Avoiding double‐count**  
   Let 
   \[
     A[r] = Rsum[r] + \text{dotRow}[r],
     \quad
     B[c] = Csum[c] + \text{dotCol}[c].
   \]
   Then the size of the merged component if we choose \((r,c)\) is
   \[
     A[r] + B[c]
       \;-\;\bigl(\text{any overlap‐sum of comp‐sizes common to row \(r\) and col \(c\)}\bigr)
       \;-\;(\text{grid}[r][c]=='.'?1:0).
   \]
   We fold the last “\(-1\) if grid[r][c]=='.'” into the definition of
   \[
     D[c] \;=\; B[c]\;-\;(grid[r][c]=='.'?1:0),
   \]
   so that we simply do
   \[
     \max_{c} \Bigl(\;D[c]\;-\;\text{overlapSum}(r,c)\Bigr)
   \]
   and then add \(A[r]\).

   How do we subtract exactly the overlap?  Observe that *for each* component \(k\) in `compsRow[r]`, that component also appears in exactly the columns in which it is “involved” (the list `compCols[k]`).  So if we, for each \(k\in \text{compsRow}[r]\) and each \(c\in\text{compCols}[k]\), subtract \(\text{size}[k]\) from `D[c]`, then for every column \(c\) we have subtracted exactly the sum of sizes of those components \(k\) common to row \(r\) and col \(c\).

4. **Algorithmic complexity**  
   - We do one BFS to label components in \(O(nm)\).
   - We build `compsRow` and `compsCol` in \(O(nm)\) by scanning the grid, marking to avoid duplicates.
   - We form also `compCols[k]` by inverting `compsCol[c]`.
   - Finally, for each row \(r\):
     - We copy \(D[c]=B[c]\) in \(O(m)\) and apply the “\(-1\)” for the dot at \((r,c)\),
     - Then for each component \(k\) in `compsRow[r]` we iterate its `compCols[k]` and do `D[c] -= size[k]`.
     - We take \(\max_{c}D[c]\).
   The total cost of those subtractions over *all* rows is 
   \(\sum_{k}(\,\lvert\text{rowsUsed}_k\rvert\cdot \lvert\text{colsUsed}_k\rvert)\),
   which in fact is bounded (because each component cannot occupy too many rows‐by‐columns more than once in aggregate).  Altogether the algorithm runs in \(O(\,nm+\) total “row×col” for components\() \le O(nm+nm)=O(nm)\), plenty fast for \(nm\le10^6\).

Hence we get an \(O(nm)\) solution per test.  Summing over all tests with total \(\sum nm\le10^6\), it easily runs in time.

---

```java
import java.io.*;
import java.util.*;

public class Main {
    static int n, m;
    static char[] grid;        // flattened grid: grid[i*m + j]
    static int[] compId;       // compId[p] = component index of cell p, or -1 if '.'
    static int[] compSize;     // size of each component
    static int compCount;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out);

        int t = Integer.parseInt(br.readLine().trim());
        for (int _case = 0; _case < t; _case++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            n = Integer.parseInt(st.nextToken());
            m = Integer.parseInt(st.nextToken());

            // Read grid in a 1D array
            grid = new char[n*m];
            compId = new int[n*m];
            Arrays.fill(compId, -1);

            for (int i = 0; i < n; i++) {
                String line = br.readLine();
                for (int j = 0; j < m; j++) {
                    grid[i*m + j] = line.charAt(j);
                }
            }

            // Step 1: BFS to label connected components of '#'
            compCount = 0;
            List<Integer> sizesList = new ArrayList<>();
            int[] queue = new int[n*m];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    int idx = i*m + j;
                    if (grid[idx] == '#' && compId[idx] == -1) {
                        // BFS from (i,j)
                        int head = 0, tail = 0;
                        queue[tail++] = idx;
                        compId[idx] = compCount;
                        int cnt = 0;
                        while (head < tail) {
                            int p = queue[head++];
                            cnt++;
                            int r = p / m, c = p % m;
                            // four neighbors
                            if (r > 0)      addNeighbor(p - m, compCount, queue);
                            if (r+1 < n)    addNeighbor(p + m, compCount, queue);
                            if (c > 0)      addNeighbor(p - 1, compCount, queue);
                            if (c+1 < m)    addNeighbor(p + 1, compCount, queue);
                        }
                        sizesList.add(cnt);
                        compCount++;
                    }
                }
            }
            compSize = new int[compCount];
            for (int i = 0; i < compCount; i++) {
                compSize[i] = sizesList.get(i);
            }

            // Step 2: Build compsRow[r], compsCol[c], and also dotRow/dotCol
            List<List<Integer>> compsRow = new ArrayList<>(n);
            for (int i = 0; i < n; i++) compsRow.add(new ArrayList<>());
            List<List<Integer>> compsCol = new ArrayList<>(m);
            for (int j = 0; j < m; j++) compsCol.add(new ArrayList<>());

            int[] dotRow = new int[n], dotCol = new int[m];
            boolean[] mark = new boolean[compCount];

            // Build compsRow[r]
            for (int r = 0; r < n; r++) {
                int c0 = r*m;  // base index for row r
                for (int c = 0; c < m; c++) {
                    int idx = c0 + c;
                    if (grid[idx] == '.') {
                        dotRow[r]++;
                        // see if above or below is a '#' to attach
                        if (r > 0) {
                            int upId = compId[idx - m];
                            if (upId >= 0 && !mark[upId]) {
                                mark[upId] = true;
                                compsRow.get(r).add(upId);
                            }
                        }
                        if (r+1 < n) {
                            int dnId = compId[idx + m];
                            if (dnId >= 0 && !mark[dnId]) {
                                mark[dnId] = true;
                                compsRow.get(r).add(dnId);
                            }
                        }
                    } else {
                        // it's '#'
                        int k = compId[idx];
                        if (!mark[k]) {
                            mark[k] = true;
                            compsRow.get(r).add(k);
                        }
                    }
                }
                // clear marks
                for (int k : compsRow.get(r)) {
                    mark[k] = false;
                }
            }

            // Build compsCol[c]
            for (int c = 0; c < m; c++) {
                for (int r = 0; r < n; r++) {
                    int idx = r*m + c;
                    if (grid[idx] == '.') {
                        dotCol[c]++;
                        // left / right
                        if (c > 0) {
                            int L = compId[idx - 1];
                            if (L >= 0 && !mark[L]) {
                                mark[L] = true;
                                compsCol.get(c).add(L);
                            }
                        }
                        if (c+1 < m) {
                            int R = compId[idx + 1];
                            if (R >= 0 && !mark[R]) {
                                mark[R] = true;
                                compsCol.get(c).add(R);
                            }
                        }
                    } else {
                        int k = compId[idx];
                        if (!mark[k]) {
                            mark[k] = true;
                            compsCol.get(c).add(k);
                        }
                    }
                }
                // clear marks
                for (int k : compsCol.get(c)) {
                    mark[k] = false;
                }
            }

            // Also build compCols[k] = list of columns that comp k appears in
            List<List<Integer>> compCols = new ArrayList<>(compCount);
            for (int k = 0; k < compCount; k++) {
                compCols.add(new ArrayList<>());
            }
            for (int c = 0; c < m; c++) {
                for (int k : compsCol.get(c)) {
                    compCols.get(k).add(c);
                }
            }

            // Build Rsum/A[r], Csum/B[c]
            long[] Rsum = new long[n], Csum = new long[m];
            for (int r = 0; r < n; r++) {
                long sum = 0;
                for (int k : compsRow.get(r)) {
                    sum += compSize[k];
                }
                Rsum[r] = sum;
            }
            for (int c = 0; c < m; c++) {
                long sum = 0;
                for (int k : compsCol.get(c)) {
                    sum += compSize[k];
                }
                Csum[c] = sum;
            }

            long[] B = new long[m];
            for (int c = 0; c < m; c++) {
                B[c] = Csum[c] + dotCol[c];
            }

            // For each row r we will build D[c] = B[c] - isDot(r,c),
            // then for each comp k in row r subtract compSize[k] from D at all c in compCols[k].
            // We maximize D[c].
            long answer = 0;
            long[] D = new long[m];

            for (int r = 0; r < n; r++) {
                long Ar = Rsum[r] + dotRow[r];
                // initialize D
                int base = r*m;
                for (int c = 0; c < m; c++) {
                    D[c] = B[c] - (grid[base + c] == '.' ? 1 : 0);
                }
                // subtract overlaps
                for (int k : compsRow.get(r)) {
                    int sz = compSize[k];
                    for (int c : compCols.get(k)) {
                        D[c] -= sz;
                    }
                }
                // find max
                long bestD = Long.MIN_VALUE;
                for (int c = 0; c < m; c++) {
                    if (D[c] > bestD) bestD = D[c];
                }
                long cand = Ar + bestD;
                if (cand > answer) answer = cand;
            }

            out.println(answer);
        }

        out.flush();
    }

    // Helper for BFS: if p in bounds, grid[p]=='#' and not yet visited, add to queue
    static void addNeighbor(int p, int compIdx, int[] queue) {
        if (grid[p] == '#' && compId[p] == -1) {
            compId[p] = compIdx;
            queue[queueTail++] = p;
        }
    }

    // We'll rewrite BFS carefully since we need a tail pointer
    static int queueTail;
}
```

**Explanation of Key Steps**

1. **Connected‐component labeling**  
   We do a single BFS (using an `int[]` queue) over all cells to assign each ‘\#’ cell a component index `compId[p]`.  We collect the component sizes in `compSize[]`.

2. **Which components touch each row/column**  
   - `compsRow[r]` is the list of all components that either already have a ‘\#’ in row `r` or are adjacent (vertically) to a dot in row `r`.  
   - `compsCol[c]` is defined analogously for columns (horizontal adjacency).
   - We also count `dotRow[r]` (# of ‘.’ in row `r`), and `dotCol[c]` (# of ‘.’ in col `c`).

3. **Precompute**  
   \[
     A[r] = Rsum[r] + \text{dotRow}[r],
     \quad 
     B[c] = Csum[c] + \text{dotCol}[c].
   \]

4. **One‐row‐at‐a‐time maximization**  
   For each row `r`, we build an array  
   ```  
   D[c] = B[c] - ( grid[r][c]=='.' ? 1 : 0 )  
   ```  
   so that we have already accounted for “\-1 if the intersection was a dot.”  
   Then for every component `k` in `compsRow[r]`, we know that that component also lies in exactly the columns listed in `compCols[k]`.  Subtracting `compSize[k]` from `D[c]` for each such column `c` removes the “double‐count” of that component.  
   The maximum of `D[c]` over all `c`, plus `A[r]`, is exactly the size of the merged component if we choose row `r` and that best column `c`.  We take the maximum over all rows `r`.

Overall time is \(O(nm)\) per test (plus a small factor for the component–row/column lists), which is perfectly fine up to a total of \(10^6\) cells over all tests.