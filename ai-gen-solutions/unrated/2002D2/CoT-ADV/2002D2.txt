D2. DFS Checker (Hard Version)
time limit per test2 seconds
memory limit per test512 megabytes
This is the hard version of the problem. In this version, you are given a generic tree and the constraints on n
 and q
 are higher. You can make hacks only if both versions of the problem are solved.

You are given a rooted tree consisting of n
 vertices. The vertices are numbered from 1
 to n
, and the root is the vertex 1
. You are also given a permutation p1,p2,…,pn
 of [1,2,…,n]
.

You need to answer q
 queries. For each query, you are given two integers x
, y
; you need to swap px
 and py
 and determine if p1,p2,…,pn
 is a valid DFS order†
 of the given tree.

Please note that the swaps are persistent through queries.

†
 A DFS order is found by calling the following dfs
 function on the given tree.

dfs_order = []

function dfs(v):
    append v to the back of dfs_order
    pick an arbitrary permutation s of children of v
    for child in s:
        dfs(child)
dfs(1)
Note that the DFS order is not unique.

Input
Each test contains multiple test cases. The first line contains the number of test cases t
 (1≤t≤104
). The description of the test cases follows.

The first line of each test case contains two integers n
, q
 (2≤n≤3⋅105
, 2≤q≤105
) — the number of vertices in the tree and the number of queries.

The next line contains n−1
 integers a2,a3,…,an
 (1≤ai<i
) — the parent of each vertex in the given tree.

The next line contains n
 integers p1,p2,…,pn
 (1≤pi≤n
, all pi
 are distinct) — the initial permutation p
.

The next q
 lines each contain two integers x
, y
 (1≤x,y≤n,x≠y
) — the positions of the elements to swap in the permutation.

It is guaranteed that the sum of all n
 does not exceed 3⋅105
, and the sum of all q
 does not exceed 105
.

Output
For each test case, print q
 lines corresponding to the q
 queries. For each query, output YES
 if there is a DFS order that exactly equals the current permutation, and output NO
 otherwise.

You can output Yes
 and No
 in any case (for example, strings yEs
, yes
, Yes
, and YES
 will be recognized as a positive response).

Example
InputCopy
3
3 3
1 1
1 2 3
2 3
3 2
1 3
7 4
1 1 2 2 3 3
1 2 3 4 5 6 7
3 5
2 5
3 7
4 6
5 4
1 1 3 4
2 3 4 5 1
5 1
4 5
3 4
2 3
OutputCopy
YES
YES
NO
YES
NO
NO
YES
YES
NO
NO
YES
Note
In the first test case, the permutation p1,p2,…,pn
 after each modification is [1,3,2],[1,2,3],[3,2,1]
, respectively. The first two permutations are valid DFS orders; the third is not a DFS order.

In the second test case, the permutation p1,p2,…,pn
 after each modification is [1,2,5,4,3,6,7],[1,3,5,4,2,6,7],[1,3,7,4,2,6,5],[1,3,7,6,2,4,5]
, respectively.