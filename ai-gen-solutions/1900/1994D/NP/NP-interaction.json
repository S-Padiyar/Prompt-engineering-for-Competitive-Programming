[
    {
        "request_timestamp": "2025-07-23T18:28:17.479987",
        "response_timestamp": "2025-07-23T18:29:45.318202",
        "sent_messages": [
            {
                "role": "user",
                "content": "Codeforces Problem:\n\nD. Funny Game\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nVanya has a graph with n\n\n vertices (numbered from 1\n\n to n\n\n) and an array a\n\n of n\n\n integers; initially, there are no edges in the graph. Vanya got bored, and to have fun, he decided to perform n−1\n\n operations.\n\n\n\nOperation number x\n\n (operations are numbered in order starting from 1\n\n) is as follows:\n\n\n\nChoose 2\n\n different numbers 1≤u,v≤n\n\n, such that |au−av|\n\n is divisible by x\n\n.\n\nAdd an undirected edge between vertices u\n\n and v\n\n to the graph.\n\nHelp Vanya get a connected∗\n\n graph using the n−1\n\n operations, or determine that it is impossible.\n\n\n\n∗\n\nA graph is called connected if it is possible to reach any vertex from any other by moving along the edges.\n\n\n\nInput\n\nEach test consists of multiple test cases. The first line contains an integer t\n\n (1≤t≤103\n\n) — the number of test cases. Then follows the description of the test cases.\n\n\n\nThe first line of each test case contains the number n\n\n (1≤n≤2000\n\n) — the number of vertices in the graph.\n\n\n\nThe second line of each test case contains n\n\n numbers a1,a2,⋯an\n\n (1≤ai≤109\n\n).\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2000\n\n.\n\n\n\nOutput\n\nFor each test case, if there is no solution, then output \"No\" (without quotes).\n\n\n\nOtherwise, output \"Yes\" (without quotes), and then output n−1\n\n lines, where in the i\n\n-th line, output the numbers u\n\n and v\n\n that need to be chosen for operation i\n\n.\n\n\n\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\n\n\nExample\n\nInputCopy\n\n8\n\n2\n\n1 4\n\n4\n\n99 7 1 13\n\n5\n\n10 2 31 44 73\n\n5\n\n87 6 81 44 32\n\n5\n\n62 35 33 79 16\n\n5\n\n6 51 31 69 42\n\n5\n\n52 63 25 21 5\n\n12\n\n33 40 3 11 31 43 37 8 50 5 12 22\n\nOutputCopy\n\nYES\n\n2 1\n\nYES\n\n4 1\n\n2 1\n\n3 2\n\nYES\n\n5 1\n\n4 1\n\n3 1\n\n2 1\n\nYES\n\n4 1\n\n3 1\n\n2 1\n\n5 4\n\nYES\n\n3 1\n\n5 1\n\n2 1\n\n4 2\n\nYES\n\n4 1\n\n5 1\n\n2 1\n\n3 2\n\nYES\n\n2 1\n\n5 2\n\n3 1\n\n4 3\n\nYES\n\n9 1\n\n12 9\n\n11 1\n\n10 1\n\n6 1\n\n7 6\n\n2 1\n\n8 2\n\n5 2\n\n3 1\n\n4 1\n\nNote\n\nLet's consider the second test case.\n\n\n\nFirst operation (x=1)\n\n: we can connect vertices 4\n\n and 1\n\n, since |a4−a1|=|13−99|=|−86|=86\n\n, and 86\n\n is divisible by 1\n\n.\n\n\n\nSecond operation (x=2)\n\n: we can connect vertices 2\n\n and 1\n\n, since |a2−a1|=|7−99|=|−92|=92\n\n, and 92\n\n is divisible by 2\n\n.\n\n\n\nThird operation (x=3)\n\n: we can connect vertices 3\n\n and 2\n\n, since |a3−a2|=|1−7|=|−6|=6\n\n, and 6\n\n is divisible by 3\n\n.\n\nFrom the picture, it can be seen that a connected graph is obtained.\n\n---\n\nUse Java."
            }
        ],
        "received_response": "{\n  \"id\": \"chatcmpl-BwcEpMX1dOucjEMVhZ2u6bENrSmCn\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"**Analysis**\\n\\nWe have \\\\(n\\\\) vertices with integer labels \\\\(a_1,\\\\dots,a_n\\\\), and we must perform exactly \\\\(n-1\\\\) operations, numbered \\\\(x=1,2,\\\\dots,n-1\\\\).  In operation \\\\(x\\\\) we must pick two distinct vertices \\\\(u,v\\\\) so that\\n\\n\\\\[\\n|a_u - a_v|\\\\equiv 0\\\\pmod x,\\n\\\\]\\n\\nand add the edge \\\\((u,v)\\\\).  After all \\\\(n-1\\\\) operations, we must end up with a *connected* graph.  Since we add exactly \\\\(n-1\\\\) edges, having a connected graph forces us to build a spanning tree (no cycles).\\n\\nThus our task is to choose, for each \\\\(x=1\\\\ldots n-1\\\\), a new edge \\\\((u_x,v_x)\\\\) with\\n\\n- \\\\((u_x,v_x)\\\\) not used before,\\n- \\\\(|a_{u_x} - a_{v_x}|\\\\equiv 0\\\\pmod x\\\\),\\n- the resulting \\\\(n-1\\\\) edges form a spanning tree.\\n\\nA neat (and fast enough for \\\\(n\\\\le2000\\\\)) greedy approach is as follows:\\n\\n1.  We keep a DSU (Union–Find) structure to maintain which vertices are already connected by previously chosen edges.  Since we need a tree, each new edge must connect two *different* DSU components.\\n\\n2.  We iterate \\\\(x\\\\) **downwards** from \\\\(n-1\\\\) to \\\\(1\\\\).  At step \\\\(x\\\\) we look for *any* pair \\\\((u,v)\\\\) in different DSU‐components such that\\n   \\\\[\\n     a_u \\\\bmod x \\\\;=\\\\; a_v \\\\bmod x\\n     \\\\quad\\\\Longrightarrow\\\\quad\\n     a_u - a_v \\\\equiv 0\\\\pmod x.\\n   \\\\]\\n   If we find such a pair, we add that edge \\\\((u,v)\\\\) and union their DSU components.  If no such pair exists, we must output “No” — no valid solution.\\n\\n3.  If we succeed in finding an edge for *each* \\\\(x=n-1,n-2,\\\\dots,1\\\\), we will have collected exactly \\\\(n-1\\\\) edges, and by construction they connect new components each time, so the final graph is a spanning tree.  We then print “Yes” and the chosen edges in the order \\\\(x=1,2,\\\\dots,n-1\\\\).\\n\\nTo make step 2 efficient (we cannot afford checking all \\\\(\\\\binom n2\\\\) pairs every time), we use the following trick for each \\\\(x\\\\):\\n\\n- Build buckets of vertices by \\\\(\\\\mathrm{rem} = a_i \\\\bmod x\\\\).  That takes \\\\(O(n)\\\\).\\n- For each nonempty bucket we only need to test the first element \\\\(u\\\\) of the bucket against the others \\\\(v\\\\) in the same bucket, and check if they are in different DSU components.  As soon as we find one such \\\\((u,v)\\\\), we stop and use that pair.  \\n- If *no* bucket yields a cross‐component pair, we fail.\\n\\nSince \\\\(n\\\\le2000\\\\), doing this for each \\\\(x\\\\) costs\\n\\\\[\\n   \\\\sum_{x=1}^{n-1} \\\\Bigl(O(n) \\\\;+\\\\; \\\\text{(scan small bucket until success/fail)}\\\\Bigr)\\n   \\\\;=\\\\; O(n^2),\\n\\\\]\\nwhich is fine for our limits.\\n\\nBelow is a Java implementation.\\n\\n```java\\nimport java.io.*;\\nimport java.util.*;\\n\\npublic class Main {\\n    static class DSU {\\n        int[] parent, rank;\\n        DSU(int n) {\\n            parent = new int[n+1];\\n            rank   = new int[n+1];\\n            for(int i = 1; i <= n; i++){\\n                parent[i] = i;\\n                rank[i] = 0;\\n            }\\n        }\\n        int find(int x){\\n            return parent[x] == x ? x : (parent[x] = find(parent[x]));\\n        }\\n        boolean union(int x, int y){\\n            x = find(x); y = find(y);\\n            if(x == y) return false;\\n            if(rank[x] < rank[y]) {\\n                parent[x] = y;\\n            } else if(rank[y] < rank[x]) {\\n                parent[y] = x;\\n            } else {\\n                parent[y] = x;\\n                rank[x]++;\\n            }\\n            return true;\\n        }\\n    }\\n    \\n    public static void main(String[] args) throws IOException {\\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n        PrintWriter   out= new PrintWriter(System.out);\\n        \\n        int t = Integer.parseInt(br.readLine().trim());\\n        while(t-- > 0){\\n            int n = Integer.parseInt(br.readLine().trim());\\n            StringTokenizer st = new StringTokenizer(br.readLine());\\n            int[] a = new int[n+1];\\n            for(int i = 1; i <= n; i++){\\n                a[i] = Integer.parseInt(st.nextToken());\\n            }\\n            \\n            // Prepare DSU\\n            DSU dsu = new DSU(n);\\n            // Will hold the chosen edge for operation x (1 <= x <= n-1).\\n            int[][] answer = new int[n][2];\\n            boolean possible = true;\\n            \\n            // We'll reuse these buckets for each x\\n            ArrayList<Integer>[] buckets = new ArrayList[n+1];\\n            for(int i = 0; i <= n; i++){\\n                buckets[i] = new ArrayList<>();\\n            }\\n            \\n            // Greedily attempt to pick an edge for x = n-1 down to 1\\n            for(int x = n-1; x >= 1; x--){\\n                // Clear buckets 0..x-1\\n                for(int r = 0; r < x; r++){\\n                    buckets[r].clear();\\n                }\\n                // Distribute vertices into buckets by a[i] % x\\n                for(int i = 1; i <= n; i++){\\n                    int r = a[i] % x;\\n                    buckets[r].add(i);\\n                }\\n                \\n                // Try to find a bucket with at least two DIFFERENT-component vertices\\n                boolean found = false;\\n                int bu = -1, bv = -1;\\n                for(int r = 0; r < x && !found; r++){\\n                    ArrayList<Integer> list = buckets[r];\\n                    if(list.size() < 2) continue;\\n                    int u0 = list.get(0);\\n                    int pu0 = dsu.find(u0);\\n                    for(int j = 1; j < list.size(); j++){\\n                        int v = list.get(j);\\n                        int pv = dsu.find(v);\\n                        if(pu0 != pv){\\n                            bu = u0;\\n                            bv = v;\\n                            found = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                if(!found){\\n                    possible = false;\\n                    break;\\n                }\\n                // Union those components, record the edge\\n                dsu.union(bu, bv);\\n                answer[x][0] = bu;\\n                answer[x][1] = bv;\\n            }\\n            \\n            if(!possible){\\n                out.println(\\\"No\\\");\\n            } else {\\n                out.println(\\\"Yes\\\");\\n                // Output in increasing order of x = 1..n-1\\n                for(int x = 1; x <= n-1; x++){\\n                    out.println(answer[x][0] + \\\" \\\" + answer[x][1]);\\n                }\\n            }\\n        }\\n        \\n        out.flush();\\n    }\\n}\\n```\\n\\n**Explanation of Key Steps**\\n\\n1. **Why DSU (Union–Find)?**  \\n   We must build exactly \\\\(n-1\\\\) edges that form a spanning tree.  Each new edge must connect two different components; if it reconnected vertices already in the same component, we would form a cycle and eventually fail to connect all nodes.\\n\\n2. **Why Bucket by \\\\(a_i \\\\bmod x\\\\)?**  \\n   We need \\\\(|a_u - a_v|\\\\equiv 0\\\\pmod x\\\\).  Equivalently,\\n   \\\\[\\n     a_u \\\\bmod x \\\\;=\\\\; a_v \\\\bmod x.\\n   \\\\]\\n   Bucketing in \\\\(O(n)\\\\) lets us quickly group candidates.\\n\\n3. **Why Greedy from \\\\(x=n-1\\\\) down to \\\\(1\\\\)?**  \\n   Larger \\\\(x\\\\) are more “restrictive” (\\\\(\\\\bmod x\\\\) is coarser), so we lock in those edges first.  Smaller \\\\(x\\\\) are easier to satisfy, hence postponing them gives us more flexibility.\\n\\n4. **Correctness Sketch**  \\n   If at stage \\\\(x\\\\) there *is* an available cross‐component pair divisible by \\\\(x\\\\), our method will find it in \\\\(O(n)\\\\).  If no such pair exists, *no* valid edge can be chosen at operation \\\\(x\\\\), and we must output “No”.\\n\\nThe overall complexity is \\\\(O(n^2)\\\\) per test case, which is fine for \\\\(n\\\\le2000\\\\) and \\\\(\\\\sum n\\\\le2000\\\\).\",\n        \"refusal\": null,\n        \"role\": \"assistant\",\n        \"annotations\": [],\n        \"audio\": null,\n        \"function_call\": null,\n        \"tool_calls\": null\n      },\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"protected_material_code\": {\n          \"filtered\": false,\n          \"detected\": true,\n          \"citation\": {\n            \"URL\": \"https://github.com/jjuyeon/Problem-Solving/tree/8be58dcef5157473b36156ec8c10cda6b4f0decb/SWEA%2FD4_3289.java\",\n            \"license\": \"NOASSERTION\"\n          }\n        },\n        \"protected_material_text\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ],\n  \"created\": 1753309711,\n  \"model\": \"o4-mini-2025-04-16\",\n  \"object\": \"chat.completion\",\n  \"service_tier\": null,\n  \"system_fingerprint\": null,\n  \"usage\": {\n    \"completion_tokens\": 7608,\n    \"prompt_tokens\": 889,\n    \"total_tokens\": 8497,\n    \"completion_tokens_details\": {\n      \"accepted_prediction_tokens\": 0,\n      \"audio_tokens\": 0,\n      \"reasoning_tokens\": 5632,\n      \"rejected_prediction_tokens\": 0\n    },\n    \"prompt_tokens_details\": {\n      \"audio_tokens\": 0,\n      \"cached_tokens\": 0\n    }\n  },\n  \"prompt_filter_results\": [\n    {\n      \"prompt_index\": 0,\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"jailbreak\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ]\n}"
    }
]