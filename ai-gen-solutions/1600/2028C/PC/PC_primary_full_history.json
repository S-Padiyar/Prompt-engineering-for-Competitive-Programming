[
  {
    "role": "user",
    "content": "C. Alice's Adventures in Cutting Cake\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nAlice is at the Mad Hatter's tea party! There is a long sheet cake made up of n\n\n sections with tastiness values a1,a2,…,an\n\n. There are m\n\n creatures at the tea party, excluding Alice.\n\n\n\nAlice will cut the cake into m+1\n\n pieces. Formally, she will partition the cake into m+1\n\n subarrays, where each subarray consists of some number of adjacent sections. The tastiness of a piece is the sum of tastiness of its sections. Afterwards, she will divvy these m+1\n\n pieces up among the m\n\n creatures and herself (her piece can be empty). However, each of the m\n\n creatures will only be happy when the tastiness of its piece is v\n\n or more.\n\n\n\nAlice wants to make sure every creature is happy. Limited by this condition, she also wants to maximize the tastiness of her own piece. Can you help Alice find the maximum tastiness her piece can have? If there is no way to make sure every creature is happy, output −1\n\n.\n\n\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n\n (1≤t≤104\n\n). The description of the test cases follows.\n\n\n\nThe first line of each test case contains three integers n,m,v\n\n (1≤m≤n≤2⋅105\n\n; 1≤v≤109\n\n) — the number of sections, the number of creatures, and the creatures' minimum requirement for tastiness, respectively.\n\n\n\nThe next line contains n\n\n space separated integers a1,a2,…,an\n\n (1≤ai≤109\n\n) — the tastinesses of the sections.\n\n\n\nThe sum of n\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output the maximum tastiness Alice can achieve for her piece, or −1\n\n if there is no way to make sure every creature is happy.\n\n\n\nExample\n\nInputCopy\n\n7\n\n6 2 1\n\n1 1 10 1 1 10\n\n6 2 2\n\n1 1 10 1 1 10\n\n6 2 3\n\n1 1 10 1 1 10\n\n6 2 10\n\n1 1 10 1 1 10\n\n6 2 11\n\n1 1 10 1 1 10\n\n6 2 12\n\n1 1 10 1 1 10\n\n6 2 12\n\n1 1 1 1 10 10\n\nOutputCopy\n\n22\n\n12\n\n2\n\n2\n\n2\n\n0\n\n-1\n\nNote\n\nFor the first test case, Alice can give the first and second section as their own pieces, and then take the remaining 10+1+1+10=22\n\n tastiness for herself. We can show that she cannot do any better.\n\n\n\nFor the second test case, Alice could give the first and second section as one piece, and the sixth section as one piece. She can then take the remaining 10+1+1=12\n\n tastiness for herself. We can show that she cannot do any better.\n\n\n\nFor the seventh test case, Alice cannot give each creature a piece of at least 12\n\n tastiness.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have an array of \\(n\\) cake‐sections \\(a_1,a_2,\\dots,a_n\\), and \\(m\\) creatures each demanding a contiguous “piece” of total tastiness at least \\(v\\).  Alice must slice the cake into \\(m+1\\) contiguous segments, give \\(m\\) of them (one each) to the creatures so that each creature’s segment sum is \\(\\ge v\\), and keep the one remaining segment for herself (possibly empty).  She wants to maximize the tastiness of her own segment; if no way exists to satisfy all creatures, the answer is \\(-1\\).\n\nLet us denote by \\(\\text{pre}[i]\\) the maximum number of contiguous segments of sum \\(\\ge v\\) one can carve from the prefix \\(a_1..a_i\\) by the standard greedy scheme\n\n```\ncurr = 0; \ncount = 0;\nfor x in a_1..a_i:\n  curr += x\n  if curr ≥ v:\n    count += 1\n    curr = 0\n```\n\nand by \\(\\text{suf}[j]\\) the same for the suffix \\(a_j..a_n\\).  It is a known fact that this “greedy‐as‐soon‐as‐you‐reach‐v” partition maximizes the number of pieces meeting the threshold.  \n\nNow suppose Alice’s piece is exactly the subarray \\([ℓ..r]\\).  Then the creatures must be allocated exactly \\(\\,m\\) segments covering all of the outside \\(\\{1..ℓ-1\\}\\cup\\{r+1..n\\}\\).  If we use \\(p\\) segments in the prefix \\([1..ℓ-1]\\) and \\(q\\) segments in the suffix \\([r+1..n]\\), we have \\(p+q=m\\).  The prefix can indeed be dissected into \\(p\\) valid segments iff \\(\\text{pre}[ℓ-1]\\ge p\\), and the suffix into \\(q\\) valid segments iff \\(\\text{suf}[r+1]\\ge q\\).  Hence we need\n\n\\[\n\\text{pre}[ℓ-1]\\;+\\;\\text{suf}[r+1]\\;\\ge\\;m.\n\\]\n\nAlice’s own gain is\n\\[\n\\sum_{i=ℓ}^r a_i\n\\;=\\;\n\\text{Psum}[r]\\;-\\;\\text{Psum}[ℓ-1],\n\\]\nwhere \\(\\text{Psum}[k]\\) is the ordinary prefix‐sum of the \\(a\\)-array.\n\nThus the problem reduces to: among all pairs \\((i,j)\\) with \\(0 \\le i < j \\le n+1\\), such that\n\\[\n\\text{pre}[\\,i\\,] + \\text{suf}[\\,j\\,] \\;\\ge\\; m,\n\\]\nmaximize\n\\[\n\\text{Psum}[\\,j-1\\,]\\;-\\;\\text{Psum}[\\,i\\,].\n\\]\n\nWe can sweep \\(j\\) from \\(1\\) to \\(n+1\\), maintain all indices \\(i\\) with \\(0\\le i<j\\) in a data structure keyed by \\(\\text{pre}[i]\\), storing the minimum \\(\\text{Psum}[i]\\) among those with a given pre‐value.  Then, at time \\(j\\), we know the suffix‐count \\(\\text{suf}[j]\\), so we need all \\(i\\) with\n\\[\n\\text{pre}[i]\\;\\ge\\;m - \\text{suf}[j].\n\\]\nWe do a range‐minimum query over all pre‐values \\(\\ge m-\\text{suf}[j]\\), subtract that from \\(\\text{Psum}[j-1]\\), and keep the maximum result.  A segment‐tree (or Fenwick tree with min) over the discrete range of possible \\(\\text{pre}[\\,i\\,]\\) (which runs from 0 up to \\(\\text{pre}[n]\\)) supports \\(O(\\log n)\\) updates and range‐mins.  Since \\(\\text{pre}[n]\\) is at most \\(n\\), everything runs in \\(O(n\\log n)\\) per test, which is fast enough for \\(\\sum n\\le2\\cdot10^5\\).\n\nIf \\(\\text{pre}[n]<m\\), we can never satisfy all \\(m\\) creatures even with Alice taking an empty segment, so answer \\(-1\\).\n\n-----\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final long INF = (long)1e18;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter  pw = new PrintWriter(System.out);\n\n        int T = Integer.parseInt(br.readLine());\n        while (T-- > 0) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(st.nextToken());\n            long v = Long.parseLong(st.nextToken());\n\n            long[] a = new long[n+1];\n            st = new StringTokenizer(br.readLine());\n            for (int i = 1; i <= n; i++) {\n                a[i] = Long.parseLong(st.nextToken());\n            }\n\n            // Compute prefix-sums\n            long[] psum = new long[n+1];\n            for (int i = 1; i <= n; i++) {\n                psum[i] = psum[i-1] + a[i];\n            }\n\n            // Greedy count of how many segments of sum>=v from the prefix [1..i]\n            int[] pre = new int[n+1];\n            {\n                long curr = 0;\n                int cnt = 0;\n                for (int i = 1; i <= n; i++) {\n                    curr += a[i];\n                    if (curr >= v) {\n                        cnt++;\n                        curr = 0;\n                    }\n                    pre[i] = cnt;\n                }\n            }\n\n            // If we cannot even carve m segments from the entire array, fail immediately\n            if (pre[n] < m) {\n                pw.println(-1);\n                continue;\n            }\n\n            // Greedy count for suffix [i..n]\n            int[] suf = new int[n+2];\n            {\n                long curr = 0;\n                int cnt = 0;\n                suf[n+1] = 0;\n                for (int i = n; i >= 1; i--) {\n                    curr += a[i];\n                    if (curr >= v) {\n                        cnt++;\n                        curr = 0;\n                    }\n                    suf[i] = cnt;\n                }\n            }\n\n            // We sweep j=1..n+1.  At step j we insert index i=j-1 into the segtree,\n            // keyed by pre[i], storing the min psum[i].  Then we query all keys >= m - suf[j].\n            int maxPre = pre[n];       // the maximum possible \"pre\"-value\n            int S = maxPre + 1;        // range of keys [0..maxPre]\n\n            // Build a segment tree for range-min over [0..S-1].\n            int size = 1;\n            while (size < S) size <<= 1;\n            long[] seg = new long[2*size];\n            Arrays.fill(seg, INF);\n\n            // Update function: at key k we install value vv = min(old,k)\n            Runnable pushRoot = null;  // just placeholder\n            class Updater {\n                void update(int k, long vv) {\n                    k += size;\n                    if (seg[k] <= vv) return;  // no need\n                    seg[k] = vv;\n                    for (k >>= 1; k > 0; k >>= 1) {\n                        seg[k] = Math.min(seg[2*k], seg[2*k+1]);\n                    }\n                }\n            }\n            Updater updater = new Updater();\n\n            // Range-min query on [l..r]\n            class Querier {\n                long query(int l, int r) {\n                    long ans = INF;\n                    l += size;\n                    r += size;\n                    while (l <= r) {\n                        if ((l & 1) == 1) ans = Math.min(ans, seg[l++]);\n                        if ((r & 1) == 0) ans = Math.min(ans, seg[r--]);\n                        l >>= 1;\n                        r >>= 1;\n                    }\n                    return ans;\n                }\n            }\n            Querier querier = new Querier();\n\n            long answer = 0;\n\n            // Sweep j = 1..n+1\n            //    insert i=j-1\n            //    let T = m - suf[j], clamp T to [0..maxPre]\n            //    query min psum[i] among pre[i]>=T\n            //    candidate = psum[j-1] - that_min\n            for (int j = 1; j <= n+1; j++) {\n                // insert i = j-1\n                int i = j - 1;\n                int pk = pre[i];       // the key\n                long pv = psum[i];     // the value\n                updater.update(pk, pv);\n\n                // we need pre[i] >= (m - suf[j])\n                int need = m - suf[j];\n                if (need < 0) need = 0;\n                if (need > maxPre) continue;\n\n                long bestPref = querier.query(need, maxPre);\n                if (bestPref != INF) {\n                    long cand = psum[j-1] - bestPref;\n                    if (cand > answer) answer = cand;\n                }\n            }\n\n            pw.println(answer);\n        }\n\n        pw.flush();\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Greedy pre‐ and suf‐counts**  \n   `pre[i]` = how many segments of sum ≥ v we get by scanning from the left up to `i` and cutting as soon as we reach `v`.  \n   `suf[j]` = similar from the right (positions `j..n`).\n\n2. **Feasibility test**  \n   If `pre[n] < m`, we cannot serve `m` creatures even if Alice takes nothing.  Print `-1`.\n\n3. **Maximization via sweeping**  \n   We rewrite Alice’s piece as the subarray `(i+1..j-1)` where `0 ≤ i < j ≤ n+1`.  The creatures must be allotted exactly `m` segments in `[1..i]` plus `m−(segments in suffix)`, so we need  \n   `pre[i] + suf[j] ≥ m`.  \n   Alice’s gain is  \n   ```\n   sum_{k=i+1..j-1}(a[k]) = Psum[j-1] - Psum[i].\n   ```\n   We sweep `j` from `1` to `n+1`.  Before handling `j`, we insert index `i = j−1` into a data structure keyed by `pre[i]` with value `Psum[i]`.  We then need the smallest `Psum[i]` among all keys ≥ `m - suf[j]`.  Subtract that from `Psum[j-1]` to get a candidate, and take the maximum over all `j`.\n\n4. **Data Structure**  \n   We use a segment tree over the key‐range `0..pre[n]`, supporting  \n   - point‐update `key = pre[i]`, value = `min(oldValue, Psum[i])`,  \n   - range‐min query over `[needed..maxKey]`.  \n   Each operation in `O(log n)`, giving overall `O(n log n)` per test.\n\nThis satisfies the constraints up to \\(n\\le2\\times10^5\\) in total across all test cases."
  }
]