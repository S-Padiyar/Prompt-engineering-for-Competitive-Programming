**Analysis**

We have an \(n\times m\) grid of non‐negative mountain heights \(A_{ij}\) and a corresponding grid of types \(T_{ij}\in\{0,1\}\).  We want the total height of type‐0 mountains to equal the total height of type‐1 mountains after performing any number of operations of the form

- choose a \(k\times k\) submatrix,
- add an integer \(c\) (possibly negative) to **all** cells in that submatrix (the mountain **types** do not change).

Let

\[
S_0 = \sum_{i,j:\,T_{ij}=0} A_{ij},\quad
S_1 = \sum_{i,j:\,T_{ij}=1} A_{ij},
\]
and
\[
D = S_0 - S_1.
\]
We wish to know whether we can make \(D=0\) by such operations.

---

### Effect of one \(k\times k\) operation on \(D\)

Define a function
\[
B_{ij} = \begin{cases}
+1, & T_{ij}=0,\\
-1, & T_{ij}=1.
\end{cases}
\]
Note that
\[
D \;=\;\sum_{i,j} A_{ij}\,B_{ij}.
\]
When we add \(c\) to a chosen \(k\times k\) submatrix, say with top‐left corner \((r,c)\to (r+k-1,c+k-1)\), the change in
\[
S_0 \;-\; S_1
\]
is exactly
\[
c\;\times \sum_{\substack{i=r..r+k-1\\j=c..c+k-1}} B_{ij}\;.
\]
Denote
\[
\Delta_{r,c}
=\sum_{i=r}^{r+k-1}\sum_{j=c}^{c+k-1} B_{ij}\,.
\]
Since we may choose **any integer** \(c\) in each operation, the *set* of all achievable changes to \(D\) is exactly all integer linear combinations of the \(\Delta_{r,c}\).  In particular, if
\[
G = \gcd\bigl(\{\Delta_{r,c} : 1\le r\le n-k+1,\;1\le c\le m-k+1\}\bigr),
\]
then one can reach \(D'=0\) from initial \(D\) if and only if
\[
D\;\equiv\;0\pmod G.
\]
If all the \(\Delta_{r,c}\) happen to be zero, then no operation ever changes \(D\), and we need \(D=0\) already.

---

### Algorithm

1.  Read \(n,m,k\).
2.  Read the height array \(A\).
3.  Read the type‐grid \(T\), build
    \[
      B_{ij} = \begin{cases}+1& T_{ij}=0,\\-1& T_{ij}=1,\end{cases}
    \]
    and simultaneously accumulate the initial
    \(\displaystyle D=\sum A_{ij}B_{ij}\).
4.  Build a 2D prefix‐sum array of \(B\), so we can quickly compute
    \(\Delta_{r,c}\) for each \(k\times k\) submatrix in \(O(1)\).
5.  Compute
    \[
      G = \gcd\bigl(|\Delta_{r,c}|\bigr)
    \]
    over all valid top‐left corners \((r,c)\).  (We treat \(\gcd(0,0)=0\).)
6.  If \(G=0\), answer YES iff \(D=0\).  Otherwise answer YES iff \(D\mod G=0\).

The overall time is \(O(nm)\) per test (for the prefix sums and scanning the \((n-k+1)(m-k+1)\) windows), and the total of all \(nm\) over all tests is \(\le250\,000\), so this runs comfortably in time.

---

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out);

        int t = Integer.parseInt(in.readLine().trim());
        while (t-- > 0) {
            StringTokenizer tok = new StringTokenizer(in.readLine());
            int n = Integer.parseInt(tok.nextToken());
            int m = Integer.parseInt(tok.nextToken());
            int k = Integer.parseInt(tok.nextToken());

            // Read the heights
            long[][] A = new long[n][m];
            for (int i = 0; i < n; i++) {
                tok = new StringTokenizer(in.readLine());
                for (int j = 0; j < m; j++) {
                    A[i][j] = Long.parseLong(tok.nextToken());
                }
            }

            // Read the types and build B, and accumulate initial D = sum A[i][j]*B[i][j]
            int[][] B = new int[n][m];
            long D = 0;
            for (int i = 0; i < n; i++) {
                String s = in.readLine();
                for (int j = 0; j < m; j++) {
                    // T=0-->B=+1, T=1-->B=-1
                    B[i][j] = (s.charAt(j) == '0' ? +1 : -1);
                    D += A[i][j] * B[i][j];
                }
            }

            // Build 2D prefix sums of B for O(1) window sums
            int[][] pref = new int[n+1][m+1];
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= m; j++) {
                    pref[i][j] = pref[i-1][j] + pref[i][j-1]
                               - pref[i-1][j-1] + B[i-1][j-1];
                }
            }

            // Compute G = gcd of all |Delta_{r,c}|
            long G = 0;
            for (int r = 0; r + k <= n; r++) {
                for (int c = 0; c + k <= m; c++) {
                    int sumB = pref[r+k][c+k] 
                             - pref[r][c+k] 
                             - pref[r+k][c] 
                             + pref[r][c];
                    G = gcd(G, Math.abs((long)sumB));
                }
            }

            // Check feasibility
            boolean ok;
            if (G == 0) {
                // No operation can change D => must already be zero
                ok = (D == 0);
            } else {
                // We need D ≡ 0 (mod G)
                ok = (D % G == 0);
            }

            out.println(ok ? "YES" : "NO");
        }

        out.flush();
    }

    // Euclidean gcd for nonnegative a,b
    static long gcd(long a, long b) {
        while (b != 0) {
            long t = a % b;
            a = b;
            b = t;
        }
        return a;
    }
}
```

**Explanation of Key Steps**

1.  We encode mountain‐type ‘0’ as \(+1\) and type ‘1’ as \(-1\).  Then  
   \[
     D = \sum A_{ij}\,(+1\text{ if }T_{ij}=0,\,-1\text{ if }T_{ij}=1)
       = (\text{sum of heights of type 0}) - (\text{sum of heights of type 1}).
   \]
2.  A single \(k\times k\) operation that adds \(c\) to that block changes  
   \[
     D\; \to\; D \;+\; c\!\sum_{(i,j)\in\text{block}} B_{ij}.
   \]
3.  Since \(c\) can be *any* integer, the *possible* changes to \(D\) are all integer combinations of the block‐sums \(\Delta_{r,c}\).  Thus the subgroup of \(\mathbb{Z}\) generated by these \(\Delta\)-values has size \(\gcd(\Delta_{r,c})\).  We can reach \(D=0\) if and only if
   \[
     D \equiv 0\pmod{\gcd\{\Delta_{r,c}\}}.
   \]
4.  We compute all \(\Delta_{r,c}\) efficiently via a 2D prefix‐sum on \(B\).

This runs in \(O(nm)\) per test, comfortably within the problem limits.