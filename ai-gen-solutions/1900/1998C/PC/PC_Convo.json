[
  {
    "timestamp": "2025-07-24T06:17:27.536977",
    "role": "user",
    "content": "The code’s binary‐search calls for counting elements ≥ d and < d are incorrect when there are duplicates (and you call binarySearch twice). Please fix by implementing proper `lowerBound` on the sorted arrays (one for `all[]`, one for `raisable[]`) so you get the first index where `val >= d`, then compute counts from that. Then provide a single Java code block ready for submission."
  },
  {
    "timestamp": "2025-07-24T06:18:32.981281",
    "role": "assistant",
    "content": "Below is a ready‐to‐submit Java solution.  It replaces the two calls to `Collections.binarySearch` with a proper `lowerBound` on sorted `long[]`’s, so that counting “\\(\\ge d\\)” and “\\(<d\\)” is robust even with duplicates.\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static BufferedReader in;\n    static StringTokenizer tok;\n\n    static String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            String line = in.readLine();\n            if (line == null) return null;\n            tok = new StringTokenizer(line);\n        }\n        return tok.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    // Returns first index i in arr[] such that arr[i] >= key,\n    // or arr.length if all elements < key.\n    static int lowerBound(long[] arr, long key) {\n        int lo = 0, hi = arr.length;\n        while (lo < hi) {\n            int mid = (lo + hi) >>> 1;\n            if (arr[mid] < key) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        tok = null;\n\n        int t = nextInt();\n        StringBuilder sb = new StringBuilder();\n        while (t-- > 0) {\n            int n = nextInt();\n            long k = nextLong();\n            long[] a = new long[n];\n            int[] b = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            for (int i = 0; i < n; i++) {\n                b[i] = nextInt();\n            }\n\n            // Sort a copy so we can do medians and >= d counts quickly\n            long[] all = a.clone();\n            Arrays.sort(all);\n\n            // K = how many elements must be >= d to raise the median of an (n-1)-array\n            int K = n - (n/2);\n\n            // Precompute the two key positions in 'all' for median-with-one-removed:\n            // Mth = all[floor(n/2)-1], M1th = all[floor(n/2)]\n            long Mth  = all[n/2 - 1];\n            long M1th = all[n/2];\n\n            // Case A preprocessing:\n            // maxBaseIfB1 = max over i with b[i]==1 of (a[i] + median(c_i))\n            long maxBaseIfB1 = Long.MIN_VALUE;\n            // Case B preprocessing:\n            // amax0 = max a[i] among those with b[i]==0\n            long amax0 = Long.MIN_VALUE;\n\n            for (int i = 0; i < n; i++) {\n                long medCi = (a[i] <= Mth ? M1th : Mth);\n                if (b[i] == 1) {\n                    maxBaseIfB1 = Math.max(maxBaseIfB1, a[i] + medCi);\n                } else {\n                    amax0 = Math.max(amax0, a[i]);\n                }\n            }\n\n            // Build the list of raisable values (those with b[i]==1),\n            // sort them, build prefix sums.\n            ArrayList<Long> list = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                if (b[i] == 1) list.add(a[i]);\n            }\n            Collections.sort(list);\n            int R = list.size();\n            long[] rais = new long[R];\n            long[] pref = new long[R+1];\n            for (int i = 0; i < R; i++) {\n                rais[i] = list.get(i);\n                pref[i+1] = pref[i] + rais[i];\n            }\n\n            // A predicate that checks if we can achieve score >= D\n            java.util.function.LongPredicate canAchieve = (D) -> {\n                // --- Case A: pick i with b[i]==1, invest all k in a[i]\n                if (maxBaseIfB1 != Long.MIN_VALUE && maxBaseIfB1 + k >= D) {\n                    return true;\n                }\n\n                // --- Case B: pick i0 with b[i0]==0, invest all k in the median of the others\n                if (amax0 == Long.MIN_VALUE) {\n                    // no zero-bit index => can't do case B\n                    return false;\n                }\n                long d = D - amax0;\n                if (d <= 0) {\n                    // needing median >=0 is always free\n                    return true;\n                }\n\n                // Count how many are already >= d in the whole array:\n                int idxAll = lowerBound(all, d);\n                int cntFree = (n - idxAll);\n                // exclude the chosen i0 if it was among those >= d\n                if (amax0 >= d) cntFree--;\n\n                // Count how many are < d but raisable (b[j]==1)\n                int idxR = lowerBound(rais, d);\n                int cntRaisable = idxR;  // those at indices [0..idxR-1]\n\n                if (cntFree + cntRaisable < K) {\n                    return false;\n                }\n                int need = Math.max(0, K - Math.max(0, cntFree));\n                if (need > cntRaisable) {\n                    return false;\n                }\n                // cost = sum_{i<need} (d - rais[i]) = need*d - sum(ra[i])\n                long sumSmall = pref[need];\n                long cost = need * d - sumSmall;\n                return cost <= k;\n            };\n\n            // Binary‐search the maximum D for which canAchieve(D) is true\n            long lo = 0, hi = (long)2e18;\n            while (lo < hi) {\n                long mid = (lo + hi + 1) >>> 1;\n                if (canAchieve.test(mid)) {\n                    lo = mid;\n                } else {\n                    hi = mid - 1;\n                }\n            }\n\n            sb.append(lo).append('\\n');\n        }\n\n        System.out.print(sb);\n    }\n}\n```\n\nExplanation of the fixes:\n\n1. We convert the “raisable” values into a primitive `long[] rais[]` so we can do an \\(O(\\log R)\\) custom `lowerBound` on it.\n2. We also use the same `lowerBound` on the fully sorted `all[]` to count how many elements \\(\\ge d\\).\n3. Counting  \n   - `cntFree = n − lowerBound(all, d)` gives how many \\(a_j\\ge d\\).  \n   - `cntRaisable = lowerBound(rais, d)` gives how many \\(a_j<d\\) among the raisable group.\n4. We then check if we can fill the required \\(K\\) “slots” to push the median up to \\(d\\) with at most \\(k\\) operations.\n\nThis runs in \\(O(n\\log n + \\log(\\text{answer})\\times \\log n)\\) per test, and handles duplicates correctly."
  }
]