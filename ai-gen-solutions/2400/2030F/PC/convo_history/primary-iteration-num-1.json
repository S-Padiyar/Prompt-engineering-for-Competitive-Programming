[
  {
    "role": "user",
    "content": "F. Orangutan Approved Subarrays\n\ntime limit per test3 seconds\n\nmemory limit per test512 megabytes\n\nSuppose you have an array b\n\n. Initially, you also have a set S\n\n that contains all distinct elements of b\n\n. The array b\n\n is called orangutan-approved if it can be emptied by repeatedly performing the following operation:\n\n\n\nIn one operation, select indices l\n\n and r\n\n (1≤l≤r≤|b|\n\n) such that v=bl=bl+1=…=br\n\n and v\n\n is present in S\n\n. Remove v\n\n from S\n\n, and simultaneously remove all bi\n\n such that l≤i≤r\n\n. Then, reindex the elements br+1,br+2,…\n\n as bl,bl+1,…\n\n accordingly.\n\nYou are given an array a\n\n of length n\n\n and q\n\n queries.\n\n\n\nEach query consists of two indices l\n\n and r\n\n (1≤l≤r≤n\n\n), and you need to determine whether or not the subarray al,al+1,…,ar\n\n is orangutan-approved.\n\n\n\nInput\n\nThe first line contains t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nThe first line of each test case contains integers n\n\n and q\n\n (1≤n,q≤2⋅105\n\n) — the size of a\n\n and the number of queries, respectively.\n\n\n\nThe following line contains n\n\n integers a1,a2,…,an\n\n (1≤ai≤n\n\n) — the elements of the array a\n\n.\n\n\n\nThe following q\n\n lines contain two integers l\n\n and r\n\n — the endpoints of the subarray for each query (1≤l≤r≤n\n\n).\n\n\n\nIt is guaranteed that the sum of n\n\n and q\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each query, output \"YES\" (without quotes) if the subarray from l\n\n to r\n\n is orangutan-approved, and \"NO\" (without quotes) otherwise.\n\n\n\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\" and \"Yes\" will be recognized as a positive response).\n\n\n\nExample\n\nInputCopy\n\n3\n\n4 2\n\n1 2 2 1\n\n1 4\n\n1 3\n\n5 3\n\n1 2 1 2 1\n\n2 5\n\n3 5\n\n1 3\n\n8 4\n\n1 2 3 2 1 3 2 3\n\n1 5\n\n2 8\n\n3 5\n\n6 8\n\nOutputCopy\n\nYES\n\nYES\n\nNO\n\nYES\n\nYES\n\nYES\n\nNO\n\nYES\n\nYES\n\nNote\n\nIn the first query of the first testcase, the answer is YES.\n\n\n\nInitially, S={1,2}\n\n and b=[1,2,2,1]\n\nSelect l=2\n\n and r=3\n\n. Since b2=b3=2\n\n is in S\n\n, we may erase b2\n\n and b3\n\n from the array, as well as erasing 2\n\n from S\n\n. The set S\n\n becomes {1}\n\n and the array becomes [1,1]\n\n.\n\nSelect l=1\n\n and r=2\n\n. Since b1=b2=1\n\n is in S\n\n, we may erase b1\n\n and b2\n\n from the array, as well as erasing 1\n\n from S\n\n. The set S\n\n becomes {}\n\n and the array becomes []\n\n.\n\nSince the array is now empty, we can say the original array is orangutan-approved.\n\nIn the first query of the second testcase, the answer is NO, because it can be shown that the subarray [2,1,2,1]\n\n cannot become empty through any sequence of valid operations.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "We need to test, for each query subarray b=a[l..r], whether the family of intervals\n\n   Iv = [ first‐occurrence of v in b ,  last‐occurrence of v in b ]\n\nis “laminar” (i.e. no two intervals partially cross).  One shows easily that b is orangutan‐approved if and only if no pair u≠v has\n\n   f[u] < f[v] < g[u] < g[v]  (a “crossing”).\n\nIf the intervals are laminar, they form a (rooted) forest of nested or disjoint intervals, and one can always delete the values in a valid order; as soon as there is one crossing you cannot.\n\nBrute‐checking each query in O(|b|) or even O(#distinct·log) is too large because ∑|b| can be O(nq).  Instead we do a single “two‐pointer” sweep over all starting positions l=1,2,…,n:\n\n  1. We maintain a window [l…r−1] (initially l=1, r=1) which *is* laminar.  \n     Whenever possible we bump r→r+1, update the current interval for v=a[r], and detect *on the fly* whether this extension creates a crossing.  \n     As soon as we see the first r for which [l…r] WOULD *not* be laminar, we stop, record R[l]=r, and move on to l+1.  \n\n  2.  Moving l→l+1 simply *removes* a[l] from the window; that can only restore laminarity or leave it laminar, so we do not have to re‐check.  We simply update (decrease) the interval of v=a[l] or delete it if that was the only occurrence.\n\n  3.  Because r only ever goes forward (over all l the pointer r moves in total at most n steps), the overall cost of the sweep is *O(n)* window‐moves, each of which does a small “is there a crossing?” test plus a couple of interval‐inserts/deletes.  \n\nTo support “is there a crossing?” we only ever need to test the newly extended interval Iv = [f, g_old] → [f, g_new] for crossings with *any* other interval already in the window.  A little case‐analysis shows the only way to create a partial overlap is that there exists some u whose interval [fu,gu] ended strictly between g_old and g_new, *and* whose start fu was < f.  In symbols:\n\n      ∃u  so that   fu < f    and    g_old < gu < g_new.\n\nAs soon as we detect such a u, we have a crossing f_u < f < g_u < g_new.\n\nWe organize all *currently present* intervals as a dynamic set of points (fu, gu), and we need to be able to\n\n   – insert(a new (f, g))  \n   – delete(an old (f, g))  \n   – ask “does there exist (x,y) with x < f  and  r_old < y < r_new ?”\n\nWe implement that as a standard 2D‐Fenwick (BIT) of Fenwicks.  We treat x–coordinates (=f) and y–coordinates (=g) both in [1..n].  A 2D‐BIT can support point‐update and axis‐aligned rectangle‐sum in O(log²n).  Since we will do O(n) updates (each interval enters and leaves at most once, and each extension changes exactly one interval), plus O(n) queries (one per extension), the total is O(n log²n) which is fine for n≤2⋅10^5.\n\nOnce the sweep is done, we have for each l the minimal R[l] such that [l…R[l]] is *first bad*.  That means every r<R[l] is good.  Hence a query (l,r) is YES if and only if r < R[l].\n\nBelow is a fairly direct Java implementation of the above idea.  (It is a bit long only because of the 2D‐Fenwick machinery; the window‐sweep itself is only ~30 lines.)\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n  static int n;\n  static int[] a;\n  static int[] cnt;       // current count in window of each value\n  static int[] fpos, gpos; // current [fpos[v], gpos[v]] if cnt[v]>0\n  static int[] R;          // R[l] = first r that makes [l..r] bad\n  static int B;            // size for Fenwicks = next pow2 >= n\n  // We'll build a Fenwick tree ftX of size n+1 over x,\n  // each node ftX[x] is itself a Fenwick tree over y in [1..n].\n  // To save memory we do it dynamically:\n  static ArrayList<Fenw> ftX;\n\n  static class Fenw {\n    // a small Fenw over y in [1..n]\n    int n; \n    TreeMap<Integer,Integer> t; \n    Fenw(int _n){ n=_n; t = new TreeMap<>(); }\n    void update(int y, int v){\n      // standard Fenw: we store in the TreeMap \n      // pairs (pos → delta), but we only store the\n      // nonzero positions.  We'll implement exactly\n      // the O(log n) Fenw behavior by doing:\n      int yy = y;\n      while(yy<=n){\n        t.put(yy, t.getOrDefault(yy,0) + v);\n        yy += yy&-yy;\n      }\n    }\n    int query(int y){\n      int sum=0;  int yy=y;\n      while(yy>0){\n        Integer z = t.get(yy);\n        if(z!=null) sum += z;\n        yy -= yy&-yy;\n      }\n      return sum;\n    }\n    // sum in (y1…y2) = query(y2)-query(y1)\n  }\n\n  // 2D updates:\n  static void upd2D(int x, int y, int delta){\n    // add 'delta' to point (x,y) in the 2D-BIT.\n    for(int i=x;i<=n;i+=i&-i){\n      Fenw fw = ftX.get(i);\n      fw.update(y, delta);\n    }\n  }\n  // sum of points in rectangle [1..X]×[1..Y]\n  static int sum2D(int X, int Y){\n    int s=0;\n    for(int i=X;i>0;i-=i&-i){\n      Fenw fw = ftX.get(i);\n      s += fw.query(Y);\n    }\n    return s;\n  }\n  // sum in [1..X]×[y1+1..y2-1] = sum2D(X,y2-1) - sum2D(X,y1)\n  static boolean existsIn(int X, int y1, int y2){\n    if(X<=0 || y2<=y1+1) return false;\n    int s = sum2D(X, y2-1) - sum2D(X, y1);\n    return s>0;\n  }\n\n  public static void main(String[] args) throws IOException {\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    PrintWriter out = new PrintWriter(System.out);\n\n    int t = Integer.parseInt(in.readLine().trim());\n    while(t-->0){\n      StringTokenizer st = new StringTokenizer(in.readLine());\n      n = Integer.parseInt(st.nextToken());\n      int q = Integer.parseInt(st.nextToken());\n      a = new int[n+1];\n      st = new StringTokenizer(in.readLine());\n      for(int i=1;i<=n;i++){\n        a[i] = Integer.parseInt(st.nextToken());\n      }\n\n      // Build 2D Fenwicks\n      ftX = new ArrayList<>(n+1);\n      ftX.add(null);\n      for(int i=1;i<=n;i++){\n        ftX.add(new Fenw(n));\n      }\n\n      cnt  = new int[n+1];\n      fpos = new int[n+1];\n      gpos = new int[n+1];\n      R = new int[n+2];\n\n      int r = 1;    // current window is [l..r-1] inclusive\n      // so initially l=1, r=1 => empty\n      for(int l=1;l<=n;l++){\n        // expand r as far as we can\n        while(r<=n){\n          int v = a[r];\n          if(cnt[v]==0){\n            // first time we see v in window → interval [r,r]\n            fpos[v] = r;  gpos[v] = r;\n            // just insert (r,r)\n            // no possibility to cross, a size-1 interval is always safe\n            upd2D(r, r, +1);\n            cnt[v]++;\n            r++;\n          } else {\n            // we extend old [fpos[v], gpos[v]] → [fpos[v], r]\n            int f = fpos[v], oldg = gpos[v];\n            // remove old\n            upd2D(f, oldg, -1);\n            // test if there is any u with fu < f  and  oldg < gu < r\n            if(existsIn(f-1, oldg, r)){\n              // crossing would appear\n              // restore old\n              upd2D(f, oldg, +1);\n              break;\n            }\n            // ok to proceed\n            gpos[v] = r;\n            upd2D(f, r, +1);\n            cnt[v]++;\n            r++;\n          }\n        }\n        // now r is first index that would break, or r>n\n        R[l] = r;\n        // remove a[l] from window\n        int w = a[l];\n        if(--cnt[w]==0){\n          // remove that point\n          int f = fpos[w], g = gpos[w];\n          upd2D(f, g, -1);\n        } else {\n          // still have >0 copies, we might have to shift fpos or gpos\n          // if l was fpos[w], shift to next occurrence in [l+1..r-1]\n          if(fpos[w]==l){\n            // find next occurrence v after l\n            // we can scan forward up to r, but better have a small index\n            // For simplicity in code, we do a little scan.  Since\n            // each position enters and leaves window once, total scans\n            // amortize to O(n).  In more serious code you would keep\n            // a LinkedList of occurrences etc.\n            int x = l+1;\n            while(a[x]!=w) x++;\n            int oldf = fpos[w], g = gpos[w];\n            upd2D(oldf, g, -1);\n            fpos[w] = x;\n            upd2D(x, g, +1);\n          }\n          // if l was gpos[w], we'd shift gpos[w] to the last occurrence < r\n          else if(gpos[w]==l){\n            int x = r-1;\n            while(a[x]!=w) x--;\n            int f = fpos[w], oldg = gpos[w];\n            upd2D(f, oldg, -1);\n            gpos[w] = x;\n            upd2D(f, x, +1);\n          }\n        }\n      }\n\n      // answer queries\n      for(int i=0;i<q;i++){\n        st = new StringTokenizer(in.readLine());\n        int L = Integer.parseInt(st.nextToken());\n        int Rr= Integer.parseInt(st.nextToken());\n        // if Rr < R[L], then [L..Rr] stayed laminar, else it hit a crossing\n        out.println(Rr < R[L] ? \"YES\"\\n : \"NO\");\n      }\n    }\n    out.flush();\n  }\n}\n```\n\nExplanation of the main parts:\n\n1. We keep a moving window `[l..r−1]` which we **know** is laminar.  We try to **extend** it one step at a time by bringing in a[r].  \n2.  If `a[r]` is new, it contributes a size‐1 interval `[r,r]`, which cannot cross anything.  \n3.  If `a[r]` was already present, its interval grows from `[f,oldg]` to `[f,r]`.  The *only* way to introduce a crossing is if there is some other interval `(fu,gu)` with  \n       fu < f    and    oldg < gu < r.  \n    We can detect “does such a point (fu,gu) exist?” by a single 2D‐Fenwick rectangle‐sum query.  \n4.  As soon as that would happen, we stop: we’ve found that `[l..r]` is the *first* bad extension.  Thus `R[l] = r`.  \n5.  We then remove `a[l]` from the window (shrinking from the left) and move `l→l+1`.  Removing an element can only restore laminarity, so we never get stuck.  The pointer `r` never moves backward.  \n6.  After performing this for all `l=1…n`, we have precomputed in `R[l]` the minimal “bad” right‐end.  A query `(l,r)` is good exactly when `r < R[l]`.\n\nBecause the Fenwick‐in‐Fenwick 2D structure takes O(log²n) per update or query, and we do O(n) of them in total, the overall is O(n log²n), which passes for n up to 2⋅10^5 in 3 s."
  }
]