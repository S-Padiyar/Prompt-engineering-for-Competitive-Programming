**Analysis**

Let 
\(S_i = a_1 + a_2 + \cdots + a_i\)
be the prefix‐sums of the array, and let
\[
\min S = \min_{1\le i\le n} S_i.
\]
We claim:

1.  The maximum achievable final value 
   \[
     c_n
   \]
   is
   \[
     k \;=\;
     \begin{cases}
       S_n, & \min S \ge 0,\\
       S_n + 2\bigl(-\min S\bigr), & \min S<0.
     \end{cases}
   \]
   Equivalently when all prefixes are nonnegative we never gain anything by any \(\lvert\cdot\rvert\)-operation (so we end up with \(S_n\)), and if the smallest prefix sum is \(\min S<0\), then one optimal strategy is to “flip” exactly at one index \(j\) where \(S_j=\min S\), which increases the final sum by \(2(-\min S)\).

2.  If \(\min S\ge0\), every choice of “take abs or not” at each of the \(n\) positions produces exactly the final value \(S_n\), so the answer is simply
\[
   2^n \pmod{998244353}.
\]
   (Even if \(\lvert c_{i-1}+a_i\rvert\) or not makes no numeric change when \(c_{i-1}+a_i\ge0\), each position still offers 2 distinct choices.)

3.  If \(\min S<0\), write
\[
   M = -\,\min S > 0,
   \quad
   k = S_n + 2M.
\]
   Let
\[
   P = \{\,j\mid S_j = \min S\}
\]
   be the set of all indices \(j\) where the running sum achieves its global minimum.  One can show that **any** procedure that (a) does not apply a “\(\lvert\cdot\rvert\)” on any earlier negative prefix and then (b) does apply a “\(\lvert\cdot\rvert\)” at exactly one \(j\in P\), and (c) afterwards can do anything, will end up with \(c_n=k\).  All other procedures end up strictly below \(k\).

   -  Before that chosen \(j\), every time \(S_i<0\) you must choose “no‐abs” (otherwise you would flip an earlier prefix and ruin getting the true minimum).  But whenever \(S_i\ge0\), abs‐or‐no‐abs makes no numeric difference, so you get a factor of \(2\).
   -  At the chosen \(j\in P\), you **must** take the abs so as to flip that minimum prefix.  (Exactly one choice.)
   -  After index \(j\), the partial sum is always \(\ge0\) (you have lifted it up by \(2M\)), so from then on each position again contributes a factor of \(2\) (abs or not gives the same result).

   Hence for each \(j\in P\) the number of ways is
   \[
     2^{\#\{\,1\le i<j: S_i\ge0\}}\;\times\;1\;\times\;2^{\,n-j}
     \;=\;
     2^{(j-1 - \#\{i<j:S_i<0\}) + (n-j)}
     \;=\;
     2^{\,n - 1 - \#\{i<j:S_i<0\}\!}\,.
   \]
   Summing over all \(j\in P\) gives the total count of maximum‐ending procedures.

Overall algorithm per test:

1.  Read \(n\) and the array \(a\).
2.  Compute prefix‐sums \(S_1,\dots,S_n\) and find \(\min S\).
3.  If \(\min S\ge0\), answer = \(2^n\pmod{998244353}\).
4.  Otherwise:
    -  Let \(\mathrm{negBefore}[i]\) = the number of indices \(k<i\) with \(S_k<0\).  We can build this in one scan.
    -  Collect all positions \(j\) for which \(S_j = \min S\).
    -  The answer is
      \[
        \sum_{j:\,S_j=\min S}
          2^{\,n - 1 - \mathrm{negBefore}[j]}
        \;\bmod\;998244353.
      \]
5.  Precompute powers of two up to the largest \(n\) needed (sum of all \(n\le3\cdot10^5\)).

This runs in \(O(n)\) time per test, with a total of \(O(\sum n)\le3\times10^5\), which is easily within the 2 s limit.

Below is a complete Java implementation.

```java
import java.io.*;
import java.util.*;

public class Main {
    static final int MOD = 998244353;
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // Precompute powers of two up to 300,000
        int MAX = 300000;
        long[] pow2 = new long[MAX+1];
        pow2[0] = 1;
        for (int i = 1; i <= MAX; i++) {
            pow2[i] = (pow2[i-1] << 1) % MOD;
        }

        int t = Integer.parseInt(in.readLine().trim());
        while (t-- > 0) {
            int n = Integer.parseInt(in.readLine().trim());
            st = new StringTokenizer(in.readLine());
            long[] a = new long[n+1];
            for (int i = 1; i <= n; i++) {
                a[i] = Long.parseLong(st.nextToken());
            }

            // 1) Build prefix-sums S and track minimum
            long[] S = new long[n+1];
            long minS = Long.MAX_VALUE;
            for (int i = 1; i <= n; i++) {
                S[i] = S[i-1] + a[i];
                if (S[i] < minS) minS = S[i];
            }

            // If no prefix ever went negative, all choices yield the same final sum S[n]
            if (minS >= 0) {
                // 2^n mod
                System.out.println(pow2[n]);
                continue;
            }

            // Otherwise we must flip at one of the positions j where S[j] == minS
            // Build negBefore[i] = count of k<i with S[k]<0
            int[] negBefore = new int[n+1];
            int cntN = 0;
            for (int i = 1; i <= n; i++) {
                negBefore[i] = cntN;
                if (S[i] < 0) cntN++;
            }

            // Sum over those j with S[j] == minS
            long ans = 0;
            for (int j = 1; j <= n; j++) {
                if (S[j] == minS) {
                    // exponent = n - 1 - negBefore[j]
                    int exp = n - 1 - negBefore[j];
                    ans = (ans + pow2[exp]) % MOD;
                }
            }

            System.out.println(ans);
        }
    }
}
```

**Explanation of Key Steps**

-  We only ever need **one** “flip” (absolute‐value application) at one of the indices where the prefix‐sum first reaches its global minimum.  Flipping there yields the maximal possible uplift in the final sum.
-  Before that index, every time the prefix was negative you are **forced** to *not* take the absolute‐value (otherwise you would lose that global minimum).  Whenever the prefix‐sum was nonnegative, taking or not taking absolute makes *no* numerical difference, so it contributes a factor of 2 of “distinct ways.”
-  At the chosen minimum‐achieving index you **must** apply the absolute‐value to effect the sign‐flip, i.e.\ exactly 1 choice.
-  Afterwards, all partial sums remain nonnegative, so every subsequent index again contributes a factor of 2 (abs or no‐abs looks identical numerically).

Adding up the contributions over *which* minimal‐index \(j\) one chooses leads to the final summation in step 4. The overall complexity is \(O(n)\) per test and easily fits the constraints.