**Analysis**

We have a robot moving on a 2D grid inside the rectangle \([0,w]\times[0,h]\).  The robot starts at \((0,0)\) and has a script \(s\) of \(n\) moves (each move is one of L/R/U/D).  The script is executed \(k\) times in a row (with \(k\le n\), the “easy” constraint).  However, whenever the robot would step outside the rectangle on the left or right, *all* future L’s and R’s in the *remaining* script are swapped (L↔R), and likewise whenever it would step outside on the top or bottom, *all* future U’s and D’s are swapped.  Those swaps persist through the remaining moves of the current run *and* into subsequent repeats of the script.

We must count how many times (over all \(k\) runs of \(s\)) the robot actually *lands* on \((0,0)\) (not counting the initial starting position).

A direct simulation over \(k\) runs of \(n\) moves each would be \(O(k\,n)\), which in the worst case is up to \(10^{12}\) steps (since \(n\) and \(k\) can each be up to \(10^6\)).  That is far too big.

**Key trick (unfolding reflections)**  
Swapping L↔R on hitting a vertical wall is exactly the same as imagining the robot on an infinite horizontal strip made by “unfolding” reflections of the original rectangle.  Concretely, represent each L as \(\Delta x=-1\), R as \(+1\), U as \(\Delta y=+1\), D as \(-1\), and let
\[
X_t \;=\;\sum_{i=1}^t \Delta x_i,\quad
Y_t \;=\;\sum_{i=1}^t \Delta y_i
\]
be the *unfolded* coordinates after \(t\) moves.  When we fold back into the rectangle \([0,w]\times[0,h]\),

- We look at \(X_t\!\bmod(2w)\).  
  - If \(X_t\) mod \(2w\) lies in \([0,w]\), it goes to \(x'=X_t\!\bmod w\).  
  - If it lies in \([w,2w)\), it maps to \(x'=w-(X_t\!\bmod w)\).  
  - One checks that \(x'=0\) *exactly* when \(X_t\equiv0\pmod{2w}\).  

- Similarly \(y'=0\) exactly when \(Y_t\equiv0\pmod{2h}\).

Hence the robot is back at \((0,0)\) in the original rectangle exactly at those steps \(t\) for which
\[
X_t\equiv 0\pmod{2w}
\quad\text{and}\quad
Y_t\equiv 0\pmod{2h}.
\]
 
Because the script of length \(n\) is repeated \(k\) times, the total move sequence has length \(N=k\,n\).  Write
\[
S_x=\sum_{i=1}^n \Delta x_i,\quad
S_y=\sum_{i=1}^n \Delta y_i
\]
as the *net* displacement of one full script.  Then after \(i\) full scripts and then \(j\) more moves (\(0\le i<k,\;1\le j\le n\)), the unfolded position is
\[
X= i\,S_x+\sum_{r=1}^j\Delta x_r,\quad
Y= i\,S_y+\sum_{r=1}^j\Delta y_r.
\]
We need
\[
i\,S_x + x_j \equiv 0\pmod{2w},\quad
i\,S_y + y_j \equiv 0\pmod{2h},
\]
where \(x_j=\sum_{r=1}^j\Delta x_r\) and likewise \(y_j\).  For each fixed \(j\), this pair of congruences in \(i\) is solved by standard linear–congruence and Chinese‐remainder techniques.  Once we find the residue class
\[
i \equiv r \pmod{L}
\]
(of modulus \(L\)), the number of \(i\in[0,k-1]\) that lie in that class is
\[
\begin{cases}
0, & r\ge k,\\
\displaystyle \biggl\lfloor\frac{k-1-r}{L}\biggr\rfloor +1, & r<k.
\end{cases}
\]
We sum this count over all \(j=1\ldots n\).  Since \(n\le10^6\) and we do only \(O(1)\) work per \(j\) (precomputing a few gcd’s and inverses), this runs in \(O(n)\) time per test case, easily within limits.

---

**Implementation in Java**

```java
import java.io.*;
import java.util.*;

public class Main {
    static final long INF = Long.MAX_VALUE/4;

    // Extended GCD: returns (g, x, y) so that a*x + b*y = g = gcd(a,b)
    // We only need x,y when gcd=1 to compute inverses.
    static long[] extGcd(long a, long b) {
        if (b == 0) return new long[]{a, 1, 0};
        long[] rec = extGcd(b, a % b);
        long g = rec[0], x = rec[2], y = rec[1] - (a / b) * rec[2];
        return new long[]{g, x, y};
    }

    // Modular inverse of a mod m, assuming gcd(a,m)=1, m>1
    static long modInv(long a, long m) {
        long[] e = extGcd(a, m);
        // e[1] is x so that a*x + m*y = 1
        long res = e[1] % m;
        if (res < 0) res += m;
        return res;
    }

    // gcd
    static long gcd(long a, long b) {
        while (b != 0) {
            long t = a % b;
            a = b; b = t;
        }
        return a;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(in.readLine().trim());
        StringBuilder output = new StringBuilder();

        while (t-- > 0) {
            StringTokenizer st = new StringTokenizer(in.readLine());
            int n   = Integer.parseInt(st.nextToken());
            long K  = Long.parseLong(st.nextToken());  // number of repeats
            int w   = Integer.parseInt(st.nextToken());
            int h   = Integer.parseInt(st.nextToken());
            String s = in.readLine().trim();

            // moduli for the unfolded checks
            int m1 = 2*w;
            int m2 = 2*h;

            // Compute total shift per script, mod m1,m2
            long Sx = 0, Sy = 0;
            for (char c: s.toCharArray()) {
                if (c=='L') Sx -= 1;
                else if (c=='R') Sx += 1;
                else if (c=='U') Sy += 1;
                else           Sy -= 1;
            }
            Sx = ((Sx % m1) + m1) % m1;
            Sy = ((Sy % m2) + m2) % m2;

            // Solve i*Sx + x_j ≡ 0 (mod m1), i*Sy + y_j ≡ 0 (mod m2)
            // Precompute data for the x‐congruence:
            long g1 = gcd(Sx, m1);
            long m1p = m1 / g1;      // the reduced modulus
            long invSx = (m1p>1 ? modInv(Sx/g1, m1p) : 0);

            // For the y‐congruence
            long g2 = gcd(Sy, m2);
            long m2p = m2 / g2;
            long invSy = (m2p>1 ? modInv(Sy/g2, m2p) : 0);

            // For CRT on (mod m1p) and (mod m2p):
            // We'll need gcd(m1p, m2p) etc.
            long g12 = gcd(m1p, m2p);
            long invM1p = 0;
            if (m2p / g12 > 1) {
                invM1p = modInv(m1p/g12, m2p/g12);
            }
            long totalVisits = 0;

            // Step through the script once, keeping track of prefix sums mod m1, m2
            long curX = 0, curY = 0;
            for (int j = 0; j < n; j++) {
                char c = s.charAt(j);
                // Update unfolded position mod m1,m2
                if (c == 'L') curX = (curX - 1 + m1) % m1;
                else if (c == 'R') curX = (curX + 1) % m1;
                else if (c == 'U') curY = (curY + 1) % m2;
                else               curY = (curY - 1 + m2) % m2;

                // We want i*Sx + curX ≡ 0 (mod m1)
                // i*Sy + curY ≡ 0 (mod m2)
                long tx = (m1 - curX) % m1;
                long ty = (m2 - curY) % m2;

                // Check basic divisibility
                if (tx % g1 != 0 || ty % g2 != 0) {
                    continue;  // no solution for this j
                }

                // Solve each separately
                long ux = (m1p==1 ? 0 : ((tx/g1) % m1p * invSx) % m1p);
                long uy = (m2p==1 ? 0 : ((ty/g2) % m2p * invSy) % m2p);

                // Now CRT: i ≡ ux (mod m1p), i ≡ uy (mod m2p)
                long r, L;  // result residue and overall modulus
                if (m1p == 1 && m2p == 1) {
                    // both free => i ≡ 0 (mod 1)
                    r = 0;  L = 1;
                } else if (m1p == 1) {
                    // only y matters
                    r = uy;  L = m2p;
                } else if (m2p == 1) {
                    r = ux;  L = m1p;
                } else {
                    // full CRT
                    long diff = uy - ux;
                    if (diff % g12 != 0) {
                        continue;  // no simultaneous solution
                    }
                    long mod2 = m2p / g12;
                    long t0 = ((diff/g12) % mod2 + mod2) % mod2;
                    long k0 = (t0 * invM1p) % mod2;
                    r = ux + k0 * m1p;
                    L = m1p * mod2;  // lcm(m1p,m2p)
                    r %= L;
                    if (r<0) r+=L;
                }

                // Count how many i in [0..K-1] satisfy i ≡ r (mod L)
                if (r < K) {
                    long cnt = ((K-1 - r) / L) + 1;
                    totalVisits += cnt;
                }
            }

            output.append(totalVisits).append('\n');
        }

        System.out.print(output);
    }
}
```

**Explanation of the Main Steps**

1. **Unfolding trick**  
   Instead of literally simulating reflections (swapping L↔R or U↔D), we let the robot wander in an infinite “unfolded” grid.  An L move decrements \(X\) by 1, R increments by 1; U increments \(Y\), D decrements.  Visiting \((0,0)\) in the *folded* rectangle \([0,w]\times[0,h]\) is equivalent to having  
   \[
     X_t \equiv 0\pmod{2w},\quad Y_t \equiv 0\pmod{2h}.
   \]

2. **Prefix sums + repetition**  
   Let the script of \(n\) moves have a *net shift* \((S_x,S_y)\).  After \(i\) *complete* runs and \(j\) extra moves, the robot’s unfolded coordinates are 
   \[
     X = i\,S_x + x_j,\quad Y = i\,S_y + y_j,
   \]
   where \(x_j\) is the sum of the first \(j\) moves’ \(\Delta x\).  
   We repeat the script \(k\) times, so \(0\le i<k\) and \(1\le j\le n\).

3. **Linear congruences**  
   For each \(j\), we need \(i\) satisfying the simultaneous pair
   \[
     i\,S_x + x_j \equiv 0 \pmod{2w},\quad
     i\,S_y + y_j \equiv 0 \pmod{2h}.
   \]
   Each is a single linear congruence in \(i\).  We solve each separately by standard division by \(\gcd\) and (if needed) modular inversion.  That gives
   \[
     i \equiv u_x \pmod{M_x},\quad
     i \equiv u_y \pmod{M_y}.
   \]
   We then use a two‐modulus CRT to merge them into one congruence
   \[
     i \equiv r \pmod{L},
   \]
   or determine that no solution exists for this \(j\).

4. **Counting solutions**  
   Having \(i\equiv r\pmod{L}\), the valid \(i\)-values in \(\{0,1,\dots,k-1\}\) are exactly 
   \(\;r,\,r+L,\,r+2L,\dots\)  as long as they remain below \(k\).  
   The count is
   \[
     \begin{cases}
       0, & r\ge k,\\
       \lfloor (k-1 - r)/L\rfloor + 1, & r<k.
     \end{cases}
   \]
   We add this to the global total for each \(j\).

Since each test case processes the script once in \(O(n)\) time, and does only \(O(1)\) extra work per character, the total is \(O(n)\).  Summed over all test cases, \(\sum n\le10^6\), comfortably within the time limits.

**Complexity**

- Time: \(O(n)\) per test case, overall \(O(\sum n)\le10^6\).
- Space: \(O(n)\) only for the input script; otherwise \(O(1)\) extra.