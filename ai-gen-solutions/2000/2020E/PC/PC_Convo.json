[
  {
    "timestamp": "2025-07-24T06:05:19.046794",
    "role": "user",
    "content": "E. Expected Power\n\ntime limit per test4 seconds\n\nmemory limit per test256 megabytes\n\nYou are given an array of n\n\n integers a1,a2,…,an\n\n. You are also given an array p1,p2,…,pn\n\n.\n\n\n\nLet S\n\n denote the random multiset (i. e., it may contain equal elements) constructed as follows:\n\n\n\nInitially, S\n\n is empty.\n\nFor each i\n\n from 1\n\n to n\n\n, insert ai\n\n into S\n\n with probability pi104\n\n. Note that each element is inserted independently.\n\nDenote f(S)\n\n as the bitwise XOR of all elements of S\n\n. Please calculate the expected value of (f(S))2\n\n. Output the answer modulo 109+7\n\n.\n\n\n\nFormally, let M=109+7\n\n. It can be shown that the answer can be expressed as an irreducible fraction pq\n\n, where p\n\n and q\n\n are integers and q≢0(modM)\n\n. Output the integer equal to p⋅q−1modM\n\n. In other words, output such an integer x\n\n that 0≤x<M\n\n and x⋅q≡p(modM)\n\n.\n\n\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n\n (1≤t≤104\n\n). The description of the test cases follows.\n\n\n\nThe first line of each test case contains a single integer n\n\n (1≤n≤2⋅105\n\n).\n\n\n\nThe second line of each test case contains n\n\n integers a1,a2,…,an\n\n (1≤ai≤1023\n\n).\n\n\n\nThe third line of each test case contains n\n\n integers p1,p2,…,pn\n\n (1≤pi≤104\n\n).\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output the expected value of (f(S))2\n\n, modulo 109+7\n\n.\n\n\n\nExample\n\nInputCopy\n\n4\n\n2\n\n1 2\n\n5000 5000\n\n2\n\n1 1\n\n1000 2000\n\n6\n\n343 624 675 451 902 820\n\n6536 5326 7648 2165 9430 5428\n\n1\n\n1\n\n10000\n\nOutputCopy\n\n500000007\n\n820000006\n\n280120536\n\n1\n\nNote\n\nIn the first test case, a=[1,2]\n\n and each element is inserted into S\n\n with probability 12\n\n, since p1=p2=5000\n\n and pi104=12\n\n. Thus, there are 4\n\n outcomes for S\n\n, each happening with the same probability of 14\n\n:\n\n\n\nS=∅\n\n. In this case, f(S)=0\n\n, (f(S))2=0\n\n.\n\nS={1}\n\n. In this case, f(S)=1\n\n, (f(S))2=1\n\n.\n\nS={2}\n\n. In this case, f(S)=2\n\n, (f(S))2=4\n\n.\n\nS={1,2}\n\n. In this case, f(S)=1⊕2=3\n\n, (f(S))2=9\n\n.\n\nHence, the answer is 0⋅14+1⋅14+4⋅14+9⋅14=144=72≡500000007(mod109+7)\n\n.\n\n\n\nIn the second test case, a=[1,1]\n\n, a1\n\n is inserted into S\n\n with probability 0.1\n\n, while a2\n\n is inserted into S\n\n with probability 0.2\n\n. There are 3\n\n outcomes for S\n\n:\n\n\n\nS=∅\n\n. In this case, f(S)=0\n\n, (f(S))2=0\n\n. This happens with probability (1−0.1)⋅(1−0.2)=0.72\n\n.\n\nS={1}\n\n. In this case, f(S)=1\n\n, (f(S))2=1\n\n. This happens with probability (1−0.1)⋅0.2+0.1⋅(1−0.2)=0.26\n\n.\n\nS={1,1}\n\n. In this case, f(S)=0\n\n, (f(S))2=0\n\n. This happens with probability 0.1⋅0.2=0.02\n\n.\n\nHence, the answer is 0⋅0.72+1⋅0.26+0⋅0.02=0.26=26100≡820000006(mod109+7)\n\n.\n\nUse Java."
  },
  {
    "timestamp": "2025-07-24T06:09:47.085798",
    "role": "assistant",
    "content": "**Analysis**\n\nLet \\(a_1,\\dots,a_n\\) be the given integers (each \\(0\\le a_i<1024\\)) and let each \\(a_i\\) be included in the multiset \\(S\\) independently with probability\n\n\\[\n  p_i \\;=\\;\\frac{\\pi_i}{10^4}\n  \\quad(\\pi_i\\in\\{1,2,\\dots,10000\\}),\n\\]\nso that\n\\[\n  X \\;=\\;f(S)\\;=\\;\\bigoplus_{i:\\,i\\in S} a_i\n\\]\nis the random XOR‐sum, and we wish to compute\n\n\\[\n  \\mathbb{E}[X^2]\n  \\;=\\;\n  \\sum_{b=0}^{9}\\sum_{c=0}^{9}\n    2^b\\,2^c\\,\n    \\mathbb{E}\\bigl[\\bigl(\\text{bit}_b(X)\\bigr)\\,\\bigl(\\text{bit}_c(X)\\bigr)\\bigr],\n\\]\nwhere \\(\\text{bit}_b(X)\\in\\{0,1\\}\\) is the \\(b\\)-th bit of \\(X\\).\n\nKey fact: if\n\\[\n  U = \\sum_{i\\in A}X_i \\pmod 2,\n  \\quad\n  V = \\sum_{i\\in B}X_i \\pmod 2,\n\\]\nwhere \\(X_i\\sim\\mathrm{Bernoulli}(p_i)\\) are independent, then\n\\[\n  \\Pr(U=1,V=1)\n  \\;=\\;\n  \\frac{1 - \\mathbb{E}[(-1)^U] \\;-\\;\\mathbb{E}[(-1)^V]\n          \\;+\\;\\mathbb{E}[(-1)^{U+V}]}{4}.\n\\]\nBut\n\\[\n  \\mathbb{E}\\bigl[(-1)^{\\sum_{i\\in A}X_i}\\bigr]\n    = \\prod_{i\\in A}\\bigl(1 - 2p_i\\bigr),\n  \\quad\n  \\mathbb{E}\\bigl[(-1)^{U+V}\\bigr]\n    = \\prod_{i\\in A\\triangle B}\\!\\!(1-2p_i).\n\\]\nIn our setting, for bit‐position \\(b\\), let\n\\[\n  S_b \\;=\\;\\prod_{\\,i:\\,(a_i)_b=1}\\,(1 - 2p_i)\n  \\quad(\\bmod 10^9+7),\n\\]\nand for two bit‐positions \\(b,c\\),\n\\[\n  S_{b\\oplus c}\n  \\;=\\;\n  \\prod_{\\,i:\\;(a_i)_b\\oplus(a_i)_c=1}\\,(1 - 2p_i).\n\\]\nThen\n\\[\n  \\Pr(\\text{bit}_b(X)=1,\\;\\text{bit}_c(X)=1)\n  \\;=\\;\n  \\frac{1 - S_b - S_c + S_{b\\oplus c}}{4}\n  \\quad(\\bmod\\,10^9+7).\n\\]\nHence\n\\[\n  \\mathbb{E}[X^2]\n  \\;=\\;\n  \\sum_{b=0}^9\\sum_{c=0}^9\n    2^b\\,2^c\n    \\;\\bigl(\\tfrac{1 - S_b - S_c + S_{b\\oplus c}}4\\bigr).\n\\]\n\nWe need only 10 bits (\\(0\\) through \\(9\\)), so a naïve double‐sum is \\(100\\) terms.  The nontrivial part is computing all the \\(S_b\\) and \\(S_{b\\oplus c}\\) efficiently under the usual modulus \\(M=10^9+7\\).  Since each \\(a_i\\) is in \\([0,1023]\\), we can group together all indices \\(i\\) with the same mask \\(m=a_i\\).  Define\n\n\\[\n  G[m] \\;=\\;\\prod_{\\,i:\\,a_i=m} (\\,1 - 2p_i)\\pmod M.\n\\]\n\nThen\n\n- \\(S_b = \\displaystyle\\prod_{\\,m:\\,(m\\text{ has bit }b=1)} G[m]\\),\n- \\(S_{b\\oplus c} = \\displaystyle\\prod_{\\,m:\\,(m_b\\oplus m_c)=1}G[m].\\)\n\nSince there are at most \\(1024\\) masks, and we only need to multiply \\(G[m]\\) into at most \\(10\\) different \\(S_b\\) and at most \\(100\\) different \\(S_{b\\oplus c}\\), the overall work per test is \\(O(n + \\#\\text{distinct masks}\\times 10)\\), which is very fast.  Finally, we do the \\(100\\)‐term double sum to get the answer.\n\nBelow is a Java implementation using exactly this plan.  It runs in \\(O(n + 100)\\) per test case (amortized), and easily handles \\(\\sum n\\le 2\\cdot10^5\\) in under a second or two.\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int MOD = 1_000_000_007;\n    static final int MAXMASK = 1<<10;  // 1024\n    static int inv10000, inv4;\n    static int[] pow2 = new int[10];\n    // bitsOfMask[m] = array of bit‐positions that are 1 in m\n    static int[][] bitsOfMask = new int[MAXMASK][];\n    \n    public static void main(String[] args) throws IOException {\n        precomputeStatics();\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int t = Integer.parseInt(st.nextToken());\n        \n        // We'll reuse these arrays across test‐cases to avoid repeated allocation:\n        int[] G = new int[MAXMASK];\n        boolean[] active = new boolean[MAXMASK];\n        ArrayList<Integer> activeList = new ArrayList<>();\n        \n        StringBuilder sb = new StringBuilder();\n        for (int _case = 0; _case < t; _case++) {\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            // read a_i\n            st = new StringTokenizer(br.readLine());\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = Integer.parseInt(st.nextToken());\n            }\n            \n            // read p_i, form w_i = (1 - 2 p_i) mod\n            st = new StringTokenizer(br.readLine());\n            activeList.clear();\n            for (int i = 0; i < n; i++) {\n                int pi = Integer.parseInt(st.nextToken());\n                // p_i mod M = pi * inv10000 mod M\n                long pmod = (long)pi * inv10000 % MOD;\n                // w_i = 1 - 2 p_i\n                int w = (int)((1 - 2*pmod + 2L*MOD) % MOD);\n                int m = a[i];\n                if (!active[m]) {\n                    active[m] = true;\n                    G[m] = w;\n                    activeList.add(m);\n                } else {\n                    G[m] = (int)((long)G[m] * w % MOD);\n                }\n            }\n            \n            // Compute S_b for b=0..9\n            int[] S_b = new int[10];\n            Arrays.fill(S_b, 1);\n            for (int m : activeList) {\n                int g = G[m];\n                for (int b : bitsOfMask[m]) {\n                    S_b[b] = (int)((long)S_b[b] * g % MOD);\n                }\n            }\n            \n            // Compute S_{b⊕c} in a 10×10 array\n            int[][] S_xor = new int[10][10];\n            for (int b = 0; b < 10; b++) {\n                for (int c = 0; c < 10; c++) {\n                    S_xor[b][c] = 1;\n                }\n            }\n            // For each active mask m, multiply G[m] into those pairs (b,c)\n            // for which bit_b(m)⊕bit_c(m)=1\n            for (int m : activeList) {\n                int g = G[m];\n                // we'll use bitsOfMask[m] = positions of ones\n                // and for each b in that set we do c's that are zeros\n                for (int b : bitsOfMask[m]) {\n                    for (int c = 0; c < 10; c++) {\n                        if (((m >> c) & 1) == 0) {\n                            // (b,c) and (c,b) both need multiplying\n                            S_xor[b][c] = (int)((long)S_xor[b][c] * g % MOD);\n                            S_xor[c][b] = (int)((long)S_xor[c][b] * g % MOD);\n                        }\n                    }\n                }\n            }\n            \n            // Now form the double sum\n            long answer = 0;\n            for (int b = 0; b < 10; b++) {\n                for (int c = 0; c < 10; c++) {\n                    // numerator = 1 - S_b - S_c + S_{b⊕c}\n                    long num = 1 - S_b[b] - S_b[c] + S_xor[b][c];\n                    num %= MOD;\n                    if (num < 0) num += MOD;\n                    // divide by 4\n                    long term = num * inv4 % MOD;\n                    // multiply by 2^b * 2^c\n                    term = term * pow2[b] % MOD * pow2[c] % MOD;\n                    answer += term;\n                }\n            }\n            \n            answer %= MOD;\n            sb.append(answer).append('\\n');\n            \n            // clear active[] for next test\n            for (int m : activeList) {\n                active[m] = false;\n            }\n        }\n        \n        System.out.print(sb);\n    }\n    \n    /** Precompute factorials, inverses, powers of two, and bit‐lists. */\n    static void precomputeStatics() {\n        inv10000 = modInv(10000, MOD);\n        inv4 = modInv(4, MOD);\n        pow2[0] = 1;\n        for (int i = 1; i < 10; i++) {\n            pow2[i] = (int)((pow2[i-1] * 2L) % MOD);\n        }\n        // build bit lists for masks 0..1023\n        for (int m = 0; m < MAXMASK; m++) {\n            int cnt = Integer.bitCount(m);\n            bitsOfMask[m] = new int[cnt];\n            int idx = 0;\n            for (int b = 0; b < 10; b++) {\n                if (((m >> b) & 1) != 0) {\n                    bitsOfMask[m][idx++] = b;\n                }\n            }\n        }\n    }\n    \n    /** Fast exponentiation a^p mod m. */\n    static long modPow(long a, long p, int m) {\n        long r = 1 % m;\n        a %= m;\n        while (p > 0) {\n            if ((p & 1) != 0) r = (r * a) % m;\n            a = (a * a) % m;\n            p >>= 1;\n        }\n        return r;\n    }\n    \n    /** Modular inverse of a mod m (m prime) via Fermat's little theorem. */\n    static int modInv(int a, int m) {\n        return (int)modPow(a, m - 2, m);\n    }\n}\n```\n\n**Explanation of the main steps**\n\n1. **Probability transform**  \n   We read each probability \\(\\pi_i/10000\\), convert it modulo \\(10^9+7\\) by multiplying \\(\\pi_i\\) with \\(\\text{inv}(10000)\\), and then form  \n   \\[\n     w_i = 1 \\;-\\; 2\\,p_i \\pmod{10^9+7}.\n   \\]\n   Such a factor \\(w_i\\) encodes the contribution of the \\(i\\)-th Bernoulli trial to \\(\\;\\mathbb{E}[(-1)^{\\mathrm{sum}}]\\).\n\n2. **Mask‐grouping**  \n   Since each \\(a_i\\) is in \\([0,1023]\\), we group all equal masks together.  We maintain  \n   \\[\n     G[m] \\;=\\;\\prod_{\\,i:\\,a_i=m} w_i,\n   \\]\n   so in the end there are at most 1024 groups, no matter how large \\(n\\) is.\n\n3. **Computing \\(S_b\\) and \\(S_{b\\oplus c}\\)**  \n   - \\(S_b=\\prod G[m]\\) over all masks \\(m\\) that have bit \\(b\\) set.  \n   - \\(S_{b\\oplus c}=\\prod G[m]\\) over all masks \\(m\\) whose bits \\(b\\) and \\(c\\) differ.  \n\n   We do a small loop over the *active* masks (those that occurred in this test) and multiply into the relevant \\(S_b\\) or \\(S_{b\\oplus c}\\).  This costs only \\(O(\\#\\text{active masks}\\times 10)\\) or so.\n\n4. **Summation**  \n   Finally\n   \\[\n     \\mathbb{E}[X^2]\n     =\n     \\sum_{b=0}^9\\sum_{c=0}^9\n     2^b\\,2^c\n     \\;\\frac{1 - S_b - S_c + S_{b\\oplus c}}{4}\n     \\;(\\bmod\\,10^9+7),\n   \\]\n   which is a straight double sum of 100 terms.\n\nBecause each test runs in \\(O(n + 100)\\) time and \\(\\sum n\\le2\\times10^5\\), this solution easily passes within the usual time and memory limits."
  }
]