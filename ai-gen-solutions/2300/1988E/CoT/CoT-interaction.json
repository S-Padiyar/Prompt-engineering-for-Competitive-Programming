[
    {
        "request_timestamp": "2025-07-23T18:45:29.812869",
        "response_timestamp": "2025-07-23T18:48:25.390097",
        "sent_messages": [
            {
                "role": "user",
                "content": "Codeforces Problem:\n\nE. Range Minimum Sum\n\ntime limit per test4 seconds\n\nmemory limit per test512 megabytes\n\nFor an array [a1,a2,…,an]\n\n of length n\n\n, define f(a)\n\n as the sum of the minimum element over all subsegments. That is,\n\nf(a)=∑l=1n∑r=lnminl≤i≤rai.\n\n\n\nA permutation is a sequence of integers from 1\n\n to n\n\n of length n\n\n containing each number exactly once. You are given a permutation [a1,a2,…,an]\n\n. For each i\n\n, solve the following problem independently:\n\n\n\nErase ai\n\n from a\n\n, concatenating the remaining parts, resulting in b=[a1,a2,…,ai−1,ai+1,…,an]\n\n.\n\nCalculate f(b)\n\n.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n\n (1≤t≤105\n\n). Description of the test cases follows.\n\n\n\nThe first line of each test case contains an integer n\n\n (1≤n≤5⋅105\n\n).\n\n\n\nThe second line of each test case contains n\n\n distinct integers a1,…,an\n\n (1≤ai≤n\n\n).\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 106\n\n.\n\n\n\nOutput\n\nFor each test case, print one line containing n\n\n integers. The i\n\n-th integer should be the answer when erasing ai\n\n.\n\n\n\nExample\n\nInputCopy\n\n4\n\n1\n\n1\n\n3\n\n3 1 2\n\n5\n\n4 2 1 5 3\n\n8\n\n8 1 4 6 7 3 5 2\n\nOutputCopy\n\n0 \n\n4 7 5 \n\n19 21 27 17 19 \n\n79 100 72 68 67 80 73 80 \n\nNote\n\nIn the second test case, a=[3,1,2]\n\n.\n\n\n\nWhen removing a1\n\n, b=[1,2]\n\n. f(b)=1+2+min{1,2}=4\n\n.\n\nWhen removing a2\n\n, b=[3,2]\n\n. f(b)=3+2+min{3,2}=7\n\n.\n\nWhen removing a3\n\n, b=[3,1]\n\n. f(b)=3+1+min{3,1}=5\n\n.\n\n---\n\nLet's think step-by-step so we don't make mistakes. Use Java. Avoid syntax errors or infinite loops."
            }
        ],
        "received_response": "{\n  \"id\": \"chatcmpl-BwcVFfynRSt8cBQqO4MQrH2Mt1Exh\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"**Analysis**\\n\\nWe have an array a of length n (a permutation of 1…n).  We delete each element a_i in turn and form  \\n    b = [a_1,…,a_{i−1}, a_{i+1},…,a_n],  \\nand we must compute\\n\\n    f(b) = ∑_{l=1}^{n−1} ∑_{r=l}^{n−1} min⁡( b_l,…,b_r ).\\n\\nA direct re-computation for each deletion would be O(n²) per query, too large when n can be up to 5·10⁵.\\n\\nInstead we decompose each f(b) into three parts:\\n\\n 1.  The contribution of all subarrays lying entirely to the left of the deletion point.\\n 2.  The contribution of all subarrays lying entirely to the right of the deletion point.\\n 3.  The contribution of all subarrays that “straddle” the deletion point—i.e. those whose left end is in the left block and whose right end is in the right block.\\n\\nWe can precompute\\n\\n  •  preF[k] = f(a[1..k]) = the sum of minimums of all subarrays of the prefix of length k.  \\n  •  sufF[k] = f(a[k..n]) = the sum of minimums of all subarrays of the suffix starting at k.\\n\\nBoth can be built in O(n) by the well-known “stack + running total” trick:\\n\\n— To build preF, walk i=1…n, maintain a monotonic (increasing) stack of pairs (value, count).  Each time you push a[i], you pop all ≥ a[i], accumulate how many suffix‐runs they covered, etc., so in O(1) amortized you know\\n\\n  dpEnd[i] = ∑_{ℓ=1..i} min(a[ℓ..i])\\n\\nand then\\n\\n  preF[i] = preF[i−1] + dpEnd[i].\\n\\n— Similarly reverse the array to build sufF.\\n\\nHence for deleting position i, the “left only” part is preF[i−1], the “right only” part is sufF[i+1].\\n\\nWe only need to compute the “cross‐block” part\\n\\n  Cross(i) = ∑_{ℓ=1}^{i−1} ∑_{r=i+1}^{n} min( min(a[ℓ..i−1]) , min(a[i+1..r]) ).\\n\\nCall\\n\\n  Lmin(ℓ,i−1) = min(a[ℓ..i−1]),  \\n  Rmin(i+1,r) = min(a[i+1..r]).\\n\\nWe must sum min( Lmin(ℓ,i−1), Rmin(i+1,r) ) over all ℓ < i < r.  A clever way to do this in O(n log n) total is to observe that as we slide i from 1 to n:\\n\\n  –  We maintain two dynamic multisets of “active” indices:\\n\\n     •  S_L = {1,2,…,i−1}  (left of the hole)  \\n     •  S_R = {i+1,i+2,…,n}  (right of the hole)\\n\\n  –  Each index k we associate two “weights”:\\n\\n         wL[k] = (k − L[k] + 1),     where L[k] is the boundary of how far to the left a[k] is the minimum  \\n         wR[k] = (R[k] − k + 1),     where R[k] is the boundary of how far to the right a[k] is the minimum\\n\\n    (These come from the standard “next‐smaller / previous‐smaller” decomposition which figures f(a) itself.)\\n\\n  –  It can be shown that\\n\\n           Cross(i) = ∑_{k∈S_L} ∑_{ℓ∈S_R} wL[k]·wR[ℓ]·min(a[k],a[ℓ]).\\n\\n  –  If we move i→i+1, then S_L gains index i and S_R loses index i+1.  One can maintain\\n\\n           Cross(i+1) = Cross(i)\\n                        − wR[i+1] · ∑_{k∈S_L} wL[k]·min(a[k],a[i+1])\\n                        + wL[i]   · ∑_{ℓ∈S_R\\\\{i+1\\\\}} wR[ℓ]·min(a[i],a[ℓ]).\\n\\n    Each of those bracketed sums is exactly\\n\\n           ∑_{x∈S} w[x]·min(value[x],X)\\n           =  ∑_{value[x] ≤ X} w[x]·value[x]\\n            + X · ∑_{value[x] > X} w[x]\\n\\n    which can be done in O(log n) by maintaining two Fenwicks (BITs): one for ∑w[x] over values, one for ∑(value[x]·w[x]).\\n\\nThus each deletion i’s Cross(i) can be built in O(log n) incrementally, and combined with preF[i−1] + sufF[i+1] gives f(b_i).\\n\\nOverall complexity per test is O(n) for preF/sufF + O(n) for next/prev smaller + O(n log n) for the Fenwick “slide‐window” → O(n log n).  Since ∑n ≤10^6, this runs comfortably in 4 s in Java.\\n\\n---\\n\\n```java\\nimport java.io.*;\\nimport java.util.*;\\n\\npublic class Main {\\n    static final int MAXN = 1000000 + 5;\\n    static int[] a = new int[MAXN];\\n    static int[] L = new int[MAXN], R = new int[MAXN];\\n    static long[] wL = new long[MAXN], wR = new long[MAXN];\\n    static long[] preF = new long[MAXN], sufF = new long[MAXN];\\n    static long[] bitCntL = new long[MAXN], bitSumL = new long[MAXN];\\n    static long[] bitCntR = new long[MAXN], bitSumR = new long[MAXN];\\n    static int N;\\n\\n    // Fenwick methods (1-based):\\n    static void fenwUpdate(long[] bit, int i, long delta) {\\n        for (; i <= N; i += i & -i) {\\n            bit[i] += delta;\\n        }\\n    }\\n    static long fenwSum(long[] bit, int i) {\\n        long s = 0;\\n        for (; i > 0; i -= i & -i) {\\n            s += bit[i];\\n        }\\n        return s;\\n    }\\n\\n    public static void main(String[] args) throws IOException {\\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));\\n        int t = Integer.parseInt(br.readLine().trim());\\n        while (t-- > 0) {\\n            N = Integer.parseInt(br.readLine().trim());\\n            StringTokenizer st = new StringTokenizer(br.readLine());\\n            for (int i = 1; i <= N; i++) {\\n                a[i] = Integer.parseInt(st.nextToken());\\n            }\\n\\n            // 1) Compute preF[i] = f(a[1..i]) in O(n).\\n            {\\n                long running = 0;\\n                // stack of (value, count)\\n                ArrayDeque<long[]> stck = new ArrayDeque<>();\\n                preF[0] = 0;\\n                for (int i = 1; i <= N; i++) {\\n                    long cnt = 1;\\n                    while (!stck.isEmpty() && stck.peek()[0] >= a[i]) {\\n                        long[] top = stck.pop();\\n                        running -= top[0] * top[1];\\n                        cnt += top[1];\\n                    }\\n                    stck.push(new long[]{a[i], cnt});\\n                    running += (long)a[i] * cnt;\\n                    preF[i] = preF[i - 1] + running;\\n                }\\n            }\\n\\n            // 2) Compute sufF[i] = f(a[i..N]) in O(n), reversed.\\n            {\\n                long running = 0;\\n                ArrayDeque<long[]> stck = new ArrayDeque<>();\\n                sufF[N + 1] = 0;\\n                for (int i = N; i >= 1; i--) {\\n                    long cnt = 1;\\n                    while (!stck.isEmpty() && stck.peek()[0] >= a[i]) {\\n                        long[] top = stck.pop();\\n                        running -= top[0] * top[1];\\n                        cnt += top[1];\\n                    }\\n                    stck.push(new long[]{a[i], cnt});\\n                    running += (long)a[i] * cnt;\\n                    sufF[i] = sufF[i + 1] + running;\\n                }\\n            }\\n\\n            // 3) Compute next smaller to the right (R) and previous smaller to the left (L).\\n            {\\n                // L[i]: 1 + index of previous smaller.  If none, L[i] = 1.\\n                ArrayDeque<Integer> stck = new ArrayDeque<>();\\n                for (int i = 1; i <= N; i++) {\\n                    while (!stck.isEmpty() && a[stck.peek()] > a[i]) {\\n                        stck.pop();\\n                    }\\n                    int prev = stck.isEmpty() ? 0 : stck.peek();\\n                    L[i] = prev + 1;\\n                    stck.push(i);\\n                }\\n                // R[i]: index of next smaller minus 1.  If none, R[i] = N.\\n                stck.clear();\\n                for (int i = N; i >= 1; i--) {\\n                    while (!stck.isEmpty() && a[stck.peek()] > a[i]) {\\n                        stck.pop();\\n                    }\\n                    int nxt = stck.isEmpty() ? N+1 : stck.peek();\\n                    R[i] = nxt - 1;\\n                    stck.push(i);\\n                }\\n            }\\n\\n            // 4) Precompute the two weight arrays:\\n            //    wL[i] = (i - L[i] + 1),   wR[i] = (R[i] - i + 1).\\n            for (int i = 1; i <= N; i++) {\\n                wL[i] = i - L[i] + 1;\\n                wR[i] = R[i] - i + 1;\\n            }\\n\\n            // 5) We'll sweep i=1..N, maintaining\\n            //      Cross(i) = sum_{k < i < ℓ} wL[k]*wR[ℓ]*min(a[k],a[ℓ])\\n            //    via two Fenwicks over “values = a[*]” for the sets\\n            //      S_L = {1..i−1},  each with weight wL[k],\\n            //      S_R = {i+1..N}, each with weight wR[ℓ].\\n            //\\n            //    Fenwicks store two arrays:  cnt[v] = ∑ weights of elements with value=v,\\n            //                                 sum[v] = ∑ (value * weight).\\n            //    Then ∑_{value≤X} sum[v] + X*(totalCnt - ∑_{value≤X} cnt[v])\\n            //    is exactly ∑ weights[*] · min(value[*], X).\\n\\n            // Clear Fenwicks\\n            for (int i = 1; i <= N; i++) {\\n                bitCntL[i] = bitSumL[i] = 0;\\n                bitCntR[i] = bitSumR[i] = 0;\\n            }\\n\\n            // Initialize S_R = {2..N}.\\n            long totalWR = 0;\\n            for (int i = 2; i <= N; i++) {\\n                totalWR += wR[i];\\n                fenwUpdate(bitCntR, a[i], wR[i]);\\n                fenwUpdate(bitSumR, a[i], wR[i] * a[i]);\\n            }\\n            long totalWL = 0;         // empty S_L\\n            long cross = 0;\\n\\n            long[] ans = new long[N+1];\\n            for (int i = 1; i <= N; i++) {\\n                // f(b_i) = preF[i-1] + sufF[i+1] + Cross(i)\\n                ans[i] = preF[i-1] + sufF[i+1] + cross;\\n\\n                if (i < N) {\\n                    //  Remove i+1 from S_R => we must subtract all pairs with ℓ = i+1\\n                    long valR = a[i+1], wr = wR[i+1];\\n\\n                    // deltaMinus = wr * ∑_{k ∈ S_L} wL[k]·min(a[k], valR)\\n                    long cL_le = fenwSum(bitCntL, valR);\\n                    long sL_le = fenwSum(bitSumL, valR);\\n                    long deltaMinus = wr * (sL_le + valR * (totalWL - cL_le));\\n\\n                    // actually remove it\\n                    fenwUpdate(bitCntR, valR, -wr);\\n                    fenwUpdate(bitSumR, valR, -wr * valR);\\n                    totalWR -= wr;\\n\\n                    // deltaPlus = wL[i] * ∑_{ℓ ∈ S_R} wR[ℓ]·min(a[ℓ], a[i])\\n                    long valL = a[i], wl = wL[i];\\n                    long cR_le = fenwSum(bitCntR, valL);\\n                    long sR_le = fenwSum(bitSumR, valL);\\n                    long deltaPlus = wl * (sR_le + valL * (totalWR - cR_le));\\n\\n                    // add i into S_L\\n                    fenwUpdate(bitCntL, valL, wl);\\n                    fenwUpdate(bitSumL, valL, wl * valL);\\n                    totalWL += wl;\\n\\n                    cross = cross - deltaMinus + deltaPlus;\\n                }\\n            }\\n\\n            // 6) Print answers\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = 1; i <= N; i++) {\\n                sb.append(ans[i]).append(' ');\\n            }\\n            pw.println(sb.toString().trim());\\n        }\\n\\n        pw.flush();\\n    }\\n}\\n```\\n\\n**Explanation of the key steps**\\n\\n1. **Computing prefix‐ and suffix‐minimum sums (preF, sufF)**  \\n   We use the classic “monotonic stack + running total” to get in O(n) time, for each index i, the sum of minimums of all subarrays ending at i (for preF) or starting at i (for sufF).\\n\\n2. **Next / previous smaller → weights wL, wR**  \\n   For each position i, let  \\n   &nbsp;&nbsp;L[i] = 1 + (index of previous element < a[i]), or 1 if none.  \\n   &nbsp;&nbsp;R[i] = (index of next element < a[i]) − 1, or N if none.  \\n   Then in the classical formula for f(a) you get contributions a[i]·(i−L[i]+1)·(R[i]−i+1).  We split that into  \\n   &nbsp;&nbsp;wL[i] = (i−L[i]+1)  and  wR[i] = (R[i]−i+1).  \\n\\n3. **The “cross‐block” sums**  \\n   One shows that deleting index i introduces exactly those new subarrays that pick some suffix of the left block and some prefix of the right block, and the total of their minima is\\n   ```\\n      Cross(i)\\n      = sum_{k < i} sum_{ℓ > i} wL[k]·wR[ℓ] · min(a[k],a[ℓ]).\\n   ```\\n   We maintain two Fenwicks over “value = a[*]”, one for the left set S_L={1..i−1} and one for the right set S_R={i+1..n}.  Each update i→i+1 removes i+1 from S_R and adds i to S_L; the change in Cross(i) can be computed by two Fenwick‐queries of form\\n   ```\\n      ∑_{value≤X} (weight·value)\\n      + X · (totalWeightInSet − ∑_{value≤X} weight)\\n   ```\\n   which is exactly ∑ weight·min(value,X).  Each of these is O(log n), so the entire sweep i=1..n is O(n log n).\\n\\n4. **Final answer**  \\n   For each i,\\n\\n      f(b_i) = preF[i−1] + sufF[i+1] + Cross(i).\\n\\nTotal time per test ∼ O(n) + O(n log n).  Since ∑n ≤ 10⁶, this easily runs in 4 s in Java.\",\n        \"refusal\": null,\n        \"role\": \"assistant\",\n        \"annotations\": [],\n        \"audio\": null,\n        \"function_call\": null,\n        \"tool_calls\": null\n      },\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"protected_material_code\": {\n          \"filtered\": false,\n          \"detected\": true,\n          \"citation\": {\n            \"URL\": \"https://github.com/arihantbansal/competitive-programming-solutions/tree/d5c1b4cc3536f94294a44b3d1c6a9bee433f8d79/codechef%2FFLOW010.java\",\n            \"license\": \"NOASSERTION\"\n          }\n        },\n        \"protected_material_text\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ],\n  \"created\": 1753310729,\n  \"model\": \"o4-mini-2025-04-16\",\n  \"object\": \"chat.completion\",\n  \"service_tier\": null,\n  \"system_fingerprint\": null,\n  \"usage\": {\n    \"completion_tokens\": 25650,\n    \"prompt_tokens\": 526,\n    \"total_tokens\": 26176,\n    \"completion_tokens_details\": {\n      \"accepted_prediction_tokens\": 0,\n      \"audio_tokens\": 0,\n      \"reasoning_tokens\": 21952,\n      \"rejected_prediction_tokens\": 0\n    },\n    \"prompt_tokens_details\": {\n      \"audio_tokens\": 0,\n      \"cached_tokens\": 0\n    }\n  },\n  \"prompt_filter_results\": [\n    {\n      \"prompt_index\": 0,\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"jailbreak\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ]\n}"
    }
]