**Analysis and Restatement**

We have an array a[1…n] and a binary tag array b[1…n].  We may perform up to k unit‐increment operations, each of which picks an index i with b[i]=1 and does a[i]++.  After all operations, we define our **score** to be

 \displaystyle \max_{1\le i\le n}\bigl\{\,a'[i]\;+\;\mathrm{median}(a'\setminus\{a'[i]\})\bigr\}\,,

where a′ is the final array and “median” of a length‐(n−1) array c is the \(\bigl\lfloor\frac{(n-1)+2}2\bigr\rfloor\)-th smallest element of c.

We want to choose where to spend at most k increments (only on positions with b[i]=1) so as to **maximize** that final score.

Key insights:

1.  If we pick index i as our “champion,” the score contributed by i is  
   
   \[
     \text{(final)}\,a'[i]\;+\;m_i
   \]
   
   where m_i = median of all the other n−1 entries after increments.  
   
2.  Incrementing the champion itself by 1 costs 1 operation and raises the champion’s term by exactly 1.  
3.  Raising the median m_i by 1 generally costs at least F = ⌊n/2⌋ operations, because to make the (⌊(n−1)+2⌋/2)-th‐smallest element go up by 1, you must bring up at least F elements that were “just below” the median.  

   Hence we have a **trade‐off**:  
   
   - Spending 1 op on the champion gives +1 to the champion term.  
   - Spending 1 op toward the median typically gives ≪1 to the final score (it takes ~F ops to raise the median by 1).  

4.  In practice the best split of the k operations is **either**:  
   
   a) **All** on the champion (if b[i]=1), or  
   b) **All** on the median‐group.  
   
   Trying to split in‐between never beats “all” or “none” because the median‐cost function is convex: once you devote ops to median, you do so in big chunks of size ~F per +1 median.

5.  Therefore for any candidate champion index i we only need to test two scenarios:

   **(A)**  Spend **0** ops on the champion and use up to k ops on the median.  Then the champion value is fixed at a[i], and we ask: can we make the median m_i ≥ (S−a[i]) with ≤k ops?  

   **(B)**  Spend **all** k ops on the champion (only possible if b[i]=1), boosting a[i] to a[i]+k, and spend 0 on the median.  Then the median stays at its initial value m_i^0, and the score for i is (a[i]+k)+m_i^0.  

We binary‐search the final answer S.  For each S we check feasibility in O(n log n):

  1.  **Precompute** initial medians m_i^0 for each i (this only depends on the initial sorted order of (a[i], b[i])).  In fact after sorting by a[i] we know that removing one index either leaves the “lower” median M_t or the “upper” median M_{t+1}, with t=⌊(n+1)/2⌋.  
  2.  **Scenario B** is easy to test: if for some i with b[i]=1 we have  
         a[i] + k + m_i^0 ≥ S  
     then S is feasible.  
  3.  **Scenario A**: we want a[i] + (new median m_i) ≥ S, but we set a[i] unchanged, so m_i ≥ S−a[i].  To test whether we can raise the median among the **other** n−1 elements up to Y=S−a[i] using ≤k ops, we do this:
     
     –  Build an array of “median‐costs” for each j ≠ i:
        cost_j = max(0, Y − a[j])  if b[j]=1,  
                 = +∞ if b[j]=0 and a[j]<Y,  
                 = 0 if a[j]≥Y.  
     –  We pick the F = ⌊n/2⌋ smallest costs among those n−1 entries, sum them up; if that sum ≤ k, we can push up the median to ≥Y.  
     –  If it works for **any** i, scenario A sees S is feasible.  

Binary‐search S (over the range [0…(max_ai + k)×2]) in ~50 steps; each step costs O(n log n) to test scenarios A+B (sorting the costs and summing the first F).  Sum of n over all tests is ≤2×10^5, so overall O((∑n)·log n·log (10^9+k)) ≈ 2×10^5·18·32 ≲1.2×10^8, which fits in 3 sec under a well‐tuned Java solution.

---

**Java Solution**

```java
import java.io.*;
import java.util.*;

public class Main {
    static final long INF = Long.MAX_VALUE / 4;

    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer tok;

        int T = Integer.parseInt(in.readLine());
        StringBuilder out = new StringBuilder();

        while (T-- > 0) {
            tok = new StringTokenizer(in.readLine());
            int n = Integer.parseInt(tok.nextToken());
            long k = Long.parseLong(tok.nextToken());
            int F = n / 2;           // we need F = floor(n/2) raises to get median

            // read a[], b[]
            long[] a = new long[n];
            int[] b = new int[n];
            tok = new StringTokenizer(in.readLine());
            for (int i = 0; i < n; i++) a[i] = Long.parseLong(tok.nextToken());
            tok = new StringTokenizer(in.readLine());
            for (int i = 0; i < n; i++) b[i] = Integer.parseInt(tok.nextToken());

            // Make a sorted list of (value,index) so we can remove each index
            // and know the "initial" median of the other n-1 elements.
            Pair[] P = new Pair[n];
            for (int i = 0; i < n; i++) {
                P[i] = new Pair(a[i], i);
            }
            Arrays.sort(P);

            // t = position of median in a sorted of size n
            // for c_i of size n-1, median is at pos_c = floor((n-1 + 2)/2).
            // That equals floor((n+1)/2).  We'll call t = floor((n+1)/2).
            int t = (n + 1) / 2;

            // precompute initial median[without i] = m0[i]
            long[] m0 = new long[n];
            // If the removed index is among the first t in sorted order,
            // the c_i median is P[t].val, else it's P[t-1].val.
            // careful with 0-based:
            for (int rank = 0; rank < n; rank++) {
                int idx = P[rank].idx;
                if (rank < t) {
                    // we removed one of the earliest t,
                    // the median of the rest is the (t)-th smallest in 0-based => P[t].val
                    m0[idx] = (t < n ? P[t].val : P[n - 1].val);
                } else {
                    // removed from >= t, median is P[t-1].val
                    m0[idx] = P[t - 1].val;
                }
            }

            // We'll binary search the final answer S.
            // Lower bound L=0, upper bound R = (max(a)+k) + (max(a)+k)
            long maxA = 0;
            for (long v : a) if (v > maxA) maxA = v;
            long L = 0, R = (maxA + k) * 2 + 5;

            while (L < R) {
                long mid = (L + R + 1) >>> 1;
                if (canAchieve(mid, n, k, F, a, b, m0)) {
                    L = mid;
                } else {
                    R = mid - 1;
                }
            }

            out.append(L).append('\n');
        }
        System.out.print(out);
    }

    static boolean canAchieve(long S, int n, long k, int F,
                              long[] a, int[] b, long[] m0) {
        // Scenario B: spend all k on the champion, 0 on median.
        // Then champion i must have b[i]=1 and
        //   a[i] + k + m0[i] >= S.
        // If any i does, we succeed immediately.
        for (int i = 0; i < n; i++) {
            if (b[i] == 1) {
                if (a[i] + k + m0[i] >= S) {
                    return true;
                }
            }
        }

        // Scenario A: spend 0 on champion, up to k on median.
        // We need for some i:
        //    a[i] + newMedian >= S
        //  => newMedian >= Y = S - a[i]
        // We'll build a cost-array of length n-1 for each i,
        // pick the F smallest costs, sum them, and see if <= k.
        //
        // We can optimize a bit by noticing that Y depends only on i,
        // but we must rebuild the costs without j=i.
        // Because n <= 2e5 in total, we can afford O(n log n) per check.

        // We prepare a sorted multiset (or an array to sort) of (cost, index)
        // for all j where j != i.
        long[] costs = new long[n];

        for (int i = 0; i < n; i++) {
            long Y = S - a[i];
            // Build costs[] over j!=i:
            int p = 0;
            for (int j = 0; j < n; j++) {
                if (j == i) continue;
                long c;
                if (a[j] >= Y) {
                    c = 0;
                } else if (b[j] == 1) {
                    c = Y - a[j];  // can raise
                } else {
                    c = INF;       // cannot raise this one => infinite cost
                }
                costs[p++] = c;
            }
            // if p != n-1 in theory, but we guaranteed just skipping i
            Arrays.sort(costs, 0, n-1);
            // sum the first F:
            long sum = 0;
            for (int x = 0; x < F; x++) {
                sum += costs[x];
                if (sum > k) break;
            }
            if (sum <= k) {
                // We can raise median ≥ Y with ≤ k ops.
                return true;
            }
        }

        // Neither scenario A nor B worked for any champion i.
        return false;
    }

    // small helper to sort (value,index)
    static class Pair implements Comparable<Pair> {
        long val;
        int idx;
        Pair(long v, int i) { val = v; idx = i; }
        public int compareTo(Pair o) {
            return Long.compare(this.val, o.val);
        }
    }
}
```

**Explanation of Key Steps**

1. **Reading and sorting.**  
   We store `(a[i],i)` in an array P and sort by `a[i]`.  This lets us quickly answer, for each removed‐index i, what the *initial* median of the other n−1 entries is (call that `m0[i]`).

2. **Binary Search on the score S.**  
   The final score lies in `[0…2·(max(a)+k)]`, so we binary‐search those ~60 steps to find the largest feasible `S`.

3. **Feasibility Check `canAchieve(S)`:**  
   We test two **extreme** ways of spending our k ops:

   - **Scenario B (all on champion).**  
     If index i has `b[i]=1`, we can add all k ops to a[i], making it `a[i]+k`.  The median of the remaining n−1 entries remains `m0[i]`.  If  
       
       `a[i] + k + m0[i] >= S`  
       
     for any i, we’re done.

   - **Scenario A (all on median).**  
     We leave the champion value `a[i]` alone, and try to pump the other n−1 entries’ median up to at least `Y = S−a[i]`.  
     To do that, form a “cost array” over the other indices j≠i:
       
       cost_j = 0, if a[j]≥Y  
                Y−a[j], if a[j]<Y but b[j]=1  
                ∞, if a[j]<Y but b[j]=0  (we cannot raise that j)  
       
     We need at least F=⌊n/2⌋ of the other elements to be ≥Y, so we take the F smallest costs, sum them; if the sum ≤k then we can spend that many ops to bring the median to ≥Y and succeed.

This check costs O(n) to build and sort the costs once per i, so O(n·log n) per `canAchieve` call.  Doing ~60 binary‐search steps gives an overall O(n log n · log (max(a)+k)) which is acceptable for ∑n ≤2·10^5.

---

**Complexity**

- Let `N = ∑ n` over all test cases.  
- We do **binary search** in O(log (10^9+k)) ≈ 32…40 steps.  
- Each step calls `canAchieve` which is O(n log n) (sorting `n−1` costs).  
- Total ≈ O(N · log n · log (10^9+k)) ≤ 2·10^5·18·40 ≈ 1.44·10^8 operations.  

With fast I/O and low‐constant code, this fits in 3 seconds in Java.