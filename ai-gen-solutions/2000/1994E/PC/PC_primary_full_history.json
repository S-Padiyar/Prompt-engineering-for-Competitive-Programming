[
  {
    "role": "user",
    "content": "E. Wooden Game\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nYou are given a forest of k\n\n rooted trees∗\n\n. Lumberjack Timofey wants to cut down the entire forest by applying the following operation:\n\n\n\nSelect a subtree†\n\n of any vertex of one of the trees and remove it from the tree.\n\nTimofey loves bitwise operations, so he wants the bitwise OR of the sizes of the subtrees he removed to be maximum. Help him and find the maximum result he can obtain.\n\n\n\n∗\n\n A tree is a connected graph without cycles, loops, or multiple edges. In a rooted tree, a selected vertex is called a root. A forest is a collection of one or more trees.\n\n\n\n†\n\n The subtree of a vertex v\n\n is the set of vertices for which v\n\n lies on the shortest path from this vertex to the root, including v\n\n itself.\n\n\n\nInput\n\nEach test consists of multiple test cases. The first line contains an integer t\n\n (1≤t≤104\n\n) — the number of test cases. Then follows the description of the test cases.\n\n\n\nThe first line of each test case contains a single integer k\n\n (1≤k≤106\n\n) — the number of trees in the forest.\n\n\n\nThis is followed by a description of each of the k\n\n trees:\n\n\n\nThe first line contains a single integer n\n\n (1≤n≤106\n\n) — the size of the tree. The vertices of the tree are numbered with integers from 1\n\n to n\n\n. The root of the tree is vertex number 1\n\n.\n\n\n\nThe second line contains n−1\n\n integers p2,p3,…pn\n\n (1≤pi<i\n\n), where pi\n\n — the parent of vertex i\n\n.\n\n\n\nIt is guaranteed that the sum of k\n\n and n\n\n for all sets of input data does not exceed 106\n\n.\n\n\n\nOutput\n\nFor each test case, output a single integer — the maximum result that can be obtained.\n\n\n\nExample\n\nInputCopy\n\n3\n\n1\n\n1\n\n\n\n2\n\n4\n\n1 2 2\n\n6\n\n1 1 3 1 3\n\n1\n\n10\n\n1 2 2 1 1 5 7 6 4\n\nOutputCopy\n\n1\n\n7\n\n10\n\nNote\n\nIn the second test case, the trees look like this:\n\n\n\n\n\n\n\nThe first operation removes the entire second tree.\n\n\n\n\n\n\n\nThe second operation removes vertex 4\n\n from the first tree.\n\n\n\n\n\n\n\nThe third operation removes the first tree. The result is 6|1|3=7\n\n (|\n\n denotes bitwise OR).\n\n\n\nIn the third test case, the entire tree needs to be removed.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have a forest of \\(k\\) rooted trees.  In each “cut” operation you choose a vertex \\(v\\) in one of the *current* trees, remove its entire current subtree (all the descendants of \\(v\\) that are still present, including \\(v\\) itself), and record the *size* of that removed subtree.  You repeat until the forest is empty, and you wish to make the bitwise‐OR of all recorded sizes as large as possible.\n\nA key observation is that different original trees never “interact’’ — any cut you do in one tree cannot affect the structure or the possible cuts in a different tree.  Hence, when you compute the global bitwise‐OR over *all* the removed‐subtree‐sizes from the entire forest, it is simply the bitwise‐OR of what you achieve tree by tree.\n\nMoreover, one finds:\n\n 1.  **If the forest has at least two trees** then *any* bit that appears in *any* original‐subtree‐size of *any* tree can be realized in the final OR, simply by taking that subtree in its own tree (or by splitting that tree so that bit lives in one component and the rest of the bits in another), and different bits may come from different trees.  In fact one can show that if \\(k\\ge2\\), then the maximum final OR is just the OR of *all* original subtree‐sizes in the entire forest.\n\n 2.  **If the forest has exactly one tree**, one cannot always realize *all* bits that appear anywhere in the original subtree‐sizes.  It turns out that to maximize the OR you never need more than a single *non‐root* cut plus the final cut of what remains at the root.  If the tree has total size \n    \\[\n       N \\;=\\; \\text{size of the whole tree}\n    \\]\n    and if you first cut off one proper‐subtree of size \\(s\\), and then finally cut the root‐subtree of size \\(N-s\\), the OR you get is\n    \\[\n       \\bigl(s\\bigr)\\;\\bigr|\\;\\bigl(N-s\\bigr)\\,.\n    \\]\n    You should also compare that with the choice of *never* cutting any proper subtree and just cutting the whole original tree at once (size \\(N\\)), whose OR is just \\(N\\).  One then maximizes\n    \\[\n      \\max\\Bigl\\{\\,N\\,,\\;\n             \\max_{v\\ne \\hbox{root}}\\bigl(\\, \\mathrm{size}(v)\\;\\bigr|\\;(N-\\mathrm{size}(v))\\bigr)\\Bigr\\}\\,.\n    \\]\n\nPutting these facts together gives an \\(O(n)\\)-time solution.  We do one pass per tree to compute all subtree‐sizes, and accumulate:\n\n- If \\(k\\ge2\\), we just OR together *every* subtree‐size of *every* tree.\n- If \\(k=1\\), we instead compute\n  \\[\n     \\mathrm{answer}\n     \\;=\\;\\max\\Bigl\\{\n         N,\n         \\max_{v\\ne\\mathrm{root}}\\bigl(\\mathrm{size}(v)\\;|\\;(N-\\mathrm{size}(v))\\bigr)\n     \\Bigr\\}.\n  \\]\n\nBelow is a Java implementation.\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static final int MAXN = 1000000;\n    static int[] parent = new int[MAXN+1];\n    static int[] head = new int[MAXN+1], to = new int[MAXN*2], nxt = new int[MAXN*2], ec = 0;\n    static int[] size = new int[MAXN+1];\n\n    // add edge u->v in adjacency list\n    static void addEdge(int u, int v) {\n        to[ec] = v;\n        nxt[ec] = head[u];\n        head[u] = ec++;\n    }\n\n    // DFS to compute subtree sizes\n    static int dfs(int u) {\n        int s = 1;\n        for (int e = head[u]; e != -1; e = nxt[e]) {\n            int v = to[e];\n            s += dfs(v);\n        }\n        size[u] = s;\n        return s;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(in.readLine().trim());\n\n        StringBuilder sb = new StringBuilder();\n        while (t-- > 0) {\n            int k = Integer.parseInt(in.readLine().trim());\n            long globalOR = 0;\n            boolean singleTree = (k == 1);\n\n            long bestSingle = 0;   // only used if singleTree\n            for (int treeIdx = 0; treeIdx < k; treeIdx++) {\n                int n = Integer.parseInt(in.readLine().trim());\n                if (n == 0) {\n                    // empty tree?\n                    in.readLine();\n                    continue;\n                }\n                // initialize adjacency\n                for (int i = 1; i <= n; i++) head[i] = -1;\n                ec = 0;\n\n                // read parents p2..pn\n                String[] parts = in.readLine().trim().split(\" \");\n                for (int i = 2; i <= n; i++) {\n                    int p = Integer.parseInt(parts[i-2]);\n                    addEdge(p, i);\n                }\n\n                // compute subtree sizes by DFS from root=1\n                int N = dfs(1);\n\n                // If we have at least two trees, we OR together every subtree size\n                if (!singleTree) {\n                    for (int i = 1; i <= n; i++) {\n                        globalOR |= size[i];\n                    }\n                } else {\n                    // Exactly one tree: we apply the special maximization\n                    // 1) cutting the entire tree at once => N\n                    long best = N;\n                    // 2) try cutting off exactly one proper subtree of size s, then root leftover = N-s\n                    for (int i = 2; i <= n; i++) {\n                        int s = size[i];\n                        long candidate = ((long)s) | ((long)(N - s));\n                        if (candidate > best) best = candidate;\n                    }\n                    bestSingle = best;\n                }\n            }\n\n            long ans = singleTree ? bestSingle : globalOR;\n            sb.append(ans).append('\\n');\n        }\n        System.out.print(sb);\n    }\n}\n```\n\n**Explanation of key steps**\n\n1.  We read the forest tree‐by‐tree.\n2.  For each tree we build its adjacency by reading the parent array, then do a single DFS to compute every node’s subtree size.\n3.  \n   - If there are **two or more** trees in the forest, we know we can mix bits from *different* trees arbitrarily.  In fact one can show that in that case the maximal final OR is simply\n     \n     \\[\n       \\biggl(\\bigvee_{\\text{all subtrees }T} \\mathrm{size}(T)\\biggr),\n     \\]\n     \n     i.e.\\ the bitwise OR of *all* original subtree‐sizes.\n   - If there is **exactly one** tree (so that all cuts must come from this single tree), one shows that the best you can do is either\n     - cut **only** the root (size \\(N\\)), or\n     - cut **exactly one** proper subtree of size \\(s\\) first, then cut the remainder of size \\(N-s\\),\n       \n       and take the maximum over\n       \\[\n         N\n         \\quad\\text{or}\\quad\n         s\\;\\bigl|\\;(N - s),\n       \\]\n       for all proper‐subtrees of size \\(s\\).  \n     Taking the best of those two possibilities yields the maximum OR you can get from that one tree.\n4.  We print the result per test case.\n\nThis runs in \\(O\\bigl(\\sum n\\bigr)\\) time overall (each node is touched only a constant number of times)."
  },
  {
    "role": "user",
    "content": "Your recursive DFS may overflow the Java call stack on a chain of up to 1e6 nodes. Please provide one block of Java code that replaces recursion with an explicit stack (iterative post-order) to compute subtree sizes, handles the k=1 special case and the k>=2 OR-all-subtrees case, and is ready for submission without any extra explanation."
  },
  {
    "role": "assistant",
    "content": "```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int MAXN = 1000005;\n    static int[] head = new int[MAXN];\n    static int[] to   = new int[MAXN];\n    static int[] nxt  = new int[MAXN];\n    static int   ec;\n    static int[] size = new int[MAXN];\n    static int[] stackNode  = new int[MAXN];\n    static int[] stackState = new int[MAXN];\n\n    static void addEdge(int u, int v) {\n        to[ec] = v;\n        nxt[ec] = head[u];\n        head[u] = ec++;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        int t = Integer.parseInt(in.readLine().trim());\n        while (t-- > 0) {\n            int k = Integer.parseInt(in.readLine().trim());\n            boolean multiple = (k >= 2);\n            long globalOR = 0;\n            long bestSingle = 0L;\n\n            for (int ti = 0; ti < k; ti++) {\n                int n = Integer.parseInt(in.readLine().trim());\n                // init adjacency\n                for (int i = 1; i <= n; i++) head[i] = -1;\n                ec = 0;\n\n                if (n > 1) {\n                    StringTokenizer st = new StringTokenizer(in.readLine());\n                    for (int i = 2; i <= n; i++) {\n                        int p = Integer.parseInt(st.nextToken());\n                        addEdge(p, i);\n                    }\n                } else {\n                    // single node tree: no parents line or empty\n                    if (n == 1) {\n                        String line = in.readLine().trim();\n                        if (!line.isEmpty()) {\n                            // in case there's an extra blank\n                        }\n                    }\n                }\n\n                // iterative post-order DFS from root=1\n                int sp = 0;\n                stackNode[sp] = 1;\n                stackState[sp] = 0;\n                sp++;\n                while (sp > 0) {\n                    sp--;\n                    int u = stackNode[sp];\n                    int stt = stackState[sp];\n                    if (stt == 0) {\n                        // pre\n                        stackNode[sp] = u;\n                        stackState[sp] = 1;\n                        sp++;\n                        // push children\n                        for (int e = head[u]; e != -1; e = nxt[e]) {\n                            int v = to[e];\n                            stackNode[sp] = v;\n                            stackState[sp] = 0;\n                            sp++;\n                        }\n                    } else {\n                        // post\n                        int s = 1;\n                        for (int e = head[u]; e != -1; e = nxt[e]) {\n                            s += size[to[e]];\n                        }\n                        size[u] = s;\n                    }\n                }\n\n                int N = size[1];\n                if (multiple) {\n                    for (int i = 1; i <= n; i++) {\n                        globalOR |= size[i];\n                    }\n                } else {\n                    long best = N; \n                    for (int i = 2; i <= n; i++) {\n                        long s = size[i];\n                        long cand = s | (N - s);\n                        if (cand > best) best = cand;\n                    }\n                    bestSingle = best;\n                }\n            }\n\n            long ans = multiple ? globalOR : bestSingle;\n            out.append(ans).append('\\n');\n        }\n        System.out.print(out.toString());\n    }\n}\n```"
  }
]