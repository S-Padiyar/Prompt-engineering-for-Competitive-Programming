Problem Restatement  
We have \(n\) piles of stones, with the \(i\)-th pile containing \(a_i\) stones. Two players (Alice first, then Bob, alternating) may on their turn choose any nonempty pile of size \(x\) and remove a positive number \(y\le x\) of stones **only if** \(\gcd(x,y)=1\). The player who cannot move loses. Both play optimally. We need to determine who wins.

Key Observation (Sprague–Grundy / Nim‐equivalence)  
This is an impartial game.  Each pile of size \(x\) has a Grundy number \(g(x)\).  The overall position is winning for the first player (Alice) if and only if the XOR of all pile‐Grundy values is nonzero.

We compute  
- \(g(0)=0\).  
- By definition  
  \[
    g(x)\;=\;\mathrm{mex}\Bigl\{g(x-y)\colon 1\le y\le x,\ \gcd(x,y)=1\Bigr\}.
  \]  

By experimenting (and as known from the Codeforces editorial), one finds:
1. If \(x\) is even and \(x>0\), then \(g(x)=0\).
2. If \(x=1\), then \(g(1)=1\).
3. If \(x\) is odd and \(x>1\), let \(p\) be the smallest (odd) prime divisor of \(x\).  Then
   \[
     g(x) \;=\; (\text{“index of }p\text{ among odd primes”}) \;+\; 2.
   \]
   For example, the odd primes in order are \(3,5,7,11,\dots\).  So
   \[
     p=3\mapsto g(x)=0+2=2,\quad
     p=5\mapsto g(x)=1+2=3,\quad
     p=7\mapsto g(x)=2+2=4,\dots
   \]

Thus to solve:
1. Precompute the smallest prime factor (spf) for every integer up to the maximum \(a_i\) using a linear or nearly‐linear sieve.
2. As we find each odd prime \(p>2\), assign it an increasing index (0 for \(p=3\), 1 for \(p=5\), etc.).
3. Then for any pile \(a\):
   - If \(a=1\), Grundy \(\,=1.\)
   - Else if \(a\) even, Grundy \(\,=0.\)
   - Else (\(a\) odd \(>1\)), Grundy \(\,= \bigl(\text{indexOf}[\text{spf}[a]]\bigr)+2.\)
4. XOR all those Grundy values.  If the result is nonzero, Alice wins; otherwise Bob wins.

Complexities  
- Sieve up to \(\max a_i\le10^7\) in \(O(N)\) time, where \(N=10^7\).  
- Processing all piles: \(O(\sum n)\), \(\sum n\le3\cdot10^5\).  
Overall well within the 2 s / 512 MB limits.

Java Implementation

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        // Fast input
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        
        int t = Integer.parseInt(br.readLine().trim());
        // We'll store each test's a[i] in a list, to process after we know the max-value
        List<int[]> testCases = new ArrayList<>(t);
        int globalMax = 0;
        
        // Read all test cases, track global maximum a_i
        for (int _case = 0; _case < t; _case++) {
            int n = Integer.parseInt(br.readLine().trim());
            int[] a = new int[n];
            st = new StringTokenizer(br.readLine());
            for (int i = 0; i < n; i++) {
                a[i] = Integer.parseInt(st.nextToken());
                if (a[i] > globalMax) {
                    globalMax = a[i];
                }
            }
            testCases.add(a);
        }
        
        // Sieve up to globalMax to get smallest prime factor (spf)
        int N = globalMax;
        int[] spf = new int[N + 1];       // spf[x] = smallest prime factor of x
        int[] oddPrimeIdx = new int[N + 1]; 
        // oddPrimeIdx[p] = index among odd primes for prime p>2, otherwise -1
        Arrays.fill(oddPrimeIdx, -1);
        
        // Linear sieve to fill spf[]
        List<Integer> primes = new ArrayList<>();
        for (int i = 2; i <= N; i++) {
            if (spf[i] == 0) {
                // i is prime
                spf[i] = i;
                primes.add(i);
            }
            for (int p : primes) {
                long prod = 1L * p * i;
                if (prod > N) break;
                spf[(int)prod] = p;
                if (p == spf[i]) {
                    // Once p divides i, we stop in a linear sieve
                    break;
                }
            }
        }
        
        // Assign indices to odd primes p>2
        int oddIdx = 0;
        for (int p : primes) {
            if (p > 2) {
                oddPrimeIdx[p] = oddIdx++;
            }
        }
        
        // Now process each test, compute XOR of Grundy values, and output
        StringBuilder sb = new StringBuilder();
        for (int[] a : testCases) {
            int xorSum = 0;
            for (int x : a) {
                int g;
                if (x == 1) {
                    // Only move: remove 1 -> 0, so mex{0}=1
                    g = 1;
                } else if ((x & 1) == 0) {
                    // Even sizes all have Grundy value 0
                    g = 0;
                } else {
                    // Odd > 1: use index of smallest prime factor + 2
                    int p = spf[x];
                    g = oddPrimeIdx[p] + 2;
                }
                xorSum ^= g;
            }
            sb.append((xorSum != 0) ? "Alice\n" : "Bob\n");
        }
        
        // Print all answers at once
        System.out.print(sb.toString());
    }
}
```

Explanation of Key Steps  
1. **Reading Input:** We first read all test cases, storing each pile array and keeping track of the maximum stone count (`globalMax`).  
2. **Computing SPF (Smallest Prime Factor):**  
   - We use a linear sieve up to `globalMax`, which runs in \(O(N)\).  
   - `spf[x]` stores the smallest prime factor of `x`.  
3. **Indexing Odd Primes:**  
   - While we extract all primes, we assign each odd prime \(p>2\) a unique 0-based index, stored in `oddPrimeIdx[p]`.  
4. **Grundy‐Value Formula:**  
   - \(x=1\): Grundy \(=1\).  
   - \(x\) even (and \(>0\)): Grundy \(=0\).  
   - \(x\) odd \(>1\): Grundy \(=\text{oddPrimeIdx}[\text{spf}[x]]+2\).  
5. **Winner Determination:**  
   - We XOR together every pile’s Grundy value; if the result is nonzero, Alice (first player) wins, otherwise Bob wins.

Time and Space Complexity  
- Sieve up to \(10^7\): \(O(N)\approx O(10^7)\).  
- Processing up to \(\sum n\le3\times10^5\) piles in \(O(\sum n)\).  
- Memory:  
  - `spf[]` and `oddPrimeIdx[]` arrays of size \(\le10^7\), about 80 MB together, well within 512 MB.  
  - Storing up to \(3\times10^5\) integers for piles.  

This meets the problem’s time (2 s) and memory (512 MB) constraints.