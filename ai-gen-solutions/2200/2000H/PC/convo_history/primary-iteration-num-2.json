[
  {
    "role": "user",
    "content": "H. Ksyusha and the Loaded Set\n\ntime limit per test3 seconds\n\nmemory limit per test512 megabytes\n\nKsyusha decided to start a game development company. To stand out among competitors and achieve success, she decided to write her own game engine. The engine must support a set initially consisting of n\n\n distinct integers a1,a2,…,an\n\n.\n\n\n\nThe set will undergo m\n\n operations sequentially. The operations can be of the following types:\n\n\n\nInsert element x\n\n into the set;\n\nRemove element x\n\n from the set;\n\nReport the k\n\n-load of the set.\n\nThe k\n\n-load of the set is defined as the minimum positive integer d\n\n such that the integers d,d+1,…,d+(k−1)\n\n do not appear in this set. For example, the 3\n\n-load of the set {3,4,6,11}\n\n is 7\n\n, since the integers 7,8,9\n\n are absent from the set, and no smaller value fits.\n\n\n\nKsyusha is busy with management tasks, so you will have to write the engine. Implement efficient support for the described operations.\n\n\n\nInput\n\nThe first line contains an integer t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nThe following lines describe the test cases.\n\n\n\nThe first line contains an integer n\n\n (1≤n≤2⋅105\n\n) — the initial size of the set.\n\n\n\nThe second line contains n\n\n integers a1,a2,…,an\n\n (1≤a1<a2<…<an≤2⋅106\n\n) — the initial state of the set.\n\n\n\nThe third line contains an integer m\n\n (1≤m≤2⋅105\n\n) — the number of operations.\n\n\n\nThe next m\n\n lines contain the operations. The operations are given in the following format:\n\n\n\n+ x\n\n (1≤x≤2⋅106\n\n) — insert element x\n\n into the set (it is guaranteed that x\n\n is not in the set);\n\n- x\n\n (1≤x≤2⋅106\n\n) — remove element x\n\n from the set (it is guaranteed that x\n\n is in the set);\n\n? k\n\n (1≤k≤2⋅106\n\n) — output the value of the k\n\n-load of the set.\n\nIt is guaranteed that the sum of n\n\n across all test cases does not exceed 2⋅105\n\n, and the same holds for m\n\n.\n\n\n\nOutput\n\nFor each test case, output the answers to the operations of type \"?\".\n\n\n\nExample\n\nInputCopy\n\n3\n\n5\n\n1 2 5 905 2000000\n\n15\n\n- 2\n\n? 2\n\n? 1\n\n- 1\n\n? 1\n\n+ 4\n\n+ 2\n\n? 2\n\n+ 6\n\n- 4\n\n+ 7\n\n? 2\n\n? 3\n\n? 4\n\n? 2000000\n\n5\n\n3 4 5 6 8\n\n9\n\n? 5\n\n- 5\n\n? 5\n\n+ 1\n\n? 2\n\n- 6\n\n- 8\n\n+ 6\n\n? 5\n\n5\n\n6 7 8 9 10\n\n10\n\n? 5\n\n- 6\n\n? 4\n\n- 10\n\n+ 5\n\n- 8\n\n+ 3\n\n+ 2\n\n- 3\n\n+ 10\n\nOutputCopy\n\n2 2 1 6 3 8 8 2000001 \n\n9 9 9 7 \n\n1 1 \n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have a dynamic set \\(S\\) of integers (initially of size \\(n\\)), supporting three kinds of operations:\n\n1. **Insert** \\(x\\): \\(x\\notin S\\) is added to \\(S\\).  \n2. **Remove** \\(x\\): \\(x\\in S\\) is removed from \\(S\\).  \n3. **Query** \\(k\\): We must find the smallest positive integer \\(d\\) such that the entire length-\\(k\\) interval\n\\[\n[d,\\;d+1,\\;\\dots,\\;d+(k-1)]\n\\]\nis **completely disjoint** from \\(S\\).  Equivalently, that interval is all missing from \\(S\\).  We call this the *\\(k\\)-load* of \\(S\\).\n\nSince \\(n,m\\) can be up to \\(2\\cdot10^5\\) and the elements themselves can be up to \\(2\\cdot10^6\\), we need an \\(O(\\log n)\\) (amortized) data structure per update/query.  A classical way is:\n\n- Keep track of the **missing intervals** (complement of \\(S\\) in a large enough universe) as a set of disjoint intervals \\([L,R]\\).\n- Support splits and merges of those intervals when we insert or remove a point.\n- Augment this set of intervals (in a balanced BST, e.g. a treap) so that each node stores, in addition to its own interval \\([L,R]\\), the maximum interval‐length in its subtree.  \n- To answer “find the leftmost interval of length \\(\\ge k\\)”, we walk down the treap in \\(O(\\log n)\\) by always first checking the left child’s stored maximum‐length, then the node itself, then the right child.  \n\nBecause all updates (interval‐splits and interval‐merges) affect only \\(O(1)\\) intervals, each insertion or removal of a single integer \\(x\\) takes \\(O(\\log N)\\), and queries also take \\(O(\\log N)\\).  Here \\(N\\) is the current number of intervals, which is bounded by \\(O(n+m)\\).\n\nWe must be sure to cover “all large positive integers after the maximum element of \\(S\\).”  Concretely, if the largest element ever inserted into \\(S\\) is at most \\(2\\,000\\,000\\) and if we may be asked for a \\(k\\) up to \\(2\\,000\\,000\\), then any block of \\(k\\) consecutive integers starting beyond \\(2\\,000\\,000\\) will be entirely missing anyway.  Thus we introduce a sentinel “missing interval” that stretches from “one past the largest possible element” out to a comfortably large bound (say \\(4\\,000\\,005\\)).  That way we never run out of missing space.\n\nBelow is a Java implementation using a randomized treap to maintain the missing intervals.\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class Node {\n        int l, r;          // the interval [l..r]\n        int len;           // = r-l+1\n        int maxlen;        // max interval-length in this subtree\n        int priority;      // very large-range random priority\n        Node left, right;  // treap children\n\n        Node(int l, int r, Random rng) {\n            this.l = l;\n            this.r = r;\n            this.len = r - l + 1;\n            this.maxlen = this.len;\n            this.priority = rng.nextInt();\n        }\n    }\n\n    // Recompute the maxlen of t from its children and itself\n    static void update(Node t) {\n        if (t == null) return;\n        t.len = t.r - t.l + 1;\n        int m = t.len;\n        if (t.left != null && t.left.maxlen > m) m = t.left.maxlen;\n        if (t.right != null && t.right.maxlen > m) m = t.right.maxlen;\n        t.maxlen = m;\n    }\n\n    // Split t into [<= key] and [> key], by the interval-start t.l\n    // returns a pair {L, R}\n    static Node[] split(Node t, int key) {\n        if (t == null) return new Node[]{null, null};\n        if (t.l <= key) {\n            Node[] sr = split(t.right, key);\n            t.right = sr[0];\n            update(t);\n            return new Node[]{t, sr[1]};\n        } else {\n            Node[] sl = split(t.left, key);\n            t.left = sl[1];\n            update(t);\n            return new Node[]{sl[0], t};\n        }\n    }\n\n    // Merge two treaps, all keys in a <= all keys in b\n    static Node merge(Node a, Node b) {\n        if (a == null) return b;\n        if (b == null) return a;\n        if (a.priority > b.priority) {\n            a.right = merge(a.right, b);\n            update(a);\n            return a;\n        } else {\n            b.left = merge(a, b.left);\n            update(b);\n            return b;\n        }\n    }\n\n    // Remove exactly the node whose interval-start == key (if it exists)\n    // from treap t, and return the new treap root.\n    static Node removeKey(Node t, int key) {\n        // first split off <=key  vs >key\n        Node[] sp1 = split(t, key);\n        // from sp1[0] we split off <=key-1 vs exactly key\n        Node[] sp2 = split(sp1[0], key - 1);\n        // sp2[1] would be the node with interval-start==key (if it exists)\n        // discard sp2[1], then re-merge\n        return merge(sp2[0], sp1[1]);\n    }\n\n    // Insert a new node (interval) into the treap\n    static Node insertNode(Node t, Node nd) {\n        if (t == null) {\n            update(nd);\n            return nd;\n        }\n        if (nd.priority > t.priority) {\n            // split t by nd.l, then put nd on top\n            Node[] sp = split(t, nd.l);\n            nd.left = sp[0];\n            nd.right = sp[1];\n            update(nd);\n            return nd;\n        } else if (nd.l < t.l) {\n            t.left = insertNode(t.left, nd);\n            update(t);\n            return t;\n        } else {\n            t.right = insertNode(t.right, nd);\n            update(t);\n            return t;\n        }\n    }\n\n    // Find in treap t the node with largest start <= x.\n    // This is \"floor\" by key=l.  May return null if none.\n    static Node findFloor(Node t, int x) {\n        if (t == null) return null;\n        if (t.l > x) {\n            return findFloor(t.left, x);\n        } else {\n            Node cand = findFloor(t.right, x);\n            return (cand != null ? cand : t);\n        }\n    }\n\n    // Find the leftmost interval of length >= k and return its start l.\n    // We rely on each node storing the maximum length in its subtree.\n    static int findLeftmostGeq(Node t, int k) {\n        // we assume t.maxlen >= k\n        Node cur = t;\n        while (true) {\n            // If the left subtree has an interval >= k, go left\n            if (cur.left != null && cur.left.maxlen >= k) {\n                cur = cur.left;\n                continue;\n            }\n            // Otherwise, check the current node\n            if (cur.len >= k) {\n                return cur.l;\n            }\n            // else must be in the right subtree\n            cur = cur.right;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        StringTokenizer st;\n        int T = Integer.parseInt(br.readLine().trim());\n\n        Random rng = new Random(1234567);\n\n        for (int tc = 0; tc < T; tc++) {\n            int n = Integer.parseInt(br.readLine().trim());\n            st = new StringTokenizer(br.readLine());\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = Integer.parseInt(st.nextToken());\n\n            int m = Integer.parseInt(br.readLine().trim());\n            char[] op = new char[m];\n            int[] vx = new int[m];\n            int kmax = 0;\n            for (int i = 0; i < m; i++) {\n                st = new StringTokenizer(br.readLine());\n                op[i] = st.nextToken().charAt(0);\n                vx[i] = Integer.parseInt(st.nextToken());\n                if (op[i] == '?') {\n                    kmax = Math.max(kmax, vx[i]);\n                }\n            }\n\n            // We'll use a sentinel upper‐bound so that we never run out of missing space\n            final int MAXP = 2_000_000;\n            int INF = MAXP + kmax + 5;\n\n            // Build initial treap of missing intervals\n            Node root = null;\n            // If a[0] > 1, we have a gap [1..a[0]-1]\n            if (n == 0 || a[0] > 1) {\n                root = insertNode(root, new Node(1, (n==0? INF : a[0]-1), rng));\n            }\n            // Gaps between consecutive a[i], a[i+1]\n            for (int i = 0; i+1 < n; i++) {\n                if (a[i+1] - a[i] > 1) {\n                    root = insertNode(root,\n                                      new Node(a[i]+1, a[i+1]-1, rng));\n                }\n            }\n            // Gap from last element to INF\n            if (n > 0 && a[n-1] < INF) {\n                root = insertNode(root, new Node(a[n-1]+1, INF, rng));\n            }\n\n            // Process the operations\n            for (int i = 0; i < m; i++) {\n                int x = vx[i];\n                if (op[i] == '+') {\n                    // Insert x into S => x was missing => we split the interval containing x\n                    Node iv = findFloor(root, x);\n                    // iv.l <= x <= iv.r\n                    root = removeKey(root, iv.l);\n                    if (iv.l <= x-1) {\n                        root = insertNode(root, new Node(iv.l, x-1, rng));\n                    }\n                    if (x+1 <= iv.r) {\n                        root = insertNode(root, new Node(x+1, iv.r, rng));\n                    }\n                }\n                else if (op[i] == '-') {\n                    // Remove x from S => x becomes missing => we may merge with neighbors\n                    // Look for an interval ending at x-1\n                    Node leftIv = findFloor(root, x-1);\n                    boolean leftMerge = (leftIv != null && leftIv.r == x-1);\n\n                    // Look for an interval starting at x+1\n                    Node rightIv = findFloor(root, x+1);\n                    boolean rightMerge = (rightIv != null && rightIv.l == x+1);\n\n                    if (leftMerge && rightMerge) {\n                        int L = leftIv.l, R = rightIv.r;\n                        root = removeKey(root, leftIv.l);\n                        root = removeKey(root, rightIv.l);\n                        root = insertNode(root, new Node(L, R, rng));\n                    } else if (leftMerge) {\n                        int L = leftIv.l, R = x;\n                        root = removeKey(root, leftIv.l);\n                        root = insertNode(root, new Node(L, R, rng));\n                    } else if (rightMerge) {\n                        int L = x, R = rightIv.r;\n                        root = removeKey(root, rightIv.l);\n                        root = insertNode(root, new Node(L, R, rng));\n                    } else {\n                        // stand‐alone [x..x]\n                        root = insertNode(root, new Node(x, x, rng));\n                    }\n                }\n                else { // op[i] == '?'\n                    int k = x;\n                    // We know we always have an interval of length >= k\n                    int ans = findLeftmostGeq(root, k);\n                    out.append(ans).append(' ');\n                }\n            }\n            out.append('\\n');\n        }\n\n        System.out.print(out.toString());\n    }\n}\n```\n\n**Explanation of key points**\n\n1. **Missing‐interval representation**  \n   We keep a dynamic set of disjoint intervals \\([L,R]\\) covering exactly all the non‐present elements.  Whenever we insert a number \\(x\\) into the present set \\(S\\), we remove \\(x\\) from the missing intervals (splitting one interval into up to two).  Whenever we remove \\(x\\) from \\(S\\), we add \\(x\\) into the missing intervals (possibly merging with an interval ending at \\(x-1\\) and/or one starting at \\(x+1\\)).\n\n2. **Treap with subtree‐max augmentation**  \n   We store each missing interval in a treap node keyed by its left endpoint \\(L\\).  Each node also records the maximum interval‐length appearing anywhere in its subtree (`maxlen`).  Thus, to answer “first missing interval of length ≥ k,” we walk down:\n\n   - If left child’s `maxlen ≥ k`, recurse left.\n   - Else if this node’s interval‐length ≥ k`, we found our answer.\n   - Else recurse right.\n\n   This takes \\(O(\\log N)\\), where \\(N\\) is the number of disjoint missing intervals.\n\n3. **Sentinel interval**  \n   We do not know exactly how large a missing interval might be “at the end” of the universe, so we introduce a sentinel top interval \\([\\,\\max S+1,\\;\\;\\text{BIG}\\,]\\) where `BIG = 2\\,000\\,000 + k_max + 5`.  Since no element above \\(2\\,000\\,000\\) ever gets inserted by the problem statement, that entire tail remains missing, and it is guaranteed to be at least \\(k_{\\max}\\) long so it will serve any query.\n\nThe overall complexity is\n\n- \\(O((n + m)\\log(n + m))\\) per test (insertion/removal of a single integer costs \\(O(\\log N)\\), query costs \\(O(\\log N)\\)),  \n- and the sums of \\(n\\) and \\(m\\) over all tests do not exceed \\(2\\cdot10^5\\),  \n\nwhich easily runs under the time and memory limits."
  },
  {
    "role": "user",
    "content": "Please provide a single, complete Java solution in one code block only, without any extra explanation or markdown formatting."
  },
  {
    "role": "assistant",
    "content": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class Node {\n        int l, r, len, maxlen, priority;\n        Node left, right;\n        Node(int l, int r, Random rng) {\n            this.l = l; this.r = r;\n            this.len = r - l + 1;\n            this.maxlen = this.len;\n            this.priority = rng.nextInt();\n        }\n    }\n\n    static void update(Node t) {\n        if (t == null) return;\n        t.len = t.r - t.l + 1;\n        int m = t.len;\n        if (t.left != null && t.left.maxlen > m) m = t.left.maxlen;\n        if (t.right != null && t.right.maxlen > m) m = t.right.maxlen;\n        t.maxlen = m;\n    }\n\n    static Node[] split(Node t, int key) {\n        if (t == null) return new Node[]{null, null};\n        if (t.l <= key) {\n            Node[] sr = split(t.right, key);\n            t.right = sr[0];\n            update(t);\n            return new Node[]{t, sr[1]};\n        } else {\n            Node[] sl = split(t.left, key);\n            t.left = sl[1];\n            update(t);\n            return new Node[]{sl[0], t};\n        }\n    }\n\n    static Node merge(Node a, Node b) {\n        if (a == null) return b;\n        if (b == null) return a;\n        if (a.priority > b.priority) {\n            a.right = merge(a.right, b);\n            update(a);\n            return a;\n        } else {\n            b.left = merge(a, b.left);\n            update(b);\n            return b;\n        }\n    }\n\n    static Node removeKey(Node t, int key) {\n        Node[] sp1 = split(t, key);\n        Node[] sp2 = split(sp1[0], key - 1);\n        return merge(sp2[0], sp1[1]);\n    }\n\n    static Node insertNode(Node t, Node nd) {\n        if (t == null) {\n            update(nd);\n            return nd;\n        }\n        if (nd.priority > t.priority) {\n            Node[] sp = split(t, nd.l);\n            nd.left = sp[0];\n            nd.right = sp[1];\n            update(nd);\n            return nd;\n        } else if (nd.l < t.l) {\n            t.left = insertNode(t.left, nd);\n            update(t);\n            return t;\n        } else {\n            t.right = insertNode(t.right, nd);\n            update(t);\n            return t;\n        }\n    }\n\n    static Node findFloor(Node t, int x) {\n        if (t == null) return null;\n        if (t.l > x) {\n            return findFloor(t.left, x);\n        } else {\n            Node cand = findFloor(t.right, x);\n            return (cand != null ? cand : t);\n        }\n    }\n\n    static int findLeftmostGeq(Node t, int k) {\n        Node cur = t;\n        while (true) {\n            if (cur.left != null && cur.left.maxlen >= k) {\n                cur = cur.left;\n                continue;\n            }\n            if (cur.len >= k) {\n                return cur.l;\n            }\n            cur = cur.right;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        int T = Integer.parseInt(br.readLine().trim());\n        Random rng = new Random(1234567);\n\n        for (int tc = 0; tc < T; tc++) {\n            int n = Integer.parseInt(br.readLine().trim());\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(br.readLine().trim());\n            char[] op = new char[m];\n            int[] vx = new int[m];\n            int kmax = 0;\n            for (int i = 0; i < m; i++) {\n                st = new StringTokenizer(br.readLine());\n                op[i] = st.nextToken().charAt(0);\n                vx[i] = Integer.parseInt(st.nextToken());\n                if (op[i] == '?') kmax = Math.max(kmax, vx[i]);\n            }\n\n            final int MAXP = 2_000_000;\n            int INF = MAXP + kmax + 5;\n            Node root = null;\n            if (n == 0 || a[0] > 1) {\n                root = insertNode(root, new Node(1, (n==0? INF : a[0]-1), rng));\n            }\n            for (int i = 0; i+1 < n; i++) {\n                if (a[i+1] - a[i] > 1) {\n                    root = insertNode(root, new Node(a[i]+1, a[i+1]-1, rng));\n                }\n            }\n            if (n > 0 && a[n-1] < INF) {\n                root = insertNode(root, new Node(a[n-1]+1, INF, rng));\n            }\n\n            for (int i = 0; i < m; i++) {\n                int x = vx[i];\n                if (op[i] == '+') {\n                    Node iv = findFloor(root, x);\n                    root = removeKey(root, iv.l);\n                    if (iv.l <= x-1) root = insertNode(root, new Node(iv.l, x-1, rng));\n                    if (x+1 <= iv.r) root = insertNode(root, new Node(x+1, iv.r, rng));\n                } else if (op[i] == '-') {\n                    Node leftIv = findFloor(root, x-1);\n                    boolean leftMerge = leftIv != null && leftIv.r == x-1;\n                    Node rightIv = findFloor(root, x+1);\n                    boolean rightMerge = rightIv != null && rightIv.l == x+1;\n                    if (leftMerge && rightMerge) {\n                        int L = leftIv.l, R = rightIv.r;\n                        root = removeKey(root, leftIv.l);\n                        root = removeKey(root, rightIv.l);\n                        root = insertNode(root, new Node(L, R, rng));\n                    } else if (leftMerge) {\n                        int L = leftIv.l, R = x;\n                        root = removeKey(root, leftIv.l);\n                        root = insertNode(root, new Node(L, R, rng));\n                    } else if (rightMerge) {\n                        int L = x, R = rightIv.r;\n                        root = removeKey(root, rightIv.l);\n                        root = insertNode(root, new Node(L, R, rng));\n                    } else {\n                        root = insertNode(root, new Node(x, x, rng));\n                    }\n                } else {\n                    int ans = findLeftmostGeq(root, x);\n                    out.append(ans).append(' ');\n                }\n            }\n            out.append('\\n');\n        }\n        System.out.print(out.toString());\n    }\n}"
  }
]