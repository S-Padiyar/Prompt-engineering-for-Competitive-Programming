Problem Restatement

We have \(n\) rectangles. Rectangle \(i\) has width \(a_i\) and height \(b_i\).  We can color individual cells one at a time.  Whenever we manage to fully color an entire row of a rectangle (all its \(a_i\) cells) or an entire column (all its \(b_i\) cells), we earn one point per completed row or column.  Coloring the same cell twice does nothing extra.

We need to collect at least \(k\) points total (summing over all rectangles).  Our task is to minimize the total number of single–cell coloring operations used.  If it is impossible to reach \(k\) points, we output \(-1\).

Key insights

1.  **Within one rectangle** of dimensions \(a \times b\), if we choose to fully color \(r\) rows and \(c\) columns,
    - we earn \(r + c\) points,
    - we must color all cells in those rows and columns.  Naïvely that seems to cost \(r\cdot a + c\cdot b\) operations, but those \(r \times c\) intersections are double–counted.  So the true cost is
      \[
        \text{cost}(r,c) \;=\;
        r\,a \;+\; c\,b \;-\; r\,c.
      \]
2.  For a single rectangle \(i\), define
    \[
       g_i(t) \;=\;
       \min_{\substack{0 \le r \le b_i,\,0 \le c \le a_i\\r+c = t}}
       \bigl[r\,a_i \;+\; c\,b_i - r\,c\bigr],
       \quad
       t=0,1,\dots,a_i+b_i.
    \]
    That is the minimum cost to earn exactly \(t\) points from that rectangle.
3.  We now have a classic “group knapsack” over the rectangles.  We maintain a global DP array
   \[
      \mathrm{dp}[j]
      =
      \text{minimum cost to earn exactly } j \text{ points so far},
      \quad j=0,1,\dots,k.
   \]
   Initially \(\mathrm{dp}[0]=0\), and \(\mathrm{dp}[1\ldots k]=\infty\).  
4.  For each rectangle \(i\), we merge it into the global DP by trying all ways \(t\) of taking points from that rectangle (from \(1\) up to \(\min(k,a_i+b_i)\)), and doing
   \[
     \mathrm{dp\_new}[j+t]
     \;=\;
     \min\bigl(\mathrm{dp\_new}[j+t],\;\mathrm{dp}[j] + g_i(t)\bigr),
   \]
   iterating \(j\) from \(k\) down to \(0\) to avoid double–counting in one rectangle.
5.  At the end, if \(\mathrm{dp}[k]\) is still \(\infty\), answer \(-1\); otherwise output \(\mathrm{dp}[k]\).

Complexities

- We only ever need points up to \(k\le100\).
- For each rectangle \(i\):
  - We compute \(g_i(t)\) for \(t=0\ldots U\), where \(U=\min(k,\,a_i+b_i)\).  Computing each \(g_i(t)\) takes up to \(O(a_i+b_i)\) tries of splitting into \((r,c)\).  Since \(a_i,b_i\le100\), that is \(O(200)\) work per rectangle.
  - We then merge into the global DP in \(O(k\cdot U)\), again up to \(100\cdot200=2\!000\) steps.
- With \(n\le1000\) and \(\sum n\le1000\) over all test cases, the total work is roughly 
  \[
    O\bigl(\sum_i (200 + 20000)\bigr)\;\approx\; O(20\,\mathrm{million}),
  \]
  which runs comfortably within the 3-second limit in Java.

Java Implementation

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        int t = Integer.parseInt(in.readLine().trim());
        final int INF = 1_000_000_000;

        while (t-- > 0) {
            st = new StringTokenizer(in.readLine());
            int n = Integer.parseInt(st.nextToken());
            int k = Integer.parseInt(st.nextToken());

            // dp[j] = min cost to earn exactly j points so far
            int[] dp = new int[k + 1];
            Arrays.fill(dp, INF);
            dp[0] = 0;

            // Keep track of maximum possible total points
            int sumPoints = 0;

            for (int i = 0; i < n; i++) {
                st = new StringTokenizer(in.readLine());
                int a = Integer.parseInt(st.nextToken());
                int b = Integer.parseInt(st.nextToken());
                sumPoints += a + b;

                // We only need g[t] up to t = min(k, a+b)
                int U = Math.min(k, a + b);
                int[] g = new int[U + 1];
                Arrays.fill(g, INF);
                g[0] = 0;

                // Precompute the best cost g[t] for exactly t points from this rectangle
                for (int tPts = 1; tPts <= U; tPts++) {
                    // We choose r rows and c cols with r + c = tPts
                    // 0 <= r <= b, 0 <= c <= a
                    int best = INF;
                    // r = number of rows
                    int rMin = Math.max(0, tPts - a);
                    int rMax = Math.min(tPts, b);
                    for (int r = rMin; r <= rMax; r++) {
                        int c = tPts - r;
                        int cost = r * a + c * b - r * c; 
                        if (cost < best) best = cost;
                    }
                    g[tPts] = best;
                }

                // Merge g[] into the global dp[] with a group-knapsack step
                for (int j = k; j >= 0; j--) {
                    if (dp[j] == INF) continue;
                    for (int tPts = 1; tPts <= U && j + tPts <= k; tPts++) {
                        int cst = g[tPts];
                        if (cst == INF) continue;
                        dp[j + tPts] = Math.min(dp[j + tPts], dp[j] + cst);
                    }
                }
            }

            // If total possible points < k, impossible
            if (sumPoints < k || dp[k] >= INF) {
                System.out.println(-1);
            } else {
                System.out.println(dp[k]);
            }
        }
    }
}
```

Explanation of Key Steps

1. **Reading Input**  
   We read \(t\) test cases.  For each test case we read \(n\) and \(k\), then the \(n\) pairs \((a_i,b_i)\).

2. **State**  
   We maintain a 1D DP array `dp[0..k]` where `dp[j]` is the minimum number of single‐cell colorings needed to earn exactly \(j\) points so far.

3. **Per‐Rectangle Computation**  
   For each rectangle of size \(a\times b\), we build an auxiliary array `g[0..U]`, where \(U=\min(k,\;a+b)\).  `g[t]` is the cheapest cost to earn exactly \(t\) points from *that* rectangle alone, considering overlaps between colored rows and columns.

4. **Group Knapsack Merge**  
   We then “merge” this rectangle into our global DP: for each existing total \(j\) (from \(k\) down to \(0\)), and for each way to take \(t\in[1..U]\) points from this rectangle, we update
   ```
   dp[j + t] = min(dp[j + t], dp[j] + g[t])
   ```
   going backwards on \(j\) to avoid reusing the same rectangle twice.

5. **Result**  
   After processing all rectangles, `dp[k]` is the minimum cost to get exactly \(k\) points, or remains “infinity” if impossible.  If the overall sum of possible points (`sumPoints = ∑(a_i+b_i)`) is less than \(k\) or `dp[k]` is still infinite, we print \(-1\); otherwise we print `dp[k]`.

Time and Space Complexity

- Time: 
  - For each rectangle, computing `g[t]` for \(t\le200\) takes \(O(200)\) by iterating possible row–column splits.
  - Merging into the global DP takes \(O(k\cdot U)\le O(100\cdot200)=20{,}000\).
  - With up to \(n=1000\) rectangles, that's on the order of \(O(20\times10^6)\), which fits in the 3-second limit in Java.
- Space:
  - We use \(O(k)\approx O(100)\) memory for `dp[]` and up to \(O(200)\) for each `g[]`.
  
Thus the solution is efficient and correct under the given constraints.