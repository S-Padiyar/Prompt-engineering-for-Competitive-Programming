**Analysis**

We have an array \(a_1,a_2,\dots,a_n\) of integers in \([1,1023]\) (so at most 10 bits) and independent insertion‐probabilities
\[
p_i \;=\;\frac{\pi_i}{10^4}\quad(1\le \pi_i\le10^4).
\]
We form a random multiset \(S\) by inserting each \(a_i\) into \(S\) with probability \(p_i\).  We then take
\[
f(S)\;=\;\bigoplus_{\,x\in S} x
\]
(the bitwise XOR of all elements in \(S\)), and we wish to compute
\[
\mathbb E\bigl[(f(S))^2\bigr]\pmod{10^9+7}.
\]

A brute‐force over all \(2^n\) outcomes is impossible for \(n\) up to \(2\times10^5\).  A direct dynamic‐programming on XOR states
\[
\text{dp}[v]\;=\;\Pr[f(S)=v]
\]
with the usual “\(\text{dp}\gets\text{dp}*(1-p_i)\;+\;\text{dp}[\,v\oplus a_i\,]*p_i\)” loop costs \(O(n\cdot 1024)\), which can be \(2\cdot10^8\) steps in the worst case and is borderline in Java.

Instead we observe a well‐known trick using the _Walsh–Hadamard transform_ (FWHT) for XOR‐convolution.  If we let
\[
g_i(v)=
\begin{cases}
1-p_i, & v=0,\\[6pt]
p_i,   & v=a_i,\\[6pt]
0,     & \text{otherwise},
\end{cases}
\]
then the overall distribution \(\mathrm{dp}\) is the XOR‐convolution of all the \(g_i\).  In the Hadamard‐domain (the FWHT domain) convolution becomes pointwise multiplication.  Concretely, if we let

\[
G_i(k)\;=\;\sum_{v\in\{0,1,\dots,1023\}}(-1)^{\mathrm{popcnt}(v\land k)}\,g_i(v),
\]

then after one step our transform is multiplied by \(G_i(k)\).  Since initially \(\mathrm{dp}\) was \(\delta_0\) whose FWHT is all 1’s, we get in the end

\[
\mathrm{DP}^\star(k)\;=\;\prod_{i=1}^n G_i(k).
\]

Finally we invert the FWHT and read off
\[
\mathrm{dp}[v]\;=\;\frac1{1024}\sum_{k=0}^{1023}(-1)^{\mathrm{popcnt}(v\land k)}\,\mathrm{DP}^\star(k).
\]
Then
\[
\mathbb E[f(S)^2]\;=\;\sum_{v=0}^{1023}v^2\,\mathrm{dp}[v]
\;=\;\frac1{1024}
\sum_{k=0}^{1023}\Bigl(\sum_{v=0}^{1023}v^2(-1)^{\mathrm{popcnt}(v\land k)}\Bigr)\;\mathrm{DP}^\star(k).
\]

If we define once and for all
\[
S(k)\;=\;\sum_{v=0}^{1023}v^2\,(-1)^{\mathrm{popcnt}(v\land k)}\pmod{10^9+7},
\]
then
\[
\mathbb E[f(S)^2]
\;=\;\frac1{1024}\;\sum_{k=0}^{1023}S(k)\,\mathrm{DP}^\star(k)\quad(\bmod\,10^9+7).
\]

----

Computing \(\mathrm{DP}^\star(k)\) in the naive way is still \(O(n\cdot1024)\).  However, since each \(a_i\) lies in \([0,1023]\), we may group all indices \(i\) having the same value \(x=a_i\).  Write

\[
G_i(k)\;=\;(1-p_i)\;+\;p_i\;(-1)^{\mathrm{popcnt}(x\land k)}.
\]
For fixed \(x\), let

\[
P_x\;=\;\prod_{i\colon a_i=x}\bigl[(1-p_i)-p_i\bigr]
\;=\;\prod_{i\colon a_i=x}(1-2p_i)\pmod{10^9+7}.
\]
One checks that if \(\mathrm{popcnt}(x\land k)\) is even then \(\prod_i G_i(k)=1\), and if it is odd then the product is exactly \(P_x\).  Hence

\[
\mathrm{DP}^\star(k)\;=\;\prod_{x=0}^{1023}
\bigl(P_x\bigr)^{\mathrm{popcnt}(x\land k)\bmod 2}.
\]

Thus to build the final \(\mathrm{DP}^\star\) array we only need, for each \(x\) that actually appears in the input, to multiply \(P_x\) into those \(\mathrm{DP}^\star(k)\) for which \(\mathrm{popcnt}(x\land k)\) is odd.  There are exactly 512 such \(k\) out of 1024, and at most 1024 distinct \(x\), so the construction costs about \(1024\cdot512=524\,288\) multiplications in the worst case.  Summed over all test‐cases (total \(n\le2\times10^5\)) this runs comfortably in time even in Java.

We then form
\[
\mathbb E[f(S)^2]
\;=\;
\bigl(1024^{-1}\bigr)\,\sum_{k=0}^{1023}S(k)\,\mathrm{DP}^\star(k)
\pmod{10^9+7}.
\]

Details:

• We precompute  
  – \(\displaystyle S(k)=\sum_{v=0}^{1023}v^2(-1)^{\mathrm{popcnt}(v\land k)}\bmod10^9+7\), for \(k=0\ldots1023\).  
  – For each \(x=0\ldots1023\) the list of all \(k\) with \(\mathrm{popcnt}(x\land k)\) odd (exactly 512 of them).  
  – \(\mathrm{inv10000}=\bigl(10^4\bigr)^{-1}\bmod10^9+7,\quad
     \mathrm{inv1024}=1024^{-1}\bmod10^9+7.\)

• For each test case:  
  1. Read \(n\).  
  2. Read the array \(a_i\).  
  3. Read the integers \(\pi_i\) and form  
     \[
        p_i \;=\;\pi_i\cdot\mathrm{inv10000}\pmod{10^9+7}, 
        \quad\text{term}_i=(1-2\,p_i)\bmod10^9+7.
     \]  
  4. Group by \(x\in[0,1023]\).  Maintain  
     \(\displaystyle P_x=\prod_{i:a_i=x}(1-2\,p_i)\bmod10^9+7\)  
     and keep a list of which \(x\) actually occur.  
  5. Initialize \(\mathrm{DP}^\star[k]=1\) for \(k=0\ldots1023\).  
  6. For each distinct \(x\), multiply \(P_x\) into those \(\mathrm{DP}^\star[k]\) where \(\mathrm{popcnt}(x\land k)\) is odd (using our precomputed list of size 512).  
  7. Compute 
     \[
       \mathrm{ans}
       \;=\;\sum_{k=0}^{1023}S(k)\,\mathrm{DP}^\star(k)\pmod{10^9+7},
     \]
     then multiply by \(\mathrm{inv1024}\) and output.

This runs in \(O(1024\log M)\) precomputation plus about \(O\bigl(512\cdot\text{distinct‐}x\bigr)\) per test, which is easily under the 4‐second limit.

---

```java
import java.io.*;
import java.util.*;

public class Main {
    static final int MAXM = 1024;
    static final int MOD = 1_000_000_007;
    static int[] S = new int[MAXM];
    static int inv10000, inv1024;
    // For each x in [0..1023], list of all k in [0..1023] with popcount(x&k)%2==1
    static int[][] oddList = new int[MAXM][];

    // fast exp base^e mod MOD
    static int modExp(int base, int e) {
        long res = 1, b = base;
        while (e > 0) {
            if ((e & 1) != 0) res = (res * b) % MOD;
            b = (b * b) % MOD;
            e >>= 1;
        }
        return (int)res;
    }

    public static void main(String[] args) throws IOException {
        // Precompute inverses of 10000 and 1024
        inv10000 = modExp(10000, MOD-2);
        inv1024  = modExp(1024,  MOD-2);

        // Precompute S[k] = sum_{v=0..1023} v^2 * (-1)^{popcount(v&k)}
        int[] v2 = new int[MAXM];
        for (int v = 0; v < MAXM; v++) {
            long vv = v;
            v2[v] = (int)((vv*vv) % MOD);
        }
        for (int k = 0; k < MAXM; k++) {
            long sum = 0;
            for (int v = 0; v < MAXM; v++) {
                int p = Integer.bitCount(v & k) & 1; // 0 or 1
                if (p == 0) sum += v2[v];
                else        sum -= v2[v];
            }
            sum %= MOD;
            if (sum < 0) sum += MOD;
            S[k] = (int)sum;
        }

        // Precompute oddList[x] = all k with popcount(x&k)%2==1
        for (int x = 0; x < MAXM; x++) {
            ArrayList<Integer> list = new ArrayList<>();
            for (int k = 0; k < MAXM; k++) {
                if (((Integer.bitCount(x & k)) & 1) == 1) {
                    list.add(k);
                }
            }
            oddList[x] = list.stream().mapToInt(i->i).toArray();
        }

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        int t = Integer.parseInt(br.readLine().trim());
        StringBuilder sb = new StringBuilder();

        while (t-- > 0) {
            int n = Integer.parseInt(br.readLine().trim());
            int[] a = new int[n];
            st = new StringTokenizer(br.readLine());
            for (int i = 0; i < n; i++) {
                a[i] = Integer.parseInt(st.nextToken());
            }
            st = new StringTokenizer(br.readLine());
            // We'll form P_x = product of (1-2p_i) for i with a_i=x
            int[] P_x = new int[MAXM];
            Arrays.fill(P_x, 1);
            boolean[] used = new boolean[MAXM];
            ArrayList<Integer> usedX = new ArrayList<>();

            for (int i = 0; i < n; i++) {
                int pi = Integer.parseInt(st.nextToken());
                // p_i mod = pi/10000 mod
                long pmod = (pi * 1L * inv10000) % MOD;
                // term = (1 - 2*p_i) mod
                long term = (1 - 2*pmod) % MOD;
                if (term < 0) term += MOD;
                int x = a[i];
                P_x[x] = (int)((P_x[x] * term) % MOD);
                if (!used[x]) {
                    used[x] = true;
                    usedX.add(x);
                }
            }

            // Build DP* array
            int[] dpStar = new int[MAXM];
            Arrays.fill(dpStar, 1);
            for (int x : usedX) {
                int px = P_x[x];
                // multiply px into dpStar[k] for those k in oddList[x]
                for (int k : oddList[x]) {
                    dpStar[k] = (int)((dpStar[k] * 1L * px) % MOD);
                }
            }

            // Sum up S[k]*dpStar[k], then multiply by inv1024
            long ans = 0;
            for (int k = 0; k < MAXM; k++) {
                ans = (ans + dpStar[k]*1L*S[k]) % MOD;
            }
            ans = (ans * inv1024) % MOD;

            sb.append(ans).append('\n');
        }

        System.out.print(sb);
    }
}
```

**Explanation of Key Steps**

1. **FWHT Idea**  
   If \(\mathrm{dp}\) is the distribution of the XOR‐sum, we can build it by iterated XOR‐convolution of
   \[
     g_i = (1-p_i)\,\delta_0 \;+\; p_i\,\delta_{a_i}.
   \]
   In the Walsh–Hadamard domain (the XOR transform), convolution becomes pointwise multiplication.

2. **Character Formula**  
   The XOR‐Hadamard transform of a vector \(h\) is
   \[
     H(k)\;=\;\sum_{v}(-1)^{\mathrm{popcnt}(v\land k)}\,h(v)\,.
   \]
   Convolving the \(g_i\) in real space is pointwise multiplying the \(G_i(k)\).  Since initially \(\mathrm{dp}\) is \(\delta_0\), whose transform is all ones, the final transform is
   \[
     \mathrm{DP}^\star(k)\;=\;\prod_i G_i(k).
   \]

3. **Grouping by \(a_i\)**  
   We only need
   \[
     G_i(k)= (1-p_i)+p_i(-1)^{\mathrm{popcnt}(a_i\land k)}.
   \]
   If a value \(x\) appears in positions \(i\in I\), then
   \[
     \prod_{i\in I}G_i(k)
     =\begin{cases}
       1,&\text{if popcount}(x\land k)\text{ is even},\\
       \displaystyle\prod_{i\in I}(1-2\,p_i)\pmod{10^9+7},&
       \text{if odd}.
     \end{cases}
   \]
   Define \(P_x=\prod_{i\colon a_i=x}(1-2\,p_i)\).  Then
   \(\mathrm{DP}^\star(k)\) is the product of those \(P_x\) for which \(\mathrm{popcnt}(x\land k)\) is odd.

4. **Fast Accumulation**  
   We precompute, for each \(x\in[0\,..\,1023]\), the list of exactly 512 integers \(k\) with \(\mathrm{popcnt}(x\land k)\equiv1\pmod2\).  Then building \(\mathrm{DP}^\star\) is
   \[
     \text{init all }\mathrm{DP}^\star[k]=1,\quad
     \text{for each distinct }x\text{ multiply }P_x\text{ into }512\text{ places.}
   \]
   This costs only \(512\cdot(\text{#distinct }x)\) multiplications.

5. **Recovering \(\mathbb E[f^2]\)**  
   Once we have \(\mathrm{DP}^\star(k)\), the inverse XOR transform to get \(\mathrm{dp}[v]\) is
   \[
     \mathrm{dp}[v]
     =\frac1{1024}\sum_{k}(-1)^{\mathrm{popcnt}(v\land k)}\,\mathrm{DP}^\star(k).
   \]
   So
   \[
     \mathbb E[f(S)^2]
     =\sum_{v}v^2\,\mathrm{dp}[v]
     =\frac1{1024}\sum_{k}\Bigl(\sum_{v}v^2(-1)^{\mathrm{popcnt}(v\land k)}\Bigr)\mathrm{DP}^\star(k).
   \]
   We precompute \(S(k)=\sum_{v}v^2(-1)^{\mathrm{popcnt}(v\land k)}\) once in \(O(1024^2)\).

All steps are \(O(1024^2)\) precomputation plus \(O(512\cdot\text{distinct})\) per test. Since \(\sum n\le2\times10^5\) and each distinct \(a_i\le1024\), this easily runs in under 4 s even in Java.