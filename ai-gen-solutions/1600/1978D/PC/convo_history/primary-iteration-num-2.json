[
  {
    "role": "user",
    "content": "D. Elections\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nElections are taking place in Berland. There are n\n\n candidates participating in the elections, numbered from 1\n\n to n\n\n. The i\n\n-th candidate has ai\n\n fans who will vote for him. Additionally, there are c\n\n people who are undecided about their favorite candidate, let's call them undecided. Undecided people will vote for the candidate with the lowest number.\n\n\n\nThe candidate who receives the maximum number of votes wins the elections, and if multiple candidates receive the same maximum number of votes, the candidate with the lowest number among them wins.\n\n\n\nYou found these elections too boring and predictable, so you decided to exclude some candidates from them. If you do not allow candidate number i\n\n to participate in the elections, all ai\n\n of his fans will become undecided, and will vote for the candidate with the lowest number.\n\n\n\nYou are curious to find, for each i\n\n from 1\n\n to n\n\n, the minimum number of candidates that need to be excluded from the elections for candidate number i\n\n to win the elections.\n\n\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single integer t\n\n (1≤t≤2⋅104\n\n) — the number of test cases. The description of the test cases follows.\n\n\n\nThe first line of each test case contains two integers n\n\n and c\n\n (1≤n≤2⋅105\n\n, 0≤c≤109\n\n) — the number of candidates in the elections and the number of undecided people.\n\n\n\nThe second line of each test case contains n\n\n integers a1,a2,…,an\n\n (0≤ai≤109\n\n) — the number of fans for each candidate.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output n\n\n integers, the i\n\n-th of which should be equal to the minimum number of candidates that need to be excluded from the elections for candidate number i\n\n to win.\n\n\n\nExample\n\nInputCopy\n\n5\n\n3 1\n\n2 0 3\n\n2 3\n\n0 10\n\n5 3\n\n5 4 3 2 1\n\n4 5\n\n3 10 7 1\n\n6 0\n\n2 2 2 3 3 3\n\nOutputCopy\n\n0 1 2\n\n1 0\n\n0 1 2 3 4\n\n1 0 2 3\n\n1 1 2 0 4 5\n\nNote\n\nIn the first test case:\n\n\n\nIf all candidates are allowed, candidate number 1\n\n will receive 3\n\n votes (1\n\n undecided person will vote for him), candidate number 2\n\n will receive 0\n\n votes, and candidate number 3\n\n will receive 3\n\n votes. Therefore, candidate number 1\n\n wins (he received the same number of votes as candidate 3\n\n, but his number is lower), so the answer for him is 0\n\n.\n\nIf candidate number 1\n\n is not allowed, his 2\n\n fans will become undecided. Then candidate number 2\n\n will receive 3\n\n votes (3\n\n undecided people will vote for him) and candidate number 3\n\n will receive 3\n\n votes. Therefore, candidate number 2\n\n wins (he received the same number of votes as candidate 3\n\n, but his number is lower), so the answer for him is 1\n\n.\n\nIf candidates with numbers 1\n\n and 2\n\n are not allowed, candidate number 3\n\n wins, so the answer for him is 2\n\n.\n\nIn the second test case, candidate number 1\n\n will win if candidate number 2\n\n is not allowed to participate.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have \\(n\\) candidates \\(1,2,\\dots,n\\) with fan‐counts \\(a_1,\\dots,a_n\\), plus \\(c\\) undecided voters who always go to the smallest‐numbered *remaining* candidate.  We may exclude some candidates; when we exclude candidate \\(j\\), all of \\(j\\)'s \\(a_j\\) fans become undecided, and again they go to the lowest‐numbered *remaining* candidate.\n\nWe must answer, for each \\(i=1\\ldots n\\), the minimum number of *other* candidates we need to exclude so that candidate \\(i\\) wins.\n\n---\n\n**Key observations**\n\n1.  **\"Empty S\" check**  \n   First observe that if we exclude *nobody* (so \\(S=\\emptyset\\)), then\n   - the smallest index *remaining* is 1,\n   - candidate 1 gets all \\(c\\) undecided votes, so ends up with \\(a_1+c\\),\n   - every other candidate \\(j>1\\) just gets \\(a_j\\),\n   - the winner is the one with the largest vote‐count, ties broken in favor of the smaller index.\n\n   In particular candidate \\(i\\) would win *without excluding anyone* precisely if\n   \\[\n     a_i > a_1 + c\n     \\quad\\text{and}\\quad\n     \\max_{j>i} a_j \\;\\le\\; a_i\n   \\]\n   (the first inequality is *strict* because if \\(a_i = a_1+c\\) then 1 wins the tie).\n\n   If that condition holds, the answer for \\(i\\) is 0.\n\n2.  **Otherwise we force candidate \\(i\\) to be the *smallest* remaining**  \n   If we do have to exclude somebody, then it never helps to leave any index \\(<i\\) in the race, because whoever is smallest picks up *all* undecideds (including the large pile of fans of *all* excluded candidates).  In practice one quickly shows the only useful strategy if you must exclude is to exclude *all* \\(1,2,\\dots,i-1\\), so that \\(i\\) becomes the new „index‐1“ among those who remain.  \n\n   Let\n   \\[\n     U_0 \\;=\\; c \\;+\\;\\sum_{j=1}^{i-1} a_j\n     \\quad\\Longrightarrow\\quad\n     \\text{candidate \\(i\\) starts with }a_i+U_0\n   \\]\n   and the only *possible* opponents are those \\(j>i\\), each with exactly \\(a_j\\) votes.  We now have a little „bribery‐game“:\n\n   - We have a multiset of opponents’ strengths \\(\\{a_j: j>i\\}\\).\n   - Our power \\(P\\) starts at\n     \\[\n       P \\;=\\; a_i \\;+\\; U_0 \\;=\\;a_i \\;+\\;c\\;+\\sum_{j<i}a_j.\n     \\]\n   -  We may „exclude“ (bribe) some of those opponents \\(j>i\\).  Each time we exclude one of strength \\(x\\), we remove it from the multiset *and* we add \\(x\\) to our power \\(P\\).  \n   -  We stop as soon as the *largest remaining* opponent has strength \\(\\le P\\).  By the usual greedy‐proof, the minimum number of exclusions is:  \n     repeatedly remove the *largest* opponent \\(>P\\), add it to \\(P\\), until every remaining opponent is \\(\\le P\\).\n\nThus for each \\(i\\), after the quick „empty‐set“ check, we fall back on:\n\n(1)  Exclude the \\(i-1\\) smaller indices for sure;\n\n(2)  Count how many of the larger‐index opponents we must still bribe until the condition „largest ≤ our power“ holds.\n\n---\n\n**Data structures**\n\nWe must do this for each \\(i\\) with\n\\[ \n  i=1,2,\\dots,n,\n\\]\nand \\(n\\) can be up to \\(2\\times10^5\\) *in total* over all testcases.  We cannot afford to re‐sort or re‐heapify from scratch for each \\(i\\).  Instead we\n\n- process \\(i\\) *in descending order* \\(i=n,n-1,\\dots,1\\);\n- maintain a Fenwick (BIT) over the *fan‐counts* of the opponents \\(\\{a_j: j>i\\}\\);\n- support\n  1.  inserting one new \\(a_i\\) in \\(O(\\log n)\\),\n  2.  querying the *current maximum opponent* in \\(O(1)\\) by simply remembering it,\n  3.  performing a *binary‐search* on „how many largest to take“ in \\(O(\\log n)\\) steps, each step using Fenwicks in \\(O(\\log n)\\).  \n\nOverall each \\(i\\) costs about \\(O(\\log^2n)\\) worst‐case, which is fast enough for \\(n\\le2\\cdot10^5\\).\n\n---\n\n**Complexities**\n\n- Building prefix‐sums and suffix‐max arrays: \\(O(n)\\).\n- Compressing the at most \\(n\\) distinct fan‐counts (for Fenwick‐indices): \\(O(n\\log n)\\).\n- The main loop does \\(n\\) iterations; each either answers `0` immediately, or else does a Fenwick‐based binary‐search of \\(O(\\log n)\\) steps, each step \\(O(\\log n)\\).  Total \\(O(n\\log^2n)\\).\n- Over all testcases \\(\\sum n\\le2\\cdot10^5\\), this fits in time.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class Fenwick {\n        int n;\n        long[] treeCnt, treeSum;\n        Fenwick(int _n) {\n            n = _n;\n            treeCnt = new long[n+1];\n            treeSum = new long[n+1];\n        }\n        // add 'cnt' to position i, and 'cnt*val' to sum‐tree\n        void update(int i, long cnt, long val) {\n            for (; i<=n; i+=i&-i) {\n                treeCnt[i] += cnt;\n                treeSum[i] += val;\n            }\n        }\n        // prefix sums [1..i]\n        long queryCnt(int i) {\n            long s=0;\n            for (; i>0; i-=i&-i) s+=treeCnt[i];\n            return s;\n        }\n        long querySum(int i) {\n            long s=0;\n            for (; i>0; i-=i&-i) s+=treeSum[i];\n            return s;\n        }\n        // find smallest idx so that prefix count >= k  (1‐based)\n        int findByOrder(long k) {\n            if (k <= 0) return 1;\n            int pos = 0;\n            int bit = Integer.highestOneBit(n);\n            for (; bit>0; bit>>=1) {\n                int nxt = pos+bit;\n                if (nxt<=n && treeCnt[nxt] < k) {\n                    k -= treeCnt[nxt];\n                    pos = nxt;\n                }\n            }\n            return pos+1;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        int T = Integer.parseInt(in.readLine());\n        while (T-- > 0) {\n            StringTokenizer st = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            long c = Long.parseLong(st.nextToken());\n            long[] a = new long[n+1];\n            st = new StringTokenizer(in.readLine());\n            for (int i=1; i<=n; i++) {\n                a[i] = Long.parseLong(st.nextToken());\n            }\n\n            // prefix sums of a\n            long[] pref = new long[n+1];\n            for (int i=1; i<=n; i++) {\n                pref[i] = pref[i-1] + a[i];\n            }\n            // suffix max of a\n            long[] sufMax = new long[n+2];\n            sufMax[n+1] = 0;\n            for (int i=n; i>=1; i--) {\n                sufMax[i] = Math.max(a[i], sufMax[i+1]);\n            }\n\n            // prepare compression of all a[i], descending order\n            long[] vals = Arrays.copyOfRange(a, 1, n+1);\n            Arrays.sort(vals);\n            // unique + descending\n            int m = 0;\n            for (int i=n-1; i>=0; i--) {\n                if (i==n-1 || vals[i]!=vals[i+1]) {\n                    vals[m++] = vals[i];\n                }\n            }\n            // vals[0..m-1] now descending‐unique\n            long[] compVal = new long[m+1];\n            for (int i=0; i<m; i++) {\n                compVal[i+1] = vals[i];\n            }\n            // map a[i] -> position in compVal\n            Map<Long,Integer> mp = new HashMap<>();\n            for (int i=1; i<=m; i++) {\n                mp.put(compVal[i], i);\n            }\n\n            Fenwick fenw = new Fenwick(m);\n            long totalCnt = 0;      // how many we've inserted\n            long maxOpp = 0;        // maximum opponent's strength so far\n            long[] ans = new long[n+1];\n\n            // process i = n down to 1\n            for (int i=n; i>=1; i--) {\n                // 1) empty‐set check\n                boolean zeroWay = false;\n                if (i>1) {\n                    // they pick up c -> a[1]+c\n                    // we need a[i] > a[1]+c  AND  forall j>i: a[j] <= a[i]\n                    if (a[i] > a[1] + c && sufMax[i+1] <= a[i]) {\n                        ans[i] = 0;\n                        zeroWay = true;\n                    }\n                }\n                if (!zeroWay) {\n                    // scenario A: we exclude 1..i-1 for sure\n                    long basePower = a[i] + c + pref[i-1]; \n                    if (totalCnt==0 || maxOpp <= basePower) {\n                        // no opponents or all already <= basePower -> 0 extra bribes\n                        ans[i] = (i-1);\n                    } else {\n                        // we must binary‐search the minimal t in [1..totalCnt]\n                        // so that sum of top‐t + basePower >= (t+1)-th largest\n                        long low=1, high=totalCnt;\n                        while (low<high) {\n                            long mid = (low+high)/2;\n                            // sum of top 'mid' opponents\n                            // find position p of the mid-th largest\n                            int p = fenw.findByOrder(mid);\n                            long cntBefore = fenw.queryCnt(p-1);\n                            long sumBefore = fenw.querySum(p-1);\n                            long takeHere = (mid - cntBefore) * compVal[p];\n                            long sumTopMid = sumBefore + takeHere;\n                            // (mid+1)-th largest?\n                            long nextVal = 0;\n                            if (mid+1 <= totalCnt) {\n                                int q = fenw.findByOrder(mid+1);\n                                nextVal = compVal[q];\n                            }\n                            if (basePower + sumTopMid >= nextVal) {\n                                high = mid;\n                            } else {\n                                low = mid+1;\n                            }\n                        }\n                        ans[i] = (i-1) + low;\n                    }\n                }\n\n                // finally insert a[i] into Fenwick (for next smaller i)\n                int pos = mp.get(a[i]);\n                fenw.update(pos, 1, a[i]);\n                totalCnt++;\n                if (a[i] > maxOpp) maxOpp = a[i];\n            }\n\n            // print answers\n            for (int i=1; i<=n; i++) {\n                out.print(ans[i]);\n                if (i<n) out.print(' ');\n            }\n            out.println();\n        }\n\n        out.flush();\n    }\n}\n```\n\n**Explanation of the core steps**\n\n1.  We precompute  \n    - `pref[i] = a[1]+⋯+a[i]`  \n    - `sufMax[i] = max(a[i],a[i+1],…,a[n])`.  \n\n2.  **Empty‐set test:**  \n    Without excluding anybody, the smallest index is 1, so candidate 1 gets all \\(c\\) undecideds.  We check \n       - \\(a_i > a_1 + c\\) (strict, to beat the tie),  \n       - and \\(\\max_{j>i}a_j \\le a_i\\).  \n    If both hold, answer is 0.\n\n3.  **Forced‐smallest (scenario A):**  \n    Otherwise we *do* exclude \\(1,2,\\dots,i-1\\).  That hands all their fans plus the original \\(c\\) to candidate \\(i\\).  So\n    \\[\n      \\text{power }P_0 \\;=\\; a_i \\;+\\;\\Bigl(c + \\sum_{j<i}a_j\\Bigr).\n    \\]\n    The *only* remaining opponents are \\(j>i\\), each with strength \\(a_j\\).  We keep them in a multiset.  We must exclude („bribe“) the *smallest* number of them so that afterwards *every* remaining opponent has strength \\(\\le P\\).  Each time we bribe someone of strength \\(x\\), they are removed and we add \\(x\\) to our power.  By the usual greedy argument, it suffices to repeatedly remove the *largest* opponent while it exceeds our current \\(P\\).\n\n4.  **Data‐structure details:**  \n    - We process \\(i\\) from \\(n\\) down to \\(1\\).  \n    - We keep a Fenwick tree over the fan‐counts of all \\(j>i\\) we have seen so far.  \n    - We also track `maxOpp`, the current maximum opponent strength (quick `O(1)` test for whether we need any bribes at all).  \n    - If we do need bribes, we binary‐search the least \\(t\\in[1,\\dots,\\text{size}]\\) so that\n      \\[\n        P_0 \\;+\\;\\bigl(\\text{sum of top‐}t\\text{ strengths}\\bigr)\n         \\;\\ge\\;\n        \\text{the }(t+1)\\text{-th largest strength}.\n      \\]\n      Each binary‐search step uses Fenwick queries in \\(O(\\log n)\\), so each \\(i\\) costs \\(O(\\log^2 n)\\).\n\nSince \\(\\sum n\\le2\\cdot10^5\\), this runs very comfortably within the time limits."
  },
  {
    "role": "user",
    "content": "The empty‐set win check only compares candidate i against candidate 1 and those with index > i, but it must also ensure candidate i beats all candidates with indices 2..i−1. Add a prefix‐max array to track max(a[2..i−1]) and require a[i] > max(a[1]+c, prefixMax[i−1]) as well as sufMax[i+1] ≤ a[i]. Please correct the code accordingly and output one complete Java solution in a single code block suitable for submission."
  },
  {
    "role": "assistant",
    "content": "```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class Fenwick {\n        int n;\n        long[] treeCnt, treeSum;\n        Fenwick(int _n) {\n            n = _n;\n            treeCnt = new long[n+1];\n            treeSum = new long[n+1];\n        }\n        // add `cnt` occurrences of value `val` at index i\n        void update(int i, long cnt, long val) {\n            for (; i <= n; i += i & -i) {\n                treeCnt[i] += cnt;\n                treeSum[i] += val;\n            }\n        }\n        // sum of counts in [1..i]\n        long queryCnt(int i) {\n            long s = 0;\n            for (; i > 0; i -= i & -i) s += treeCnt[i];\n            return s;\n        }\n        // sum of values in [1..i]\n        long querySum(int i) {\n            long s = 0;\n            for (; i > 0; i -= i & -i) s += treeSum[i];\n            return s;\n        }\n        // find smallest index p such that prefix count >= k\n        int findByOrder(long k) {\n            int pos = 0;\n            int bit = Integer.highestOneBit(n);\n            for (; bit > 0; bit >>= 1) {\n                int nxt = pos + bit;\n                if (nxt <= n && treeCnt[nxt] < k) {\n                    k -= treeCnt[nxt];\n                    pos = nxt;\n                }\n            }\n            return pos + 1;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        int T = Integer.parseInt(in.readLine());\n        while (T-- > 0) {\n            StringTokenizer st = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            long c = Long.parseLong(st.nextToken());\n            long[] a = new long[n+2];\n            st = new StringTokenizer(in.readLine());\n            for (int i = 1; i <= n; i++) {\n                a[i] = Long.parseLong(st.nextToken());\n            }\n\n            // prefix-sum of fans\n            long[] pref = new long[n+2];\n            for (int i = 1; i <= n; i++) {\n                pref[i] = pref[i-1] + a[i];\n            }\n            // prefix-max of fans\n            long[] prefixMax = new long[n+2];\n            prefixMax[1] = a[1];\n            for (int i = 2; i <= n; i++) {\n                prefixMax[i] = Math.max(prefixMax[i-1], a[i]);\n            }\n            // suffix-max of fans\n            long[] sufMax = new long[n+3];\n            sufMax[n+1] = 0;\n            for (int i = n; i >= 1; i--) {\n                sufMax[i] = Math.max(a[i], sufMax[i+1]);\n            }\n\n            // compress the distinct a[i]s in descending order\n            long[] vals = new long[n];\n            for (int i = 0; i < n; i++) vals[i] = a[i+1];\n            Arrays.sort(vals);\n            int m = 0;\n            for (int i = n-1; i >= 0; i--) {\n                if (i == n-1 || vals[i] != vals[i+1]) {\n                    vals[m++] = vals[i];\n                }\n            }\n            long[] compVal = new long[m+1];\n            for (int i = 1; i <= m; i++) {\n                compVal[i] = vals[i-1];\n            }\n            Map<Long,Integer> compMap = new HashMap<>();\n            for (int i = 1; i <= m; i++) {\n                compMap.put(compVal[i], i);\n            }\n\n            Fenwick fenw = new Fenwick(m);\n            long totalCnt = 0;\n            long maxOpp = 0;\n            long[] ans = new long[n+2];\n\n            // process candidates from n down to 1\n            for (int i = n; i >= 1; i--) {\n                boolean zeroWay = false;\n\n                // empty‐set check: no one excluded\n                if (i > 1) {\n                    // need:\n                    // 1) a[i] > max(a[1]+c, max_{2<=j<i} a[j])\n                    // 2) a[i] >= max_{j>i} a[j]\n                    long needHigher = Math.max(a[1] + c, prefixMax[i-1]);\n                    if (a[i] > needHigher && sufMax[i+1] <= a[i]) {\n                        ans[i] = 0;\n                        zeroWay = true;\n                    }\n                }\n                // for i=1, we handle in scenario A below\n\n                if (!zeroWay) {\n                    // scenario A: exclude 1..i-1 for sure\n                    // candidate i becomes smallest => picks up c + sum_{j<i} a[j]\n                    long basePower = a[i] + c + pref[i-1];\n                    if (totalCnt == 0 || maxOpp <= basePower) {\n                        // no opponents or all <= basePower\n                        ans[i] = (i - 1);\n                    } else {\n                        // binary‐search minimal t in [1..totalCnt] so that\n                        // basePower + sumTop(t) >= (t+1)-th largest\n                        long low = 1, high = totalCnt;\n                        while (low < high) {\n                            long mid = (low + high) >>> 1;\n                            // compute sum of top‐mid values\n                            int p = fenw.findByOrder(mid);\n                            long cntBefore = fenw.queryCnt(p - 1);\n                            long sumBefore = fenw.querySum(p - 1);\n                            long takeHere = (mid - cntBefore) * compVal[p];\n                            long sumTopMid = sumBefore + takeHere;\n\n                            // (mid+1)-th largest value\n                            long nextVal = 0;\n                            if (mid + 1 <= totalCnt) {\n                                int q = fenw.findByOrder(mid + 1);\n                                nextVal = compVal[q];\n                            }\n                            if (basePower + sumTopMid >= nextVal) {\n                                high = mid;\n                            } else {\n                                low = mid + 1;\n                            }\n                        }\n                        ans[i] = (i - 1) + low;\n                    }\n                }\n\n                // insert candidate i's fans into Fenwick (as an opponent for smaller i)\n                int pos = compMap.get(a[i]);\n                fenw.update(pos, 1, a[i]);\n                totalCnt++;\n                if (a[i] > maxOpp) {\n                    maxOpp = a[i];\n                }\n            }\n\n            // output answers\n            for (int i = 1; i <= n; i++) {\n                out.print(ans[i]);\n                if (i < n) out.print(' ');\n            }\n            out.println();\n        }\n\n        out.flush();\n    }\n}\n```\n\nExplanation of the fix:\n\n- We introduced a `prefixMax[]` array so that `prefixMax[i-1]` = max (a[1],…,a[i−1]).\n- In the \"empty‐set\" check (no exclusions), candidate i must beat\n  1) all previous candidates (so `a[i] > prefixMax[i-1]`),\n  2) plus beat candidate 1 with all undecideds (`a[i] > a[1]+c`),\n  3) and have at least as many votes as any later candidate (`a[i] ≥ sufMax[i+1]`).\n- Only if all three hold do we set `ans[i]=0`. Otherwise we fall back to the \"exclude 1..i−1, then bribe largest opponents\" strategy as before."
  }
]