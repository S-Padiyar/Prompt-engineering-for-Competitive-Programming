[
  {
    "timestamp": "2025-07-24T06:04:13.695475",
    "role": "user",
    "content": "F. Sheriff's Defense\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\n\"Why, master,\" quoth Little John, taking the bags and weighing them in his hand, \"here is the chink of gold.\"\n\nThe folk hero Robin Hood has been troubling Sheriff of Nottingham greatly. Sheriff knows that Robin Hood is about to attack his camps and he wants to be prepared.\n\n\n\nSheriff of Nottingham built the camps with strategy in mind and thus there are exactly n\n\n camps numbered from 1\n\n to n\n\n and n−1\n\n trails, each connecting two camps. Any camp can be reached from any other camp. Each camp i\n\n has initially ai\n\n gold.\n\n\n\nAs it is now, all camps would be destroyed by Robin. Sheriff can strengthen a camp by subtracting exactly c\n\n gold from each of its neighboring camps and use it to build better defenses for that camp. Strengthening a camp doesn't change its gold, only its neighbors' gold. A camp can have negative gold.\n\n\n\nAfter Robin Hood's attack, all camps that have been strengthened survive the attack, all others are destroyed.\n\n\n\nWhat's the maximum gold Sheriff can keep in his surviving camps after Robin Hood's attack if he strengthens his camps optimally?\n\n\n\nCamp a\n\n is neighboring camp b\n\n if and only if there exists a trail connecting a\n\n and b\n\n. Only strengthened camps count towards the answer, as others are destroyed.\n\n\n\nInput\n\nThe first line contains a single integer t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nEach test case begins with two integers n\n\n, c\n\n (1≤n≤2⋅105,1≤c≤109\n\n) — the number of camps and the gold taken from each neighboring camp for strengthening.\n\n\n\nThe second line of each test case contains n\n\n integers a1,a2,…,an\n\n (−109≤ai≤109\n\n) — the initial gold of each camp.\n\n\n\nThen follow n−1\n\n lines, each with integers u\n\n, v\n\n (1≤u,v≤n\n\n, u≠v\n\n) — meaning that there is a trail between u\n\n and v\n\n.\n\n\n\nThe sum of n\n\n over all test cases doesn't exceed 2⋅105\n\n.\n\n\n\nIt is guaranteed that any camp is reachable from any other camp.\n\n\n\nOutput\n\nOutput a single integer, the maximum gold Sheriff of Nottingham can keep in his surviving camps after Robin Hood's attack.\n\n\n\nExample\n\nInputCopy\n\n5\n\n3 1\n\n2 3 1\n\n1 2\n\n2 3\n\n3 1\n\n3 6 3\n\n1 2\n\n2 3\n\n3 1\n\n-2 -3 -1\n\n1 2\n\n2 3\n\n6 1\n\n5 -4 3 6 7 3\n\n4 1\n\n5 1\n\n3 5\n\n3 6\n\n1 2\n\n8 1\n\n3 5 2 7 8 5 -3 -4\n\n7 3\n\n1 8\n\n4 3\n\n3 5\n\n7 6\n\n8 7\n\n2 1\n\nOutputCopy\n\n3\n\n8\n\n0\n\n17\n\n26\n\nNote\n\nIn the first test case, it is optimal to strengthen the second base. The final gold at each base is [1,3,0]\n\n.\n\n\n\nIn the second test case, it is optimal to strengthen all bases. The final gold at each base is [2,4,2]\n\n.\n\n\n\nIn the third test case, it is optimal to not strengthen any base.\n\nUse Java."
  },
  {
    "timestamp": "2025-07-24T06:09:23.233882",
    "role": "assistant",
    "content": "**Analysis**\n\nWe have a tree of \\(n\\) camps (nodes) with exactly \\(n-1\\) trails (edges).  Each camp \\(i\\) starts with \\(a_i\\) gold (possibly negative).  We may choose any subset \\(S\\) of camps to **strengthen**.  Strengthening a camp \\(u\\in S\\) does **not** change its own gold, but it **subtracts** \\(c\\) gold from each of its neighbors (whether those neighbors are in \\(S\\) or not).  After the attack, *only* the strengthened camps \\(S\\) survive, and we sum their final gold.  The neighbors’ gold—possibly driven negative—does not count since they are destroyed if they were not strengthened.\n\nIf we select a set \\(S\\), then:\n\n- Each node \\(v\\in S\\) contributes its original \\(a_v\\).\n- But for each edge \\((u,v)\\) with both \\(u\\in S\\) and \\(v\\in S\\), we have subtracted \\(c\\) from \\(u\\) when strengthening \\(v\\) and subtract \\(c\\) from \\(v\\) when strengthening \\(u\\).  Thus each internal edge in the induced subgraph on \\(S\\) costs us a total of \\(2c\\).\n\nHence the total gold kept is\n\\[\n\\sum_{v\\in S} a_v \\;-\\; 2c\\,\\bigl|\\{\\text{edges with both ends in }S\\}\\bigr|.\n\\]\nWe want to choose \\(S\\subseteq\\{1,2,\\dots,n\\}\\) (possibly empty) to **maximize** this quantity.  If we take \\(S=\\emptyset\\), the sum is \\(0\\), so the answer is never below 0.\n\nThis is a classic dynamic-programming‐on‐trees problem.  Root the tree arbitrarily (say at node 1).  For each node \\(u\\), we keep two DP values:\n\n- \\(\\text{dp0}[u]\\) = the maximum total we can obtain in the subtree of \\(u\\) if **we do not select** (strengthen) \\(u\\).\n- \\(\\text{dp1}[u]\\) = the maximum total we can obtain in the subtree of \\(u\\) if **we do select** \\(u\\).\n\nTransitions:  \nLet the children of \\(u\\) be \\(v_1,v_2,\\dots\\).  Then\n\n1.  If \\(u\\) is **not** selected, its children are free to be selected or not, but we do **not** pay any \\(-2c\\) penalty on the edge \\((u,v)\\) (because at least one endpoint, namely \\(u\\), is outside \\(S\\)).\n   \n   \\[\n   \\text{dp0}[u]\n   = \\sum_{v\\;:\\;\\text{child of }u}\\;\\max\\bigl(\\text{dp0}[v],\\,\\text{dp1}[v]\\bigr).\n   \\]\n\n2.  If \\(u\\) **is** selected, then for each child \\(v\\) we have a choice:\n   - We leave \\(v\\) unselected, gaining \\(\\text{dp0}[v]\\) with no penalty,\n   - Or we select \\(v\\), gaining \\(\\text{dp1}[v]\\) but paying a penalty of \\(2c\\) for the edge \\((u,v)\\).\n   \n   Hence\n   \\[\n   \\text{dp1}[u]\n   = a_u \\;+\\;\n     \\sum_{v\\;:\\;\\text{child of }u}\n       \\max\\!\\bigl(\\text{dp0}[v],\\,\\text{dp1}[v]-2c\\bigr).\n   \\]\n\nWe do a single DFS to obtain a topological (parent‐before‐child) ordering, then process the nodes in **reverse** order (children before parents).  Finally the answer for the entire tree is\n\\[\n\\max\\bigl(\\text{dp0}[1],\\,\\text{dp1}[1]\\bigr),\n\\]\nand we clamp to at least 0 (but our DP never goes below 0 if leaving selection empty is an option).\n\nThis runs in \\(O(n)\\) per test.  Since the sum of \\(n\\) over all test cases is up to \\(2\\cdot10^5,\\) it easily fits the time limit.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    // Maximum total nodes across all tests\n    static final int MAXN = 200_000 + 5;\n    \n    // Adjacency via edge‐lists\n    static int[] head = new int[MAXN];\n    static int[] to   = new int[2 * MAXN];\n    static int[] nxt  = new int[2 * MAXN];\n    static int edgeCnt;\n\n    // Tree DP arrays\n    static long[] a   = new long[MAXN];\n    static long[] dp0 = new long[MAXN];\n    static long[] dp1 = new long[MAXN];\n    static int[] parent = new int[MAXN];\n    static int[] order  = new int[MAXN];\n    static int[] stack  = new int[MAXN];\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br  = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter    out = new PrintWriter(System.out);\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int t = Integer.parseInt(st.nextToken());\n\n        while (t-- > 0) {\n            // Read n and c\n            st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            long c = Long.parseLong(st.nextToken());\n\n            // Read the gold at each node\n            st = new StringTokenizer(br.readLine());\n            for (int i = 1; i <= n; i++) {\n                a[i] = Long.parseLong(st.nextToken());\n            }\n\n            // Build the adjacency lists\n            // Clear old lists\n            for (int i = 1; i <= n; i++) {\n                head[i] = -1;\n            }\n            edgeCnt = 0;\n\n            // Read edges\n            for (int i = 0; i < n - 1; i++) {\n                st = new StringTokenizer(br.readLine());\n                int u = Integer.parseInt(st.nextToken());\n                int v = Integer.parseInt(st.nextToken());\n                addEdge(u, v);\n                addEdge(v, u);\n            }\n\n            // 1) Build a DFS order (parent pointers + an array 'order' in preorder)\n            int sp = 0;\n            stack[sp++] = 1;\n            parent[1] = 0;\n            int ordSz = 0;\n            while (sp > 0) {\n                int u = stack[--sp];\n                order[ordSz++] = u;\n                for (int e = head[u]; e != -1; e = nxt[e]) {\n                    int v = to[e];\n                    if (v != parent[u]) {\n                        parent[v] = u;\n                        stack[sp++] = v;\n                    }\n                }\n            }\n\n            // 2) Process in reverse order: children before parents\n            for (int i = ordSz - 1; i >= 0; i--) {\n                int u = order[i];\n\n                // If we do NOT select u\n                long best0 = 0;\n                // If we DO select u\n                long best1 = a[u];\n\n                for (int e = head[u]; e != -1; e = nxt[e]) {\n                    int v = to[e];\n                    if (v == parent[u]) continue;\n\n                    // for dp0[u], we can pick v or not pick v without penalty\n                    best0 += Math.max(dp0[v], dp1[v]);\n\n                    // for dp1[u], if we pick v we pay 2c for the edge (u,v)\n                    long pickV = dp1[v] - 2 * c;\n                    best1 += Math.max(dp0[v], pickV);\n                }\n\n                dp0[u] = best0;\n                dp1[u] = best1;\n            }\n\n            // The answer is max(dp0[1], dp1[1]), clamped >= 0\n            long ans = Math.max(dp0[1], dp1[1]);\n            if (ans < 0) ans = 0;\n            out.println(ans);\n        }\n\n        out.flush();\n    }\n\n    static void addEdge(int u, int v) {\n        to[edgeCnt] = v;\n        nxt[edgeCnt] = head[u];\n        head[u]     = edgeCnt++;\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Modeling the Penalty**  \n   Choosing a node \\(u\\) in the surviving set \\(S\\) gives us \\(a_u\\) gold, but every neighbor \\(v\\in S\\) also wears a subtraction of \\(c\\) when \\(u\\) was strengthened, and another \\(c\\) when \\(v\\) was strengthened—totaling \\(2c\\) per **internal** edge of \\(S\\).\n\n2. **Tree DP States**  \n   - `dp0[u]`: best total in \\(u\\)'s subtree if \\(u\\) is **not** chosen.  \n   - `dp1[u]`: best total in \\(u\\)'s subtree if \\(u\\) **is** chosen.  \n\n   Transitions follow by summing over children and accounting for the \\(-2c\\) penalty on edges where both endpoints are chosen.\n\n3. **Overall Complexity**  \n   Each test runs in \\(O(n)\\) time, and the sum of all \\(n\\) is \\(\\le2\\cdot10^5\\).  Thus it comfortably fits within the 2-second limit in Java."
  }
]