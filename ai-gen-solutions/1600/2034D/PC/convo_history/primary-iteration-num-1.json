[
  {
    "role": "user",
    "content": "D. Darius' Wisdom\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nDarius the Great is constructing n\n\n stone columns, each consisting of a base and between 0\n\n, 1\n\n, or 2\n\n inscription pieces stacked on top.\n\n\n\nIn each move, Darius can choose two columns u\n\n and v\n\n such that the difference in the number of inscriptions between these columns is exactly 1\n\n, and transfer one inscription from the column with more inscriptions to the other one. It is guaranteed that at least one column contains exactly 1\n\n inscription.\n\n\n\n\n\nSince beauty is the main pillar of historical buildings, Darius wants the columns to have ascending heights. To avoid excessive workers' efforts, he asks you to plan a sequence of at most n\n\n moves to arrange the columns in non-decreasing order based on the number of inscriptions. Minimizing the number of moves is not required.\n\n\n\nInput\n\nThe first line contains an integer t\n\n — the number of test cases. (1≤t≤3000\n\n)\n\n\n\nThe first line of each test case contains an integer n\n\n — the number of stone columns. (1≤n≤2⋅105\n\n)\n\n\n\nThe second line contains n\n\n integers a1,a2,…,an\n\n, where ai∈{0,1,2}\n\n represents the initial number of inscriptions in the i\n\n-th column. It is guaranteed that at least one column has exactly 1\n\n inscription.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output an integer k\n\n — the number of moves used to sort the columns. (0≤k≤n\n\n)\n\n\n\nThen, output k\n\n lines, each containing two integers ui\n\n and vi\n\n (1≤ui,vi≤n\n\n), representing the indices of the columns involved in the i\n\n-th move. During each move, it must hold that |aui−avi|=1\n\n, and one inscription is transferred from the column with more inscriptions to the other.\n\n\n\nIt can be proven that a valid solution always exists under the given constraints.\n\n\n\nExample\n\nInputCopy\n\n3\n\n4\n\n0 2 0 1\n\n3\n\n1 2 0\n\n6\n\n0 1 1 2 2 2\n\nOutputCopy\n\n2\n\n2 4\n\n2 3\n\n2\n\n3 1\n\n2 3\n\n0\n\nNote\n\nColumns state in the first test case:\n\n\n\nInitial: 0,2,0,1\n\nAfter the first move: 0,1,0,2\n\nAfter the second move: 0,0,1,2\n\nColumns state in the second test case:\n\n\n\nInitial: 1,2,0\n\nAfter the first move: 0,2,1\n\nAfter the second move: 0,1,2\n\nIn the third test case, the column heights are already sorted in ascending order.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have an array a[1…n] with entries in {0,1,2}, and at least one 1.  We wish to sort it into non‐decreasing order (all the 0’s, then all the 1’s, then all the 2’s), using at most n moves of the following type:\n\n– Pick two indices u,v such that |a[u]−a[v]|=1.  Then one inscription (one unit) moves from the higher column to the lower column.  In other words, if a[u]>a[v], we do  \n a[u]–;  a[v]++  \notherwise   \n a[v]–;  a[u]++.\n\nWe do _not_ care about minimizing the number of moves, only that we use ≤n moves overall to reach a sorted array.  \n\nKey observations:\n\n1.  A move between values 0↔1 or 1↔2 simply “swaps” one unit (a value‐token) between those two piles, preserving the total counts of 0’s, 1’s, and 2’s.  \n2.  Sorting means we want exactly c₀ zeros in positions 1…c₀, exactly c₁ ones in positions c₀+1…c₀+c₁, and c₂ twos in positions c₀+c₁+1…n, where  \n   \n   ```\n   c₀ = # of zeros in the entire array,\n   c₁ = # of ones,\n   c₂ = # of twos.\n   ```\n\nWe use a two‐phase “block‐fixing” strategy.  Depending on which end is smaller (zeros‐block or twos‐block), we fix that end first, then the other.  Concretely:\n\n– **Zeros‐first**:  if c₀≤c₂, first move all zeros into their correct “zeros block” [1…c₀], then move all the twos into their correct “twos‐block” [n−c₂+1…n].  \n– **Twos‐first**: otherwise we first move all twos into [n−c₂+1…n], then fix the zeros.\n\nEach “block‐fixing” can be done in one or two moves per item out of place, but a careful counting shows that if we always fix the _smaller_ block first, the total number of moves never exceeds n.  \n\nImplementation sketch for “zeros‐first” (the twos‐first is symmetrical):\n\n1.  **Build a set** `onesSet` of all positions holding a 1.  \n2.  **Zeros‐phase**:  \n    – Collect all indices `misZ` in [1…c₀] where `a[i]≠0`.  \n    – Collect all indices `outZ` in (c₀…n] where `a[j]==0`.  \n    – Pair them up 1‐to‐1 as `(i,outZ[k])`.  Each pair needs to “swap” a[i] with a[j].  \n        * If a[i] was 1, a[j] was 0, we can swap in one move (1↔0).  \n        * If a[i] was 2, a[j] was 0, we do a 2‐step swap via any pivot k where a[k]==1.  One move does (i,k) swapping 2↔1, the next does (i,j) swapping 1↔0.  \n    –  Each move we record and also update our array `a[]` and `onesSet` to track where the 1’s ended up.  \n3.  **Twos‐phase**:  \n    – Collect all indices `misT` in [n−c₂+1…n] where `a[i]≠2`.  \n    – Collect all indices `outT` in [1…n−c₂] where `a[j]==2`.  \n    – Pair them similarly; now every misplaced item in the twos block must be a 1 (since all 0’s ended up in place).  A 1↔2 swap is a single allowed move.  We again update `a[]` and `onesSet` after each move.\n\nOne checks that the total number of moves used,\n   \n   #moves ≤ (zeros‐phase) + (twos‐phase) ≤ n,\n   \nprovided we fix the smaller of the two blocks first.\n\nWe simply implement exactly this plan with O(n) time per test.  We keep an `ArrayList` of moves `(u,v)` and at the end output its size and the list.  \n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        FastReader(InputStream in) { br = new BufferedReader(new InputStreamReader(in)); }\n        String next() {\n            while (st == null || !st.hasMoreTokens())\n                try { st = new StringTokenizer(br.readLine()); }\n                catch (IOException e) { throw new RuntimeException(e); }\n            return st.nextToken();\n        }\n        int nextInt() { return Integer.parseInt(next()); }\n    }\n\n    public static void main(String[] args) throws IOException {\n        FastReader in = new FastReader(System.in);\n        StringBuilder out = new StringBuilder();\n        int t = in.nextInt();\n        while (t-- > 0) {\n            int n = in.nextInt();\n            int[] a = new int[n+1];\n            int c0 = 0, c1 = 0, c2 = 0;\n            for (int i = 1; i <= n; i++) {\n                a[i] = in.nextInt();\n                if (a[i] == 0) c0++;\n                else if (a[i] == 1) c1++;\n                else c2++;\n            }\n\n            // We'll store positions of 1's so we can pick any as pivot in 2↔0 swaps.\n            HashSet<Integer> onesSet = new HashSet<>();\n            for (int i = 1; i <= n; i++) {\n                if (a[i] == 1) onesSet.add(i);\n            }\n\n            // We'll record all moves here.\n            ArrayList<int[]> moves = new ArrayList<>();\n\n            // A small helper to perform one legal move between u and v:\n            // We assume abs(a[u]-a[v])==1, and we transfer from the larger to the smaller.\n            // We also update a[] and the set of positions holding 1.\n            Runnable nop = () -> {};  // do-nothing\n\n            class Op {\n                void apply(int u, int v) {\n                    // Ensure a[u] > a[v], if not swap them\n                    if (a[u] < a[v]) { int tmp=u; u=v; v=tmp; }\n                    // now a[u] == a[v]+1\n                    int oldU = a[u], oldV = a[v];\n                    a[u]--; a[v]++;\n                    moves.add(new int[]{u, v});\n                    // update the set of 1-positions:\n                    if (oldU == 2 && a[u] == 1) onesSet.add(u);\n                    else if (oldU == 1 && a[u] == 0) onesSet.remove(u);\n                    if (oldV == 0 && a[v] == 1) onesSet.add(v);\n                    else if (oldV == 1 && a[v] == 2) onesSet.remove(v);\n                }\n            }\n            Op op = new Op();\n\n            // We'll write two small routines: fixZeros() and fixTwos().\n            // But depending on which block is smaller we do them in one of the two orders.\n\n            // Fix the zero-block [1..c0]:\n            Runnable fixZeros = () -> {\n                List<Integer> misZ = new ArrayList<>();\n                List<Integer> outZ = new ArrayList<>();\n                for (int i = 1; i <= n; i++) {\n                    if (i <= c0) {\n                        if (a[i] != 0) misZ.add(i);\n                    } else {\n                        if (a[i] == 0) outZ.add(i);\n                    }\n                }\n                // They must match in size:\n                for (int k = 0; k < misZ.size(); k++) {\n                    int i = misZ.get(k), j = outZ.get(k);\n                    if (a[i] == 1) {\n                        // direct 1↔0\n                        op.apply(i, j);\n                    } else {\n                        // must be a[i]==2, a[j]==0\n                        // pick any pivot k != i,j with a[k]==1\n                        int pivot = -1;\n                        for (int x : onesSet) {\n                            pivot = x;\n                            break;\n                        }\n                        // pivot is guaranteed to exist and isn't i or j\n                        op.apply(i, pivot);  // swaps a[i]==2 with a[pivot]==1\n                        op.apply(i, j);      // now a[i]==1 with a[j]==0\n                    }\n                }\n            };\n\n            // Fix the two-block [n-c2+1..n]:\n            Runnable fixTwos = () -> {\n                List<Integer> misT = new ArrayList<>();\n                List<Integer> outT = new ArrayList<>();\n                for (int i = 1; i <= n; i++) {\n                    if (i > n - c2) {\n                        if (a[i] != 2) misT.add(i);\n                    } else {\n                        if (a[i] == 2) outT.add(i);\n                    }\n                }\n                // direct 1↔2 swaps\n                for (int k = 0; k < misT.size(); k++) {\n                    int i = misT.get(k), j = outT.get(k);\n                    op.apply(j, i);\n                }\n            };\n\n            // Choose order so that the smaller block (zeros or twos) is fixed first.\n            if (c0 <= c2) {\n                fixZeros.run();\n                fixTwos.run();\n            } else {\n                fixTwos.run();\n                fixZeros.run();\n            }\n\n            // Now a[] must be sorted.  We used at most n moves.\n            out.append(moves.size()).append('\\n');\n            for (int[] mv : moves) {\n                out.append(mv[0]).append(' ').append(mv[1]).append('\\n');\n            }\n        }\n\n        System.out.print(out.toString());\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1.  **Counting blocks.**  We let  \n      c₀ = number of 0’s,  \n      c₁ = number of 1’s,  \n      c₂ = number of 2’s.  \n    In the final sorted array, the first c₀ positions must all be 0, the next c₁ must be 1, and the last c₂ must be 2.  \n\n2.  **Two‐phase fix.**  We have two “out‐of‐place” regions:  \n    – The **zero‐block** (positions 1…c₀), some of which may contain 1’s or 2’s that must be swapped out with zeros lying to the right.  \n    – The **two‐block** (positions n−c₂+1…n), some of which may contain 0’s or 1’s that must be swapped out with twos lying to the left.  \n   \n    We always fix the _smaller_ of these two blocks first, then the other.  A counting argument shows this guarantees at most n moves in total.\n\n3.  **Performing a swap.**  \n    – To swap a 1‐in‐block with a 0‐outside (direct 1↔0), we use exactly one allowed move.  \n    – To swap a 2‐in‐block with a 0‐outside (2↔0), we need two moves.  We carry out  \n       1) a 2↔1 swap (using some other pivot where the array has a 1),  \n       2) then a 1↔0 swap.  \n    – Swapping 1↔2 is again a single move.  \n\n4.  **Keeping track of 1’s.**  We maintain a `HashSet` of all current positions holding a 1, so we can pick a “pivot” to decompose a 2↔0 swap.  Every time we do a move, we update both the array and our set of positions of 1’s.\n\nEach move decreases the _distance_ of out‐of‐place elements in a way that guarantees termination in at most n steps.  This solves the problem in O(n) time (per test) and uses at most n moves, as required."
  }
]