[
  {
    "timestamp": "2025-07-24T06:01:23.350756",
    "role": "user",
    "content": "Please provide a single Java code block (with class Main and main method) that solves the problem as described, without any additional explanation or commentary."
  },
  {
    "timestamp": "2025-07-24T06:03:10.983482",
    "role": "assistant",
    "content": "```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int T = Integer.parseInt(br.readLine().trim());\n        while (T-- > 0) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int K = Integer.parseInt(st.nextToken());\n            int p = Integer.parseInt(st.nextToken());\n            if (n == 1) {\n                System.out.println(1);\n                continue;\n            }\n            long[] inv = new long[K+1];\n            for (int i = 1; i <= K; i++) {\n                inv[i] = modPow(i, p-2, p);\n            }\n            long[] pow2 = new long[n+1];\n            pow2[0] = 1;\n            for (int d = 1; d <= n; d++) {\n                pow2[d] = (pow2[d-1] << 1) % p;\n            }\n            long[] prevF = new long[K+1], prevG = new long[K+1];\n            for (int s = 0; s <= K; s++) {\n                prevF[s] = 1;\n                prevG[s] = 1;\n            }\n            for (int depth = 2; depth <= n; depth++) {\n                long[] prefixG = new long[K+1];\n                prefixG[0] = prevG[0];\n                for (int s = 1; s <= K; s++) {\n                    prefixG[s] = (prefixG[s-1] + prevG[s]) % p;\n                }\n                long[] currF = new long[K+1];\n                for (int s = 0; s <= K; s++) {\n                    long sum = 0;\n                    for (int l = 1; l <= s; l++) {\n                        int bound = Math.min(l - 1, s - l);\n                        if (bound >= 0) {\n                            sum = (sum + prevF[l] * prefixG[bound]) % p;\n                        }\n                    }\n                    currF[s] = (sum * 2) % p;\n                }\n                long[] currG = new long[K+1];\n                currG[0] = 1;\n                for (int s = 1; s <= K; s++) {\n                    long num = (pow2[depth] + s - 2) % p;\n                    if (num < 0) num += p;\n                    currG[s] = currG[s-1] * num % p * inv[s] % p;\n                }\n                prevF = currF;\n                prevG = currG;\n            }\n            System.out.println(prevF[K]);\n        }\n    }\n    static long modPow(long a, long e, int mod) {\n        long r = 1 % mod;\n        a %= mod;\n        while (e > 0) {\n            if ((e & 1) == 1) r = (r * a) % mod;\n            a = (a * a) % mod;\n            e >>= 1;\n        }\n        return r;\n    }\n}\n```"
  }
]