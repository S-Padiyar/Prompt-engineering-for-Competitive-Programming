**Analysis**

We have an array of _n_ cards with positive integers aᵢ (1 ≤ _i_ ≤ _n_), and a target integer _x_.  It is guaranteed that no single card equals _x_ (so aᵢ ≠ _x_ for all _i_).  We wish to partition the array into the minimum number of contiguous **bad** segments, where a segment is called **bad** if **no** subset (not necessarily contiguous) of its cards has product exactly _x_.  

Equivalently, we scan from left to right, maintaining a sliding‐window segment that is still **bad**; as soon as adding a new card would allow some subset of the window to multiply to _x_, we must cut the segment right before that card.  We then start a new segment at that card, and continue.

To check quickly whether a growing segment has some subset with product _x_, note that _x_ ≤ 10⁵ has at most about 128 divisors.  Let

  	div₀ = 1, div₁, div₂, …, div_{D–1} = _x_

be the sorted list of all divisors of _x_.  We keep a boolean DP array

  	dp[j] = “can we select some subset of the current segment whose product is div_j?”

Initially (empty segment) dp[0] = true (product 1 is always possible), others false.  When we add a new card aᵢ that divides _x_, we update

  for j = D–1 down to 0:
   if dp[j] is true and div_j·aᵢ ≤ _x_, 
   let newVal = div_j·aᵢ, and find its index `k = idx[newVal]`.  
   set dp[k] = true.

If after that `dp[idx[x]]` becomes true, then the segment is no longer bad (it is “good”), so we must cut **before** aᵢ.  We increment our segment‐count, reset dp to all false except dp[0]=true, and **replay** the update for aᵢ in the fresh segment (which never yields dp[x] because aᵢ ≠ x).  This greedy—always extend until you first must cut—produces the minimum number of bad segments.

Each test requires:

1. Factor _x_ in O(√x), gather its divisors, sort them (at most ≈128).
2. Build an array `idx[divisor] = position` so each divisor maps to its 0‐based index.
3. Scan the _n_ cards with an O(D) DP‐update per card, plus O(D) per cut.  Summed over all tests, _n_ ≤ 10⁵, D ≤ ~128, so about 2·10⁷ steps—easily within 4s in Java.

Below is a clean Java implementation.

```java
import java.io.*;
import java.util.*;

public class Main {
    static final int MAXX = 100000;
    // divIdx[v] = (1 + index of v in the divisor list), or 0 if v is not a divisor
    static int[] divIdx = new int[MAXX + 1];

    public static void main(String[] args) throws IOException {
        FastReader in = new FastReader();
        StringBuilder sb = new StringBuilder();

        int t = in.nextInt();
        while (t-- > 0) {
            int n = in.nextInt();
            int x = in.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = in.nextInt();
            }

            // 1) Compute and sort all divisors of x
            List<Integer> divsList = new ArrayList<>();
            for (int d = 1; d * d <= x; d++) {
                if (x % d == 0) {
                    divsList.add(d);
                    if (d * d != x) {
                        divsList.add(x / d);
                    }
                }
            }
            Collections.sort(divsList);
            int D = divsList.size();
            int[] divs = new int[D];
            for (int i = 0; i < D; i++) {
                divs[i] = divsList.get(i);
                // mark in divIdx so we can map a divisor back to its index
                divIdx[divs[i]] = i + 1;
            }
            int xIdx = divIdx[x] - 1;  // index of x among divisors

            // 2) We'll maintain a DP array dp[j] = can we form divisor divs[j] in current segment
            boolean[] dp = new boolean[D];
            dp[0] = true;  // we can always form product 1 (divs[0] == 1)

            int segments = 1;  // at least one segment
            for (int v : a) {
                // If v doesn't divide x, it can't help form x, so skip it
                if (x % v != 0) continue;

                int vmax = x / v;  // to avoid overflow, only divs[j] <= x/v can multiply by v
                boolean cut = false;

                // Try to add v to current segment's DP
                for (int j = D - 1; j >= 0; j--) {
                    if (!dp[j]) continue;
                    int dj = divs[j];
                    if (dj > vmax) continue;
                    int prod = dj * v;      // guaranteed ≤ x
                    int k = divIdx[prod] - 1; 
                    if (!dp[k]) {
                        dp[k] = true;
                    }
                    // If we just made dp[x] = true, we must cut
                    if (k == xIdx) {
                        cut = true;
                    }
                }

                if (cut) {
                    // start a new segment at v
                    segments++;
                    Arrays.fill(dp, false);
                    dp[0] = true;
                    // replay v into the fresh dp
                    for (int j = D - 1; j >= 0; j--) {
                        if (!dp[j]) continue;
                        int dj = divs[j];
                        if (dj > vmax) continue;
                        int prod = dj * v;
                        int k = divIdx[prod] - 1;
                        dp[k] = true;
                    }
                }
            }

            // Clear divIdx entries for the next test
            for (int d : divs) {
                divIdx[d] = 0;
            }

            sb.append(segments).append('\n');
        }

        System.out.print(sb);
    }

    // Fast IO
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;
        FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }
        String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }
        int nextInt() throws IOException {
            return Integer.parseInt(next());
        }
    }
}
```

**Explanation of Key Steps**

1. **Divisors Preprocessing**  
   We factor _x_ in O(√x), collect its divisors (at most ~128), sort them, and build a tiny array‐map `divIdx[divisor] → its 0-based index`.  
2. **Subset‐Product DP**  
   We keep a boolean array `dp[j]` saying “we can pick some subset of the current window whose product is exactly `divs[j]`.”  Initially only `dp[0] = true` (product 1).  
   To add a new card _v_ that divides _x_, we do a **backward** scan j = D-1 … 0 and if `dp[j]` was true, we turn on  
     dp[`index_of(divs[j]*v)`] = true  
   provided `divs[j]*v` ≤ _x_.  If we ever set dp at the index of _x_, the segment can now form _x_ ⇒ it is **good**, so we must cut before this card.  
3. **Greedy Cutting**  
   As soon as the DP “becomes good” (can form _x_), we finalize the previous segment, reset `dp[]`, and replay the current card into the new segment.  This ensures every segment is **bad**, and greedily makes them as long as possible, yielding the **minimum** number of bad segments.  

This runs in O((_n_ + number_of_divisors(_x_)) · number_of_divisors(_x_)) per test, comfortably fast for ∑_n_ ≤ 10⁵ and up to 10³ tests.