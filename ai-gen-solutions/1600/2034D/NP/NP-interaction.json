[
    {
        "request_timestamp": "2025-07-23T18:22:35.180073",
        "response_timestamp": "2025-07-23T18:23:14.527083",
        "sent_messages": [
            {
                "role": "user",
                "content": "Codeforces Problem:\n\nD. Darius' Wisdom\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nDarius the Great is constructing n\n\n stone columns, each consisting of a base and between 0\n\n, 1\n\n, or 2\n\n inscription pieces stacked on top.\n\n\n\nIn each move, Darius can choose two columns u\n\n and v\n\n such that the difference in the number of inscriptions between these columns is exactly 1\n\n, and transfer one inscription from the column with more inscriptions to the other one. It is guaranteed that at least one column contains exactly 1\n\n inscription.\n\n\n\n\n\nSince beauty is the main pillar of historical buildings, Darius wants the columns to have ascending heights. To avoid excessive workers' efforts, he asks you to plan a sequence of at most n\n\n moves to arrange the columns in non-decreasing order based on the number of inscriptions. Minimizing the number of moves is not required.\n\n\n\nInput\n\nThe first line contains an integer t\n\n — the number of test cases. (1≤t≤3000\n\n)\n\n\n\nThe first line of each test case contains an integer n\n\n — the number of stone columns. (1≤n≤2⋅105\n\n)\n\n\n\nThe second line contains n\n\n integers a1,a2,…,an\n\n, where ai∈{0,1,2}\n\n represents the initial number of inscriptions in the i\n\n-th column. It is guaranteed that at least one column has exactly 1\n\n inscription.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output an integer k\n\n — the number of moves used to sort the columns. (0≤k≤n\n\n)\n\n\n\nThen, output k\n\n lines, each containing two integers ui\n\n and vi\n\n (1≤ui,vi≤n\n\n), representing the indices of the columns involved in the i\n\n-th move. During each move, it must hold that |aui−avi|=1\n\n, and one inscription is transferred from the column with more inscriptions to the other.\n\n\n\nIt can be proven that a valid solution always exists under the given constraints.\n\n\n\nExample\n\nInputCopy\n\n3\n\n4\n\n0 2 0 1\n\n3\n\n1 2 0\n\n6\n\n0 1 1 2 2 2\n\nOutputCopy\n\n2\n\n2 4\n\n2 3\n\n2\n\n3 1\n\n2 3\n\n0\n\nNote\n\nColumns state in the first test case:\n\n\n\nInitial: 0,2,0,1\n\nAfter the first move: 0,1,0,2\n\nAfter the second move: 0,0,1,2\n\nColumns state in the second test case:\n\n\n\nInitial: 1,2,0\n\nAfter the first move: 0,2,1\n\nAfter the second move: 0,1,2\n\nIn the third test case, the column heights are already sorted in ascending order.\n\n---\n\nUse Java."
            }
        ],
        "received_response": "{\n  \"id\": \"chatcmpl-Bwc96Rx87rexTfCrjKPFBaPZbXCMv\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"**Analysis**\\n\\nWe have an array `a[1..n]` whose entries are in {0,1,2}, with at least one `1`.  We want to reorder it into non‐decreasing order (all the 0’s, then all the 1’s, then all the 2’s) by a sequence of moves, where in one move we pick two indices `u,v` with `|a[u]−a[v]|=1` and transfer one “inscription” from the larger to the smaller.  Concretely:\\n\\n- If `a[u]=1, a[v]=0`, in one move we can make `(a[u],a[v])` go to `(0,1)`.  \\n- If `a[u]=2, a[v]=1`, one move can make `(a[u],a[v])` go to `(1,2)`.\\n\\nObserve that these moves exactly allow us to swap a 1 and a 0 (wherever they are), or a 2 and a 1, but we cannot directly swap a 2 and a 0.\\n\\nWe only need *some* sequence of at most `n` moves; we do not need to minimize the number of moves.\\n\\n**Strategy**\\n\\n1.  Count how many 0’s, 1’s, 2’s there are: `c0`, `c1`, `c2`.  \\n    - Final positions `1..c0` must all be 0.  \\n    - Final positions `c0+1..c0+c1` must all be 1.  \\n    - Final positions `c0+c1+1..n` must all be 2.\\n\\n2.  We do two passes:\\n\\n    **Pass 1** (fix the 0‐block):\\n\\n    For `i = 1..c0`, we want `a[i]` to become 0.\\n    - If `a[i] == 0`, do nothing.\\n    - If `a[i] == 1`, find any position `j>i` with `a[j]==0` and swap them by a single move.  That is valid because |1−0|=1.\\n    - If `a[i] == 2`, we cannot swap directly with a 0.  But we know there is at least one `1` somewhere (and because of the swaps we did earlier, there *must* be a `1` to the right of `i`).  So:\\n        1.  Find `k>i` with `a[k]==1` and swap `(2,1)→(1,2)`.\\n        2.  Now `a[i]` is `1`.  Then find `j>i` with `a[j]==0` and swap `(1,0)→(0,1)`.\\n\\n    Each time we record the move `(i,j)` or `(i,k)`, and update our data structures.\\n\\n    After this pass we guarantee `a[1..c0]` are all zero.\\n\\n    ---\\n    \\n    **Pass 2** (fix the 1‐block):\\n\\n    For `i = c0+1 .. c0+c1`, we want `a[i]` to be 1.\\n    - If it is already `1`, do nothing.\\n    - If it is `2`, we must swap it with some `1` in the 2‐zone (positions `>c0+c1`), which exists because the total number of 1’s is `c1`, and if there is a `2` in the 1‐block we haven’t placed all 1’s there yet.  So find `k > c0+c1` with `a[k]==1`, swap `(2,1)->(1,2)`, and record that move.\\n\\n    After this pass, `a[c0+1..c0+c1]` are all `1`, and the suffix `a[c0+c1+1..n]` must be all `2` automatically.\\n\\nIt can be shown that this uses at most `2·c0 + (c1_in_second_pass) ≤ n` moves, so we are within the required bound of `≤n` moves.\\n\\nTo implement efficiently we maintain three `TreeSet<Integer>` (or any balanced‐BST) storing the positions of 0’s, 1’s, and 2’s.  Each time we change a value in `a[]`, we remove the old position from its old set and insert it into its new set in `O(log n)`.  Finding e.g. a 0 to the right of `i` is just `set0.higher(i)` in `O(log n)`.\\n\\nOverall complexity is `O(n log n)` per test, which is fine for `n` up to 2·10^5 total.\\n\\n**Code**\\n\\n```java\\nimport java.io.*;\\nimport java.util.*;\\n\\npublic class Main {\\n    public static void main(String[] args) throws IOException {\\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n        PrintWriter    pw = new PrintWriter(System.out);\\n        int t = Integer.parseInt(br.readLine());\\n        while (t-- > 0) {\\n            int n = Integer.parseInt(br.readLine());\\n            StringTokenizer st = new StringTokenizer(br.readLine());\\n            int[] a = new int[n+1];\\n            for (int i = 1; i <= n; i++) {\\n                a[i] = Integer.parseInt(st.nextToken());\\n            }\\n            // Count how many 0,1,2\\n            int c0=0, c1=0, c2=0;\\n            for (int i = 1; i <= n; i++) {\\n                if (a[i]==0) c0++;\\n                else if (a[i]==1) c1++;\\n                else c2++;\\n            }\\n            // Three sets storing positions of 0s,1s,2s\\n            TreeSet<Integer> set0 = new TreeSet<>();\\n            TreeSet<Integer> set1 = new TreeSet<>();\\n            TreeSet<Integer> set2 = new TreeSet<>();\\n            for (int i = 1; i <= n; i++) {\\n                if (a[i]==0) set0.add(i);\\n                else if (a[i]==1) set1.add(i);\\n                else             set2.add(i);\\n            }\\n\\n            List<int[]> moves = new ArrayList<>();\\n\\n            // Pass 1: Make positions 1..c0 all zeros\\n            for (int i = 1; i <= c0; i++) {\\n                if (a[i] == 0) continue;\\n                if (a[i] == 1) {\\n                    // Swap with a 0 somewhere to the right\\n                    Integer j = set0.higher(i);\\n                    // perform swap(i,j)\\n                    moves.add(new int[]{i, j});\\n                    // update sets and a[]\\n                    set1.remove(i); set0.remove(j);\\n                    a[i] = 0;  a[j] = 1;\\n                    set0.add(i); set1.add(j);\\n                } else {\\n                    // a[i] == 2.  First swap with a 1\\n                    Integer k = set1.higher(i);\\n                    moves.add(new int[]{i, k});\\n                    set2.remove(i); set1.remove(k);\\n                    a[i] = 1;  a[k] = 2;\\n                    set1.add(i); set2.add(k);\\n\\n                    // Now a[i] == 1, swap with a 0\\n                    Integer j = set0.higher(i);\\n                    moves.add(new int[]{i, j});\\n                    set1.remove(i); set0.remove(j);\\n                    a[i] = 0;  a[j] = 1;\\n                    set0.add(i); set1.add(j);\\n                }\\n            }\\n\\n            // Pass 2: Make positions c0+1..c0+c1 all ones\\n            int startOne = c0+1, endOne = c0+c1;\\n            for (int i = startOne; i <= endOne; i++) {\\n                if (a[i] == 1) continue;\\n                // then a[i] must be 2, swap with a 1 in the suffix\\n                Integer k = set1.higher(endOne);\\n                moves.add(new int[]{i, k});\\n                set2.remove(i); set1.remove(k);\\n                a[i] = 1;  a[k] = 2;\\n                set1.add(i); set2.add(k);\\n            }\\n\\n            // Output result\\n            pw.println(moves.size());\\n            for (int[] mv : moves) {\\n                pw.println(mv[0] + \\\" \\\" + mv[1]);\\n            }\\n        }\\n        pw.flush();\\n        pw.close();\\n    }\\n}\\n```\\n\\n**Explanation of Key Steps**\\n\\n- We keep three balanced‐BST sets (`TreeSet<Integer>` in Java) storing the *current* positions of all 0’s, all 1’s, and all 2’s.\\n- **Pass 1** ensures the first `c0` positions become 0.  Whenever we see a 1 in that range, we swap it with a 0 further right.  If we see a 2, we first swap it with a 1 (to make it a 1), then immediately swap that 1 with a 0.  Each individual swap is valid (difference 1).\\n- **Pass 2** ensures the next `c1` positions become 1.  Any 2 in that block is swapped with a 1 in the tail.\\n- We record each swap as a move `(u,v)` and update both the array `a[]` and our three sets in `O(log n)` each time.\\n- One can show we make at most `2·c0 + (at most c1)` swaps, so ≤ `n` moves in total.  Thus the solution always respects the limit of at most `n` moves.\",\n        \"refusal\": null,\n        \"role\": \"assistant\",\n        \"annotations\": [],\n        \"audio\": null,\n        \"function_call\": null,\n        \"tool_calls\": null\n      },\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"protected_material_code\": {\n          \"filtered\": false,\n          \"detected\": true,\n          \"citation\": {\n            \"URL\": \"https://github.com/ThePinger/ACM/tree/955836e9648a2328cc9638e5af21cec5f4fb5143/UVa%2F11034%2FMain.java\",\n            \"license\": \"NOASSERTION\"\n          }\n        },\n        \"protected_material_text\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ],\n  \"created\": 1753309356,\n  \"model\": \"o4-mini-2025-04-16\",\n  \"object\": \"chat.completion\",\n  \"service_tier\": null,\n  \"system_fingerprint\": null,\n  \"usage\": {\n    \"completion_tokens\": 6341,\n    \"prompt_tokens\": 623,\n    \"total_tokens\": 6964,\n    \"completion_tokens_details\": {\n      \"accepted_prediction_tokens\": 0,\n      \"audio_tokens\": 0,\n      \"reasoning_tokens\": 4224,\n      \"rejected_prediction_tokens\": 0\n    },\n    \"prompt_tokens_details\": {\n      \"audio_tokens\": 0,\n      \"cached_tokens\": 0\n    }\n  },\n  \"prompt_filter_results\": [\n    {\n      \"prompt_index\": 0,\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"jailbreak\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ]\n}"
    }
]