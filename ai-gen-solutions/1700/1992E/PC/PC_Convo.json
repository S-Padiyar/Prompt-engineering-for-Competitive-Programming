[
  {
    "timestamp": "2025-07-24T05:47:12.602382",
    "role": "user",
    "content": "E. Novice's Mistake\n\ntime limit per test3 seconds\n\nmemory limit per test256 megabytes\n\nOne of the first programming problems by K1o0n looked like this: \"Noobish_Monk has n\n\n (1≤n≤100)\n\n friends. Each of them gave him a\n\n (1≤a≤10000)\n\n apples for his birthday. Delighted with such a gift, Noobish_Monk returned b\n\n (1≤b≤min(10000,a⋅n))\n\n apples to his friends. How many apples are left with Noobish_Monk?\"\n\n\n\nK1o0n wrote a solution, but accidentally considered the value of n\n\n as a string, so the value of n⋅a−b\n\n was calculated differently. Specifically:\n\n\n\nwhen multiplying the string n\n\n by the integer a\n\n, he will get the string s=n+n+⋯+n+na times\n\nwhen subtracting the integer b\n\n from the string s\n\n, the last b\n\n characters will be removed from it. If b\n\n is greater than or equal to the length of the string s\n\n, it will become empty.\n\nLearning about this, ErnKor became interested in how many pairs (a,b)\n\n exist for a given n\n\n, satisfying the constraints of the problem, on which K1o0n's solution gives the correct answer.\n\n\n\n\"The solution gives the correct answer\" means that it outputs a non-empty string, and this string, when converted to an integer, equals the correct answer, i.e., the value of n⋅a−b\n\n.\n\n\n\nInput\n\nThe first line contains a single integer t\n\n (1≤t≤100\n\n)  — the number of test cases.\n\n\n\nFor each test case, a single line of input contains an integer n\n\n (1≤n≤100\n\n).\n\n\n\nIt is guaranteed that in all test cases, n\n\n is distinct.\n\n\n\nOutput\n\nFor each test case, output the answer in the following format:\n\n\n\nIn the first line, output the integer x\n\n — the number of bad tests for the given n\n\n.\n\n\n\nIn the next x\n\n lines, output two integers ai\n\n and bi\n\n — such integers that K1o0n's solution on the test \"n\n\n ai\n\n bi\n\n\" gives the correct answer.\n\n\n\nExample\n\nInputCopy\n\n3\n\n2\n\n3\n\n10\n\nOutputCopy\n\n3\n\n20 18 \n\n219 216 \n\n2218 2214 \n\n1\n\n165 162 \n\n1\n\n1262 2519 \n\nNote\n\nIn the first example, a=20\n\n, b=18\n\n are suitable, as \"2\n\n\" ⋅20−18=\n\n \"22222222222222222222\n\n\"−18=22=2⋅20−18\n\nUse Java."
  },
  {
    "timestamp": "2025-07-24T05:50:06.386855",
    "role": "assistant",
    "content": "**Analysis**\n\nWe have an integer \\(n\\) (in the problem \\(1\\le n\\le100\\)) and we are to look at all pairs \\((a,b)\\) with\n```\n1 ≤ a ≤ 10 000,\n1 ≤ b ≤ min(10 000, a·n)\n```\nsuch that the \"buggy\" solution\n\n  1. writes the decimal string of \\(n\\) repeated \\(a\\) times,\n  2. then \"subtracts\" \\(b\\) by deleting the last \\(b\\) characters of that string,\n  \nproduces, as a non‐empty string, exactly the same integer as the correct answer\n\\[\nn\\cdot a - b.\n\\]\n\nLet \\(L\\) = the number of digits of \\(n\\), and write the decimal string of \\(n\\) as \\(\\mathit{str}(n)\\).  When you repeat that string \\(a\\) times you get a long string of length \\(N=aL\\).  Deleting the last \\(b\\) characters leaves the first\n\\[\nk \\;=\\; aL - b\n\\]\ncharacters of the repetition.  We require \\(k>0\\) (so the result is nonempty) and that that first-\\(k\\)-digits string, interpreted as an integer, is exactly\n\\[\nn\\,a - b.\n\\]\n\nIt turns out one can write a small number of closed‐form tests for two cases:\n\n1. **Full–block deletions**  \n   If \\(b\\) is a multiple of \\(L\\), say \\(b=m\\,L\\), then after removing \\(b\\) chars you have exactly\n   \\[\n     a - m\n   \\]\n   full copies of \\(n\\) left, i.e. the integer whose decimal is \\(\\underbrace{n\\,n\\cdots n}_{a-m}\\).  \n   One checks those are the solutions of\n   \\[\n     \\underbrace{n\\,n\\cdots n}_{a-m}\\;=\\;n\\,a - m\\,L.\n   \\]\n   One can solve that in closed‐form for an integer \\(a\\) in terms of \\(t=a-m\\).  Letting\n   \\[\n     D = n,\\quad\n     B=10,\\quad\n     L=\\text{digits}(n),\\quad\n     A=n-L,\\quad\n     R = B^L-1\n   \\]\n   one finds the candidate\n   \\[\n     a \\;=\\;\n       \\frac{\\,D\\,(B^{tL}-1)\\;-\\;tL\\,R}\n            {\\,R\\,(D-L)\\,}\n       \\quad\n       (\\text{and then }b=(a-t)L).\n   \\]\n   We only keep those integer solutions \\(1\\le a\\le10000\\), \\(b\\ge1\\), \\(b\\le10000\\), \\(b\\le a\\,n\\).\n\n2. **Partial–block deletions**  \n   If \\(b\\) is _not_ a multiple of \\(L\\), write\n   \\[\n     k = q\\,L + r,\\quad 1\\le r\\le L-1,\n   \\]\n   so that exactly \\(q\\) full copies of \\(\\mathit{str}(n)\\) plus the first \\(r\\) digits of \\(\\mathit{str}(n)\\) remain.  One can again set up a small formula\n   \\[\n     \\underbrace{n\\,n\\cdots n}_{q}\\,\\bigl(\\text{first $r$ digits of }n\\bigr)\n     \\;=\\;\n     n\\,a - b\n     \\;=\\;\n     a\\,(n-L)+\\bigl(qL+r\\bigr)\n   \\]\n   and solve for \\(a\\).  As soon as that \\(a\\) exceeds 10 000 one can stop scanning larger \\(q\\).\n\nWe implement both patterns with BigInteger (to handle intermediate powers like \\(10^{12}\\) cleanly) but in practice we only ever need small exponents because everything beyond a small threshold forces \\(a>10000\\) and we quit.  The overall per‐\\(n\\) work is only a few dozen BigInteger multiplications, which is instant.\n\nSpecial case \\(n=1\\):  then repeating the digit `\"1\"` \\(a\\) times gives the decimal\n\\[\n 111\\cdots1\\quad(a\\text{ ones})\n\\]\nwhich as an integer is \\((10^a-1)/9\\).  We demand that equals\n\\[\n 1\\cdot a - b = a - b,\n\\]\nand also that \\(k=a-b>0\\).  One checks\n\\[\n \\frac{10^k - 1}{9} = k\n\\]\nonly for \\(k=1\\).  Hence \\(a-b=1\\), or \\(b=a-1\\).  That forces \\(a\\ge2\\).  Within \\(1\\le a\\le10000\\), we get the pairs\n\\[\n (a,b) = (2,1),(3,2),\\dots,(10000,9999).\n\\]\n\nFor each test \\(n\\), we collect all such \\((a,b)\\), sort them by increasing \\(a\\), and print:\n\nFirst the count \\(x\\), then the \\(x\\) lines of \\(a\\;b\\).\n\nThis runs comfortably in the time/memory limits even though in the worst case (\\(n=1\\)) you output about 9999 lines.\n\n---\n\n```java\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader  br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter     pw = new PrintWriter(new BufferedOutputStream(System.out));\n        int t = Integer.parseInt(br.readLine().trim());\n\n        for (int _case = 0; _case < t; _case++) {\n            int n = Integer.parseInt(br.readLine().trim());\n            int L = String.valueOf(n).length();\n            List<int[]> ans = new ArrayList<>();\n\n            // Special case n = 1: all (a, b=a-1), a=2..10000\n            if (n == 1) {\n                for (int a = 2; a <= 10000; a++) {\n                    int b = a - 1;\n                    ans.add(new int[]{a, b});\n                }\n            } else {\n                // We will use BigInteger to handle powers 10^(something)\n                BigInteger BI_n = BigInteger.valueOf(n);\n                BigInteger BI_L = BigInteger.valueOf(L);\n                BigInteger ten = BigInteger.TEN;\n\n                // 10^L\n                BigInteger pow10L = ten.pow(L);\n                // R = 10^L - 1\n                BigInteger R = pow10L.subtract(BigInteger.ONE);\n                // A = n - L\n                int Aint = n - L;\n                BigInteger BI_A = BigInteger.valueOf(Aint);\n\n                // ---- Case 1: b = multiple of L  (full-block deletions) ----\n                // denom0 = (10^L - 1) * (n - L)\n                BigInteger denom0 = R.multiply(BI_A);\n                // We'll build BpowLt = 10^(t*L) by iterating t\n                BigInteger BpowLt = BigInteger.ONE;\n\n                for (int tblk = 1; ; tblk++) {\n                    BpowLt = BpowLt.multiply(pow10L); \n                    // numerator = n*(10^(tL)-1) - t*L*(10^L -1)\n                    BigInteger num = BI_n\n                                      .multiply(BpowLt.subtract(BigInteger.ONE))\n                                      .subtract(\n                                          BigInteger.valueOf((long)tblk * L)\n                                          .multiply(R)\n                                      );\n                    // If num <= 0 no valid a>0\n                    if (num.signum() <= 0) {\n                        continue;\n                    }\n                    // If num > denom0*10000, then a>10000 and will only grow; break\n                    if (num.compareTo(denom0.multiply(BigInteger.valueOf(10000L))) > 0) {\n                        break;\n                    }\n                    // check divisibility\n                    if (num.mod(denom0).equals(BigInteger.ZERO)) {\n                        BigInteger aBig = num.divide(denom0);\n                        int a = aBig.intValue();\n                        if (a > tblk && a <= 10000) {\n                            int b = (a - tblk) * L;\n                            // ensure b in range\n                            if (b >= 1 && b <= 10000 && b <= a * n) {\n                                ans.add(new int[]{a, b});\n                            }\n                        }\n                    }\n                }\n\n                // ---- Case 2: partial block (b not multiple of L) ----\n                // We delete q full copies plus r extra digits, 1 <= r < L\n                String s = String.valueOf(n);\n                // Precompute first-r-digit numbers of n\n                int[] prefix = new int[L];\n                for (int r = 1; r < L; r++) {\n                    prefix[r] = Integer.parseInt(s.substring(0, r));\n                }\n\n                for (int r = 1; r < L; r++) {\n                    BigInteger Br = ten.pow(r);   // 10^r\n                    BigInteger tsum = BigInteger.ZERO;   // will become (10^{qL}-1)/(10^L-1)\n                    // iterate q\n                    for (int q = 1; ; q++) {\n                        // build tsum = tsum*(10^L) + 1\n                        tsum = tsum.multiply(pow10L).add(BigInteger.ONE);\n                        // big part = n * 10^r * tsum\n                        BigInteger bigPart = BI_n.multiply(Br).multiply(tsum);\n                        // plus the small offset P - (qL + r)\n                        BigInteger num = bigPart.add(\n                            BigInteger.valueOf((long)prefix[r] - (q * L + r))\n                        );\n                        if (num.signum() <= 0) {\n                            continue;   // no valid a>0 yet\n                        }\n                        // if num > A*10000 => a>10000 => break\n                        if (num.compareTo(BI_A.multiply(BigInteger.valueOf(10000L))) > 0) {\n                            break;\n                        }\n                        // must divide evenly by A\n                        if (num.mod(BI_A).equals(BigInteger.ZERO)) {\n                            BigInteger aBig = num.divide(BI_A);\n                            int a = aBig.intValue();\n                            if (a > q && a <= 10000) {\n                                // b = aL - (qL + r) = (a-q)*L - r\n                                int b = (a - q) * L - r;\n                                if (b >= 1 && b <= 10000 && b <= a * n) {\n                                    ans.add(new int[]{a, b});\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Sort by increasing a\n            ans.sort(Comparator.comparingInt(x -> x[0]));\n\n            // Output\n            pw.println(ans.size());\n            for (int[] pr : ans) {\n                pw.println(pr[0] + \" \" + pr[1]);\n            }\n        }\n\n        pw.flush();\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Count the digits**  \n   We need \\(L=\\) the decimal‐digit length of \\(n\\).\n\n2. **Full‐block deletions**  \n   If \\(b\\) is a multiple of \\(L\\), say \\(b=mL\\), then the remaining string is exactly \\(a-m\\) copies of \\(\\mathit{str}(n)\\).  One shows the only integer solutions to\n   \\[\n     \\underbrace{n\\,n\\,\\cdots\\,n}_{a-m}\n     \\;=\\;\n     n\\,a \\;-\\; m\\,L\n   \\]\n   arise from the closed‐form\n   \\[\n     a\n     \\;=\\;\n     \\frac{\\,n\\,(10^{tL}-1)\\;-\\;t\\,L\\,(10^L-1)}\n          {(10^L-1)\\,(n-L)}, \n     \\quad\n     t = a-m.\n   \\]\n   We try \\(t=1,2,3,\\dots\\) until \\(a>10000\\), collecting those integer \\((a,b)\\).\n\n3. **Partial‐block deletions**  \n   If \\(b\\) is not a multiple of \\(L\\), write \\(b=aL-k\\) with\n   \\[\n     k = q\\,L + r,\\quad 1\\le r< L,\\;0\\le q\\le a-1.\n   \\]\n   The leftover string is \\(q\\) copies of \\(\\mathit{str}(n)\\) plus the first \\(r\\) digits.  One sets up\n   \\[\n     n\\cdot \\bigl(10^r\\sum_{i=0}^{q-1}10^{iL}\\bigr)\n     + \\bigl(\\text{first $r$ digits of }n\\bigr)\n     \\;=\\;\n     n\\,a - b \\;=\\; a\\,(n-L)+(qL+r)\n   \\]\n   and solves for \\(a\\).  One only needs to try small \\(q\\) until the implied \\(a\\) exceeds 10000.\n\n4. **Special case \\(n=1\\)**  \n   Repeating `\"1\"` \\(a\\) times yields \\((10^a-1)/9\\).  Equating that to \\(1\\cdot a - b\\) forces \\(k=a-b=1\\).  So \\(b=a-1\\) for all \\(2\\le a\\le10000\\).\n\nAll valid \\((a,b)\\) are collected, sorted by \\(a\\), then printed. This runs in well under a second even for 100 test‐cases."
  }
]