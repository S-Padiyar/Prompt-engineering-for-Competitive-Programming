[
  {
    "role": "user",
    "content": "D2. DFS Checker (Hard Version)\n\ntime limit per test2 seconds\n\nmemory limit per test512 megabytes\n\nThis is the hard version of the problem. In this version, you are given a generic tree and the constraints on n\n\n and q\n\n are higher. You can make hacks only if both versions of the problem are solved.\n\n\n\nYou are given a rooted tree consisting of n\n\n vertices. The vertices are numbered from 1\n\n to n\n\n, and the root is the vertex 1\n\n. You are also given a permutation p1,p2,…,pn\n\n of [1,2,…,n]\n\n.\n\n\n\nYou need to answer q\n\n queries. For each query, you are given two integers x\n\n, y\n\n; you need to swap px\n\n and py\n\n and determine if p1,p2,…,pn\n\n is a valid DFS order†\n\n of the given tree.\n\n\n\nPlease note that the swaps are persistent through queries.\n\n\n\n†\n\n A DFS order is found by calling the following dfs\n\n function on the given tree.\n\n\n\ndfs_order = []\n\n\n\nfunction dfs(v):\n\n    append v to the back of dfs_order\n\n    pick an arbitrary permutation s of children of v\n\n    for child in s:\n\n        dfs(child)\n\ndfs(1)\n\nNote that the DFS order is not unique.\n\n\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n\n (1≤t≤104\n\n). The description of the test cases follows.\n\n\n\nThe first line of each test case contains two integers n\n\n, q\n\n (2≤n≤3⋅105\n\n, 2≤q≤105\n\n) — the number of vertices in the tree and the number of queries.\n\n\n\nThe next line contains n−1\n\n integers a2,a3,…,an\n\n (1≤ai<i\n\n) — the parent of each vertex in the given tree.\n\n\n\nThe next line contains n\n\n integers p1,p2,…,pn\n\n (1≤pi≤n\n\n, all pi\n\n are distinct) — the initial permutation p\n\n.\n\n\n\nThe next q\n\n lines each contain two integers x\n\n, y\n\n (1≤x,y≤n,x≠y\n\n) — the positions of the elements to swap in the permutation.\n\n\n\nIt is guaranteed that the sum of all n\n\n does not exceed 3⋅105\n\n, and the sum of all q\n\n does not exceed 105\n\n.\n\n\n\nOutput\n\nFor each test case, print q\n\n lines corresponding to the q\n\n queries. For each query, output YES\n\n if there is a DFS order that exactly equals the current permutation, and output NO\n\n otherwise.\n\n\n\nYou can output Yes\n\n and No\n\n in any case (for example, strings yEs\n\n, yes\n\n, Yes\n\n, and YES\n\n will be recognized as a positive response).\n\n\n\nExample\n\nInputCopy\n\n3\n\n3 3\n\n1 1\n\n1 2 3\n\n2 3\n\n3 2\n\n1 3\n\n7 4\n\n1 1 2 2 3 3\n\n1 2 3 4 5 6 7\n\n3 5\n\n2 5\n\n3 7\n\n4 6\n\n5 4\n\n1 1 3 4\n\n2 3 4 5 1\n\n5 1\n\n4 5\n\n3 4\n\n2 3\n\nOutputCopy\n\nYES\n\nYES\n\nNO\n\nYES\n\nNO\n\nNO\n\nYES\n\nYES\n\nNO\n\nNO\n\nYES\n\nNote\n\nIn the first test case, the permutation p1,p2,…,pn\n\n after each modification is [1,3,2],[1,2,3],[3,2,1]\n\n, respectively. The first two permutations are valid DFS orders; the third is not a DFS order.\n\n\n\nIn the second test case, the permutation p1,p2,…,pn\n\n after each modification is [1,2,5,4,3,6,7],[1,3,5,4,2,6,7],[1,3,7,4,2,6,5],[1,3,7,6,2,4,5]\n\n, respectively.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have a rooted tree on \\(n\\) vertices (rooted at 1) and a permutation \\(p[1\\ldots n]\\).  We must support \\(q\\) operations, each swapping two entries of \\(p\\), and after each swap decide whether the current permutation \\(p\\) can arise as *some* DFS preorder of the given tree, when we are allowed to choose the visiting order of each node’s children arbitrarily.\n\nA well‐known characterization is:\n\n  1.  In a valid DFS preorder, the very first vertex must be the root, i.e. \\(p[1]=1\\).\n  2.  For every adjacent pair \\((p[i],p[i+1])\\), if we let\n        \\[\n          u = p[i],\\quad v = p[i+1],\\quad\n          w = \\mathrm{LCA}(u,v),\n        \\]\n      then \\(v\\) must be a direct child of \\(w\\).  Equivalently,\n        \\[\n          \\mathrm{parent}[v]=\\mathrm{LCA}(u,v).\n        \\]\n        \nIndeed, in a preorder DFS when you move from visiting \\(u\\) to visiting the *next* vertex \\(v\\), you either go down an unvisited child of \\(u\\) (so \\(\\mathrm{LCA}(u,v)=u\\) and \\(\\mathrm{parent}[v]=u\\)), or you have finished \\(u\\)'s subtree and you pop back up to some ancestor \\(w\\), whose next child to visit is \\(v\\).  In that latter case \\(\\mathrm{LCA}(u,v)=w\\) and \\(v\\)'s parent must be exactly \\(w\\).  It can be shown that these two conditions (\\(p[1]=1\\) and \\(\\mathrm{parent}[p[i+1]] = \\mathrm{LCA}(p[i],\\,p[i+1])\\) for every \\(i\\)) are necessary and sufficient for \\(p\\) to be a valid preorder.\n\nWe must maintain this validity under swaps of two positions in \\(p\\).  Notice that swapping at positions \\(x,y\\) affects only the adjacent‐pair conditions at indices\n\n\\[\n  x-1,\\,x,\\quad y-1,\\,y\n\\]\n\n(as long as those lie in \\(1\\le i\\le n-1\\)).  We can keep a boolean array\n\n```\n   validEdge[i]   // 1 if parent[p[i+1]]==LCA(p[i],p[i+1]), else 0\n```\n\nand an integer `goodCount = sum(validEdge[1..n-1])`.  Also we check `p[1]==1` separately.  Then:\n\n  * Initially build a preprocessing for LCA in \\(O(n\\log n)\\) (here we use binary‐lifting).\n  * Compute the initial `validEdge[i]` for \\(i=1\\ldots n-1\\).  Let\n        \\(\\displaystyle\\mathit{goodCount}=\\sum_{i=1}^{n-1}\\mathit{validEdge}[i].\\)\n  * A permutation is a valid DFS order exactly when `p[1]==1` and `goodCount == n-1`.\n\nOn each swap:\n\n1.  Swap `p[x]` and `p[y]`.\n2.  Recompute `validEdge[i]` (and adjust `goodCount`) for each affected index \\(i\\in\\{x-1,x,y-1,y\\}\\cap[1,n-1]\\), using the new `p[]`.\n3.  Answer `YES` if `p[1]==1 && goodCount==n-1`, else `NO`.\n\nEach update touches at most 4 entries of `validEdge[]`, and each requires one LCA in \\(O(\\log n)\\).  Thus each query is \\(O(\\log n)\\), and overall (over all testcases) is \\(O((\\sum n)\\log n + (\\sum q)\\log n )\\), which easily fits under the given limits.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int MAXN = 300_000;\n    static final int LOG  = 19;  // 2^18=262144 < 3e5 < 2^19\n\n    static int n, q;\n    static int[] parent = new int[MAXN+1];\n    static int[] depth  = new int[MAXN+1];\n    static int[][] up   = new int[LOG][MAXN+1];\n    static int[] p      = new int[MAXN+1];\n    static int[] validEdge = new int[MAXN+1];\n\n    // Compute LCA with binary lifting\n    static int lca(int a, int b) {\n        if (depth[a] < depth[b]) {\n            int t=a; a=b; b=t;\n        }\n        // Lift a up to the same depth as b\n        int diff = depth[a] - depth[b];\n        for(int k=0; k<LOG; k++){\n            if ((diff & (1<<k)) != 0) {\n                a = up[k][a];\n            }\n        }\n        if (a==b) return a;\n        // Lift both up until their parents match\n        for(int k=LOG-1; k>=0; k--){\n            if (up[k][a] != up[k][b]) {\n                a = up[k][a];\n                b = up[k][b];\n            }\n        }\n        // now they differ but up[0][a]==up[0][b] is the LCA\n        return up[0][a];\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        int T = Integer.parseInt(br.readLine().trim());\n\n        while(T-- > 0){\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            n = Integer.parseInt(st.nextToken());\n            q = Integer.parseInt(st.nextToken());\n\n            // Read parent array (a[2..n]), set parent[1]=1\n            parent[1] = 1;\n            st = new StringTokenizer(br.readLine());\n            for (int i = 2; i <= n; i++) {\n                parent[i] = Integer.parseInt(st.nextToken());\n            }\n\n            // Build depth[] and up[0][]\n            depth[1] = 0;\n            up[0][1] = 1;\n            for (int v = 2; v <= n; v++) {\n                depth[v] = depth[parent[v]] + 1;\n                up[0][v] = parent[v];\n            }\n            // Build binary‐lifting table up[k][v]\n            for (int k = 1; k < LOG; k++) {\n                for (int v = 1; v <= n; v++) {\n                    up[k][v] = up[k-1][ up[k-1][v] ];\n                }\n            }\n\n            // Read initial permutation p[]\n            st = new StringTokenizer(br.readLine());\n            for (int i = 1; i <= n; i++) {\n                p[i] = Integer.parseInt(st.nextToken());\n            }\n\n            // Initialize validEdge[i] for i=1..n-1\n            int goodCount = 0;\n            for (int i = 1; i < n; i++) {\n                int u = p[i], v = p[i+1];\n                int w = lca(u, v);\n                if (parent[v] == w) {\n                    validEdge[i] = 1;\n                    goodCount++;\n                } else {\n                    validEdge[i] = 0;\n                }\n            }\n\n            // Process the q swaps/queries\n            for (int _q = 0; _q < q; _q++) {\n                st = new StringTokenizer(br.readLine());\n                int x = Integer.parseInt(st.nextToken());\n                int y = Integer.parseInt(st.nextToken());\n\n                // Perform the swap in p[]\n                int tmp = p[x]; \n                p[x] = p[y];\n                p[y] = tmp;\n\n                // Recompute up to 4 affected edges\n                // i in {x-1, x, y-1, y} ∩ [1..n-1]\n                int[] idx = {x-1, x, y-1, y};\n                for (int k = 0; k < 4; k++) {\n                    int i = idx[k];\n                    if (i < 1 || i >= n) continue;\n                    // recompute validEdge[i]\n                    int oldVal = validEdge[i];\n                    int u = p[i], v = p[i+1];\n                    int w = lca(u, v);\n                    int newVal = (parent[v] == w ? 1 : 0);\n                    if (newVal != oldVal) {\n                        validEdge[i] = newVal;\n                        goodCount += (newVal - oldVal);\n                    }\n                }\n\n                // Finally check if p[1]==1 AND all edges are valid\n                if (p[1] == 1 && goodCount == n-1) {\n                    out.append(\"YES\\n\");\n                } else {\n                    out.append(\"NO\\n\");\n                }\n            }\n        }\n\n        System.out.print(out.toString());\n    }\n}\n```\n\n**Explanation of the key steps**\n\n1. **LCA Preprocessing**  \n   We store `up[k][v]` = the \\(2^k\\)-th ancestor of \\(v\\).  \n   - `up[0][v] = parent[v]`.  \n   - Then `up[k][v] = up[k-1][ up[k-1][v] ]`.  \n   We also store `depth[v]`.  LCA queries run in \\(O(\\log n)\\) by lifting.\n\n2. **Validity condition**  \n   A permutation \\(p\\) is a valid DFS preorder *if and only if*  \n   - \\(p[1]=1\\), and  \n   - for each adjacent pair \\((u,v)=(p[i],p[i+1])\\), letting \\(w=\\mathrm{LCA}(u,v)\\), we have\n     \\[\n       \\text{parent}[v] = w.\n     \\]\n\n3. **Maintaining under swaps**  \n   Swapping `p[x]` with `p[y]` only disturbs the conditions at indices \\(i = x-1,x,y-1,y\\) (where those lie in \\([1,n-1]\\)).  \n   We keep an array `validEdge[i]` which is 1 if that local LCA‐condition is satisfied, else 0.  We also maintain the total\n   \\(\\mathit{goodCount} = \\sum_{i=1}^{n-1} \\mathit{validEdge}[i]\\).  \n   After each swap, we recompute at most 4 of these `validEdge[i]` values (each in \\(O(\\log n)\\) time via an LCA).\n\n4. **Answering**  \n   At each query, we simply check  \n   ```\n     (p[1] == 1)  AND  (goodCount == n-1)\n   ```\n   If both hold, the permutation is some valid DFS preorder; otherwise it is not.\n\nThis runs in \\(O((n+q)\\log n)\\) per test (over all tests \\(\\sum n\\le3\\cdot10^5,\\sum q\\le10^5\\)), well within the 2‐second limit."
  }
]