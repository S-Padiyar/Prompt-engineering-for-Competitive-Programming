**Analysis**

We have \(n\) cities on a line (numbered \(1\) to \(n\)), each city carrying exactly two different “portal‐colors” chosen from \(\{B,G,R,Y\}\).  You may “teleport” between any two cities that share at least one portal–color, and that teleport costs the absolute difference of their city‐indices.

We must answer \(q\) queries \((x,y)\), asking for the minimum cost to get from city \(x\) to city \(y\), or \(-1\) if they are disconnected.

A direct fully‐connected “clique” of same‐color cities would give \(\bigl|i-j\bigr|\) cost for every pair in that clique, but in fact the cheapest way to move among the same‐color cities is simply to walk the color‐line in index‐order between neighbors (since walking “step‐by‐step” on a color line exactly telescopes to \(\lvert i-j\rvert\)).  Thus each color induces a simple path graph on the subset of cities that carry that color, plus at each city we have a zero‐cost “switch” between its two portal‐colors.

We build a segment‐tree over the cities.  In each segment‐node covering \([L,R]\) we store a \(4\times4\) matrix `d[a][b]`, which is the minimum cost to enter the segment at its *left* boundary with color \(a\), and to exit the segment at its *right* boundary with color \(b\).  Colors are \(\{B,G,R,Y\}\equiv\{0,1,2,3\}\).

-  **Leaf** for city \(i\) has
   \[
     d[a][b]=
     \begin{cases}
       0,&\text{if }a=b\text{ and city \(i\) has color \(a\),}\\
       0,&\text{if }\{a,b\}\text{ are exactly the two colors of city \(i\),}\\
       \infty,&\text{otherwise.}
     \end{cases}
   \]
  (This allows zero‐cost switching between the two portals at city \(i\), or staying in the same color if that color is present.)

-  **Merging** two adjacent segments \(A\) covering \([L,M]\) and \(B\) covering \([M+1,R]\) amounts to a “min‐plus” multiplication of their matrices, *plus* the cost of crossing the boundary between city \(M\) and city \(M+1\).  One can only cross in color \(c\) if *both* city \(M\) and city \(M+1\) have portal \(c\), and that crossing costs 1.  Hence if `mask[M] & mask[M+1]` has bit \(c\), we can go through color \(c\).  

Putting it all together, each segment‐tree node stores
\[
   d_C[a][b] \;=\;
     \min_{c\in\{0,1,2,3\},\,\text{boundary has }c}
       \bigl(A.d[a][c]\;+\;1\;+\;B.d[c][b]\bigr).
\]

We then answer a query \([x,y]\) by fetching exactly the \(O(\log n)\) segment‐tree nodes whose intervals partition \([x,y]\), merge them left‐to‐right (using the same merge‐logic), and then look up
\[
  \min_{a\in\mathrm{colors}(x),\,b\in\mathrm{colors}(y)}  
    d_{\mathrm{whole}}[\,a\,][\,b\,].
\]
If the result is “infinity,” we print \(-1\); otherwise we print that minimum.

Since each merge is only \(O(4^2)\) or say \(O(16)\) operations (we iterate over the at‐most‐two boundary‐colors), the segment‐tree build is \(O(n)\) and each query is \(O(\log n)\).  With \(n,q\le2\cdot10^5\) (summed over all tests), this runs comfortably in time.

---

```java
import java.io.*;
import java.util.*;

public class Main {
    static final int INF = 1_000_000_000;
    // Map 'B','G','R','Y' -> 0,1,2,3
    static int colorIndex(char c) {
        switch(c) {
            case 'B': return 0;
            case 'G': return 1;
            case 'R': return 2;
            default:  return 3; // 'Y'
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        int t = Integer.parseInt(br.readLine().trim());
        StringBuilder sb = new StringBuilder();

        while (t-- > 0) {
            st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            int q = Integer.parseInt(st.nextToken());

            // Read city portal‐pairs and build a bitmask of colors per city
            int[] mask = new int[n+1];
            st = new StringTokenizer(br.readLine());
            for (int i = 1; i <= n; i++) {
                String s = st.nextToken();
                int c1 = colorIndex(s.charAt(0));
                int c2 = colorIndex(s.charAt(1));
                mask[i] = (1<<c1) | (1<<c2);
            }

            // Build segment‐tree size = next power of two >= n
            int size = 1;
            while (size < n) size <<= 1;
            int segSize = size << 1;

            // larr/rarr store the [L,R] interval of each node
            int[] larr = new int[segSize];
            int[] rarr = new int[segSize];
            // ds[node][a][b] = min cost from color a at left boundary to color b at right boundary
            int[][][] ds = new int[segSize][4][4];

            // Initialize leaves
            for (int i = size; i < size + n; i++) {
                int city = i - size + 1;
                larr[i] = rarr[i] = city;
                // fill INF
                for (int a = 0; a < 4; a++)
                    Arrays.fill(ds[i][a], INF);
                // if city has color a, staying in a costs 0
                for (int a = 0; a < 4; a++) {
                    if ((mask[city] & (1<<a)) != 0) {
                        ds[i][a][a] = 0;
                    }
                }
                // the two portal‐colors at city can switch at cost 0
                int twoColors = mask[city];
                int c0 = Integer.numberOfTrailingZeros(twoColors);
                int c1 = 31 - Integer.numberOfLeadingZeros(twoColors);
                if (c0 != c1) {
                    ds[i][c0][c1] = 0;
                    ds[i][c1][c0] = 0;
                }
            }
            // Mark empty leaves (i > n) with invalid interval
            for (int i = size + n; i < segSize; i++) {
                larr[i] = 1;
                rarr[i] = 0; // invalid means l>r
            }

            // Build up the internal nodes
            for (int i = size - 1; i >= 1; i--) {
                mergeNode(i<<1, (i<<1)|1, i, mask, larr, rarr, ds);
            }

            // Process queries
            while (q-- > 0) {
                st = new StringTokenizer(br.readLine());
                int x = Integer.parseInt(st.nextToken());
                int y = Integer.parseInt(st.nextToken());
                if (x > y) {
                    int tmp = x; x = y; y = tmp;
                }
                // We will do the standard iterative segment‐tree range query on [x-1, y)
                // but we must merge nodes left‐to‐right using the same merge logic
                int li = x-1 + size;
                int ri = y   + size;

                // curL represents the merged segment so far from the left
                boolean haveL = false;
                int Ll=0, Lr=0;
                int[][] dL = new int[4][4];  // will point into ds when haveL==false, or store merges

                // curR for the right side (we will later merge L and R)
                boolean haveR = false;
                int Rl=0, Rr=0;
                int[][] dR = new int[4][4];

                // temp array for merges
                int[][] tmp = new int[4][4];

                while (li < ri) {
                    if ((li & 1) == 1) {
                        // merge curL with node li
                        if (!haveL) {
                            // first node for L
                            haveL = true;
                            Ll = larr[li];
                            Lr = rarr[li];
                            dL = ds[li];
                        } else {
                            mergeAny(Ll, Lr, dL, 
                                     larr[li], rarr[li], ds[li],
                                     mask, tmp);
                            Lr = rarr[li];
                            // swap tmp -> dL
                            int[][] swap = dL; dL = tmp; tmp = swap;
                        }
                        li++;
                    }
                    if ((ri & 1) == 1) {
                        ri--;
                        // merge node ri with curR
                        if (!haveR) {
                            haveR = true;
                            Rl = larr[ri];
                            Rr = rarr[ri];
                            dR = ds[ri];
                        } else {
                            mergeAny(larr[ri], rarr[ri], ds[ri],
                                     Rl, Rr, dR,
                                     mask, tmp);
                            Rl = larr[ri];
                            int[][] swap = dR; dR = tmp; tmp = swap;
                        }
                    }
                    li >>= 1;
                    ri >>= 1;
                }

                // now final merge L & R
                int[][] dAll;
                if (!haveL) {
                    if (!haveR) {
                        // empty
                        dAll = new int[4][4];
                        for (int a = 0; a < 4; a++)
                            Arrays.fill(dAll[a], INF);
                    } else {
                        dAll = dR;
                    }
                } else if (!haveR) {
                    dAll = dL;
                } else {
                    mergeAny(Ll, Lr, dL,
                             Rl, Rr, dR,
                             mask, tmp);
                    dAll = tmp;
                }

                // Finally take min over the two colors at x and the two at y
                int ans = INF;
                int mx = mask[x];
                int my = mask[y];
                for (int cx = 0; cx < 4; cx++) if ((mx & (1<<cx))!=0) {
                    for (int cy = 0; cy < 4; cy++) if ((my & (1<<cy))!=0) {
                        ans = Math.min(ans, dAll[cx][cy]);
                    }
                }
                if (ans >= INF) ans = -1;
                sb.append(ans).append('\n');
            }
        }

        System.out.print(sb.toString());
    }

    /** 
     * Merge two built segment‐tree children A=2*i,B=2*i+1 into parent idx.
     */
    static void mergeNode(int aIdx, int bIdx, int pIdx,
                          int[] mask, int[] L, int[] R,
                          int[][][] ds) {
        int l1 = L[aIdx], r1 = R[aIdx];
        int l2 = L[bIdx], r2 = R[bIdx];
        L[pIdx] = l1;
        R[pIdx] = r2;
        int[][] d1 = ds[aIdx], d2 = ds[bIdx], d3 = ds[pIdx];

        // clear d3
        for (int i = 0; i < 4; i++) Arrays.fill(d3[i], INF);

        if (l1 > r1) {
            // left empty => copy right
            for (int i = 0; i < 4; i++)
                System.arraycopy(d2[i], 0, d3[i], 0, 4);
            return;
        }
        if (l2 > r2) {
            // right empty => copy left
            for (int i = 0; i < 4; i++)
                System.arraycopy(d1[i], 0, d3[i], 0, 4);
            return;
        }

        // boundary between r1 and l2
        int mInter = mask[r1] & mask[l2];
        if (mInter == 0) {
            // no color to cross => all INF
            return;
        }
        // for each color c in the intersection
        for (int c = 0; c < 4; c++) {
            if (((mInter >> c) & 1) != 0) {
                // cross cost = 1 in color c
                for (int a = 0; a < 4; a++) {
                    int da = d1[a][c];
                    if (da >= INF) continue;
                    da += 1;
                    for (int b = 0; b < 4; b++) {
                        int val = da + d2[c][b];
                        if (val < d3[a][b]) d3[a][b] = val;
                    }
                }
            }
        }
    }

    /**
     * Merge any two segments described by (l1..r1,d1) and (l2..r2,d2)
     * into the result array 'res' (4x4).
     */
    static void mergeAny(int l1, int r1, int[][] d1,
                         int l2, int r2, int[][] d2,
                         int[] mask, int[][] res) {
        // initialize INF
        for (int i = 0; i < 4; i++) Arrays.fill(res[i], INF);

        if (l1 > r1) {
            // just copy d2
            for (int i = 0; i < 4; i++)
                System.arraycopy(d2[i], 0, res[i], 0, 4);
            return;
        }
        if (l2 > r2) {
            // just copy d1
            for (int i = 0; i < 4; i++)
                System.arraycopy(d1[i], 0, res[i], 0, 4);
            return;
        }

        int mInter = mask[r1] & mask[l2];
        if (mInter == 0) {
            // no boundary crossing possible => stays INF
            return;
        }
        // for each crossing‐color c
        for (int c = 0; c < 4; c++) {
            if (((mInter >> c) & 1) != 0) {
                // cost to cross = 1
                for (int a = 0; a < 4; a++) {
                    int da = d1[a][c];
                    if (da >= INF) continue;
                    da += 1;
                    for (int b = 0; b < 4; b++) {
                        int val = da + d2[c][b];
                        if (val < res[a][b]) res[a][b] = val;
                    }
                }
            }
        }
    }
}
```

**Explanation of the key points**

1. **Color‐lines as paths.**  Each of the four colors induces a path on the cities that carry that color, with unit‐weight edges between consecutive‐by‐index cities (since walking neighbor‐to‐neighbor telescopes exactly to \(\lvert i-j\rvert\)).

2. **Zero‐cost switches** at each city connect exactly the two colors found in that city.

3. **Segment‐tree** stores for every interval \([L,R]\) a \(4\times4\) “transfer‐matrix” \(d\) where  
   \[
     d[a][b]\;=\;\min\{\text{cost of any path staying inside }[L,R]\text{ that starts
     at city }L\text{ in color }a\text{ and ends at city }R\text{ in color }b\}.
   \]
   
4. **Leaf initialization.**  A single city \(i\) allows staying in any of its two colors at cost \(0\), and switching between those two colors at cost \(0\).  All other color‐pairs are \(\infty\).

5. **Merge operation.**  To merge two adjacent intervals \([L,M]\) and \([M+1,R]\), we take
   \[
     d_{\mathrm{tot}}[a][b]
      \;=\;\min_{c\in\{0,1,2,3\}\,\cap\,(\mathrm{mask}[M]\wedge\mathrm{mask}[M+1])}
            \bigl(d_A[a][c]\;+\;1\;+\;d_B[c][b]\bigr).
   \]
   i.e.\ we must cross the boundary in some color \(c\) that both city \(M\) and city \(M+1\) share, at cost 1.

6. **Answering a query \((x,y)\)** becomes precisely the “min‐plus” product of those \(O(\log n)\) segment‐tree matrices that cover \([x,y]\), finally taking
   \[
     \min_{a\in\mathrm{colors}(x),\,b\in\mathrm{colors}(y)} 
         d_{\mathrm{merged}}[a][b].
   \]
   If it remains \(\infty\), we output \(-1\).

Each merge is \(O(4^2)\) (we only iterate over the at‐most‐two colors that can cross the boundary), so building is \(O(n)\) and each query \(O(\log n)\).  With \(n,q\le2\cdot10^5\) total, this easily fits in 2 s and 256 MB.