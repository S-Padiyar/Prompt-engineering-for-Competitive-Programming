[
  {
    "timestamp": "2025-07-24T05:45:59.307875",
    "role": "user",
    "content": "E. Manhattan Triangle\n\ntime limit per test3 seconds\n\nmemory limit per test256 megabytes\n\nThe Manhattan distance between two points (x1,y1)\n\n and (x2,y2)\n\n is defined as:\n\n|x1−x2|+|y1−y2|.\n\n\n\nWe call a Manhattan triangle three points on the plane, the Manhattan distances between each pair of which are equal.\n\n\n\nYou are given a set of pairwise distinct points and an even integer d\n\n. Your task is to find any Manhattan triangle, composed of three distinct points from the given set, where the Manhattan distance between any pair of vertices is equal to d\n\n.\n\n\n\nInput\n\nEach test consists of multiple test cases. The first line contains one integer t\n\n (1≤t≤104\n\n) — the number of test cases. The description of the test cases follows.\n\n\n\nThe first line of each test case contains two integers n\n\n and d\n\n (3≤n≤2⋅105\n\n, 2≤d≤4⋅105\n\n, d\n\n is even) — the number of points and the required Manhattan distance between the vertices of the triangle.\n\n\n\nThe (i+1)\n\n-th line of each test case contains two integers xi\n\n and yi\n\n (−105≤xi,yi≤105\n\n) — the coordinates of the i\n\n-th point. It is guaranteed that all points are pairwise distinct.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output three distinct integers i\n\n, j\n\n, and k\n\n (1≤i,j,k≤n\n\n) — the indices of the points forming the Manhattan triangle. If there is no solution, output \"0 0 0\n\n\" (without quotes).\n\n\n\nIf there are multiple solutions, output any of them.\n\n\n\nExample\n\nInputCopy\n\n6\n\n6 4\n\n3 1\n\n0 0\n\n0 -2\n\n5 -3\n\n3 -5\n\n2 -2\n\n5 4\n\n0 0\n\n0 -2\n\n5 -3\n\n3 -5\n\n2 -2\n\n6 6\n\n3 1\n\n0 0\n\n0 -2\n\n5 -3\n\n3 -5\n\n2 -2\n\n4 4\n\n3 0\n\n0 3\n\n-3 0\n\n0 -3\n\n10 8\n\n2 1\n\n-5 -1\n\n-4 -1\n\n-5 -3\n\n0 1\n\n-2 5\n\n-4 4\n\n-4 2\n\n0 0\n\n-4 1\n\n4 400000\n\n100000 100000\n\n-100000 100000\n\n100000 -100000\n\n-100000 -100000\n\nOutputCopy\n\n2 6 1\n\n4 3 5\n\n3 5 1\n\n0 0 0\n\n6 1 3\n\n0 0 0\n\nNote\n\nIn the first test case:\n\n\n\nPoints A\n\n, B\n\n, and F\n\n form a Manhattan triangle, the Manhattan distance between each pair of vertices is 4\n\n. Points D\n\n, E\n\n, and F\n\n can also be the answer.\n\nIn the third test case:\n\n\n\nPoints A\n\n, C\n\n, and E\n\n form a Manhattan triangle, the Manhattan distance between each pair of vertices is 6\n\n.\n\nIn the fourth test case, there are no two points with a Manhattan distance of 4\n\n, and therefore there is no suitable Manhattan triangle.\n\nUse Java."
  },
  {
    "timestamp": "2025-07-24T06:00:25.322728",
    "role": "assistant",
    "content": "**Analysis**\n\nWe are given \\(n\\) distinct integer points \\((x_i,y_i)\\) in the plane and an even integer \\(d\\).  We wish to find three of these points \\(A,B,C\\) such that\n\n\\[\n\\;|x_A - x_B| + |y_A - y_B| \\;=\\;\n|x_B - x_C| + |y_B - y_C| \\;=\\;\n|x_C - x_A| + |y_C - y_A|\\;=\\;d.\n\\]\n\nSuch a triple is called an *equilateral triangle in the \\(L^1\\) (Manhattan) metric*.  It turns out that *all* such “equilateral” triples come from one of two rigid‐motion families:\n\n1. **“45°‐rotated” squares** (always available for any even \\(d\\)).  \n   Write \\(D = d/2\\).  Then one family is\n   \\[\n     A = P,\\quad\n     B = P + (D,D),\\quad\n     C = P + (D,-D),\n   \\]\n   or any choice of signs in the two coordinates of those two vectors.  \n   One checks\n   \\[\n     \\|B - A\\|_1 = |D|+|D| = d,\\quad\n     \\|C - A\\|_1 = |D|+|{-D}| = d,\\quad\n     \\|B - C\\|_1 = |D - D| + |D - (-D)| = 2|D| = d.\n   \\]\n   By switching the signs of \\(\\pm D\\) independently in each coordinate, we get 4 possible “adjacent‐edge” pairs.\n\n2. **The “3 : 1”‐ratio family** (only if \\(d\\) is divisible by 4).  \n   Write \\(u = d/4\\).  Then set\n   \\[\n     a = 3u,\\quad b = u.\n   \\]\n   One shows that for\n   \\[\n     v_1=(\\pm a,\\pm b),\\quad v_2=(\\pm b,\\pm a)\n   \\]\n   *with the same sign choice in corresponding coordinates*, the three points\n   \\[\n     A = P,\\quad B = P+v_1,\\quad C = P+v_2\n   \\]\n   again satisfy \n   \\[\n     \\|B-A\\|_1=\\|C-A\\|_1=d,\\quad\n     \\|B-C\\|_1=d.\n   \\]\n   This yields 4 more “patterns” whenever \\(d\\equiv 0\\pmod 4\\).\n\nHence our solution is:\n\n1.  Read all points and store them in a hash‐map (or `HashMap`) from the 64‐bit encoded key\n   \\[\n     \\Bigl(x\\ll32\\Bigr)\\;|\\;(y\\;\\&\\;0xffffffffL)\n   \\]\n   to its index \\(1\\ldots n\\).\n\n2.  Let \\(D = d/2\\).  We always try **Family 1**: the four sign‐choices\n   \\[\n     v_1 = (\\sigma_1 D,\\;\\sigma_2 D),\\quad\n     v_2 = (\\sigma_1 D,\\;-\\sigma_2 D),\\quad\n     \\sigma_1,\\sigma_2\\in\\{+1,-1\\}.\n   \\]\n   For each base‐point \\(P=(x,y)\\) we check whether both \\(P+v_1\\) and \\(P+v_2\\) lie in our set.\n   If yes, we output the three indices and move to the next test case.\n\n3.  If \\(d\\equiv0\\pmod4\\), also try **Family 2**.  Put \\(u=d/4\\), \\(a=3u\\), \\(b=u\\).  Then for\n   \\(\\sigma_1,\\sigma_2\\in\\{+1,-1\\}\\) we let\n   \\[\n     v_1=(\\sigma_1 a,\\;\\sigma_2 b),\\quad \n     v_2=(\\sigma_1 b,\\;\\sigma_2 a).\n   \\]\n   Again we check if \\(P+v_1\\) and \\(P+v_2\\) are in our set.  If so, we report the triple and stop.\n\n4.  If no triple is ever found, we print `0 0 0`.\n\nEach point does \\(O(1)\\) checks — at most \\(8\\) hash‐lookups if \\(d\\not\\equiv0\\pmod4\\), or \\(16\\) lookups otherwise — so overall \\(O(n)\\) per test case, which is plenty fast for \\(\\sum n\\le2\\cdot10^5\\).\n\nBelow is a complete Java implementation.\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int t = Integer.parseInt(st.nextToken());\n\n        StringBuilder sb = new StringBuilder();\n        // We'll reuse one HashMap per test to avoid reallocation overhead.\n        HashMap<Long,Integer> map = new HashMap<>();\n\n        outer:\n        for (int _case = 0; _case < t; _case++) {\n            st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int d = Integer.parseInt(st.nextToken());\n\n            // Read points, build map\n            map.clear();\n            int[] X = new int[n];\n            int[] Y = new int[n];\n            for (int i = 0; i < n; i++) {\n                st = new StringTokenizer(br.readLine());\n                int x = Integer.parseInt(st.nextToken());\n                int y = Integer.parseInt(st.nextToken());\n                X[i] = x;\n                Y[i] = y;\n                long key = encode(x, y);\n                map.put(key, i+1);  // store 1-based index\n            }\n\n            int D = d / 2;         // always integer because d is even\n            boolean found = false;\n            int ai=0, bi=0, ci=0;\n\n            // Precompute all 4 patterns of Family 1 (45°‐square)\n            int[][] fam1_dx = new int[4][2];\n            int[][] fam1_dy = new int[4][2];\n            int idx = 0;\n            for (int s1 = -1; s1 <= 1; s1 += 2) {\n                for (int s2 = -1; s2 <= 1; s2 += 2) {\n                    fam1_dx[idx][0] = s1 * D;  // v1.x\n                    fam1_dy[idx][0] = s2 * D;  // v1.y\n                    fam1_dx[idx][1] = s1 * D;  // v2.x\n                    fam1_dy[idx][1] = -s2 * D; // v2.y\n                    idx++;\n                }\n            }\n\n            // Precompute Family 2 (3:1) if d divisible by 4\n            boolean useFam2 = (d % 4 == 0);\n            int u = d / 4;\n            int a = 3 * u, b = u;\n            int[][] fam2_dx = null, fam2_dy = null;\n            if (useFam2) {\n                fam2_dx = new int[4][2];\n                fam2_dy = new int[4][2];\n                idx = 0;\n                for (int s1 = -1; s1 <= 1; s1 += 2) {\n                    for (int s2 = -1; s2 <= 1; s2 += 2) {\n                        fam2_dx[idx][0] = s1 * a; fam2_dy[idx][0] = s2 * b;\n                        fam2_dx[idx][1] = s1 * b; fam2_dy[idx][1] = s2 * a;\n                        idx++;\n                    }\n                }\n            }\n\n            // Try every point as the \"anchor\" A\n            for (int i = 0; i < n && !found; i++) {\n                int x = X[i], y = Y[i];\n                long baseKey = encode(x, y);\n\n                // Family 1\n                for (int k = 0; k < 4 && !found; k++) {\n                    int x1 = x + fam1_dx[k][0],  y1 = y + fam1_dy[k][0];\n                    int x2 = x + fam1_dx[k][1],  y2 = y + fam1_dy[k][1];\n                    long k1 = encode(x1, y1);\n                    long k2 = encode(x2, y2);\n                    Integer j = map.get(k1);\n                    Integer l = map.get(k2);\n                    if (j != null && l != null) {\n                        ai = i+1; bi = j; ci = l;\n                        found = true;\n                    }\n                }\n\n                // Family 2\n                if (!found && useFam2) {\n                    for (int k = 0; k < 4 && !found; k++) {\n                        int x1 = x + fam2_dx[k][0], y1 = y + fam2_dy[k][0];\n                        int x2 = x + fam2_dx[k][1], y2 = y + fam2_dy[k][1];\n                        long k1 = encode(x1, y1);\n                        long k2 = encode(x2, y2);\n                        Integer j = map.get(k1);\n                        Integer l = map.get(k2);\n                        if (j != null && l != null) {\n                            ai = i+1; bi = j; ci = l;\n                            found = true;\n                        }\n                    }\n                }\n            }\n\n            if (!found) {\n                sb.append(\"0 0 0\\n\");\n            } else {\n                sb.append(ai).append(' ')\n                  .append(bi).append(' ')\n                  .append(ci).append('\\n');\n            }\n        }\n\n        // print all answers\n        System.out.print(sb.toString());\n    }\n\n    // encode a pair (x,y) into a single 64-bit key\n    static long encode(int x, int y) {\n        return ( (long)x << 32 ) ^ (y & 0xffffffffL);\n    }\n}\n```\n\n**Explanation of the key steps**\n\n1. **Hashing the points**  \n   We store each point \\((x,y)\\) in a `HashMap<Long,Integer>` where the key is a 64‐bit combine of \\((x,y)\\) and the value is the 1‐based index of that point.  Look‐ups in this map cost average \\(O(1)\\).\n\n2. **Family 1 (45°‐rotated square)**  \n   We set \\(D = d/2\\).  From any point \\(A=(x,y)\\), the other two vertices must be\n   \\[\n     B = A + (\\pm D,\\pm D),\\quad\n     C = A + (\\pm D,\\mp D),\n   \\]\n   where the two sign‐bits \\(\\sigma_1,\\sigma_2\\) can be chosen independently.  We test all 4 sign‐choices; if both of those neighbors appear in our map, we are done.\n\n3. **Family 2 (“3:1” ratio)**  \n   Only valid if \\(d\\) is a multiple of 4, say \\(d=4u\\).  We set \\(a=3u\\), \\(b=u\\).  From any \\(A\\) we try\n   \\[\n     v_1=(\\,\\pm a,\\;\\pm b),\\quad \n     v_2=(\\,\\pm b,\\;\\pm a),\n   \\]\n   with the *same* sign combination in corresponding coordinates.  \n   Again if both \\(A+v_1\\) and \\(A+v_2\\) lie in our set, we have a perfect Manhattan‐equilateral triangle of side \\(d\\).\n\n4. **Complexity**  \n   Each of the \\(n\\) base‐points does up to 4 checks for Family 1 and (if \\(d\\equiv0\\pmod4\\)) 4 more for Family 2.  Each check is two hash‐lookups.  Thus \\(O(n)\\) overall per test case, well within the problem’s limits.\n\nThis completes the solution in \\(O(n)\\) per test case and uses only \\(O(n)\\) extra space."
  }
]