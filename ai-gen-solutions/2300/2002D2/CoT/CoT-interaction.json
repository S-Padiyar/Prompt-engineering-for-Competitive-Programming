[
    {
        "request_timestamp": "2025-07-23T20:07:51.347693",
        "response_timestamp": "2025-07-23T20:08:47.007610",
        "sent_messages": [
            {
                "role": "user",
                "content": "Codeforces Problem:\n\nD2. DFS Checker (Hard Version)\n\ntime limit per test2 seconds\n\nmemory limit per test512 megabytes\n\nThis is the hard version of the problem. In this version, you are given a generic tree and the constraints on n\n\n and q\n\n are higher. You can make hacks only if both versions of the problem are solved.\n\n\n\nYou are given a rooted tree consisting of n\n\n vertices. The vertices are numbered from 1\n\n to n\n\n, and the root is the vertex 1\n\n. You are also given a permutation p1,p2,…,pn\n\n of [1,2,…,n]\n\n.\n\n\n\nYou need to answer q\n\n queries. For each query, you are given two integers x\n\n, y\n\n; you need to swap px\n\n and py\n\n and determine if p1,p2,…,pn\n\n is a valid DFS order†\n\n of the given tree.\n\n\n\nPlease note that the swaps are persistent through queries.\n\n\n\n†\n\n A DFS order is found by calling the following dfs\n\n function on the given tree.\n\n\n\ndfs_order = []\n\n\n\nfunction dfs(v):\n\n    append v to the back of dfs_order\n\n    pick an arbitrary permutation s of children of v\n\n    for child in s:\n\n        dfs(child)\n\ndfs(1)\n\nNote that the DFS order is not unique.\n\n\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n\n (1≤t≤104\n\n). The description of the test cases follows.\n\n\n\nThe first line of each test case contains two integers n\n\n, q\n\n (2≤n≤3⋅105\n\n, 2≤q≤105\n\n) — the number of vertices in the tree and the number of queries.\n\n\n\nThe next line contains n−1\n\n integers a2,a3,…,an\n\n (1≤ai<i\n\n) — the parent of each vertex in the given tree.\n\n\n\nThe next line contains n\n\n integers p1,p2,…,pn\n\n (1≤pi≤n\n\n, all pi\n\n are distinct) — the initial permutation p\n\n.\n\n\n\nThe next q\n\n lines each contain two integers x\n\n, y\n\n (1≤x,y≤n,x≠y\n\n) — the positions of the elements to swap in the permutation.\n\n\n\nIt is guaranteed that the sum of all n\n\n does not exceed 3⋅105\n\n, and the sum of all q\n\n does not exceed 105\n\n.\n\n\n\nOutput\n\nFor each test case, print q\n\n lines corresponding to the q\n\n queries. For each query, output YES\n\n if there is a DFS order that exactly equals the current permutation, and output NO\n\n otherwise.\n\n\n\nYou can output Yes\n\n and No\n\n in any case (for example, strings yEs\n\n, yes\n\n, Yes\n\n, and YES\n\n will be recognized as a positive response).\n\n\n\nExample\n\nInputCopy\n\n3\n\n3 3\n\n1 1\n\n1 2 3\n\n2 3\n\n3 2\n\n1 3\n\n7 4\n\n1 1 2 2 3 3\n\n1 2 3 4 5 6 7\n\n3 5\n\n2 5\n\n3 7\n\n4 6\n\n5 4\n\n1 1 3 4\n\n2 3 4 5 1\n\n5 1\n\n4 5\n\n3 4\n\n2 3\n\nOutputCopy\n\nYES\n\nYES\n\nNO\n\nYES\n\nNO\n\nNO\n\nYES\n\nYES\n\nNO\n\nNO\n\nYES\n\nNote\n\nIn the first test case, the permutation p1,p2,…,pn\n\n after each modification is [1,3,2],[1,2,3],[3,2,1]\n\n, respectively. The first two permutations are valid DFS orders; the third is not a DFS order.\n\n\n\nIn the second test case, the permutation p1,p2,…,pn\n\n after each modification is [1,2,5,4,3,6,7],[1,3,5,4,2,6,7],[1,3,7,4,2,6,5],[1,3,7,6,2,4,5]\n\n, respectively.\n\n---\n\nLet's think step-by-step so we don't make mistakes. Use Java. Avoid syntax errors or infinite loops."
            }
        ],
        "received_response": "{\n  \"id\": \"chatcmpl-BwdmxGTnYC9vZ8OiHQQAlb5UowFYF\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"Here is a Java solution.  It precomputes binary‐lifting parents and depths in O(n log n), then keeps track of \\nS = ∑_{i=1 to n−1} dist(p[i], p[i+1]).  One can show that p[1..n] is a valid DFS‐order iff p[1]=1 and\\n\\n   S + depth[p[n]] == 2·(n−1).\\n\\nEach swap at positions x,y only affects at most four adjacent “distances” f[i]=dist(p[i],p[i+1]), so we update S in O(log n) per updated f[i].  Overall runtime over all tests is O((∑n)·log n + ∑q·log n), which is fine for ∑n≤3·10^5, ∑q≤10^5.\\n\\n```java\\nimport java.io.*;\\nimport java.util.StringTokenizer;\\n\\npublic class Main {\\n    static final int MAXN = 300000 + 5;\\n    static final int LOG = 19;  // since 2^18 = 262144 < 300000 < 2^19\\n    static int[][] up = new int[LOG][MAXN];\\n    static int[] depth = new int[MAXN];\\n    static int[] parent = new int[MAXN];\\n    static int[] p = new int[MAXN];\\n    static int[] f = new int[MAXN];\\n    static int n, q;\\n\\n    public static void main(String[] args) throws IOException {\\n        FastReader in = new FastReader();\\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\\n        int t = in.nextInt();\\n        while (t-- > 0) {\\n            n = in.nextInt();\\n            q = in.nextInt();\\n            // read parents a2..an\\n            parent[1] = 0;\\n            depth[1] = 0;\\n            up[0][1] = 0;\\n            for (int i = 2; i <= n; i++) {\\n                int par = in.nextInt();\\n                parent[i] = par;\\n                depth[i] = depth[par] + 1;\\n                up[0][i] = par;\\n            }\\n            // build binary lifting\\n            for (int k = 1; k < LOG; k++) {\\n                for (int i = 1; i <= n; i++) {\\n                    up[k][i] = up[k - 1][ up[k - 1][i] ];\\n                }\\n            }\\n            // read permutation p[1..n]\\n            for (int i = 1; i <= n; i++) {\\n                p[i] = in.nextInt();\\n            }\\n            // build initial sum of distances\\n            long S = 0;\\n            for (int i = 1; i < n; i++) {\\n                f[i] = dist(p[i], p[i+1]);\\n                S += f[i];\\n            }\\n            // process queries\\n            for (int qi = 0; qi < q; qi++) {\\n                int x = in.nextInt();\\n                int y = in.nextInt();\\n                // positions where f[] depends on p[x] or p[y]:\\n                int[] idxs = { x - 1, x, y - 1, y };\\n                // subtract old\\n                for (int idx : idxs) {\\n                    if (idx >= 1 && idx < n) {\\n                        S -= f[idx];\\n                    }\\n                }\\n                // swap in the permutation\\n                int tmp = p[x];\\n                p[x] = p[y];\\n                p[y] = tmp;\\n                // recompute those f[] and add back\\n                for (int idx : idxs) {\\n                    if (idx >= 1 && idx < n) {\\n                        f[idx] = dist(p[idx], p[idx + 1]);\\n                        S += f[idx];\\n                    }\\n                }\\n                // check validity: need p[1]==1 and S + depth[p[n]] == 2*(n-1)\\n                if (p[1] == 1 && S + depth[p[n]] == 2L * (n - 1)) {\\n                    out.println(\\\"YES\\\");\\n                } else {\\n                    out.println(\\\"NO\\\");\\n                }\\n            }\\n        }\\n        out.flush();\\n        out.close();\\n    }\\n\\n    // LCA by binary lifting\\n    static int lca(int u, int v) {\\n        if (depth[u] < depth[v]) {\\n            int t = u; u = v; v = t;\\n        }\\n        // lift u up to depth[v]\\n        int diff = depth[u] - depth[v];\\n        for (int k = 0; k < LOG; k++) {\\n            if ((diff & (1 << k)) != 0) {\\n                u = up[k][u];\\n            }\\n        }\\n        if (u == v) return u;\\n        for (int k = LOG - 1; k >= 0; k--) {\\n            if (up[k][u] != up[k][v]) {\\n                u = up[k][u];\\n                v = up[k][v];\\n            }\\n        }\\n        return parent[u]; // or up[0][u]\\n    }\\n\\n    static int dist(int u, int v) {\\n        int w = lca(u, v);\\n        return depth[u] + depth[v] - 2 * depth[w];\\n    }\\n\\n    // fast input\\n    static class FastReader {\\n        BufferedReader br;\\n        StringTokenizer st;\\n        FastReader() {\\n            br = new BufferedReader(new InputStreamReader(System.in));\\n        }\\n        String next() throws IOException {\\n            while (st == null || !st.hasMoreTokens())\\n                st = new StringTokenizer(br.readLine());\\n            return st.nextToken();\\n        }\\n        int nextInt() throws IOException {\\n            return Integer.parseInt(next());\\n        }\\n    }\\n}\\n```\\n\\nExplanation of the key idea:\\n\\n1.  In any DFS of a rooted tree starting at 1, if you record each vertex on first entry, then for consecutive vertices `p[i]`,`p[i+1]` one travels along the unique path between them.  The sum\\n     ∑_{i=1..n−1} dist(p[i],p[i+1]) plus the final ascent back from `p[n]` to the root (which is `depth[p[n]]`)\\n     is exactly twice the number of edges, i.e. 2·(n−1).\\n\\n2.  Hence if and only if `p[1] = 1` and\\n     ∑_{i=1..n−1} dist(p[i],p[i+1]) + depth[p[n]] == 2·(n−1),\\n     the permutation can be realized by **some** DFS ordering (since children can be visited in any order).\\n\\n3.  When we swap two positions `x,y` in `p`, only at most four adjacent distances change: those at indices `x−1, x, y−1, y`.  We subtract out their old contributions, swap, recompute those four, and restore the sum — all in O(log n) per distance because we use LCA by binary‐lifting. \\n\\nThus each query costs O(log n), and precomputation is O(n log n), which easily fits the given bounds.\",\n        \"refusal\": null,\n        \"role\": \"assistant\",\n        \"annotations\": [],\n        \"audio\": null,\n        \"function_call\": null,\n        \"tool_calls\": null\n      },\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"protected_material_code\": {\n          \"filtered\": false,\n          \"detected\": true,\n          \"citation\": {\n            \"URL\": \"https://github.com/ayoub62/letscode3/tree/2a026d6a39f1bf21c16913e1b11507bd9a1fee38/Space.java\",\n            \"license\": \"NOASSERTION\"\n          }\n        },\n        \"protected_material_text\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ],\n  \"created\": 1753315671,\n  \"model\": \"o4-mini-2025-04-16\",\n  \"object\": \"chat.completion\",\n  \"service_tier\": null,\n  \"system_fingerprint\": null,\n  \"usage\": {\n    \"completion_tokens\": 9247,\n    \"prompt_tokens\": 889,\n    \"total_tokens\": 10136,\n    \"completion_tokens_details\": {\n      \"accepted_prediction_tokens\": 0,\n      \"audio_tokens\": 0,\n      \"reasoning_tokens\": 7680,\n      \"rejected_prediction_tokens\": 0\n    },\n    \"prompt_tokens_details\": {\n      \"audio_tokens\": 0,\n      \"cached_tokens\": 0\n    }\n  },\n  \"prompt_filter_results\": [\n    {\n      \"prompt_index\": 0,\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"jailbreak\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ]\n}"
    }
]