[
  {
    "role": "user",
    "content": "C. Eri and Expanded Sets\n\ntime limit per test3 seconds\n\nmemory limit per test512 megabytes\n\nLet there be a set that contains distinct positive integers. To expand the set to contain as many integers as possible, Eri can choose two integers x≠y\n\n from the set such that their average x+y2\n\n is still a positive integer and isn't contained in the set, and add it to the set. The integers x\n\n and y\n\n remain in the set.\n\n\n\nLet's call the set of integers consecutive if, after the elements are sorted, the difference between any pair of adjacent elements is 1\n\n. For example, sets {2}\n\n, {2,5,4,3}\n\n, {5,6,8,7}\n\n are consecutive, while {2,4,5,6}\n\n, {9,7}\n\n are not.\n\n\n\nEri likes consecutive sets. Suppose there is an array b\n\n, then Eri puts all elements in b\n\n into the set. If after a finite number of operations described above, the set can become consecutive, the array b\n\n will be called brilliant.\n\n\n\nNote that if the same integer appears in the array multiple times, we only put it into the set once, as a set always contains distinct positive integers.\n\n\n\nEri has an array a\n\n of n\n\n positive integers. Please help him to count the number of pairs of integers (l,r)\n\n such that 1≤l≤r≤n\n\n and the subarray al,al+1,…,ar\n\n is brilliant.\n\n\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single integer t\n\n (1≤t≤104\n\n) — the number of test cases. The description of the test cases follows.\n\n\n\nThe first line of each test case contains a single integer n\n\n (1≤n≤4⋅105\n\n) — length of the array a\n\n.\n\n\n\nThe second line of each test case contains n\n\n integers a1,a2,…an\n\n (1≤ai≤109\n\n) — the elements of the array a\n\n.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases doesn't exceed 4⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output a single integer — the number of brilliant subarrays.\n\n\n\nExample\n\nInputCopy\n\n6\n\n2\n\n2 2\n\n6\n\n1 3 6 10 15 21\n\n5\n\n6 30 18 36 9\n\n1\n\n1000000000\n\n6\n\n1 1 4 5 1 4\n\n12\n\n70 130 90 90 90 108 612 500 451 171 193 193\n\nOutputCopy\n\n3\n\n18\n\n5\n\n1\n\n18\n\n53\n\nNote\n\nIn the first test case, the array a=[2,2]\n\n has 3\n\n subarrays: [2]\n\n, [2]\n\n, and [2,2]\n\n. For all of them, the set only contains a single integer 2\n\n, therefore it's always consecutive. All these subarrays are brilliant, so the answer is 3\n\n.\n\n\n\nIn the second test case, let's consider the subarray [3,6,10]\n\n. We can do operations as follows:\n\n\n\n{3,6,10}−→−−−−x=6,y=10{3,6,8,10}−→−−−−x=6,y=8{3,6,7,8,10}−→−−−−x=3,y=7{3,5,6,7,8,10}\n\n−→−−−−x=3,y=5{3,4,5,6,7,8,10}−→−−−−x=8,y=10{3,4,5,6,7,8,9,10}\n\n{3,4,5,6,7,8,9,10}\n\n is a consecutive set, so the subarray [3,6,10]\n\n is brilliant.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have an array \\(a\\) of length \\(n\\).  We call a subarray \\(a_{\\ell},a_{\\ell+1},\\dots,a_{r}\\) _brilliant_ if the set of _distinct_ values in that subarray can be “filled in” (by repeatedly taking integer mid-points \\(\\frac{x+y}2\\), when they land in the integers and are not already present) so as to form a consecutive block of integers from its minimum to its maximum.\n\nA key combinatorial/algebraic fact is that for any finite integer set\n\\[\nS = \\{s_1<s_2<\\cdots<s_k\\},\n\\]\nthe _greatest common divisor_ of ***all*** pairwise differences\n\\[\n\\gcd\\bigl(|s_j-s_i|\\;:\\;1\\le i<j\\le k\\bigr)\n\\]\ngoverns exactly which arithmetic strides survive the midpoint-filling process.  In fact one shows\n\n1.  If that GCD has an odd prime factor, the filling process _cannot_ overcome that odd factor (you never get numbers that break that odd modulus), so you cannot ever become fully consecutive.\n2.  Conversely if that GCD is a pure power of two, then repeated mid-points divide out the 2’s until the only “stride” remaining is \\(1\\), and you do eventually fill out every integer in between.\n\nThus a subarray is _brilliant_ precisely if\n\n- it has only one distinct value (which trivially is a consecutive block of size 1), or\n- the GCD of all pairwise differences in the distinct set is a power of two.\n\n---\n\nBut we do _not_ want to recompute a full pairwise GCD for every subarray—that would be \\(O(n^2)\\).  The classic trick is:\n\n1.  Observe \\(\\gcd(s_j-s_i\\;\\text{over all }i<j)\\)\n    equals\n    \\[\n      \\gcd\\bigl(|a_{i+1}-a_i| : i=\\ell,\\dots,r-1\\bigr),\n    \\]\n    i.e.\\ the GCD of the _adjacent_ differences in that subarray.\n\n2.  Therefore if we define a new array\n   \\[\n     d_i = |a_{i+1}-a_i|,\\quad i=1,\\dots,n-1,\n   \\]\n   then for any subarray \\(a_\\ell,\\dots,a_r\\) with \\(r>\\ell\\), the relevant GCD is\n   \\(\\gcd(d_\\ell,d_{\\ell+1},\\dots,d_{r-1})\\).\n\n3.  We must count all subarrays of \\(d\\) whose GCD is a power of two (or zero, which corresponds to “all equal” in the \\(a\\)-subarray).  We then add \\(n\\) singleton subarrays \\([\\,\\ell=\\!r\\,]\\), all of which are brilliant by definition.\n\nTo count the number of subarrays of \\(d\\) whose GCD lies in the set \n\\(\\{\\,0,1,2,4,8,\\dots\\}\\), one uses the well–known “GCD‐on‐the‐fly” DP:\n\n- We sweep a right‐endpoint \\(i\\) from \\(1\\) to \\(n-1\\).\n- We maintain a small list of pairs \\((g,c)\\) meaning: “there are \\(c\\) subarrays ending at \\(i-1\\) whose GCD is \\(g\\).”\n- When we move to add \\(d_i\\), every old GCD \\(g\\) gets updated to \\(\\gcd(g,d_i)\\).  We merge equal GCD‐values to keep the list of size \\(\\le O(\\log(\\max d_i))\\).  \n- We also start a brand‐new subarray \\([i,i]\\) with GCD \\(d_i\\).\n- In that list for endpoint \\(i\\), we sum up the counts \\(c\\) whose GCD is \\(0\\) or a power of two.  That contributes to our running total of brilliant subarrays of length \\(\\ge2\\).\n\nFinally we add \\(n\\) for the trivial single‐element subarrays.\n\nOverall time is\n\\[\n  \\sum_{i=1}^{n-1}O(\\log(\\max d_i))\n  = O\\bigl(n\\log(\\max a_i)\\bigr),\n\\]\nwhich is fine for \\(n\\) up to \\(4\\cdot10^5\\).\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    // Fast I/O\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        FastReader(InputStream in) { br = new BufferedReader(new InputStreamReader(in)); }\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try { st = new StringTokenizer(br.readLine()); }\n                catch (IOException e) { throw new RuntimeException(e); }\n            }\n            return st.nextToken();\n        }\n        int nextInt() { return Integer.parseInt(next()); }\n    }\n\n    // gcd helper\n    static int gcd(int a, int b) {\n        while (b != 0) {\n            int t = a % b;\n            a = b;\n            b = t;\n        }\n        return a;\n    }\n\n    // Check if x is 0 or a power of two\n    static boolean isPowerOfTwoOrZero(int x) {\n        return x == 0 || ((x & (x - 1)) == 0);\n    }\n\n    public static void main(String[] args) {\n        FastReader in = new FastReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int t = in.nextInt();\n        while (t-- > 0) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n            }\n\n            // If n == 1, there's exactly 1 subarray and it's brilliant.\n            if (n == 1) {\n                out.println(1);\n                continue;\n            }\n\n            // Build the difference array d[i] = |a[i+1] - a[i]|, length = n-1\n            int m = n - 1;\n            int[] d = new int[m];\n            for (int i = 0; i < m; i++) {\n                d[i] = Math.abs(a[i + 1] - a[i]);\n            }\n\n            // We'll do the classic \"sliding GCD\" DP.\n            // prevG[k], prevCnt[k] will store the distinct GCD-values\n            // and their counts for subarrays ending at index i-1.\n            int[] prevG = new int[32], prevCnt = new int[32];\n            int prevSize = 0;\n\n            long ans = 0;  // counts all brilliant subarrays of length >= 2\n\n            for (int i = 0; i < m; i++) {\n                int val = d[i];\n                int[] curG = new int[32], curCnt = new int[32];\n                int curSize = 0;\n\n                // Extend every old subarray by d[i]\n                for (int j = 0; j < prevSize; j++) {\n                    int g = gcd(prevG[j], val);\n                    if (curSize > 0 && curG[curSize - 1] == g) {\n                        curCnt[curSize - 1] += prevCnt[j];\n                    } else {\n                        curG[curSize] = g;\n                        curCnt[curSize] = prevCnt[j];\n                        curSize++;\n                    }\n                }\n\n                // Also start a brand-new subarray [i, i]\n                if (curSize > 0 && curG[curSize - 1] == val) {\n                    curCnt[curSize - 1]++;\n                } else {\n                    curG[curSize] = val;\n                    curCnt[curSize] = 1;\n                    curSize++;\n                }\n\n                // Count how many of these ending-at-i have GCD in {0,1,2,4,8,...}\n                for (int j = 0; j < curSize; j++) {\n                    if (isPowerOfTwoOrZero(curG[j])) {\n                        ans += curCnt[j];\n                    }\n                }\n\n                // Move cur -> prev for next iteration\n                prevSize = curSize;\n                System.arraycopy(curG, 0, prevG, 0, curSize);\n                System.arraycopy(curCnt,0, prevCnt,0, curSize);\n            }\n\n            // Add the n single-element subarrays (all are brilliant).\n            ans += n;\n\n            out.println(ans);\n        }\n\n        out.flush();\n    }\n}\n```\n\n**Explanation of the main steps**\n\n1.  **Precompute differences**  \n    We build an array \\(d\\) of length \\(n-1\\) with  \n    \\[\n      d_i = |\\,a_{i+1}-a_i|\\,,\\quad i=1,\\dots,n-1.\n    \\]\n    A subarray of the original \\(a\\) from \\(\\ell\\) to \\(r\\) with \\(r>\\ell\\) is brilliant precisely if  \n    \\(\\gcd(d_\\ell,d_{\\ell+1},\\dots,d_{r-1})\\)  \n    is an integer power of two (or zero, which occurs when all the \\(a\\)-values are equal in that subarray).\n\n2.  **“GCD‐on‐the‐fly” for subarrays of \\(d\\)**  \n    We sweep over each right‐end \\(i\\) of the difference‐array \\(d\\).  We maintain a small list of pairs \\((g,c)\\) meaning that there are \\(c\\) subarrays of \\(d\\) ending at index \\(i-1\\) whose GCD is \\(g\\).  When we extend to include \\(d_i\\), each old GCD \\(g\\) becomes \\(\\gcd(g,d_i)\\).  We merge equal GCD’s (to keep the list length \\(O(\\log\\max d)\\)).  We also start one new subarray \\([i,i]\\) with GCD \\(d_i\\).  Then we simply sum up the counts \\(c\\) for those entries whose updated GCD is in \\(\\{0,1,2,4,8,\\dots\\}\\).\n\n3.  **Adding singletons**  \n    Every subarray of length 1 in \\(a\\) is automatically brilliant, so at the end we add \\(n\\) for those.\n\nThe total complexity is \\(O(n\\log A)\\), where \\(A\\) is the largest \\(|a_i|\\), easily fast enough for \\(n\\) up to \\(4\\times10^5\\)."
  },
  {
    "role": "system",
    "content": "Identify any errors in this response and output a prompt to help the AI resolve said issues. Your response MUST be in one of two formats: 1. If the response looks perfect, return \"Perfect\". Do not return this if there are any issues. Use this very sparingly as any errors in the final output from the AI will be considered a failure on your part. 2. Otherwise, return \"{prompt}\" where {prompt} is replaced with your concise prompt. This should be done most often, even if the AI's response is mostly correct. Ensure the entire response is enclosed in double quotations if it's a prompt. Make sure your prompt asks the AI to return one block of code for submission."
  },
  {
    "role": "assistant",
    "content": "Perfect"
  }
]