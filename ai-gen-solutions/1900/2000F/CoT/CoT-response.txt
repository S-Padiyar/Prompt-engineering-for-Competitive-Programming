**Analysis**

We have \(n\) rectangles, the \(i\)-th of size \(a_i\times b_i\).  We may color individual cells one by one.  Each time we manage to fully color a row or a column of any rectangle, we gain 1 point.  We want at least \(k\) points in total, using as few colored‐cell operations as possible.

In rectangle \((a,b)\), suppose we choose to complete \(x\) columns and \(y\) rows (so we earn \(x+y\) points from that rectangle).  To color those \(x\) columns we need \(x\cdot b\) cell‐colorings; to color those \(y\) rows we need \(y\cdot a\) cell‐colorings.  However, each chosen column crosses each chosen row in exactly one cell, so that cell would otherwise have been counted twice; thus the total **distinct** cell‐colorings is

\[
  \text{cost}(x,y)
  \;=\;
  x\,b \;+\; y\,a \;-\; x\,y.
\]

We must distribute our target of \(k\) points across the \(n\) rectangles.  Let
\[
  p_i = x_i + y_i
\]
be the points we extract from rectangle \(i\), with cost
\[
  c_i(p_i)
  \;=\;
  \min_{\substack{x_i+y_i = p_i \\ 0\le x_i\le a_i,\,0\le y_i\le b_i}}
  \bigl(x_i\,b_i + y_i\,a_i - x_i\,y_i\bigr).
\]
We then need
\[
  \sum_{i=1}^n p_i \;\ge\; k,
\]
and want to minimize
\[
  \sum_{i=1}^n c_i(p_i).
\]

Since \(k\le100\), a standard DP‐over‐points knapsack works in \(O(n\cdot k^2)\).  Concretely:

1. For each rectangle \(i\), precompute an array  
   \(\mathrm{cost}_i[0\ldots k]\), where  
   \(\mathrm{cost}_i[p]\) = minimal number of cell‐colorings to get exactly \(p\) points  
   (i.e.\ \(p=x+y\)), or \(\infty\) if \(p>a_i+b_i\).

2. Maintain a DP array \(\mathrm{dp}[0\ldots k]\), where  
   \(\mathrm{dp}[j]\) = minimal total cell‐colorings to achieve exactly \(j\) points so far  
   (baseline \(\mathrm{dp}[0]=0\), others \(=\infty\)).  

3. Process rectangles one by one; for each new rectangle \(i\), build a new array \(\mathrm{newdp}\) by
   \[
     \mathrm{newdp}[\,\min(k,\,j + p)\,]
     \;=\;
     \min\Bigl(\mathrm{newdp}[\,\min(k,\,j + p)\,],\,\mathrm{dp}[j] + \mathrm{cost}_i[p]\Bigr)
     \quad
     (\forall j=0\ldots k,\;\forall p=0\ldots k).
   \]
   We cap the sum of points at \(k\) by using \(\min(k,\dots)\), because we only care about attaining **at least** \(k\) points.

4. After all \(n\) rectangles, \(\mathrm{dp}[k]\) is our answer (or \(-1\) if it remains \(\infty\)).

This runs in \(O\bigl(n\,k^2 + n\,k\cdot\max(a_i,b_i)\bigr)\), which is fine for \(n\le1000\), \(k\le100\), \(a_i,b_i\le100\).

---

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer tok = new StringTokenizer(in.readLine());
        int t = Integer.parseInt(tok.nextToken());

        final int INF = 1_000_000_000;
        StringBuilder sb = new StringBuilder();

        while (t-- > 0) {
            tok = new StringTokenizer(in.readLine());
            int n = Integer.parseInt(tok.nextToken());
            int k = Integer.parseInt(tok.nextToken());

            int[] a = new int[n], b = new int[n];
            for (int i = 0; i < n; i++) {
                tok = new StringTokenizer(in.readLine());
                a[i] = Integer.parseInt(tok.nextToken());
                b[i] = Integer.parseInt(tok.nextToken());
            }

            // dp[j] = minimal cost to get exactly j points so far
            int[] dp = new int[k+1];
            Arrays.fill(dp, INF);
            dp[0] = 0;

            // Process each rectangle
            for (int i = 0; i < n; i++) {
                // Precompute cost_i[p] = minimal operations to get exactly p points
                // from rectangle i (width = a[i], height = b[i]).
                int maxP = Math.min(k, a[i] + b[i]);
                int[] cost = new int[maxP+1];
                Arrays.fill(cost, INF);
                cost[0] = 0;  // zero rows + zero columns = 0 cost

                // Try all ways x columns + y rows = p
                for (int x = 0; x <= a[i]; x++) {
                    for (int y = 0; y <= b[i]; y++) {
                        int p = x + y;
                        if (p > maxP) continue;
                        // cost to paint x columns + y rows, minus double‐count
                        int c = x * b[i] + y * a[i] - x * y;
                        if (c < cost[p]) {
                            cost[p] = c;
                        }
                    }
                }

                // knapsack update: produce newdp
                int[] newdp = new int[k+1];
                Arrays.fill(newdp, INF);

                for (int got = 0; got <= k; got++) {
                    if (dp[got] == INF) continue;
                    // either take 0..maxP points from this rectangle
                    for (int p = 0; p <= maxP; p++) {
                        int c = cost[p];
                        if (c == INF) continue;
                        int nxt = got + p;
                        if (nxt > k) nxt = k;  // cap at k
                        int v = dp[got] + c;
                        if (v < newdp[nxt]) {
                            newdp[nxt] = v;
                        }
                    }
                }

                dp = newdp;
            }

            int ans = dp[k];
            sb.append(ans >= INF ? -1 : ans).append('\n');
        }

        System.out.print(sb);
    }
}
```

**Explanation of Key Steps**

1. **Cost‐Table for Each Rectangle**  
   We build `cost[p]` for \(p=0\ldots \min(k,a+b)\).  For a rectangle \(a\times b\), if we choose exactly \(x\) columns and \(y\) rows with \(x+y=p\), the number of distinct cell‐colorings is
   \[
     x\cdot b + y\cdot a \;-\; x\cdot y.
   \]
   We minimize over all \(0\le x\le a\), \(0\le y\le b\) with \(x+y=p\).

2. **DP‐Over‐Points**  
   We maintain `dp[j]` = minimal cost to get exactly \(j\) points after processing some rectangles.  When we add rectangle \(i\), we form `newdp` by considering adding \(p\) points from rectangle \(i\) (with cost `cost[p]`), updating
   \[
     \mathrm{newdp}[\min(k,\,j+p)]
     =
     \min\bigl(\mathrm{newdp}[\cdot],\,dp[j] + cost[p]\bigr).
   \]
   We cap index at \(k\) because any total beyond \(k\) is equally “at least \(k\).”

3. **Answer**  
   After all rectangles, `dp[k]` holds the minimum number of cell‐colorings needed to achieve **at least** \(k\) complete rows/columns, or it remains \(\infty\) if impossible.

This runs in \(O(n\cdot k^2 + \sum (a_i+1)(b_i+1))\), which is efficient for \(n\le1000\), \(k\le100\), \(a_i,b_i\le100\).