**Analysis**

We have an array \(a\) of length \(n\).  We are given an integer \(x\), and we are allowed to repeatedly pick any element \(a_i\ge x\) and replace it with \(a_i - x\).  Equivalently, once you are done, each element
\[
b_i\;=\;a_i \bmod x
\]
because you might as well subtract \(x\) as many times as possible until \(0\le b_i<x\).  Clearly, to make the median as small as possible, one should reduce **every** \(a_i\ge x\) as much as one can.  Hence the final multiset of numbers is
\[
\{\,a_i\bmod x\mid i=1\ldots n\},
\]
and the answer is the median of that multiset.

We must answer \(q\) queries, each query giving a different \(x\).  A brute‐force solution recomputing all \(a_i\bmod x\) and resorting would be \(O(n\log n)\) per query, which is too big when \(n\) and \(q\) can each be up to \(10^5\) (and \(n+q\) over all tests is up to \(10^5\)).

Instead we

1.  Precompute once the frequencies of the original array values and build their prefix‐sum array so that we can query
   \[
     \#\{\,i\mid a_i\in [L,R]\}
     \;=\;
     \text{pf}[R]\;-\;\text{pf}[L-1].
   \]
2.  Observe that for a given \(x\), the distribution of remainders
   \[
     \{\,a_i\bmod x\}
   \]
   is exactly, for each remainder \(r\in[0,x-1]\),
   \[
     \sum_{k\ge0}\#\{\,a_i\in [kx + r,\;kx + r]\}.
   \]
   Hence if we let
   \[
     S_x(v)
     \;=\;
     \#\{\,i\mid a_i\bmod x\le v\}
     \;=\;
     \sum_{k:\;kx\le \max a}\Bigl(\text{pf}[\min(\max a,\;k x+v)]-\text{pf}[k x-1]\Bigr),
   \]
   then the median is the smallest \(v\) for which \(S_x(v)\ge m\), where
   \[
     m=\Bigl\lceil\frac{n}{2}\Bigr\rceil
     \quad
     \text{if \(n\) odd},
     \quad
     m=\frac n2 +1
     \quad
     \text{if \(n\) even}.
   \]
   Equivalently \(m=(n+2)\sslash 2\).

3.  We will handle "small" \(x\) (\(x\le B\)) by a direct \(\bmod\)-scan:
   - Pick \(B\approx \sqrt{n}\).  For each \(x=1,2,\dots,B\), we make an array `cnt[0..x-1]` and do
     \[
       \text{cnt}[\,a_i \bmod x\,]++\quad(i=1\ldots n),
     \]
     then scan `cnt` to find the first remainder whose prefix‐sum \(\ge m\).  This costs \(O(n)\) per small \(x\), so \(O(nB)\approx O(n\sqrt n)\) total for all \(x\le B\).  Since \(\sum n\le10^5\) over all tests and \(B\approx 316\) for \(n\approx10^5\), that is about \(3\times10^7\) very‐tight but still under 1 s in optimized Java.

4.  For "large" \(x\) (\(x>B\)), the number of blocks \(k\) with \(k\,x\le \max a\) is at most \(\lfloor n/x\rfloor\le \lfloor n/B\rfloor=O(\sqrt n)\).  Hence evaluating
   \[
     S_x(v)\;=\;\sum_{k=0}^{\lfloor\max a/x\rfloor}
          \bigl(\text{pf}[\min(\max a,kx+v)]-\text{pf}[kx-1]\bigr)
   \]
   costs \(O(\sqrt n)\).  We binary‐search \(v\in[0,x-1]\) in \(O(\log n)\) steps, each step \(O(\sqrt n)\).  Since we only need to do this once per distinct \(x\) (caching the result), and
   \(\sum_{x>B}n/x=O(\,n\ln n\,)\),
   the total over all distinct \(x\) is about \(O(n \ln n)\approx10^6\)–\(10^7\), perfectly safe.  

5.  If \(x>\max a\), then trivially \(a_i<x\) for all \(i\), so \(b_i=a_i\).  The median is just the median of the original array, which we can also read off from the prefix‐sum of the original frequencies in \(O(n)\).

Putting it all together runs in roughly \(O(n\sqrt n + n\ln n + q)\) per test file—and since \(\sum n,\,\sum q\le10^5\), we stay within the 1 s limit in optimized Java.

---

```java
import java.io.*;
import java.util.*;

public class Main {
    static BufferedReader in;
    static StringBuilder out = new StringBuilder();
    static StringTokenizer tok;
    
    static int nextInt() throws IOException {
        while (tok == null || !tok.hasMoreTokens()) {
            String line = in.readLine();
            if (line == null) return -1;
            tok = new StringTokenizer(line);
        }
        return Integer.parseInt(tok.nextToken());
    }
    
    public static void main(String[] args) throws IOException {
        in = new BufferedReader(new InputStreamReader(System.in));
        int t = nextInt();
        while (t-- > 0) {
            int n = nextInt(), q = nextInt();
            int[] a = new int[n];
            int maxVal = 0;
            for (int i = 0; i < n; i++) {
                a[i] = nextInt();
                if (a[i] > maxVal) maxVal = a[i];
            }
            // median position m = (n+2)/2  (1-based)
            int m = (n + 2) >> 1;
            
            // Build frequency of original a[i], and prefix-sum pf[]
            int[] freq = new int[maxVal + 1];
            for (int v : a) freq[v]++;
            int[] pf = new int[maxVal + 1];
            pf[0] = freq[0];
            for (int i = 1; i <= maxVal; i++) {
                pf[i] = pf[i - 1] + freq[i];
            }
            // If x > maxVal, the array mod x is just the original array,
            // so its median is the original median.  We read it off pf[].
            int originalMedian = 0;
            for (int i = 0; i <= maxVal; i++) {
                if (pf[i] >= m) {
                    originalMedian = i;
                    break;
                }
            }
            
            // We'll cache answers in ans[x], -1 meaning "not yet computed"
            int[] ans = new int[n + 1];
            Arrays.fill(ans, -1);
            
            // Precompute for small x <= B by direct counting a_i % x
            // B = ~ sqrt(maxVal)
            int B = (int)Math.sqrt(maxVal) + 1;
            if (B > n) B = n;  // no need to exceed n
            for (int x = 1; x <= B; x++) {
                int[] cnt = new int[x];
                for (int v : a) {
                    cnt[v % x]++;
                }
                int sum = 0;
                for (int r = 0; r < x; r++) {
                    sum += cnt[r];
                    if (sum >= m) {
                        ans[x] = r;
                        break;
                    }
                }
            }
            
            // Helper to compute S_x(v) = # of i with (a_i mod x) <= v
            // in O(maxVal/x) by using pf[]
            class Checker {
                int x;
                Checker(int x) { this.x = x; }
                // return true if S_x(v) >= m
                boolean ok(int v) {
                    int sum = 0;
                    for (int k = 0; ; k++) {
                        int L = k * x;
                        if (L > maxVal) break;
                        int R = L + v;
                        if (R > maxVal) R = maxVal;
                        if (L == 0)
                            sum += pf[R];
                        else
                            sum += pf[R] - pf[L - 1];
                        if (sum >= m) return true;
                    }
                    return false;
                }
            }
            
            // Process queries
            while (q-- > 0) {
                int x = nextInt();
                if (x <= B) {
                    // precomputed
                    out.append(ans[x]).append(' ');
                } else if (x > maxVal) {
                    // trivial: same as original median
                    out.append(originalMedian).append(' ');
                } else {
                    // we may need to binary-search the remainder
                    if (ans[x] == -1) {
                        Checker c = new Checker(x);
                        int lo = 0, hi = x - 1;
                        while (lo < hi) {
                            int mid = (lo + hi) >> 1;
                            if (c.ok(mid)) hi = mid;
                            else lo = mid + 1;
                        }
                        ans[x] = lo;
                    }
                    out.append(ans[x]).append(' ');
                }
            }
            out.append('\n');
        }
        System.out.print(out);
    }
}
```

**Explanation of Key Steps**

1. **Remainder‐view**.  After all reductions by multiples of \(x\), the final array is exactly \(\{\,a_i\bmod x\}\).  The median of that is the answer.
2. **Prefix sums**.  We build `pf[v] =` number of original elements \(\le v\).  That lets us count how many lie in any interval \([L,R]\) in \(O(1)\) as `pf[R] - pf[L-1]`.
3. **Small \(x\le B\)**.  We do one pass over the \(n\) elements, increment `cnt[a[i]%x]` for \(i=1..n\), then scan the small array `cnt[0..x-1]` to find the \(m\)-th remainder.  Total cost over all small \(x\) is
   \[
     O\Bigl(\sum_{x\le B}n\Bigr)\;=\;O(n\,B)\approx O(n\sqrt n).
   \]
4. **Large \(x\!>\!B\)**.  Now \(\lfloor\max a/x\rfloor=O(n/x)\le O(\sqrt n)\).  We binary‐search the remainder \(v\in[0,x-1]\).  Each “check” sums up to \(O(n/x)\) blocks via the prefix sums, so in \(O(\log n\cdot n/x)\).  But we do that at most once per distinct \(x\), and
   \(\sum_{x>B}n/x=O(n\ln n)\). 
5. **If \(x>\max a\)** all reductions are impossible (every \(a_i<x\)), so the remainders are just the original numbers and the median is the original median (obtained in \(O(\max a)\) from `pf[]`).

This combined strategy runs well under 1 s for \(\sum n,\sum q\le10^5\).