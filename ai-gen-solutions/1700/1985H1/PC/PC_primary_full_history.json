[
  {
    "role": "user",
    "content": "H1. Maximize the Largest Component (Easy Version)\n\ntime limit per test2 seconds\n\nmemory limit per test512 megabytes\n\nEasy and hard versions are actually different problems, so read statements of both problems completely and carefully. The only difference between the two versions is the operation.\n\n\n\nAlex has a grid with n\n\n rows and m\n\n columns consisting of '.' and '#' characters. A set of '#' cells forms a connected component if from any cell in this set, it is possible to reach any other cell in this set by only moving to another cell in the set that shares a common side. The size of a connected component is the number of cells in the set.\n\n\n\nIn one operation, Alex selects any row r\n\n (1≤r≤n\n\n) or any column c\n\n (1≤c≤m\n\n), then sets every cell in row r\n\n or column c\n\n to be '#'. Help Alex find the maximum possible size of the largest connected component of '#' cells that he can achieve after performing the operation at most once.\n\n\n\nInput\n\nThe first line of the input contains a single integer t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nThe first line of each test case contains two integers n\n\n and m\n\n (1≤n⋅m≤106\n\n) — the number of rows and columns of the grid.\n\n\n\nThe next n\n\n lines each contain m\n\n characters. Each character is either '.' or '#'.\n\n\n\nIt is guaranteed that the sum of n⋅m\n\n over all test cases does not exceed 106\n\n.\n\n\n\nOutput\n\nFor each test case, output a single integer — the maximum possible size of a connected component of '#' cells that Alex can achieve.\n\n\n\nExample\n\nInputCopy\n\n6\n\n1 1\n\n.\n\n4 2\n\n..\n\n#.\n\n#.\n\n.#\n\n3 5\n\n.#.#.\n\n..#..\n\n.#.#.\n\n5 5\n\n#...#\n\n....#\n\n#...#\n\n.....\n\n...##\n\n6 6\n\n.#..#.\n\n#..#..\n\n.#...#\n\n#.#.#.\n\n.#.##.\n\n###..#\n\n6 8\n\n..#....#\n\n.####.#.\n\n###.#..#\n\n.##.#.##\n\n.#.##.##\n\n#..##.#.\n\nOutputCopy\n\n1\n\n6\n\n9\n\n11\n\n15\n\n30\n\nNote\n\nIn the second test case, it is optimal for Alex to set all cells in column 2\n\n to be '#'. Doing so will lead to the largest connected component of '#' having a size of 6\n\n.\n\n\n\nIn the third test case, it is optimal for Alex to set all cells in row 2\n\n to be '#'. Doing so will lead to the largest connected component of '#' having a size of 9\n\n.\n\n\n\nIn the fourth test case, it is optimal for Alex to set all cells in row 4\n\n to be '#'. Doing so will lead to the largest connected component of '#' having a size of 11\n\n.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have an \\(n\\times m\\) grid of `.` and `#`.  A connected component of `#`‐cells is the usual 4‐neighbor connectivity, and its size is the number of `#`‐cells in it.\n\nWe are allowed at most one operation: pick a row or a column and turn *all* its cells into `#`.  After that operation (or doing nothing), we want the size of the largest connected component of `#`‐cells.\n\nLet us call the original largest component size \\(M_0\\).  Then we compare three possibilities:\n\n1.  **No operation** → answer = \\(M_0\\).\n\n2.  **Fill some row \\(r\\)**.  \n    After filling row \\(r\\), that row becomes entirely `#` (contributing \\(m\\) cells).  It will connect to any original components that touch that row (either by overlapping it originally, or by being right above or below it).  By connecting we absorb *all* of each such original component.  \n    One must be careful not to double–count cells of components that already lay partly in row \\(r\\).  \n\n    A clean way to see the new merged component size is:\n    \n    \\[\n      \\bigl|\\{\\text{cells in row }r\\}\\bigr|\n      \\;+\\;\n      \\bigl|\\{\\text{all cells of the original components that touch row }r\\}\\bigr|\n      \\;-\\;\n      \\bigl|\\{\\text{old `#' cells in row }r\\}\\bigr|.\n    \\]\n    \n    But \\(|\\{\\text{cells in row }r\\}| = m\\), and \\(|\\{\\text{old `#' in row }r\\}|=\\) the count of `#' in row \\(r\\).  \n    So if we let\n      - \\(\\mathrm{origHashRow}[r]\\) = number of `#' in row \\(r\\),\n      - \\(\\mathcal C(r)\\) = the set of indices of *all* original components that have at least one cell in row \\(r-1\\), \\(r\\), or \\(r+1\\),\n      - \\(\\mathrm{size}[c]\\) = size of component \\(c\\),  \n    then the merged size by filling row \\(r\\) is\n    \\[\n      m \\;-\\;\\mathrm{origHashRow}[r]\\;+\\;\\sum_{c\\in \\mathcal C(r)}\\mathrm{size}[c].\n    \\]\n    We compute that for every \\(r\\).\n\n3.  **Fill some column \\(c\\)** similarly gives\n    \\[\n      n\\;-\\;\\mathrm{origHashCol}[c]\\;+\\;\\sum_{c\\in \\mathcal D(c)}\\mathrm{size}[c],\n    \\]\n    where \\(\\mathrm{origHashCol}[c]\\) = number of `#' in column \\(c\\), and \\(\\mathcal D(c)\\) = set of original components touching column \\(c-1\\), \\(c\\), or \\(c+1\\).\n\nWe take the maximum of\n\\[\n  M_0,\\quad\n  \\max_{0\\le r<n}\\bigl[m - \\mathrm{origHashRow}[r] + \\sum_{c\\in\\mathcal C(r)}\\mathrm{size}[c]\\bigr],\n  \\quad\n  \\max_{0\\le c<m}\\bigl[n - \\mathrm{origHashCol}[c] + \\sum_{c\\in\\mathcal D(c)}\\mathrm{size}[c]\\bigr].\n\\]\n\nImplementation details:\n\n-  First, we label every original `#`‐component by a single integer id (0,1,2,…), via a BFS over all `#` cells.  We store in an array `comp[i]` the component‐id of cell index `i`, or −1 if it was `.`.\n\n-  While labeling each component we record its size in an array `compSize[id]`.  We also keep track of `origHashRow[r]` and `origHashCol[c]` simply by counting `#`s in each row/column as we read the grid.\n\n-  After labeling, let `M0 =` the maximum over all `compSize[id]`.\n\n-  To compute the row‐fill merges efficiently, we do the following for each row `r`:\n\n   1.  We want to sum `compSize[id]` over all *distinct* component‐ids appearing in rows `r-1`, `r`, or `r+1`.  \n   2.  We scan those three rows cell by cell.  Whenever we see a `#` whose component‐id is `cid`, we add `compSize[cid]` *once* into our running sum, using a small “last‐seen” array to ensure we do not double‐count the same `cid`.  \n   3.  After gathering that sum, we compute\n      \\[\n        \\mathrm{mergeRow}(r)= \n        m - \\mathrm{origHashRow}[r] \\;+\\;\\bigl(\\text{summed component sizes}\\bigr).\n      \\]\n   4.  We take the maximum over all `r`.\n\n-  We do an entirely analogous pass over columns.\n\n-  Finally, the answer for the test case is\n  \\[\n    \\max\\bigl(M_0,\\;\\max_r\\mathrm{mergeRow}(r),\\;\\max_c\\mathrm{mergeCol}(c)\\bigr).\n  \\]\n\nEach test runs in \\(O(nm)\\):  \n  - one BFS pass to label components,  \n  - one pass to count `#` per row/column,  \n  - one \\(O(n\\cdot 3m)\\) scan for row‐fills,  \n  - one \\(O(m\\cdot 3n)\\) scan for column‐fills.  \n\nSince the sum of \\(n\\!\\times\\!m\\) over all tests is up to \\(10^6\\), this easily fits in time.\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        int t = Integer.parseInt(br.readLine().trim());\n        while (t-- > 0) {\n            String[] nm = br.readLine().trim().split(\" \");\n            int n = Integer.parseInt(nm[0]);\n            int m = Integer.parseInt(nm[1]);\n            int N = n * m;\n\n            // Read grid into a flat array\n            char[] grid = new char[N];\n            int[] origHashRow = new int[n];\n            int[] origHashCol = new int[m];\n            for (int i = 0; i < n; i++) {\n                String line = br.readLine();\n                for (int j = 0; j < m; j++) {\n                    char c = line.charAt(j);\n                    grid[i*m + j] = c;\n                    if (c == '#') {\n                        origHashRow[i]++;\n                        origHashCol[j]++;\n                    }\n                }\n            }\n\n            // comp[idx] = component-id of cell idx, or -1 if '.'\n            int[] comp = new int[N];\n            Arrays.fill(comp, -1);\n\n            // We will store sizes of each component in compSize[]\n            // We don't yet know how many components, but at most N.\n            int[] compSize = new int[N];\n            int compCount = 0;\n            int initialMax = 0;\n\n            // BFS queue\n            int[] queue = new int[N];\n\n            // Label components by BFS\n            for (int start = 0; start < N; start++) {\n                if (grid[start] == '#' && comp[start] < 0) {\n                    // New component\n                    int head = 0, tail = 0;\n                    queue[tail++] = start;\n                    comp[start] = compCount;\n                    int sizeC = 1;\n\n                    while (head < tail) {\n                        int cur = queue[head++];\n                        int r = cur / m, c = cur % m;\n\n                        // Up\n                        if (r > 0) {\n                            int nb = cur - m;\n                            if (grid[nb] == '#' && comp[nb] < 0) {\n                                comp[nb] = compCount;\n                                queue[tail++] = nb;\n                                sizeC++;\n                            }\n                        }\n                        // Down\n                        if (r < n - 1) {\n                            int nb = cur + m;\n                            if (grid[nb] == '#' && comp[nb] < 0) {\n                                comp[nb] = compCount;\n                                queue[tail++] = nb;\n                                sizeC++;\n                            }\n                        }\n                        // Left\n                        if (c > 0) {\n                            int nb = cur - 1;\n                            if (grid[nb] == '#' && comp[nb] < 0) {\n                                comp[nb] = compCount;\n                                queue[tail++] = nb;\n                                sizeC++;\n                            }\n                        }\n                        // Right\n                        if (c < m - 1) {\n                            int nb = cur + 1;\n                            if (grid[nb] == '#' && comp[nb] < 0) {\n                                comp[nb] = compCount;\n                                queue[tail++] = nb;\n                                sizeC++;\n                            }\n                        }\n                    }\n\n                    compSize[compCount] = sizeC;\n                    if (sizeC > initialMax) {\n                        initialMax = sizeC;\n                    }\n                    compCount++;\n                }\n            }\n\n            // lastSeen[cid] helps us sum each component-size at most once per row/column pass\n            int[] lastSeen = new int[compCount];\n            int stamp = 1;\n            int answer = initialMax;\n\n            // Try filling each row r\n            for (int r = 0; r < n; r++) {\n                stamp++;\n                int sumSizes = 0;\n                // look at rows r-1, r, r+1\n                for (int dr = -1; dr <= 1; dr++) {\n                    int rr = r + dr;\n                    if (rr < 0 || rr >= n) continue;\n                    int base = rr * m;\n                    for (int j = 0; j < m; j++) {\n                        int idx = base + j;\n                        int cid = comp[idx];\n                        if (cid >= 0 && lastSeen[cid] != stamp) {\n                            lastSeen[cid] = stamp;\n                            sumSizes += compSize[cid];\n                        }\n                    }\n                }\n                int merged = m - origHashRow[r] + sumSizes;\n                if (merged > answer) answer = merged;\n            }\n\n            // Try filling each column c\n            for (int c = 0; c < m; c++) {\n                stamp++;\n                int sumSizes = 0;\n                // look at columns c-1, c, c+1\n                for (int dc = -1; dc <= 1; dc++) {\n                    int cc = c + dc;\n                    if (cc < 0 || cc >= m) continue;\n                    for (int i = 0; i < n; i++) {\n                        int idx = i*m + cc;\n                        int cid = comp[idx];\n                        if (cid >= 0 && lastSeen[cid] != stamp) {\n                            lastSeen[cid] = stamp;\n                            sumSizes += compSize[cid];\n                        }\n                    }\n                }\n                int merged = n - origHashCol[c] + sumSizes;\n                if (merged > answer) answer = merged;\n            }\n\n            out.println(answer);\n        }\n\n        out.flush();\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Component–labelling**  \n   We scan the entire grid and whenever we see an unvisited `#` we start a BFS, marking all reachable `#`‐cells with the same component‐id and counting their number.  This lets us later refer to each component by a small integer \\(0\\ldots(\\text{compCount}-1)\\) and know its size in \\(O(1)\\).\n\n2. **Initial maximum**  \n   As we label each component we track the maximum size seen so far.  This covers the “no operation” answer.\n\n3. **Row/Column fills**  \n   When we fill row \\(r\\), we add \\(m\\) new `#`‐cells.  We must also absorb every original component that is *adjacent* to the filled row—i.e.\\ any component having a cell in row \\(r\\), or row \\(r-1\\), or row \\(r+1\\).  We sum their sizes but must *not* double–count the same component if it appears more than once.  We do a quick “lastSeen” trick: for each component‐id we keep a small array `lastSeen` of length = number of components; every time we start filling a new row we increment a global `stamp`, and whenever we first see a component‐id in our scan we check if `lastSeen[id] != stamp`; if so, we add its size and write `lastSeen[id] = stamp`.  That way each component contributes only once.\n\n4.  Finally, we do the exact same logic for columns, and take the global maximum of all three cases.\n\nOverall time per test is \\(O(nm)\\), which is fine because the sum of \\(n\\!\\times\\!m\\) over all tests is up to \\(10^6\\)."
  }
]