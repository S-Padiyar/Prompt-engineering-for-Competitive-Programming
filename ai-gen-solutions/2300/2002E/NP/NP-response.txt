**Analysis**

We have a RLE‐(run‐length encoded) description of a (conceptually huge) array of integers.  We process it run‐by‐run, and after we have processed the first _k_ runs, we ask:

  “If one applies the “cosmic‐ray” deletion rule to the fully expanded array (runs 1.._k_ concatenated), how many seconds until it becomes empty?”

The deletion rule says that at each second we delete all elements in positions  
1) the very first element of the current array, and  
2) every element whose value differs from its left neighbor.

One can show (by a careful “merge‐gap” argument) that the total time to delete everything is

   max_{value v} (T_v)

where for each distinct value _v_, T_v is the time at which the last _v_‐element disappears, under the same process, looking only at the sub‐array of runs of value _v_ interspersed by other runs.

A beautiful observation (and the crux of the official editorial solution) is that we can compute, for each run _i_, a small DP value

   dp[i] = “the deletion‐time contribution coming from run i merges”,

and then

   ans[k] = max_{0 ≤ i < k} dp[i]

is precisely the desired strength of the prefix of length _k_.

Concretely, let run _i_ have length _a[i]_ and value _b[i]_.  We keep

 1) A segment‐tree (or sparse table) over the _a_[] array so that we can answer

        M = max_{j = j0+1 .. i−1}  a[j]

    in O(log n) time (or O(1) with a sparse table).

 2) An array  last[v]  which remembers the index of the last run of value _v_ we have seen.

We then define

   dp[i] = a[i]  
   if last[b[i]] = j ≠ −1 then
     let  M = max(a[j+1..i−1])  (zero if the range is empty).
     if  a[j] > M  and  a[i] > M  
       “both blocks are big enough to survive until the gap between them has entirely deleted”  
     then
       dp[i] ← dp[j] + (a[i] − M)
   // else dp[i] stays = a[i]

Finally we keep

   ans[i] = max( ans[i−1], dp[i] ),

and ans[i] is our answer for the first i runs.

This runs in O(n log n) per test (n = number of runs), which is fine for ∑n ≤ 3×10^5.

---

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out);

        int T = Integer.parseInt(br.readLine().trim());
        while (T-- > 0) {
            int n = Integer.parseInt(br.readLine().trim());
            long[] a = new long[n];
            int[] b = new int[n];
            for (int i = 0; i < n; i++) {
                StringTokenizer st = new StringTokenizer(br.readLine());
                a[i] = Long.parseLong(st.nextToken());
                b[i] = Integer.parseInt(st.nextToken());
            }

            // Build a segment tree for range‐maximum queries over a[]
            SegmentTree seg = new SegmentTree(a);

            long[] dp = new long[n];
            long[] ans = new long[n];

            // last[v] = last index where value v appeared, or -1 if none
            // b[i] <= n by problem statement, so we size n+1.
            int[] last = new int[n+1];
            Arrays.fill(last, -1);

            long currentMax = 0;
            for (int i = 0; i < n; i++) {
                // start dp[i] = a[i]
                long best = a[i];
                int v = b[i];
                int j = last[v];
                if (j != -1) {
                    // query the maximum a[k] for k in [j+1..i-1]
                    long gapMax = 0L;
                    if (j + 1 <= i - 1) {
                        gapMax = seg.rangeMax(j + 1, i - 1);
                    }
                    // can the two runs merge?  They both must survive until the gap is gone
                    if (a[j] > gapMax && a[i] > gapMax) {
                        long candidate = dp[j] + (a[i] - gapMax);
                        if (candidate > best) {
                            best = candidate;
                        }
                    }
                }
                dp[i] = best;
                // answer so far
                currentMax = Math.max(currentMax, dp[i]);
                ans[i] = currentMax;
                // remember this run of value v
                last[v] = i;
            }

            // output answers for prefixes 1..n
            for (int i = 0; i < n; i++) {
                out.print(ans[i]);
                out.print(i+1 < n ? ' ' : '\n');
            }
        }

        out.flush();
    }

    // A simple iterative segment tree for range‐maximum on a static array.
    static class SegmentTree {
        int n;
        long[] tree;

        // Build from array arr[0..n-1]
        SegmentTree(long[] arr) {
            int sz = arr.length;
            n = 1;
            while (n < sz) n <<= 1;
            tree = new long[2 * n];
            // initialize leaves
            for (int i = 0; i < sz; i++) {
                tree[n + i] = arr[i];
            }
            for (int i = sz; i < n; i++) {
                tree[n + i] = 0L;  // neutral for max
            }
            // build internal nodes
            for (int i = n - 1; i > 0; i--) {
                tree[i] = Math.max(tree[2 * i], tree[2 * i + 1]);
            }
        }

        // range‐max on [l..r], 0‐based inclusive
        long rangeMax(int l, int r) {
            long res = 0L; // neutral for max (all a[i] ≥ 1)
            l += n;
            r += n;
            while (l <= r) {
                if ((l & 1) == 1) {
                    res = Math.max(res, tree[l++]);
                }
                if ((r & 1) == 0) {
                    res = Math.max(res, tree[r--]);
                }
                l >>= 1;
                r >>= 1;
            }
            return res;
        }
    }
}
```

**Explanation of the DP**

-  We keep `dp[i]` as the best “merged‐length contribution” coming from run _i_ of length `a[i]` and value `b[i]`.

-  Initially `dp[i] = a[i]` (just itself, no merge).

-  If this value `b[i]` has appeared before at run `j = last[b[i]]`, we look at the _largest_ run‐length in the gap `(j+1..i-1)`:
     `gapMax = max(a[j+1..i−1])`.
  For the two runs at `j` and `i` to actually be able to merge in the cosmic‐ray process,
  each must “survive” until all the intervening runs have fully deleted.  Since each run shrinks
  by exactly 1 per second (it loses its “first” element each second until its length hits 0),
  a run of initial length `L` disappears after exactly `L` seconds if it never merges.  Hence both
  must have > `gapMax` length, otherwise one of them would vanish before the gap finishes.

-  If `a[j] > gapMax` and `a[i] > gapMax`, they _will_ merge (at time = `gapMax`), and the
  new merged run inherits all previously‐merged length from run _j_ plus the extra from run _i_,
  minus the time we “wasted” deleting the first `gapMax` elements on both sides:

     `dp[i] = dp[j] + (a[i] - gapMax).`

  Here `dp[j]` already contains any chain of merges that run _j_ took part in.

-  Finally we keep `ans[i] = max(ans[i−1], dp[i])`.  This `ans[i]` is exactly the total number
  of seconds until the first _i_ runs are completely erased by the cosmic‐ray rule.

This runs in O(n log n) per test by using a segment tree (or sparse‐table) for the range‐maximum queries over `a[]`.  Since the total of all _n_ in the input is ≤ 3·10^5, it easily meets the time limits.