**Analysis**

We have \(n\) card‐types labeled \(1,2,\dots,n\).  Alice starts with card 1 and wants to end up with card \(n\).  There are three other players–Queen, King, Jack–each of whom holds one of each card \(1\ldots n\).  We are given for each player a “preference” array \(p\) of length \(n\), where \(p[x]\) is that player’s *value* or *utility* of card \(x\).  A higher \(p[x]\) means that player values card \(x\) more.

A legal trade with a player \(P\) works like this:

– Alice offers them a card \(a\) (the one she currently holds) and receives a card \(b\).  
– The player \(P\) will agree if they value \(a\) *more* than \(b\); i.e.\ \(p[a] > p[b]\).  In that case they trade away their copy of \(b\).  
– Alice will agree only if she values \(b\) *more* than \(a\); since Alice’s value is just the label itself, she requires \(b > a\).

Hence from Alice’s current card \(c\) she can move to card \(b\) via player \(P\) precisely when

1. \(b > c\), and  
2. \(p_P[c] > p_P[b]\).

We want to see if there is a path from \(1\) to \(n\) in this directed graph.  If there is, we also have to output one such path (sequence of trades).

A straightforward way to do a BFS on this graph would be \(\mathcal{O}(n^2)\) in the worst case (because each node \(c\) could have \(\Theta(n)\) outgoing edges).  But \(n\) can be up to \(2\times 10^5\).  

We exploit the fact that all edges go from smaller–labeled nodes to larger–labeled nodes (\(b>c\)), and we only add each node \(b\) once to the BFS queue (the first time we discover it).  Thus each of the \(n\) nodes enters the queue exactly once, and each node is “removed” so that no later search tries to visit it again.  

To find efficiently, for a given \(c\) and a given player \(P\), all \(b>c\) with \(p_P[b] < p_P[c]\), we keep a segment tree over the indices \(1\ldots n\).  At position \(b\), it stores the value \(p_P[b]\) if \(b\) is not yet visited, or \(+\infty\) if \(b\) is already removed/visited.  Then:

– In \(\log n\) time we can query the minimum value of \(p_P\) over the range \([c+1,\,n]\).  
– If that minimum is \(\ge p_P[c]\), there are no more \(b\) in \([c+1,n]\) with \(p_P[b]<p_P[c]\).  
– Otherwise we can in another \(\log n\) time descend the tree and find some such index \(b\) with \(p_P[b]<p_P[c]\).  

Each time we find such a \(b\), we mark it visited, remove it from *all* three players’ segment trees (so we never visit it a second time), record \(\text{parent}[b]=(c,P)\), and push \(b\) into the BFS queue.  

Since each node is discovered and removed exactly once, the total number of segment‐tree removals is \(3n\), and the total number of “find‐and‐remove” steps is also \(\le 3n\).  Each such step costs \(\mathcal{O}(\log n)\).  Thus the total is \(\mathcal{O}(n\log n)\), which is fine for \(n\) up to \(2\cdot10^5\).

Finally, if we have reached \(n\), we reconstruct the path by following the recorded parents back to \(1\).  If we never reached \(n\), we print “NO”.

**Implementation in Java**

```java
import java.io.*;
import java.util.*;

public class Main {
    static final int INF = Integer.MAX_VALUE;
    static class SegTree {
        int n;
        int[] st;  // segment tree array for minimums

        public SegTree(int n) {
            this.n = n;
            // Safe size: 4*n
            st = new int[4 * n + 4];
        }

        // Build the tree with initial values a[1..n].
        void build(int[] a) {
            build(1, 1, n, a);
        }
        private void build(int node, int l, int r, int[] a) {
            if (l == r) {
                st[node] = a[l];
            } else {
                int mid = (l + r) >>> 1;
                build(node<<1,     l,   mid, a);
                build(node<<1 | 1, mid+1, r,   a);
                st[node] = Math.min(st[node<<1], st[node<<1|1]);
            }
        }

        // Point update: set position pos to value v
        void update(int pos, int v) {
            update(1, 1, n, pos, v);
        }
        private void update(int node, int l, int r, int pos, int v) {
            if (l == r) {
                st[node] = v;
            } else {
                int mid = (l + r) >>> 1;
                if (pos <= mid) update(node<<1, l, mid, pos, v);
                else            update(node<<1|1, mid+1, r, pos, v);
                st[node] = Math.min(st[node<<1], st[node<<1|1]);
            }
        }

        // Query min on interval [ql..qr]
        int queryMin(int ql, int qr) {
            return queryMin(1, 1, n, ql, qr);
        }
        private int queryMin(int node, int l, int r, int ql, int qr) {
            if (qr < l || r < ql) return INF;
            if (ql <= l && r <= qr) return st[node];
            int mid = (l + r) >>> 1;
            return Math.min(
                queryMin(node<<1,     l,   mid, ql, qr),
                queryMin(node<<1 | 1, mid+1, r,   ql, qr)
            );
        }

        // Find *any* index in [ql..qr] whose value < target.
        // If none, return -1.
        int findFirstLess(int ql, int qr, int target) {
            return findFirstLess(1, 1, n, ql, qr, target);
        }
        private int findFirstLess(int node, int l, int r, int ql, int qr, int target) {
            if (qr < l || r < ql || st[node] >= target) {
                return -1;
            }
            if (l == r) {
                // Leaf and st[node] < target
                return l;
            }
            int mid = (l + r) >>> 1;
            int res = findFirstLess(node<<1, l, mid, ql, qr, target);
            if (res != -1) return res;
            return findFirstLess(node<<1|1, mid+1, r, ql, qr, target);
        }
    }

    public static void main(String[] args) throws IOException {
        FastReader fr = new FastReader();
        PrintWriter out = new PrintWriter(System.out);

        int T = fr.nextInt();
        while (T-- > 0) {
            int n = fr.nextInt();
            // Read the three preference arrays for Queen, King, Jack
            int[][] pref = new int[3][n+1];
            for (int p = 0; p < 3; p++) {
                for (int i = 1; i <= n; i++) {
                    pref[p][i] = fr.nextInt();
                }
            }

            // Build three segment trees, one per player
            SegTree[] seg = new SegTree[3];
            for (int p = 0; p < 3; p++) {
                seg[p] = new SegTree(n);
                seg[p].build(pref[p]);
            }

            // BFS state
            boolean[] visited = new boolean[n+1];
            // parent[v] = (previous node, which player used)
            int[][] parent = new int[n+1][2];

            // Start BFS from node 1
            Deque<Integer> dq = new ArrayDeque<>();
            visited[1] = true;
            dq.addLast(1);

            // We never need node '1' in any segment tree, so we can remove it right away
            // (Optional since we only search b>c).
            for (int p = 0; p < 3; p++) {
                seg[p].update(1, INF);
            }

            while (!dq.isEmpty()) {
                int c = dq.pollFirst();
                // For each player p = 0(Q),1(K),2(J)
                for (int p = 0; p < 3; p++) {
                    // We can only move to b>c with pref[p][b] < pref[p][c]
                    while (true) {
                        // What's the minimum preference value in [c+1..n]?
                        if (c+1 > n) break;
                        int mn = seg[p].queryMin(c+1, n);
                        if (mn >= pref[p][c]) {
                            // no more b satisfy pref[b] < pref[c]
                            break;
                        }
                        // find some b
                        int b = seg[p].findFirstLess(c+1, n, pref[p][c]);
                        // mark b visited and remove from all three trees
                        visited[b] = true;
                        parent[b][0] = c;
                        parent[b][1] = p;
                        for (int pp = 0; pp < 3; pp++) {
                            seg[pp].update(b, INF);
                        }
                        dq.addLast(b);
                    }
                }
            }

            if (!visited[n]) {
                out.println("NO");
            } else {
                out.println("YES");
                // Reconstruct path by tracing parents from n back to 1
                List<String> moves = new ArrayList<>();
                int cur = n;
                char[] who = {'q','k','j'};
                while (cur != 1) {
                    int par = parent[cur][0];
                    int p   = parent[cur][1];
                    moves.add(who[p] + " " + cur);
                    cur = par;
                }
                Collections.reverse(moves);
                out.println(moves.size());
                for (String mv : moves) {
                    out.println(mv);
                }
            }
        }
        out.flush();
    }

    // Fast IO
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;
        FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }
        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    String line = br.readLine();
                    if (line == null) return null;
                    st = new StringTokenizer(line);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        int nextInt() {
            return Integer.parseInt(next());
        }
    }
}
```

**Explanation of Key Steps**

1. **Modeling trades as directed edges**  
   From a card \(c\) Alice can move to \(b\) using player \(P\) precisely when  
   - \(b>c\) (Alice only trades upward in her own preference), and  
   - \(p_P[c]>p_P[b]\) (player \(P\) values \(c\) more than \(b\), so they will give away \(b\)).  

2. **BFS in a DAG**  
   Since all edges go \(c\to b\) with \(b>c\), the graph is acyclic and only goes “upwards”.  We start a BFS from node \(1\).  Once we visit a node \(b\), we never visit it again.

3. **Segment trees to enumerate edges in \(\log n\)**  
   For each player \(P\), we keep a segment tree over \(\{1,\dots,n\}\).  At position \(b\) it stores  
   \[
     \begin{cases}
       p_P[b], & \text{if }b\text{ not yet visited},\\
       +\infty, & \text{if }b\text{ is visited}.
     \end{cases}
   \]
   When handling current node \(c\) in the BFS, we want *all* \(b\in[c+1..n]\) with \(p_P[b] < p_P[c]\).  We:

   - Query the minimum value in \([c+1..n]\).  If it’s \(\ge p_P[c]\), we’re done for that player.  
   - Otherwise we locate one index \(b\) whose value is below \(p_P[c]\) (still \(\log n\) time).  
   - Remove \(b\) (set its value to \(\infty\) in all 3 trees), record its parent pointer \((c,P)\), and enqueue it.  

   Since each node is enqueued exactly once and removed from the trees exactly once, the total complexity is 
   \[
     O\bigl(3n \cdot \log n\bigr) \;=\; O\bigl(n\log n\bigr),
   \]
   which easily handles \(n\) up to \(2\times 10^5\).

4. **Reconstructing the path**  
   Once BFS finishes, if we have visited \(n\), we follow the recorded parents back from \(n\) to \(1\), reverse the sequence, and print the trades.  Each trade line is of the form  
   \[
     \langle \text{player-char}\rangle\;\langle \text{card-received}\rangle,
   \]
   where player‐char is ‘q’,‘k’, or ‘j’.

This solution runs in \(O(n\log n)\) per test and supports up to \(\sum n \le 2\times 10^5\), as required.