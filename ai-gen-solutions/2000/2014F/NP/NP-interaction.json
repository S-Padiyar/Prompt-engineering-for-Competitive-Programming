[
    {
        "request_timestamp": "2025-07-23T18:31:09.338923",
        "response_timestamp": "2025-07-23T18:32:23.709343",
        "sent_messages": [
            {
                "role": "user",
                "content": "Codeforces Problem:\n\nF. Sheriff's Defense\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\n\"Why, master,\" quoth Little John, taking the bags and weighing them in his hand, \"here is the chink of gold.\"\n\nThe folk hero Robin Hood has been troubling Sheriff of Nottingham greatly. Sheriff knows that Robin Hood is about to attack his camps and he wants to be prepared.\n\n\n\nSheriff of Nottingham built the camps with strategy in mind and thus there are exactly n\n\n camps numbered from 1\n\n to n\n\n and n−1\n\n trails, each connecting two camps. Any camp can be reached from any other camp. Each camp i\n\n has initially ai\n\n gold.\n\n\n\nAs it is now, all camps would be destroyed by Robin. Sheriff can strengthen a camp by subtracting exactly c\n\n gold from each of its neighboring camps and use it to build better defenses for that camp. Strengthening a camp doesn't change its gold, only its neighbors' gold. A camp can have negative gold.\n\n\n\nAfter Robin Hood's attack, all camps that have been strengthened survive the attack, all others are destroyed.\n\n\n\nWhat's the maximum gold Sheriff can keep in his surviving camps after Robin Hood's attack if he strengthens his camps optimally?\n\n\n\nCamp a\n\n is neighboring camp b\n\n if and only if there exists a trail connecting a\n\n and b\n\n. Only strengthened camps count towards the answer, as others are destroyed.\n\n\n\nInput\n\nThe first line contains a single integer t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nEach test case begins with two integers n\n\n, c\n\n (1≤n≤2⋅105,1≤c≤109\n\n) — the number of camps and the gold taken from each neighboring camp for strengthening.\n\n\n\nThe second line of each test case contains n\n\n integers a1,a2,…,an\n\n (−109≤ai≤109\n\n) — the initial gold of each camp.\n\n\n\nThen follow n−1\n\n lines, each with integers u\n\n, v\n\n (1≤u,v≤n\n\n, u≠v\n\n) — meaning that there is a trail between u\n\n and v\n\n.\n\n\n\nThe sum of n\n\n over all test cases doesn't exceed 2⋅105\n\n.\n\n\n\nIt is guaranteed that any camp is reachable from any other camp.\n\n\n\nOutput\n\nOutput a single integer, the maximum gold Sheriff of Nottingham can keep in his surviving camps after Robin Hood's attack.\n\n\n\nExample\n\nInputCopy\n\n5\n\n3 1\n\n2 3 1\n\n1 2\n\n2 3\n\n3 1\n\n3 6 3\n\n1 2\n\n2 3\n\n3 1\n\n-2 -3 -1\n\n1 2\n\n2 3\n\n6 1\n\n5 -4 3 6 7 3\n\n4 1\n\n5 1\n\n3 5\n\n3 6\n\n1 2\n\n8 1\n\n3 5 2 7 8 5 -3 -4\n\n7 3\n\n1 8\n\n4 3\n\n3 5\n\n7 6\n\n8 7\n\n2 1\n\nOutputCopy\n\n3\n\n8\n\n0\n\n17\n\n26\n\nNote\n\nIn the first test case, it is optimal to strengthen the second base. The final gold at each base is [1,3,0]\n\n.\n\n\n\nIn the second test case, it is optimal to strengthen all bases. The final gold at each base is [2,4,2]\n\n.\n\n\n\nIn the third test case, it is optimal to not strengthen any base.\n\n---\n\nUse Java."
            }
        ],
        "received_response": "{\n  \"id\": \"chatcmpl-BwcHNF0h9UP4gh9ILgVjq1XYPnGWg\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"**Analysis**\\n\\nWe have a tree of \\\\(n\\\\) camps (nodes) connected by \\\\(n-1\\\\) edges.  Each camp \\\\(i\\\\) has initial gold \\\\(a_i\\\\).  We may choose any subset \\\\(S\\\\) of camps to **strengthen**.  Strengthening camp \\\\(v\\\\) does not change \\\\(v\\\\)'s own gold, but it *subtracts* exactly \\\\(c\\\\) gold from _each_ neighbor of \\\\(v\\\\).  After Robin Hood's attack, *only* the strengthened camps survive, and we sum up their (possibly reduced) gold.\\n\\nLet us denote by \\\\(S\\\\) the set of strengthened camps.  What is the total gold of the surviving (i.e.\\\\ strengthened) camps?\\n\\n1.  If \\\\(v\\\\in S\\\\), its own gold contribution is its original \\\\(a_v\\\\), **minus** \\\\(c\\\\) for *each* neighbor \\\\(u\\\\in S\\\\) who also strengthened.  (Because when \\\\(u\\\\) is strengthened, it takes \\\\(c\\\\) gold from each of its neighbors, including \\\\(v\\\\).)\\n\\n2.  Equivalently, the total we get from the chosen set \\\\(S\\\\) is\\n\\\\[\\n   \\\\sum_{v\\\\in S} a_v \\\\;-\\\\; c\\\\!\\\\!\\\\sum_{\\\\substack{(u,v)\\\\in E\\\\\\\\u,v\\\\in S}} 1.\\n\\\\]\\nBut each edge \\\\((u,v)\\\\) with both endpoints in \\\\(S\\\\) causes \\\\(c\\\\) to be taken from \\\\(u\\\\) and \\\\(c\\\\) from \\\\(v\\\\), i.e.\\\\ a total of \\\\(2c\\\\) penalty per such edge.  Hence the overall score of a strengthened set \\\\(S\\\\) is\\n\\n\\\\[\\n   \\\\sum_{v\\\\in S} a_v \\\\;-\\\\; 2c \\\\times \\\\bigl|\\\\{\\\\text{edges both of whose endpoints are in }S\\\\}\\\\bigr|.\\n\\\\]\\n\\nWe want to choose \\\\(S\\\\) to **maximize** this quantity.\\n\\nOn a tree, one can do a classic DP.  Root the tree at node \\\\(1\\\\).  For each node \\\\(v\\\\), let\\n\\n- \\\\(\\\\mathrm{dp0}[v]\\\\) = the maximum total we can obtain in the subtree of \\\\(v\\\\), _given that_ \\\\(v\\\\) **is not** chosen (not in \\\\(S\\\\)).\\n- \\\\(\\\\mathrm{dp1}[v]\\\\) = the maximum total we can obtain in the subtree of \\\\(v\\\\), _given that_ \\\\(v\\\\) **is** chosen (in \\\\(S\\\\)).\\n\\nTransitions: suppose \\\\(v\\\\) has children \\\\(u_1,u_2,\\\\dots\\\\).  Then\\n\\n1. If \\\\(v\\\\) is **not** chosen, its children may be chosen or not chosen independently, and no edge \\\\((v,u)\\\\) contributes a \\\\(-2c\\\\) penalty (since \\\\(v\\\\notin S\\\\)).  Thus\\n   \\\\[\\n     \\\\mathrm{dp0}[v]\\n       = \\\\sum_{u\\\\text{ child of }v}\\n           \\\\max\\\\bigl(\\\\mathrm{dp0}[u],\\\\,\\\\mathrm{dp1}[u]\\\\bigr).\\n   \\\\]\\n\\n2. If \\\\(v\\\\) **is** chosen, each child \\\\(u\\\\) if chosen also incurs a \\\\(-2c\\\\) penalty ( because that edge \\\\((v,u)\\\\) lies inside \\\\(S\\\\) ).  So for each child \\\\(u\\\\) we choose\\n   \\\\[\\n     \\\\max\\\\!\\\\bigl(\\\\mathrm{dp0}[u],\\\\,\\\\mathrm{dp1}[u] - 2c \\\\bigr),\\n   \\\\]\\n   and we add \\\\(a_v\\\\) for choosing \\\\(v\\\\) itself.  Thus\\n   \\\\[\\n     \\\\mathrm{dp1}[v]\\n       = a_v\\n         + \\\\sum_{u\\\\text{ child of }v}\\n             \\\\max\\\\bigl(\\\\mathrm{dp0}[u],\\\\,\\\\mathrm{dp1}[u] - 2c\\\\bigr).\\n   \\\\]\\n\\nFinally, the answer for the whole tree is\\n\\\\[\\n   \\\\max\\\\bigl(\\\\mathrm{dp0}[1],\\\\,\\\\mathrm{dp1}[1]\\\\bigr),\\n\\\\]\\nbecause the root may be chosen or not chosen, and empty choice (i.e.\\\\ choosing nobody) yields zero, which is covered by \\\\(\\\\mathrm{dp0}[1]\\\\).  Since all DP values can be negative, the \\\\(\\\\mathrm{dp0}[1]\\\\) path can produce 0 by effectively choosing none in the entire subtree.\\n\\nWe implement this in \\\\(O(n)\\\\) time per test by\\n\\n- reading the tree,\\n- rooting it at 1 with a BFS to record parent and a topological (BFS) order,\\n- processing nodes in reverse BFS order (from leaves upward) to fill dp0,dp1,\\n- printing \\\\(\\\\max(\\\\mathrm{dp0}[1],\\\\mathrm{dp1}[1])\\\\).\\n\\nOverall complexity is \\\\(O(\\\\sum n)\\\\), which is \\\\(O(2\\\\times10^5)\\\\) over all test cases, easily within the 2-second limit.\\n\\n---\\n\\n**Java Implementation**\\n\\n```java\\nimport java.io.*;\\nimport java.util.*;\\n\\npublic class Main {\\n    static final int MAXN = 200_000;\\n    static int[] head = new int[MAXN + 5];\\n    static int[] to   = new int[2 * MAXN + 5];\\n    static int[] nxt  = new int[2 * MAXN + 5];\\n    static long[] dp0 = new long[MAXN + 5];\\n    static long[] dp1 = new long[MAXN + 5];\\n    static int[] parent = new int[MAXN + 5];\\n    static int[] order  = new int[MAXN + 5];\\n    static int[] queue  = new int[MAXN + 5];\\n    static long[] A     = new long[MAXN + 5];\\n    static int edgeCnt;\\n\\n    public static void main(String[] args) throws IOException {\\n        FastReader fr = new FastReader();\\n        PrintWriter pw = new PrintWriter(System.out);\\n\\n        int t = fr.nextInt();\\n        while (t-- > 0) {\\n            int n = fr.nextInt();\\n            long c = fr.nextLong();\\n\\n            // initialize adjacency\\n            for (int i = 1; i <= n; i++) {\\n                head[i] = -1;\\n            }\\n            edgeCnt = 0;\\n\\n            // read gold amounts\\n            for (int i = 1; i <= n; i++) {\\n                A[i] = fr.nextLong();\\n            }\\n\\n            // read edges\\n            for (int i = 0; i < n - 1; i++) {\\n                int u = fr.nextInt();\\n                int v = fr.nextInt();\\n                addEdge(u, v);\\n                addEdge(v, u);\\n            }\\n\\n            // BFS to root at 1, record parent and BFS order\\n            int front = 0, back = 0;\\n            queue[back++] = 1;\\n            parent[1] = 0;\\n            order[0] = 1;\\n            int ordSize = 1;\\n\\n            while (front < back) {\\n                int v = queue[front++];\\n                for (int e = head[v]; e != -1; e = nxt[e]) {\\n                    int u = to[e];\\n                    if (u == parent[v]) continue;\\n                    parent[u] = v;\\n                    queue[back++] = u;\\n                    order[ordSize++] = u;\\n                }\\n            }\\n\\n            // DP in reverse BFS order (children before parent)\\n            for (int idx = ordSize - 1; idx >= 0; idx--) {\\n                int v = order[idx];\\n                long take0 = 0;         // v not chosen\\n                long take1 = A[v];      // v chosen\\n\\n                for (int e = head[v]; e != -1; e = nxt[e]) {\\n                    int u = to[e];\\n                    if (u == parent[v]) continue;\\n                    // if v not chosen, child u may be chosen or not\\n                    take0 += Math.max(dp0[u], dp1[u]);\\n                    // if v chosen, edge (v,u) penalizes 2c if u is also chosen\\n                    long option0 = dp0[u];\\n                    long option1 = dp1[u] - 2 * c;\\n                    take1 += Math.max(option0, option1);\\n                }\\n\\n                dp0[v] = take0;\\n                dp1[v] = take1;\\n            }\\n\\n            long ans = Math.max(dp0[1], dp1[1]);\\n            pw.println(ans);\\n        }\\n\\n        pw.close();\\n    }\\n\\n    static void addEdge(int u, int v) {\\n        to[edgeCnt] = v;\\n        nxt[edgeCnt] = head[u];\\n        head[u] = edgeCnt++;\\n    }\\n\\n    // Fast I/O\\n    static class FastReader {\\n        BufferedReader br;\\n        StringTokenizer st;\\n\\n        public FastReader() throws IOException {\\n            br = new BufferedReader(\\n                   new InputStreamReader(System.in));\\n        }\\n\\n        String next() throws IOException {\\n            while (st == null || !st.hasMoreTokens()) {\\n                String s = br.readLine();\\n                if (s == null) return null;\\n                st = new StringTokenizer(s);\\n            }\\n            return st.nextToken();\\n        }\\n\\n        int nextInt() throws IOException {\\n            return Integer.parseInt(next());\\n        }\\n\\n        long nextLong() throws IOException {\\n            return Long.parseLong(next());\\n        }\\n    }\\n}\\n```\\n\\n**Explanation of Key Steps**\\n\\n1. **Transforming the Problem**  \\n   Picking a subset \\\\(S\\\\) of nodes yields total gold  \\n   \\\\[\\n     \\\\sum_{v\\\\in S} a_v \\\\;-\\\\; 2c\\\\,\\\\bigl|\\\\{\\\\text{edges fully inside }S\\\\}\\\\bigr|.\\n   \\\\]\\n\\n2. **Tree DP**  \\n   - \\\\(\\\\mathrm{dp0}[v]\\\\) = best sum in \\\\(v\\\\)'s subtree if \\\\(v\\\\notin S\\\\).  \\n   - \\\\(\\\\mathrm{dp1}[v]\\\\) = best sum in \\\\(v\\\\)'s subtree if \\\\(v\\\\in S\\\\).  \\n   We combine children carefully to account for the \\\\(-2c\\\\) penalty whenever both ends of an edge are chosen.\\n\\n3. **Implementation Details**  \\n   - We root at node 1.  \\n   - Run a BFS to determine parent pointers and to get an array of nodes in BFS order.  \\n   - Process the nodes in _reverse_ BFS order so that when we process a node \\\\(v\\\\), all its children have already been processed.  \\n   - Each node \\\\(v\\\\) merges the DP values of its children according to whether \\\\(v\\\\) is chosen or not.  \\n\\nThis runs in \\\\(O(n)\\\\) per test, and since the total \\\\(n\\\\) over all tests does not exceed \\\\(2\\\\times10^5\\\\), it easily fits the time and memory limits.\",\n        \"refusal\": null,\n        \"role\": \"assistant\",\n        \"annotations\": [],\n        \"audio\": null,\n        \"function_call\": null,\n        \"tool_calls\": null\n      },\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"protected_material_code\": {\n          \"filtered\": false,\n          \"detected\": true,\n          \"citation\": {\n            \"URL\": \"https://github.com/efgen/solutions-archive/tree/5c02bd6d154e55e0d52d282c089b05913648a025/timus%2F1474.java\",\n            \"license\": \"NOASSERTION\"\n          }\n        },\n        \"protected_material_text\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ],\n  \"created\": 1753309869,\n  \"model\": \"o4-mini-2025-04-16\",\n  \"object\": \"chat.completion\",\n  \"service_tier\": null,\n  \"system_fingerprint\": null,\n  \"usage\": {\n    \"completion_tokens\": 5175,\n    \"prompt_tokens\": 741,\n    \"total_tokens\": 5916,\n    \"completion_tokens_details\": {\n      \"accepted_prediction_tokens\": 0,\n      \"audio_tokens\": 0,\n      \"reasoning_tokens\": 2816,\n      \"rejected_prediction_tokens\": 0\n    },\n    \"prompt_tokens_details\": {\n      \"audio_tokens\": 0,\n      \"cached_tokens\": 0\n    }\n  },\n  \"prompt_filter_results\": [\n    {\n      \"prompt_index\": 0,\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"jailbreak\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ]\n}"
    }
]