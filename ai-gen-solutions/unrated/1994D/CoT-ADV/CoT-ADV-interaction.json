[
    {
        "request_timestamp": "2025-07-23T23:06:42.225003",
        "response_timestamp": "2025-07-23T23:08:05.637969",
        "sent_messages": [
            {
                "role": "user",
                "content": "Codeforces Problem:\n\nD. Funny Game\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nVanya has a graph with n\n\n vertices (numbered from 1\n\n to n\n\n) and an array a\n\n of n\n\n integers; initially, there are no edges in the graph. Vanya got bored, and to have fun, he decided to perform n−1\n\n operations.\n\n\n\nOperation number x\n\n (operations are numbered in order starting from 1\n\n) is as follows:\n\n\n\nChoose 2\n\n different numbers 1≤u,v≤n\n\n, such that |au−av|\n\n is divisible by x\n\n.\n\nAdd an undirected edge between vertices u\n\n and v\n\n to the graph.\n\nHelp Vanya get a connected∗\n\n graph using the n−1\n\n operations, or determine that it is impossible.\n\n\n\n∗\n\nA graph is called connected if it is possible to reach any vertex from any other by moving along the edges.\n\n\n\nInput\n\nEach test consists of multiple test cases. The first line contains an integer t\n\n (1≤t≤103\n\n) — the number of test cases. Then follows the description of the test cases.\n\n\n\nThe first line of each test case contains the number n\n\n (1≤n≤2000\n\n) — the number of vertices in the graph.\n\n\n\nThe second line of each test case contains n\n\n numbers a1,a2,⋯an\n\n (1≤ai≤109\n\n).\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2000\n\n.\n\n\n\nOutput\n\nFor each test case, if there is no solution, then output \"No\" (without quotes).\n\n\n\nOtherwise, output \"Yes\" (without quotes), and then output n−1\n\n lines, where in the i\n\n-th line, output the numbers u\n\n and v\n\n that need to be chosen for operation i\n\n.\n\n\n\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\n\n\nExample\n\nInputCopy\n\n8\n\n2\n\n1 4\n\n4\n\n99 7 1 13\n\n5\n\n10 2 31 44 73\n\n5\n\n87 6 81 44 32\n\n5\n\n62 35 33 79 16\n\n5\n\n6 51 31 69 42\n\n5\n\n52 63 25 21 5\n\n12\n\n33 40 3 11 31 43 37 8 50 5 12 22\n\nOutputCopy\n\nYES\n\n2 1\n\nYES\n\n4 1\n\n2 1\n\n3 2\n\nYES\n\n5 1\n\n4 1\n\n3 1\n\n2 1\n\nYES\n\n4 1\n\n3 1\n\n2 1\n\n5 4\n\nYES\n\n3 1\n\n5 1\n\n2 1\n\n4 2\n\nYES\n\n4 1\n\n5 1\n\n2 1\n\n3 2\n\nYES\n\n2 1\n\n5 2\n\n3 1\n\n4 3\n\nYES\n\n9 1\n\n12 9\n\n11 1\n\n10 1\n\n6 1\n\n7 6\n\n2 1\n\n8 2\n\n5 2\n\n3 1\n\n4 1\n\nNote\n\nLet's consider the second test case.\n\n\n\nFirst operation (x=1)\n\n: we can connect vertices 4\n\n and 1\n\n, since |a4−a1|=|13−99|=|−86|=86\n\n, and 86\n\n is divisible by 1\n\n.\n\n\n\nSecond operation (x=2)\n\n: we can connect vertices 2\n\n and 1\n\n, since |a2−a1|=|7−99|=|−92|=92\n\n, and 92\n\n is divisible by 2\n\n.\n\n\n\nThird operation (x=3)\n\n: we can connect vertices 3\n\n and 2\n\n, since |a3−a2|=|1−7|=|−6|=6\n\n, and 6\n\n is divisible by 3\n\n.\n\nFrom the picture, it can be seen that a connected graph is obtained.\n\n---\n\nYou are a competitive programming assistant solving Codeforces problems using Java. First, carefully read and restate the problem in your own words to ensure full understanding. Identify the input and output formats, list the constraints, and consider any edge cases that might affect the logic. Next, determine which algorithmic pattern the problem fits best—such as greedy, binary search, two pointers, dynamic programming, or graph traversal—and briefly explain why that pattern applies. Then, plan your solution step by step, describing the key ideas, data structures, or mathematical insights you’ll use. Once your plan is clear, write a clean and fully working Java program. Use import java.util.*; and include a Main class with a main method, using Scanner or BufferedReader for input depending on the constraints. Add comments to explain important logic in the code. After coding, walk through a sample input manually to show how your solution works in practice. Finally, analyze the time and space complexity of your approach using Big-O notation, justifying your answer. Think step by step and only write code once the logic is sound and complete."
            }
        ],
        "received_response": "{\n  \"id\": \"chatcmpl-BwgaAQ8CeTr8sv3LvSVFYFYsZlNvr\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"**Problem Restatement**\\n\\nWe have \\\\(n\\\\) vertices (numbered \\\\(1\\\\) through \\\\(n\\\\)) and an integer label \\\\(a_i\\\\) on each vertex \\\\(i\\\\). Initially, the graph has no edges. We must perform exactly \\\\(n-1\\\\) operations, numbered \\\\(x=1,2,\\\\dots,n-1\\\\). In operation \\\\(x\\\\) we pick two *different* vertices \\\\(u,v\\\\) such that\\n\\n\\\\[\\n|a_u - a_v|\\\\;\\\\bmod\\\\;x \\\\;=\\\\;0,\\n\\\\]\\n\\nand we add an undirected edge \\\\((u,v)\\\\).  After all \\\\(n-1\\\\) operations, the resulting graph must be *connected* (equivalently, it will be a tree, since a connected graph on \\\\(n\\\\) vertices with \\\\(n-1\\\\) edges is a tree).  We must either\\n\\n- Output “No” if it is impossible to choose such edges for each \\\\(x\\\\), or\\n- Output “Yes” and then exactly \\\\(n-1\\\\) pairs \\\\((u,v)\\\\), one per line in the order \\\\(x=1,2,\\\\dots,n-1\\\\), describing a valid sequence of operations that yields a connected graph.\\n\\n**Input & Output**\\n\\n- **Input:**  \\n  - First line: integer \\\\(t\\\\), the number of test cases \\\\((1\\\\le t\\\\le 10^3)\\\\).  \\n  - For each test case:  \\n    - Line 1: integer \\\\(n\\\\) \\\\((1\\\\le n\\\\le 2000)\\\\).  \\n    - Line 2: \\\\(n\\\\) integers \\\\(a_1,a_2,\\\\dots,a_n\\\\)\\\\ \\\\((1\\\\le a_i\\\\le10^9)\\\\).  \\n  - It is guaranteed that \\\\(\\\\sum n\\\\le2000\\\\).\\n\\n- **Output:**  \\n  - For each test case:  \\n    - If no valid sequence of operations exists, print a single line `No`.  \\n    - Otherwise, print `Yes`, then \\\\(n-1\\\\) lines.  On line \\\\(x\\\\) (for \\\\(1\\\\le x\\\\le n-1\\\\)) print two integers `u v` indicating that in operation \\\\(x\\\\) we add edge \\\\((u,v)\\\\).  Those choices must satisfy \\\\(\\\\bigl|a_u-a_v\\\\bigr|\\\\bmod x=0\\\\) and must form a connected graph in the end.\\n\\n**Constraints and Edge Cases**\\n\\n- \\\\(n\\\\) up to 2000, sum over all tests \\\\(\\\\le2000\\\\).  \\n- We must choose exactly one edge for each label \\\\(x\\\\in[1,n-1]\\\\).  \\n- The final graph must have \\\\(n-1\\\\) edges and be connected (thus it is a spanning tree).  \\n- Operation \\\\(x=1\\\\) is always the easiest constraint, since any difference is divisible by 1.  Larger \\\\(x\\\\) impose stronger restrictions, so we must be careful to reserve those “harder” labels first.\\n\\n**High-Level Solution Idea**\\n\\nWe will build the tree *greedily from the largest operation number down to 1*.  Why largest first?  A larger \\\\(x\\\\) requires \\\\(\\\\lvert a_u-a_v\\\\rvert\\\\) to be a multiple of \\\\(x\\\\), which is a tighter condition (fewer pairs satisfy it).  Once we use up “easy” small labels, we might not be able to repair a missed opportunity for a large label.  So:\\n\\n1. Maintain a Disjoint-Set Union (DSU) over the vertices to ensure that we do not create cycles.  \\n2. For \\\\(x\\\\) going from \\\\(n-1\\\\) down to \\\\(1\\\\):\\n   - We must pick one edge \\\\((u,v)\\\\) so that \\\\(\\\\lvert a_u-a_v\\\\rvert\\\\mod x=0\\\\) *and* \\\\(u,v\\\\) lie in different DSU components (so that we connect two components and avoid a cycle).\\n   - If *no* such pair \\\\((u,v)\\\\) exists, we answer “No” for this test case.\\n   - Otherwise, we union their components in the DSU and record \\\\((u,v)\\\\) as the edge chosen for label \\\\(x\\\\).\\n3. If we succeed for every \\\\(x= n-1\\\\ldots1\\\\), we will have chosen exactly \\\\(n-1\\\\) edges, no cycles, and by DSU argument the final graph is connected.  We print “Yes” and then output our recorded edges in the order \\\\(x=1,2,\\\\dots,n-1\\\\).\\n\\n**Key Data Structures**\\n\\n- DSU (`parent[]` + `rank[]`) for cycle-avoidance and component management.\\n- A temporary array `head[0..x-1]` to group vertices by their residue modulo \\\\(x\\\\).  All vertices with the same `a[i] % x` form candidate edges among themselves (because two numbers are congruent \\\\(\\\\bmod\\\\,x\\\\) exactly when \\\\(x\\\\) divides their difference).\\n- A linked-list style `nextNode[i]` to chain vertices in each residue bucket, so that building and scanning buckets takes \\\\(O(n)\\\\) per \\\\(x\\\\).\\n\\n**Algorithm Complexity**\\n\\n- For each test:\\n  - We loop \\\\(x\\\\) from \\\\(n-1\\\\) down to \\\\(1\\\\) \\\\(=\\\\) \\\\(O(n)\\\\) iterations.\\n  - In each iteration we:\\n    - Build residue buckets in \\\\(O(n)\\\\).\\n    - Scan them in total \\\\(O(n)\\\\) time to find a cross-component edge.\\n    - DSU find/union is essentially \\\\(O(\\\\alpha(n))\\\\approx O(1)\\\\).\\n  - Total per test: \\\\(O(n^2)\\\\).  Since \\\\(\\\\sum n\\\\le2000\\\\), worst-case is about \\\\((2000)^2=4\\\\cdot10^6\\\\) operations, which is well within 2 seconds.\\n- Space: \\\\(O(n)\\\\) for DSU arrays, residues, nextNode, and answer storage.\\n\\n---\\n\\n```java\\nimport java.util.*;\\n\\npublic class Main {\\n    static int[] parent, rank;\\n    static int[] head, nextNode;\\n    static int[] ansU, ansV;\\n    static int n;\\n    static int[] a;\\n\\n    // DSU find with path compression\\n    static int findSet(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = findSet(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n\\n    // DSU union by rank\\n    static void unionSet(int x, int y) {\\n        x = findSet(x);\\n        y = findSet(y);\\n        if (x == y) return;\\n        if (rank[x] < rank[y]) {\\n            parent[x] = y;\\n        } else if (rank[y] < rank[x]) {\\n            parent[y] = x;\\n        } else {\\n            parent[y] = x;\\n            rank[x]++;\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        Scanner in = new Scanner(System.in);\\n        int t = in.nextInt();\\n\\n        while (t-- > 0) {\\n            n = in.nextInt();\\n            a = new int[n+1];\\n            for (int i = 1; i <= n; i++) {\\n                a[i] = in.nextInt();\\n            }\\n\\n            // Initialize DSU\\n            parent = new int[n+1];\\n            rank   = new int[n+1];\\n            for (int i = 1; i <= n; i++) {\\n                parent[i] = i;\\n                rank[i]   = 0;\\n            }\\n\\n            // Prepare storage for answers: ansU[x], ansV[x] = edge chosen at label x\\n            ansU = new int[n];\\n            ansV = new int[n];\\n\\n            // Helper arrays for residue-bucketing\\n            head     = new int[n];    // we'll only use indices [0..x-1]\\n            nextNode = new int[n+1];  // nextNode[i] chains i in the bucket list\\n\\n            boolean possible = true;\\n\\n            // Build edges from largest x (n-1) down to 1\\n            for (int x = n - 1; x >= 1; x--) {\\n                // Reset head[0..x-1] = -1\\n                Arrays.fill(head, 0, x, -1);\\n\\n                // Bucket each vertex i by its residue r = a[i] % x\\n                for (int i = 1; i <= n; i++) {\\n                    int r = a[i] % x;\\n                    nextNode[i] = head[r];\\n                    head[r]     = i;\\n                }\\n\\n                // Attempt to find any cross-component pair in the same residue\\n                boolean found = false;\\n                for (int r = 0; r < x && !found; r++) {\\n                    int listHead = head[r];\\n                    if (listHead == -1) continue;\\n                    int repNode = -1, repRoot = -1;\\n                    // Walk the bucket's linked list\\n                    for (int cur = listHead; cur != -1; cur = nextNode[cur]) {\\n                        int root = findSet(cur);\\n                        if (repNode < 0) {\\n                            // first node in this residue\\n                            repNode = cur;\\n                            repRoot = root;\\n                        } else if (root != repRoot) {\\n                            // found u = repNode, v = cur in different DSU components\\n                            unionSet(repNode, cur);\\n                            ansU[x] = repNode;\\n                            ansV[x] = cur;\\n                            found = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n\\n                if (!found) {\\n                    possible = false;\\n                    break;\\n                }\\n            }\\n\\n            if (!possible) {\\n                System.out.println(\\\"No\\\");\\n            } else {\\n                System.out.println(\\\"Yes\\\");\\n                // Output edges in order x=1..n-1\\n                for (int x = 1; x <= n - 1; x++) {\\n                    System.out.println(ansU[x] + \\\" \\\" + ansV[x]);\\n                }\\n            }\\n        }\\n\\n        in.close();\\n    }\\n}\\n```\\n\\n**Explanation of Key Steps**\\n\\n1. **DSU Setup**  \\n   We keep `parent[i]` and `rank[i]` so that `findSet(i)` returns the representative of node \\\\(i\\\\)’s component, and `unionSet(u,v)` merges them if distinct.\\n\\n2. **Residue Bucketing**  \\n   For a given \\\\(x\\\\), two vertices \\\\(u,v\\\\) satisfy \\\\(\\\\lvert a_u-a_v\\\\rvert\\\\mod x=0\\\\) precisely when\\n   \\\\[\\n     a_u \\\\equiv a_v \\\\;(\\\\bmod\\\\,x).\\n   \\\\]\\n   Thus we group vertices by `r = a[i] % x`.  All vertices in the same bucket `head[r]` share that residue.\\n\\n3. **Finding a Cross-Component Pair**  \\n   Within each bucket, we scan the chain of vertices.  We remember the first vertex we see (`repNode`) and its DSU root (`repRoot`).  As soon as we see another vertex `cur` whose `findSet(cur)` is different from `repRoot`, we have two vertices in the same residue but different components.  We pick `(repNode, cur)` as the edge for label \\\\(x\\\\), call `unionSet(repNode, cur)`, and move on to the next (smaller) \\\\(x\\\\).\\n\\n4. **Failure Case**  \\n   If for some \\\\(x\\\\) no bucket yields a valid cross-component pair, we must print “No” and give up.  Otherwise, we eventually record exactly one edge per \\\\(x\\\\in[1,n-1]\\\\).  Those \\\\(n-1\\\\) edges form a spanning tree (connected, no cycles) by DSU logic.\\n\\n**Example Walkthrough**\\n\\nTake the sample\\n```\\nn = 4, a = [99, 7, 1, 13].\\n```\\nWe run \\\\(x=3\\\\to2\\\\to1\\\\).\\n\\n- x = 3  \\n  - Residues mod 3:  \\n    99%3=0 → bucket 0: {1}  \\n    7%3=1  → bucket 1: {2}  \\n    1%3=1  → bucket 1: {2,3}  \\n    13%3=1 → bucket 1: {2,3,4}  \\n  - In bucket 1 we inspect say node 2 (`repNode=2`), then node 3 has `root(3)!=root(2)`.  We pick edge (2,3) for x=3.  DSU merges {2,3}.\\n\\n- x = 2  \\n  - Residues mod 2:  \\n    99%2=1 → {1}, 7%2=1→{1,2}, 1%2=1→{1,2,3}, 13%2=1→{1,2,3,4}.  \\n  - In that big bucket pick first say vertex 1, then the next vertex whose root differs is e.g. 4 (since {2,3,4} are in the other component).  We pick (1,4) for x=2.  DSU merges {1,4} and {2,3} → now all 4 are in one component.\\n\\n- x = 1  \\n  - Residues mod 1: all are 0, a single bucket of all 4 vertices.  We pick any two from different roots; but by now all are in one component!  Oops—**we must ensure we never merge all into 1 component too early**.  \\n  Our code actually finds cross-component pairs in each step and guarantees we end with exactly two components before the final step.  \\n  In practice we did merges for x=3 and x=2, leaving exactly two components of size 2 each, so x=1 can connect them.  \\n\\nThus we obtain a spanning tree that respects all divisibility constraints.\\n\\n**Time & Space Complexity**\\n\\n- Time:  \\n  - We do \\\\(n-1\\\\) iterations (for \\\\(x\\\\) from \\\\(n-1\\\\) down to 1).  \\n  - In each, we bucket \\\\(n\\\\) vertices (O(n)), then scan them (another O(n)).  \\n  - DSU operations are amortized \\\\(O(\\\\alpha(n))\\\\approx O(1)\\\\).  \\n  ⇒ \\\\(O(n^2)\\\\) per test, and \\\\(\\\\sum n\\\\le2000\\\\) ⇒ ~4 million operations total, easily within 2 s.\\n\\n- Space:  \\n  - \\\\(O(n)\\\\) for the DSU arrays, the bucketing arrays, and the answer storage.\\n\\nThis completes a correct, efficient solution under the problem constraints.\",\n        \"refusal\": null,\n        \"role\": \"assistant\",\n        \"annotations\": [],\n        \"audio\": null,\n        \"function_call\": null,\n        \"tool_calls\": null\n      },\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"protected_material_code\": {\n          \"filtered\": false,\n          \"detected\": true,\n          \"citation\": {\n            \"URL\": \"https://github.com/Sweater-Baron/acmprep/tree/e0efc625d941554582656b04231c3b40472f3ae3/regional%2FPacificNW%2F2015%2FI_O%2FCheckers%2FCheckers-dan.c\",\n            \"license\": \"NOASSERTION\"\n          }\n        },\n        \"protected_material_text\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ],\n  \"created\": 1753326410,\n  \"model\": \"o4-mini-2025-04-16\",\n  \"object\": \"chat.completion\",\n  \"service_tier\": null,\n  \"system_fingerprint\": null,\n  \"usage\": {\n    \"completion_tokens\": 8041,\n    \"prompt_tokens\": 1107,\n    \"total_tokens\": 9148,\n    \"completion_tokens_details\": {\n      \"accepted_prediction_tokens\": 0,\n      \"audio_tokens\": 0,\n      \"reasoning_tokens\": 4864,\n      \"rejected_prediction_tokens\": 0\n    },\n    \"prompt_tokens_details\": {\n      \"audio_tokens\": 0,\n      \"cached_tokens\": 0\n    }\n  },\n  \"prompt_filter_results\": [\n    {\n      \"prompt_index\": 0,\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"jailbreak\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ]\n}"
    }
]