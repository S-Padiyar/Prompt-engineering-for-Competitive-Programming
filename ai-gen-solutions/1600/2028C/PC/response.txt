**Analysis**

We have an array of \(n\) cake‐sections \(a_1,a_2,\dots,a_n\), and \(m\) creatures each demanding a contiguous “piece” of total tastiness at least \(v\).  Alice must slice the cake into \(m+1\) contiguous segments, give \(m\) of them (one each) to the creatures so that each creature’s segment sum is \(\ge v\), and keep the one remaining segment for herself (possibly empty).  She wants to maximize the tastiness of her own segment; if no way exists to satisfy all creatures, the answer is \(-1\).

Let us denote by \(\text{pre}[i]\) the maximum number of contiguous segments of sum \(\ge v\) one can carve from the prefix \(a_1..a_i\) by the standard greedy scheme

```
curr = 0; 
count = 0;
for x in a_1..a_i:
  curr += x
  if curr ≥ v:
    count += 1
    curr = 0
```

and by \(\text{suf}[j]\) the same for the suffix \(a_j..a_n\).  It is a known fact that this “greedy‐as‐soon‐as‐you‐reach‐v” partition maximizes the number of pieces meeting the threshold.  

Now suppose Alice’s piece is exactly the subarray \([ℓ..r]\).  Then the creatures must be allocated exactly \(\,m\) segments covering all of the outside \(\{1..ℓ-1\}\cup\{r+1..n\}\).  If we use \(p\) segments in the prefix \([1..ℓ-1]\) and \(q\) segments in the suffix \([r+1..n]\), we have \(p+q=m\).  The prefix can indeed be dissected into \(p\) valid segments iff \(\text{pre}[ℓ-1]\ge p\), and the suffix into \(q\) valid segments iff \(\text{suf}[r+1]\ge q\).  Hence we need

\[
\text{pre}[ℓ-1]\;+\;\text{suf}[r+1]\;\ge\;m.
\]

Alice’s own gain is
\[
\sum_{i=ℓ}^r a_i
\;=\;
\text{Psum}[r]\;-\;\text{Psum}[ℓ-1],
\]
where \(\text{Psum}[k]\) is the ordinary prefix‐sum of the \(a\)-array.

Thus the problem reduces to: among all pairs \((i,j)\) with \(0 \le i < j \le n+1\), such that
\[
\text{pre}[\,i\,] + \text{suf}[\,j\,] \;\ge\; m,
\]
maximize
\[
\text{Psum}[\,j-1\,]\;-\;\text{Psum}[\,i\,].
\]

We can sweep \(j\) from \(1\) to \(n+1\), maintain all indices \(i\) with \(0\le i<j\) in a data structure keyed by \(\text{pre}[i]\), storing the minimum \(\text{Psum}[i]\) among those with a given pre‐value.  Then, at time \(j\), we know the suffix‐count \(\text{suf}[j]\), so we need all \(i\) with
\[
\text{pre}[i]\;\ge\;m - \text{suf}[j].
\]
We do a range‐minimum query over all pre‐values \(\ge m-\text{suf}[j]\), subtract that from \(\text{Psum}[j-1]\), and keep the maximum result.  A segment‐tree (or Fenwick tree with min) over the discrete range of possible \(\text{pre}[\,i\,]\) (which runs from 0 up to \(\text{pre}[n]\)) supports \(O(\log n)\) updates and range‐mins.  Since \(\text{pre}[n]\) is at most \(n\), everything runs in \(O(n\log n)\) per test, which is fast enough for \(\sum n\le2\cdot10^5\).

If \(\text{pre}[n]<m\), we can never satisfy all \(m\) creatures even with Alice taking an empty segment, so answer \(-1\).

-----

```java
import java.io.*;
import java.util.*;

public class Main {
    static final long INF = (long)1e18;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter  pw = new PrintWriter(System.out);

        int T = Integer.parseInt(br.readLine());
        while (T-- > 0) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            int m = Integer.parseInt(st.nextToken());
            long v = Long.parseLong(st.nextToken());

            long[] a = new long[n+1];
            st = new StringTokenizer(br.readLine());
            for (int i = 1; i <= n; i++) {
                a[i] = Long.parseLong(st.nextToken());
            }

            // Compute prefix-sums
            long[] psum = new long[n+1];
            for (int i = 1; i <= n; i++) {
                psum[i] = psum[i-1] + a[i];
            }

            // Greedy count of how many segments of sum>=v from the prefix [1..i]
            int[] pre = new int[n+1];
            {
                long curr = 0;
                int cnt = 0;
                for (int i = 1; i <= n; i++) {
                    curr += a[i];
                    if (curr >= v) {
                        cnt++;
                        curr = 0;
                    }
                    pre[i] = cnt;
                }
            }

            // If we cannot even carve m segments from the entire array, fail immediately
            if (pre[n] < m) {
                pw.println(-1);
                continue;
            }

            // Greedy count for suffix [i..n]
            int[] suf = new int[n+2];
            {
                long curr = 0;
                int cnt = 0;
                suf[n+1] = 0;
                for (int i = n; i >= 1; i--) {
                    curr += a[i];
                    if (curr >= v) {
                        cnt++;
                        curr = 0;
                    }
                    suf[i] = cnt;
                }
            }

            // We sweep j=1..n+1.  At step j we insert index i=j-1 into the segtree,
            // keyed by pre[i], storing the min psum[i].  Then we query all keys >= m - suf[j].
            int maxPre = pre[n];       // the maximum possible "pre"-value
            int S = maxPre + 1;        // range of keys [0..maxPre]

            // Build a segment tree for range-min over [0..S-1].
            int size = 1;
            while (size < S) size <<= 1;
            long[] seg = new long[2*size];
            Arrays.fill(seg, INF);

            // Update function: at key k we install value vv = min(old,k)
            Runnable pushRoot = null;  // just placeholder
            class Updater {
                void update(int k, long vv) {
                    k += size;
                    if (seg[k] <= vv) return;  // no need
                    seg[k] = vv;
                    for (k >>= 1; k > 0; k >>= 1) {
                        seg[k] = Math.min(seg[2*k], seg[2*k+1]);
                    }
                }
            }
            Updater updater = new Updater();

            // Range-min query on [l..r]
            class Querier {
                long query(int l, int r) {
                    long ans = INF;
                    l += size;
                    r += size;
                    while (l <= r) {
                        if ((l & 1) == 1) ans = Math.min(ans, seg[l++]);
                        if ((r & 1) == 0) ans = Math.min(ans, seg[r--]);
                        l >>= 1;
                        r >>= 1;
                    }
                    return ans;
                }
            }
            Querier querier = new Querier();

            long answer = 0;

            // Sweep j = 1..n+1
            //    insert i=j-1
            //    let T = m - suf[j], clamp T to [0..maxPre]
            //    query min psum[i] among pre[i]>=T
            //    candidate = psum[j-1] - that_min
            for (int j = 1; j <= n+1; j++) {
                // insert i = j-1
                int i = j - 1;
                int pk = pre[i];       // the key
                long pv = psum[i];     // the value
                updater.update(pk, pv);

                // we need pre[i] >= (m - suf[j])
                int need = m - suf[j];
                if (need < 0) need = 0;
                if (need > maxPre) continue;

                long bestPref = querier.query(need, maxPre);
                if (bestPref != INF) {
                    long cand = psum[j-1] - bestPref;
                    if (cand > answer) answer = cand;
                }
            }

            pw.println(answer);
        }

        pw.flush();
    }
}
```

**Explanation of Key Steps**

1. **Greedy pre‐ and suf‐counts**  
   `pre[i]` = how many segments of sum ≥ v we get by scanning from the left up to `i` and cutting as soon as we reach `v`.  
   `suf[j]` = similar from the right (positions `j..n`).

2. **Feasibility test**  
   If `pre[n] < m`, we cannot serve `m` creatures even if Alice takes nothing.  Print `-1`.

3. **Maximization via sweeping**  
   We rewrite Alice’s piece as the subarray `(i+1..j-1)` where `0 ≤ i < j ≤ n+1`.  The creatures must be allotted exactly `m` segments in `[1..i]` plus `m−(segments in suffix)`, so we need  
   `pre[i] + suf[j] ≥ m`.  
   Alice’s gain is  
   ```
   sum_{k=i+1..j-1}(a[k]) = Psum[j-1] - Psum[i].
   ```
   We sweep `j` from `1` to `n+1`.  Before handling `j`, we insert index `i = j−1` into a data structure keyed by `pre[i]` with value `Psum[i]`.  We then need the smallest `Psum[i]` among all keys ≥ `m - suf[j]`.  Subtract that from `Psum[j-1]` to get a candidate, and take the maximum over all `j`.

4. **Data Structure**  
   We use a segment tree over the key‐range `0..pre[n]`, supporting  
   - point‐update `key = pre[i]`, value = `min(oldValue, Psum[i])`,  
   - range‐min query over `[needed..maxKey]`.  
   Each operation in `O(log n)`, giving overall `O(n log n)` per test.

This satisfies the constraints up to \(n\le2\times10^5\) in total across all test cases.