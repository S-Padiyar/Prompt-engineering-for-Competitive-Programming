[
  {
    "timestamp": "2025-07-24T06:10:20.651980",
    "role": "user",
    "content": "Please rewrite the Java solution as a single code block. Use a priority queue of `State { long time; int node; }` objects keyed by `time` (max-heap). On each poll, skip stale entries by checking if `state.time != L[state.node]`. Do *not* call `pq.remove()`. Ensure you handle multiple test cases and meet the required time complexity."
  },
  {
    "timestamp": "2025-07-24T06:12:24.239146",
    "role": "assistant",
    "content": "```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to;\n        long bus, walk;\n        Edge(int t, long b, long w) { to = t; bus = b; walk = w; }\n    }\n    static class State {\n        int node;\n        long time;\n        State(int n, long t) { node = n; time = t; }\n    }\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st;\n        int T = Integer.parseInt(br.readLine().trim());\n        StringBuilder sb = new StringBuilder();\n        \n        while (T-- > 0) {\n            st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(st.nextToken());\n            st = new StringTokenizer(br.readLine());\n            long t0 = Long.parseLong(st.nextToken());\n            long t1 = Long.parseLong(st.nextToken());\n            long t2 = Long.parseLong(st.nextToken());\n            \n            List<Edge>[] adj = new ArrayList[n+1];\n            for (int i = 1; i <= n; i++) adj[i] = new ArrayList<>();\n            for (int i = 0; i < m; i++) {\n                st = new StringTokenizer(br.readLine());\n                int u = Integer.parseInt(st.nextToken());\n                int v = Integer.parseInt(st.nextToken());\n                long w1 = Long.parseLong(st.nextToken());\n                long w2 = Long.parseLong(st.nextToken());\n                adj[u].add(new Edge(v, w1, w2));\n                adj[v].add(new Edge(u, w1, w2));\n            }\n            \n            // L[u] = latest departure time from u to still reach n by t0\n            long[] L = new long[n+1];\n            Arrays.fill(L, -1L);\n            L[n] = t0;\n            \n            // Max‐heap on departure time\n            PriorityQueue<State> pq = new PriorityQueue<>(\n                (a, b) -> Long.compare(b.time, a.time)\n            );\n            pq.offer(new State(n, t0));\n            \n            while (!pq.isEmpty()) {\n                State stt = pq.poll();\n                int v = stt.node;\n                long cur = stt.time;\n                // skip stale\n                if (cur != L[v]) continue;\n                // if cur<0, no further positive updates possible\n                if (cur < 0) break;\n                \n                for (Edge e : adj[v]) {\n                    int u = e.to;\n                    // 1) walk\n                    long candWalk = cur - e.walk;\n                    if (candWalk >= 0 && candWalk > L[u]) {\n                        L[u] = candWalk;\n                        pq.offer(new State(u, candWalk));\n                    }\n                    // 2) bus\n                    long w1 = e.bus;\n                    // pre‐call\n                    long tPre = Math.min(t1 - w1, cur - w1);\n                    if (tPre < 0) tPre = -1;\n                    // post‐call\n                    long tPost = -1;\n                    long dep = cur - w1;\n                    if (dep >= t2) tPost = dep;\n                    long tNew = Math.max(tPre, tPost);\n                    if (tNew >= 0 && tNew > L[u]) {\n                        L[u] = tNew;\n                        pq.offer(new State(u, tNew));\n                    }\n                }\n            }\n            \n            long ans = L[1];\n            sb.append(ans < 0 ? -1 : ans).append('\\n');\n        }\n        System.out.print(sb.toString());\n    }\n}\n```"
  }
]