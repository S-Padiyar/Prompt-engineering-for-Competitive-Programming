[
  {
    "role": "user",
    "content": "C. Perform Operations to Maximize Score\n\ntime limit per test3 seconds\n\nmemory limit per test256 megabytes\n\nI see satyam343. I'm shaking. Please more median problems this time. I love those. Please satyam343 we believe in you.\n\n— satyam343's biggest fan\n\nYou are given an array a\n\n of length n\n\n and an integer k\n\n. You are also given a binary array b\n\n of length n\n\n.\n\n\n\nYou can perform the following operation at most k\n\n times:\n\n\n\nSelect an index i\n\n (1≤i≤n\n\n) such that bi=1\n\n. Set ai=ai+1\n\n (i.e., increase ai\n\n by 1\n\n).\n\nYour score is defined to be maxi=1n(ai+median(ci))\n\n, where ci\n\n denotes the array of length n−1\n\n that you get by deleting ai\n\n from a\n\n. In other words, your score is the maximum value of ai+median(ci)\n\n over all i\n\n from 1\n\n to n\n\n.\n\n\n\nFind the maximum score that you can achieve if you perform the operations optimally.\n\n\n\nFor an arbitrary array p\n\n, median(p)\n\n is defined as the ⌊|p|+12⌋\n\n-th smallest element of p\n\n. For example, median([3,2,1,3])=2\n\n and median([6,2,4,5,1])=4\n\n.\n\n\n\nInput\n\nThe first line contains an integer t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nEach test case begins with two integers n\n\n and k\n\n (2≤n≤2⋅105\n\n, 0≤k≤109\n\n) — the length of the a\n\n and the number of operations you can perform.\n\n\n\nThe following line contains n\n\n space separated integers a1,a2,…,an\n\n (1≤ai≤109\n\n) — denoting the array a\n\n.\n\n\n\nThe following line contains n\n\n space separated integers b1,b2,…,bn\n\n (bi\n\n is 0\n\n or 1\n\n) — denoting the array b\n\n.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output the maximum value of score you can get on a new line.\n\n\n\nExample\n\nInputCopy\n\n8\n\n2 10\n\n3 3\n\n1 1\n\n3 10\n\n3 3 3\n\n0 0 0\n\n4 4\n\n2 1 5 1\n\n0 1 0 1\n\n5 4\n\n7 5 2 5 4\n\n0 0 1 0 1\n\n5 1\n\n5 15 15 2 11\n\n1 0 0 1 1\n\n5 2\n\n10 11 4 10 15\n\n1 1 0 1 0\n\n4 4\n\n1 1 2 5\n\n1 1 0 0\n\n2 1000000000\n\n1000000000 1000000000\n\n1 1\n\nOutputCopy\n\n16\n\n6\n\n8\n\n13\n\n21\n\n26\n\n8\n\n3000000000\n\nNote\n\nFor the first test case, it is optimal to perform 5\n\n operations on both elements so a=[8,8]\n\n. So, the maximum score we can achieve is max(8+median[8],8+median[8])=16\n\n, as c1=[a2]=[8]\n\n. It can be proven that you cannot get a better score.\n\n\n\nFor the second test case, you are not able to perform operations on any elements, so a\n\n remains [3,3,3]\n\n. So, the maximum score we can achieve is 3+median[3,3]=6\n\n, as c1=[a2,a3]=[3,3]\n\n. It can be proven that you cannot get a better score.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have an array *a* of length *n*, a binary mask *b* of the same length, and up to *k* operations, each operation can raise one chosen \\(a_j\\) (with \\(b_j=1\\)) by one.  The final “score” is\n\n\\[\n\\max_{1 \\le i \\le n}\\bigl(\\,a_i^{\\text{(final)}} \\;+\\;\\mathrm{median}(a_1^{\\text{(final)}},\\dots,a_{i-1}^{\\text{(final)}},a_{i+1}^{\\text{(final)}},\\dots,a_n^{\\text{(final)}})\\bigr).\n\\]\n\nHere the median of an array of length \\(m\\) is by definition the \\(\\lfloor(m+1)/2\\rfloor\\)-th smallest element.\n\nWe must distribute our \\(k\\) “+1” operations among those positions \\(j\\) with \\(b_j=1\\).  Which distribution maximizes the final score?\n\n---\n\n### Key insight\n\nEach unit of operation invested *directly* in raising \\(a_i\\) (i.e. choosing \\(j=i\\) in an operation) raises the term \\(a_i\\) in the score by exactly 1.  On the other hand, if we put operations into raising the *median*, each time we raise the median by 1 we must raise *at least* \\(K\\) distinct elements by 1, where\n\\[\nK \\;=\\; (\\text{size of the “other” array}) - \\Bigl\\lfloor \\frac{\\text{size of “other”}+1}{2}\\Bigr\\rfloor +1\n\\;=\\;\nn - \\Bigl\\lfloor\\frac n2\\Bigr\\rfloor\n\\]\nbecause the “other” array has length \\(n-1\\), and to bump its median up by one we must push up all the elements that sit in the “lower half.”  Thus *each* single increment of the median costs at least \\(K\\) of our operations, so the “efficiency” is \\(+\\!1\\) score per \\(K\\) ops, i.e. \\(+\\tfrac1K\\) score per single op, whereas if we dedicate that single op to raise our chosen \\(a_i\\) directly we gain \\(+1\\) score.  Since \\(1 > 1/K\\), if we *can* apply an operation to our chosen center index \\(i\\), it is always strictly better (or at least not worse) to put *all* operations into raising that \\(a_i\\) rather than “waste” any on the median.  \n\nHence the optimum strategy falls into two *mutually exclusive* cases:\n\n1. **Case A (we choose an \\(i\\) with \\(b_i=1\\)).**  \n   Then we can put *all* \\(k\\) operations into \\(a_i\\).  The median of the other \\(n-1\\) elements remains its *initial* value.  Let us call\n   \\[\n     M(i)\\;=\\;\\mathrm{median}\\bigl(\\{a_j: j\\ne i\\}\\bigr)\\quad\\text{(computed on the *original* array).}\n   \\]\n   Then by investing all \\(k\\) ops into \\(a_i\\) we achieve a score\n   \\[\n     S(i)\\;=\\;\\bigl(a_i + k\\bigr)\\;+\\;M(i).\n   \\]\n   We pick the maximum over all \\(i\\) with \\(b_i=1\\).\n\n2. **Case B (we must choose an \\(i\\) with \\(b_i=0\\)).**  \n   Here we *cannot* invest any ops on \\(a_i\\); so \\(a_i\\) is frozen.  Our only way to raise the total \\(a_i + \\text{median}(\\dots)\\) is to invest *all* our \\(k\\) operations into pushing the median of the other \\(n-1\\) elements upward as much as possible.  We then ask: how large can we make that median?  If our target is to reach a final median of \\(d\\), each of the \\(K\\) “positions” whose values must be \\(\\ge d\\) either already is \\(\\ge d\\) (cost zero) or else must be raised at cost \\((d - a_j)\\).  If any of those \\(K\\) “slots” sits on an index \\(j\\) with \\(b_j=0\\) _and_ \\(a_j<d\\), we cannot raise it, so the whole plan fails.  Otherwise we gather (i) the count of already-“free” elements \\(\\ge d\\), (ii) the count of “raisable” elements \\(<d\\) with \\(b_j=1\\), and see if their sum is \\(\\ge K\\).  If so we take the cheapest \\(K-\\text{(already free)}\\) raisable elements, sum their \\((d-a_j)\\), and that must be \\(\\le k\\).  If it fits, the median \\(\\ge d\\).  \n\n   Hence if the chosen \\(i\\) has \\(b_i=0\\) and we fix a candidate final score \\(D\\), we set\n   \\[\n     d \\;=\\; D - a_i\n   \\]\n   and check feasibility of raising the median to at least \\(d\\) with \\(\\le k\\) ops.  If feasible for *any* \\(i\\) with \\(b_i=0\\), then score \\(D\\) is achievable.\n\nSince we only need the maximum possible score, we binary‐search on \\(D\\).  For each candidate \\(D\\) we do:\n\n- **Fast test for Case A.**  \n  Precompute\n  \\[\n    \\mathrm{maxA1}\\;=\\;\\max_{\\{i: b_i=1\\}}\\bigl(a_i + M(i)\\bigr).\n  \\]\n  If \\(\\mathrm{maxA1} + k \\ge D\\), we can succeed by choosing that \\(i\\) and allocating all \\(k\\) ops to \\(a_i\\).\n\n- **Fast test for Case B.**  \n  Let\n  \\[\n    i_0 = \\arg\\max_{\\{i:b_i=0\\}}\\,a_i,\\quad\n    a_0 = a_{i_0}.\n  \\]\n  (One checks only the largest \\(a_i\\) among those with \\(b_i=0\\).  If a lower \\(a_i\\) ever worked, the larger one certainly would.)  \n \n  We set\n  \\[\n    d\\;=\\;D - a_0.\n  \\]\n  If \\(d\\le 0\\) we're done (the median need only be \\(\\ge 0\\), trivial).  Otherwise in \\(O(\\log n)\\) time we compute:\n\n  1. `freeCount` = \\(\\#\\{j:a_j\\ge d\\}\\).  \n  2. `raisableCount` = \\(\\#\\{j: b_j=1,\\;a_j<d\\}\\).  \n  3. We must check if `freeCount - (a_0\\ge d?1:0)` \\((=\\,\\)the number of “free” slots among \\(j\\ne i_0\\)) plus `raisableCount` is at least \\(K\\).  \n  4. If so, let `need = K - (freeCountMinusI0)`.  We take the `need` smallest values of \\(a_j\\) among those \\(b_j=1,a_j<d\\), sum them in a prefix‐sum, and compute\n     \\[\n       \\text{cost} \\;=\\;\\sum_{j\\in\\text{those }need\\text{}} (d - a_j)\n       \\;=\\;\n       \\bigl(\\,need\\cdot d\\,\\bigr)\\;-\\;\\bigl(\\sum_{j\\in\\text{those }need\\!}a_j\\bigr).\n     \\]\n     If `cost ≤ k`, success; otherwise failure.\n\nIf either Case A or Case B can make \\(D\\), we say “yes” and move our binary search up; otherwise “no.”  After \\(O(\\log(10^{18}))\\) steps we converge on the maximum feasible \\(D\\).  \n\nOverall time per test: \n  - We sort once (\\(O(n\\log n)\\)),  \n  - compute each initial median‐of‐c_i in \\(O(1)\\) by a small formula,  \n  - build a sorted list of all \\(a_j\\) with \\(b_j=1\\) plus a prefix sum array,  \n  - each mid‐test is \\(O(\\log n)\\).  \nSince \\(\\sum n\\le2\\cdot10^5\\) over all tests, this easily runs in time.\n\n---\n\n**Java Implementation**\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static BufferedReader in;\n    static StringTokenizer tok;\n\n    // Read next token\n    static String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            String line = in.readLine();\n            if (line == null) return null;\n            tok = new StringTokenizer(line);\n        }\n        return tok.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        tok = null;\n\n        int t = nextInt();\n        StringBuilder sb = new StringBuilder();\n        while (t-- > 0) {\n            int n = nextInt();\n            long k = nextLong();\n            long[] a = new long[n];\n            int[] b = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            for (int i = 0; i < n; i++) {\n                b[i] = nextInt();\n            }\n\n            // Sort all a[] to help find medians quickly\n            long[] all = a.clone();\n            Arrays.sort(all);\n\n            // K = how many elements must be >= d to push the median of an (n-1)-sized array to d\n            int K = n - (n / 2);\n\n            // Precompute M(i) = median of the array with index i removed\n            // We only need M(i) in case A, and it depends on whether a[i] is among\n            // the lowest M = floor(n/2) or not.  One can show:\n            //   Let M = floor(n/2), then\n            //   median(c_i) = (a[i] <= all[M-1] ? all[M] : all[M-1])\n            long Mth   = all[n/2 - 1]; // all[M-1]\n            long M1th  = all[n/2];     // all[M]\n\n            // Build two auxiliaries:\n            // 1) maxBaseIfB1 = max over i with b[i]==1 of (a[i] + median(c_i))\n            // 2) amax0 = max a[i] over i with b[i]==0\n            long maxBaseIfB1 = Long.MIN_VALUE;\n            long amax0 = Long.MIN_VALUE;\n            for (int i = 0; i < n; i++) {\n                long medCi = (a[i] <= Mth ? M1th : Mth);\n                if (b[i] == 1) {\n                    maxBaseIfB1 = Math.max(maxBaseIfB1, a[i] + medCi);\n                } else {\n                    amax0 = Math.max(amax0, a[i]);\n                }\n            }\n\n            // Build a sorted list of a[j] for all j with b[j]==1 (for \"raisable\" elements).\n            // We'll need quick prefix sums on their sorted values.\n            ArrayList<Long> raisable = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                if (b[i] == 1) raisable.add(a[i]);\n            }\n            Collections.sort(raisable);\n            int R = raisable.size();\n            long[] pref = new long[R + 1];\n            for (int i = 0; i < R; i++) {\n                pref[i + 1] = pref[i] + raisable.get(i);\n            }\n\n            // Also keep the fully sorted all[] for fast \"count >= d\" queries:\n            //   cntFree = n - (first index in all[] where value >= d)\n            // We use Arrays.binarySearch for that.\n\n            // A helper that checks if we can achieve score >= D\n            java.util.function.LongPredicate possible = (D) -> {\n                // Case A: pick some i with b[i]==1, invest all k into a[i]\n                // score = maxBaseIfB1 + k\n                if (maxBaseIfB1 != Long.MIN_VALUE && maxBaseIfB1 + k >= D) {\n                    return true;\n                }\n\n                // Case B: must pick i with b[i]==0, invest all k into the median\n                if (amax0 == Long.MIN_VALUE) {\n                    // no b[i]==0 at all => can't do Case B\n                    return false;\n                }\n                long d = D - amax0;  // we require median >= d\n                if (d <= 0) {\n                    // median>=0 is trivial\n                    return true;\n                }\n\n                // count how many a[j] >= d in the *whole* array:\n                int pos = Arrays.binarySearch(all, d);\n                int idx = (pos >= 0 ? pos : -pos-1);\n                int cntFree = n - idx;  // those already >= d\n\n                // But we must exclude the chosen i0 if amax0>=d,\n                // because i0 has b[i0]==0 so not in \"raisable\" anyway.\n                if (amax0 >= d) cntFree--;\n\n                // count how many are < d but b[j]==1 (the raisable group)\n                int cntRaisable = Collections.binarySearch(raisable, d) >= 0\n                        ? Collections.binarySearch(raisable, d)\n                        : -Collections.binarySearch(raisable, d) - 1;\n\n                // can we gather ≥K elements total?\n                if (cntFree + cntRaisable < K) return false;\n\n                // we need to promote (K - cntFree) of the raisable ones\n                int need = Math.max(0, K - Math.max(0, cntFree));\n                if (need > cntRaisable) return false;\n\n                // cost = sum_{i<need} (d - a_raisable[i])\n                //      = need*d - sum of first {need} a_raisable[i]\n                long sumSmall = pref[need];\n                long cost = need * d - sumSmall;\n                return cost <= k;\n            };\n\n            // Binary search the largest D for which possible(D)==true\n            long lo = 0, hi = (long)2e18;\n            while (lo < hi) {\n                long mid = (lo + hi + 1) >>> 1;\n                if (possible.test(mid)) {\n                    lo = mid;\n                } else {\n                    hi = mid - 1;\n                }\n            }\n\n            sb.append(lo).append('\\n');\n        }\n\n        System.out.print(sb);\n    }\n}\n```\n\n**Explanation of the main steps**\n\n1. **Pre-sorting**  \n   We sort `all[] = a.clone()` so we can in \\(O(\\log n)\\) count how many are \\(\\ge d\\).  \n\n2. **Computing \\(M(i)\\)**  \n   Removing one element from a sorted array of length \\(n\\) to get length \\(n-1\\) shifts the median in a simple way:\n   \\[\n     M = \\left\\lfloor\\frac n2\\right\\rfloor,\n     \\quad\n     M(i) \\;=\\; \n       \\begin{cases}\n         \\text{all}[M] & \\text{if }a_i \\le\\text{all}[M-1],\\\\\n         \\text{all}[M-1] & \\text{otherwise.}\n       \\end{cases}\n   \\]\n   Thus we only need the two array entries `all[M-1]` and `all[M]`.\n\n3. **Case A (center has \\(b_i=1\\))**  \n   We invest all \\(k\\) ops in that center.  Its score becomes  \n   \\[\n     a_i + k + M(i).\n   \\]\n   We take the maximum over all those \\(i\\).  Call it `maxBaseIfB1 + k.`\n\n4. **Case B (center has \\(b_i=0\\))**  \n   We pick the zero‐bit with *largest* \\(a_i\\) (call it `amax0`)—it dominates any smaller one—and see if by expending all \\(k\\) operations on the *median* of the other \\(n-1\\) values we can push that median up to at least\n   \\[\n     d = D - a_{i_0}.\n   \\]\n   To raise the median by 1, we must raise the \\(K\\) elements that occupy the “lower half” of size \\(n-1\\).  Among those \\(K\\) positions, some may already be \\(\\ge d\\) (no cost), the rest must come from positions with \\(b_j=1\\) and \\(a_j<d\\).  We pick the cheapest such \\(K-\\text{(already free)}\\) elements, sum their \\((d - a_j)\\), and see if it \\(\\le k\\).  A single binary search on `all[]` plus prefix‐sum‐lookups in a sorted list of “raisable” values yields an \\(O(\\log n)\\) check.\n\n5. **Binary search**  \n   We binary‐search \\(D\\in[0,2\\cdot10^{18}]\\).  If either Case A or Case B “succeeds” at mid‐value \\(D\\), we move up; otherwise we move down.  Finally the low‐end is the maximum feasible score.\n\nThis runs in \\(O(n\\log n + \\log(\\text{value})\\cdot\\log n)\\) per test, which is easily under the CF 3-second limit for \\(\\sum n\\le 2\\times10^5\\)."
  },
  {
    "role": "user",
    "content": "The code’s binary‐search calls for counting elements ≥ d and < d are incorrect when there are duplicates (and you call binarySearch twice). Please fix by implementing proper `lowerBound` on the sorted arrays (one for `all[]`, one for `raisable[]`) so you get the first index where `val >= d`, then compute counts from that. Then provide a single Java code block ready for submission."
  },
  {
    "role": "assistant",
    "content": "Below is a ready‐to‐submit Java solution.  It replaces the two calls to `Collections.binarySearch` with a proper `lowerBound` on sorted `long[]`’s, so that counting “\\(\\ge d\\)” and “\\(<d\\)” is robust even with duplicates.\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static BufferedReader in;\n    static StringTokenizer tok;\n\n    static String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            String line = in.readLine();\n            if (line == null) return null;\n            tok = new StringTokenizer(line);\n        }\n        return tok.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    // Returns first index i in arr[] such that arr[i] >= key,\n    // or arr.length if all elements < key.\n    static int lowerBound(long[] arr, long key) {\n        int lo = 0, hi = arr.length;\n        while (lo < hi) {\n            int mid = (lo + hi) >>> 1;\n            if (arr[mid] < key) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        tok = null;\n\n        int t = nextInt();\n        StringBuilder sb = new StringBuilder();\n        while (t-- > 0) {\n            int n = nextInt();\n            long k = nextLong();\n            long[] a = new long[n];\n            int[] b = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            for (int i = 0; i < n; i++) {\n                b[i] = nextInt();\n            }\n\n            // Sort a copy so we can do medians and >= d counts quickly\n            long[] all = a.clone();\n            Arrays.sort(all);\n\n            // K = how many elements must be >= d to raise the median of an (n-1)-array\n            int K = n - (n/2);\n\n            // Precompute the two key positions in 'all' for median-with-one-removed:\n            // Mth = all[floor(n/2)-1], M1th = all[floor(n/2)]\n            long Mth  = all[n/2 - 1];\n            long M1th = all[n/2];\n\n            // Case A preprocessing:\n            // maxBaseIfB1 = max over i with b[i]==1 of (a[i] + median(c_i))\n            long maxBaseIfB1 = Long.MIN_VALUE;\n            // Case B preprocessing:\n            // amax0 = max a[i] among those with b[i]==0\n            long amax0 = Long.MIN_VALUE;\n\n            for (int i = 0; i < n; i++) {\n                long medCi = (a[i] <= Mth ? M1th : Mth);\n                if (b[i] == 1) {\n                    maxBaseIfB1 = Math.max(maxBaseIfB1, a[i] + medCi);\n                } else {\n                    amax0 = Math.max(amax0, a[i]);\n                }\n            }\n\n            // Build the list of raisable values (those with b[i]==1),\n            // sort them, build prefix sums.\n            ArrayList<Long> list = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                if (b[i] == 1) list.add(a[i]);\n            }\n            Collections.sort(list);\n            int R = list.size();\n            long[] rais = new long[R];\n            long[] pref = new long[R+1];\n            for (int i = 0; i < R; i++) {\n                rais[i] = list.get(i);\n                pref[i+1] = pref[i] + rais[i];\n            }\n\n            // A predicate that checks if we can achieve score >= D\n            java.util.function.LongPredicate canAchieve = (D) -> {\n                // --- Case A: pick i with b[i]==1, invest all k in a[i]\n                if (maxBaseIfB1 != Long.MIN_VALUE && maxBaseIfB1 + k >= D) {\n                    return true;\n                }\n\n                // --- Case B: pick i0 with b[i0]==0, invest all k in the median of the others\n                if (amax0 == Long.MIN_VALUE) {\n                    // no zero-bit index => can't do case B\n                    return false;\n                }\n                long d = D - amax0;\n                if (d <= 0) {\n                    // needing median >=0 is always free\n                    return true;\n                }\n\n                // Count how many are already >= d in the whole array:\n                int idxAll = lowerBound(all, d);\n                int cntFree = (n - idxAll);\n                // exclude the chosen i0 if it was among those >= d\n                if (amax0 >= d) cntFree--;\n\n                // Count how many are < d but raisable (b[j]==1)\n                int idxR = lowerBound(rais, d);\n                int cntRaisable = idxR;  // those at indices [0..idxR-1]\n\n                if (cntFree + cntRaisable < K) {\n                    return false;\n                }\n                int need = Math.max(0, K - Math.max(0, cntFree));\n                if (need > cntRaisable) {\n                    return false;\n                }\n                // cost = sum_{i<need} (d - rais[i]) = need*d - sum(ra[i])\n                long sumSmall = pref[need];\n                long cost = need * d - sumSmall;\n                return cost <= k;\n            };\n\n            // Binary‐search the maximum D for which canAchieve(D) is true\n            long lo = 0, hi = (long)2e18;\n            while (lo < hi) {\n                long mid = (lo + hi + 1) >>> 1;\n                if (canAchieve.test(mid)) {\n                    lo = mid;\n                } else {\n                    hi = mid - 1;\n                }\n            }\n\n            sb.append(lo).append('\\n');\n        }\n\n        System.out.print(sb);\n    }\n}\n```\n\nExplanation of the fixes:\n\n1. We convert the “raisable” values into a primitive `long[] rais[]` so we can do an \\(O(\\log R)\\) custom `lowerBound` on it.\n2. We also use the same `lowerBound` on the fully sorted `all[]` to count how many elements \\(\\ge d\\).\n3. Counting  \n   - `cntFree = n − lowerBound(all, d)` gives how many \\(a_j\\ge d\\).  \n   - `cntRaisable = lowerBound(rais, d)` gives how many \\(a_j<d\\) among the raisable group.\n4. We then check if we can fill the required \\(K\\) “slots” to push the median up to \\(d\\) with at most \\(k\\) operations.\n\nThis runs in \\(O(n\\log n + \\log(\\text{answer})\\times \\log n)\\) per test, and handles duplicates correctly."
  },
  {
    "role": "system",
    "content": "Identify any errors in this response and output a prompt to help the AI resolve said issues. Your response MUST be in one of two formats: 1. If the response looks perfect, return \"Perfect\". Do not return this if there are any issues. Use this very sparingly as any errors in the final output from the AI will be considered a failure on your part. 2. Otherwise, return \"{prompt}\" where {prompt} is replaced with your concise prompt. This should be done most often, even if the AI's response is mostly correct. Ensure the entire response is enclosed in double quotations if it's a prompt. Make sure your prompt asks the AI to return one block of code for submission."
  },
  {
    "role": "assistant",
    "content": "Perfect"
  }
]