[
  {
    "timestamp": "2025-07-24T05:48:20.231852",
    "role": "user",
    "content": "D. Med-imize\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nGiven two positive integers n\n\n and k\n\n, and another array a\n\n of n\n\n integers.\n\n\n\nIn one operation, you can select any subarray of size k\n\n of a\n\n, then remove it from the array without changing the order of other elements. More formally, let (l,r)\n\n be an operation on subarray al,al+1,…,ar\n\n such that r−l+1=k\n\n, then performing this operation means replacing a\n\n with [a1,…,al−1,ar+1,…,an]\n\n.\n\n\n\nFor example, if a=[1,2,3,4,5]\n\n and we perform operation (3,5)\n\n on this array, it will become a=[1,2]\n\n. Moreover, operation (2,4)\n\n results in a=[1,5]\n\n, and operation (1,3)\n\n results in a=[4,5]\n\n.\n\n\n\nYou have to repeat the operation while the length of a\n\n is greater than k\n\n (which means |a|>k\n\n). What is the largest possible median†\n\n of all remaining elements of the array a\n\n after the process?\n\n\n\n†\n\nThe median of an array of length n\n\n is the element whose index is ⌊(n+1)/2⌋\n\n after we sort the elements in non-decreasing order. For example: median([2,1,5,4,3])=3\n\n, median([5])=5\n\n, and median([6,8,2,4])=4\n\n.\n\n\n\nInput\n\nThe first line contains a single integer t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nThe first line of each test case contains two integers n\n\n and k\n\n (1≤n,k≤5⋅105\n\n).\n\n\n\nThe second line contains n\n\n integers a1,a2,…,an\n\n (1≤ai≤109\n\n) — the array a\n\n.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 5⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, print a single integer — the largest median possible after performing the operations.\n\n\n\nExample\n\nInputCopy\n\n5\n\n4 3\n\n3 9 9 2\n\n5 3\n\n3 2 5 6 4\n\n7 1\n\n5 9 2 6 5 4 6\n\n8 2\n\n7 1 2 6 8 3 4 5\n\n4 5\n\n3 4 5 6\n\nOutputCopy\n\n3\n\n4\n\n9\n\n6\n\n4\n\nNote\n\nIn the first test case, you can select a subarray (l,r)\n\n which can be either (1,3)\n\n or (2,4)\n\n. Thus, two obtainable final arrays are [3]\n\n and [2]\n\n. The former one has the larger median (3>2\n\n) so the answer is 3\n\n.\n\n\n\nIn the second test case, three obtainable final arrays are [6,4]\n\n, [3,4]\n\n, and [3,2]\n\n. Their medians are 4\n\n, 3\n\n, and 2\n\n respectively. The answer is 4\n\n.\n\n\n\nIn the third test case, only one element is left in the final array and it can be any element of the initial array. The largest one among them is 9\n\n, so the answer is 9\n\n.\n\nUse Java."
  },
  {
    "timestamp": "2025-07-24T05:51:14.619904",
    "role": "assistant",
    "content": "**Analysis**\n\nWe have an array a of length n and a positive integer k.  At each step, if the current length of the array is still greater than k we must delete a contiguous block of exactly k elements.  Eventually the array shrinks to length\n\n  m =  \n    n,      if n ≤ k  \n    n mod k, if n > k and n mod k > 0  \n    k,     if n > k and n mod k = 0  \n\n(One checks that when n > k, deleting exactly t = ⌈(n−k)/k⌉ blocks of size k leaves m = n − t·k elements, and this m is exactly what the formula above gives.)\n\nWe then must choose exactly one element to keep from each of the first m residue‐classes modulo k (namely positions whose 1-based index is ≡1,2,…,m (mod k)).  One can show that *any* valid sequence of k-deletions that ends with exactly **m** survivors has picked exactly one surviving element from each of these m residue‐classes.  Hence the final array of size m consists of exactly one element from each class.\n\nWe now want the resulting **median** of that final m-element array to be as large as possible.  Since the final array has length m, its median index is\n\n  med_idx = ⌊(m+1)/2⌋  (1‐based)\n\nbut the condition “median ≥ X” means that *all* of the first med_idx elements (after sorting) are ≥ X.  Equivalently, the number of survivors ≥ X must be at least\n\n  need = m − med_idx + 1 = ⌈(m+1)/2⌉  \n  (which is equal to ⌊m/2⌋+1).\n\nTo maximize that median, we simply look *within each residue class* to see the largest element we could choose from that class.  Denote\n\n  M[j] = the maximum of all a[i] with i ≡ j (mod k),\n\nfor j = 1,2,…,m.  We must pick exactly one survivor from each class, and in as many of them as possible we’d like to pick something ≥ X.  Thus to test a candidate X we count how many of the M[j] ≥ X;  we need at least **need** of them.  \n\nBut instead of binary‐searching X, we observe that the best we can do is to sort the array M[1…m] in descending order and pick the **need-th largest** of the M[j].  That value is our answer.\n\nOverall each test case takes:\n\n- O(n) to bucket into the k classes (but we only need the first m ≤ k).\n- O(m log m) to sort the m maxima.\n- Constant extra.\n\nSince ∑n ≤ 5·10^5 over all test cases, this runs easily in time.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        FastReader in = new FastReader();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int t = in.nextInt();\n        while (t-- > 0) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n            }\n\n            // Compute final size m\n            int m;\n            if (n <= k) {\n                m = n;\n            } else {\n                int r = n % k;\n                m = (r == 0 ? k : r);\n            }\n\n            // For j = 1..m, find the maximum in positions i ≡ j (mod k)\n            // We'll store them in an array of length m, 0-based indexed.\n            int[] M = new int[m];\n            Arrays.fill(M, Integer.MIN_VALUE);\n            for (int j = 0; j < m; j++) {\n                // class (j+1) mod k => positions j, j+k, j+2k, ...\n                for (int pos = j; pos < n; pos += k) {\n                    M[j] = Math.max(M[j], a[pos]);\n                }\n            }\n\n            // We need at least `need = floor(m/2) + 1` classes whose max >= X\n            // Sorting M descending and taking the need-th largest does the job.\n            Arrays.sort(M);        // ascending\n            int need = (m / 2) + 1;\n            // the need-th largest in an ascending array is at index m - need\n            int answer = M[m - need];\n\n            out.println(answer);\n        }\n\n        out.flush();\n    }\n\n    // Fast input reader\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = br.readLine();\n                if (s == null) return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Final array length `m`.**  \n   One can show that if you must keep deleting blocks of size k until the length is at most k, you end up with  \n   &nbsp;&nbsp;• m = n if n ≤ k  \n   &nbsp;&nbsp;• otherwise m = n mod k, unless n mod k = 0 in which case you get exactly k survivors.\n\n2. **Residue classes.**  \n   A standard “block‐removal” argument shows that *exactly one* element survives in each of the first m residue classes of the form { i ∣ i≡1,2,…,m (mod k) }.\n\n3. **Max per class.**  \n   In class j (1-based), the best choice of a survivor is simply  \n     \\( M[j] = \\max\\{\\,a[i]\\mid i\\equiv j\\pmod k\\}\\,. \\)\n\n4. **Finding the maximum median.**  \n   A final array of size m has median index `floor((m+1)/2)`.  In order for that median to be at least X, at least  \n   \\[\n     \\text{need} \\;=\\;\\bigl\\lceil\\frac{m+1}{2}\\bigr\\rceil\n   \\]\n   of the survivors must be ≥ X.  Hence to get the largest possible X, we sort the m values `M[1…m]` in descending order and pick the `need`-th largest.\n\nThis runs in O(n + m log m) per test, and ∑n≤5⋅10^5 ensures it is fast enough for the given limits."
  }
]