**Analysis**

We are given an array a of length n and a fixed window‐size k.  We define for any subarray b

- an operation is to pick a single position i in b and overwrite b_i with any integer of our choice;
- \(f(b)\) = the minimum number of these operations needed so that \(b\) contains somewhere a contiguous “consecutive” run of length at least k, i.e. \(b_s,b_{s+1},\dots,b_{s+k-1}\) such that 
\[
\forall j\in[s,s+k-1]:\;b_j = b_{j-1} + 1.
\]

Yunli asks many queries \((\ell,r)\) with \(r\ge \ell + k-1\).  Each query wants
\[
\sum_{j=\ell+k-1}^r f\bigl(a_\ell,a_{\ell+1},\dots,a_j\bigr).
\]

We must answer up to \(2\times10^5\) total \(n\)-entries and \(2\times10^5\) total queries over all test‐cases in about 3 s.  A straightforward DP over all subarrays is too big.

---

### 1. Reducing \(f(b)\) to a “sliding‐mode” problem

First observe that to enforce
\[
b_s,b_{s+1},\dots,b_{s+k-1}
\]
to be exactly an increasing-by‐1 run, we must make
\[
b_{s+j} \;-\; (s+j)
\quad\text{all equal for }j=0,\dots,k-1.
\]
Define
\[
C_i \;=\; a_i - i.
\]
In any window of length \(k\), to make all \(C_{s},C_{s+1},\dots,C_{s+k-1}\) equal we need to overwrite all but the most‐frequent value.  Hence the number of operations in that window is
\[
k \;-\;\bigl(\text{frequency of the mode of }C\text{ in that window}\bigr).
\]
Taking the minimum over all window‐starts \(s\) inside our subarray is exactly
\[
f(b)
=\min_{s}s\;-\;\bigl(\max_{s}\,\{\text{mode‐count in window }s\}\bigr)
= k \;-\;\bigl(\max_{s}\{\text{mode‐count in window }s\}\bigr).
\]

Thus, if we let
\[
w_s 
= \max\bigl\{\text{frequency of any value in }C_s,C_{s+1},\dots,C_{s+k-1}\bigr\},
\qquad
s=1,2,\dots,n-k+1,
\]
then any prefix \((a_\ell,\dots,a_j)\) with \(j\ge \ell+k-1\) has
\[
f\bigl(a_\ell,\dots,a_j\bigr)
= k \;-\; \max_{s=\ell,\dots,j-k+1} w_s.
\]
Define the array \(W\) of length \(M=n-k+1\) by
\[
W[s]=w_s,\;s=1,\dots,M.
\]
Then for a fixed \(\ell\) and \(j\ge \ell+k-1\) we set
\[
L=\ell,\quad
R=j-k+1,\quad
f(\ell,j)=k \;-\;\max_{s=L}^R W[s].
\]
We want for each query \((\ell,r)\):
\[
\sum_{j=\ell+k-1}^r f(\ell,j).
\]
Let
\[
S(L,R)\;=\;\sum_{i=L}^R\max_{s=L}^i W[s]
\]
be the sum of the running‐maxima of \(W[L],W[L+1],\dots,W[R]\).  Then
\[
\sum_{j=\ell+k-1}^r f(\ell,j)
=\sum_{i=L}^R \bigl(k - \max_{s=L}^i W[s]\bigr)
=(R-L+1)\,k \;-\;S(L,R),
\]
where \(L=\ell\) and \(R=r-k+1\).

Hence each query \((\ell,r)\) reduces to computing
\[
(R-L+1)\,k \;-\; S(L,R),
\]
where
\[
S(L,R)=\sum_{i=L}^R \bigl(\max_{s=L}^i W[s]\bigr).
\]

---

### 2. Preprocessing the mode‐counts \(w_s\) in \(O(n)\)

We must build \(W[1..M]\) quickly.  Notice
\[
C_i = a_i - i,
\]
so \(C\) has ~\-\(n\)\[to\]n range.  We first compress all \(C_i\) to \(\{0,1,\dots,U-1\}\).  

Then we run a classic “sliding window mode” of window‐size \(k\):

- Maintain an array `cnt[val] =` how many times `val` is in the current window.
- Also maintain `freqCount[c]` = how many distinct values currently have count exactly \(c\).
- Keep track of `currentMode` = the largest \(c\) with `freqCount[c]>0`.

Initialize with the first window \(C_1,\dots,C_k\) in \(O(k)\).  Then slide from \(s=2\) to \(M\), removing \(C_{s-1}\), adding \(C_{s+k-1}\), each in \(O(1)\) updating of `cnt` and `freqCount`, keeping `currentMode`.  At each slide we set
\[
w_s = \text{currentMode}.
\]
This whole pass is \(O(n)\).

---

### 3. Answering range‐queries \(\sum_{i=L}^R\max(W[L..i])\) in \(O(\log n)\)

Fix the array \(W[1..M]\).  We build the “next‐greater‐to‐right” array
\[
\text{nxt}[i]
= \min\{j>i:W[j]>W[i]\},
\]
or \(M+1\) if none.  This we get in \(O(M)\) by a stack.  

Consider the “chain” of prefix‐maxima starting at \(i\):
\[
i = u_0 < u_1 < u_2 < \dots < u_k,
\]
where each \(u_{r+1} = \text{nxt}[u_r]\) is the next place the max strictly increases.  
On any interval \([L,R]\), the sequence \(\max_{s=L}^iW[s]\) is piecewise‐constant on the blocks \([u_r,\;u_{r+1}-1]\).  
In particular
\[
\sum_{i=L}^R \max_{s=L}^i W[s]
= \sum_{r:\,u_r\le R} 
   W[u_r]\; \bigl(\min(u_{r+1},R+1)-u_r\bigr).
\]
We can simulate walking up the chain of “next‐greater” using binary‐lifting:

- Let `parent[i][0] = nxt[i]` and `fullSum[i][0] = W[i]*(nxt[i]-i)`.
- Build \(parent[i][j],\;fullSum[i][j]\) for \(j=1..{\lfloor\log M\rfloor}\) in the usual doubling way.

To compute \(S(L,R)\), we start `cur=L`, `acc=0`.  We scan \(j\) from large to 0 and see if we can jump `2^j` steps without exceeding \(R\).  Precisely:

```
for (j=LOG-1 down to 0) {
  if (parent[cur][j] <= R) {
    acc += fullSum[cur][j]; 
    cur = parent[cur][j];
  }
}
```
After this loop, `cur` is the last block‐start \(u_k \le R\) whose `nxt[cur]` goes *beyond* \(R\).  We still owe a “partial block”  
\(\;W[cur]\times\bigl(R+1 - cur\bigr)\).  Hence
\[
S(L,R)=\textit{acc}\;+\;W[\textit{cur}]\times\bigl(R+1-\textit{cur}\bigr).
\]
Finally the query’s answer is
\[
(R-L+1)\times k \;-\; S(L,R).
\]

Each query costs \(O(\log n)\).  We have \(O(n)\) preprocessing plus \(O(q\log n)\) over all queries, which comfortably fits under the given limits.

---

```java
import java.io.*;
import java.util.*;

public class Main {
    static final int MAXN = 200_000 + 5;
    static final int LOG = 18;  // enough for 2e5

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder out = new StringBuilder();
        StringTokenizer st;

        int T = Integer.parseInt(br.readLine());
        // Scratch arrays, reused across test‐cases
        int[] a = new int[MAXN];
        int[] C = new int[MAXN];
        int[] Cvals = new int[MAXN];
        int[] Cc = new int[MAXN];
        int[] cnt = new int[MAXN];
        int[] freqCount = new int[MAXN];
        int[] w = new int[MAXN];
        int[][] parent = new int[LOG][MAXN];
        long[][] fullSum = new long[LOG][MAXN];
        int[] stack = new int[MAXN];  // for next‐greater

        for (int _case = 0; _case < T; _case++) {
            st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            int k = Integer.parseInt(st.nextToken());
            int q = Integer.parseInt(st.nextToken());

            // read a[1..n]
            st = new StringTokenizer(br.readLine());
            for (int i = 1; i <= n; i++) {
                a[i] = Integer.parseInt(st.nextToken());
            }
            // build C[i] = a[i] - i
            for (int i = 1; i <= n; i++) {
                C[i] = a[i] - i;
            }
            // compress C to [0..U-1]
            System.arraycopy(C, 1, Cvals, 1, n);
            Arrays.sort(Cvals, 1, n + 1);
            int U = 0;
            for (int i = 1; i <= n; i++) {
                if (i == 1 || Cvals[i] != Cvals[i - 1]) {
                    U++;
                    Cvals[U] = Cvals[i];
                }
            }
            for (int i = 1; i <= n; i++) {
                int x = C[i];
                // binary search in Cvals[1..U]
                int idx = Arrays.binarySearch(Cvals, 1, U + 1, x);
                Cc[i] = idx;
            }

            // Build w[s] = mode‐count of window Cc[s..s+k-1]
            // reset cnt[0..U-1] = 0
            for (int i = 1; i <= U; i++) cnt[i] = 0;
            // freqCount up to k
            for (int i = 1; i <= k; i++) freqCount[i] = 0;

            int modeFreq = 0;
            // add function
            // c_old = cnt[x], c_new = c_old+1,
            // if c_old>=1 freqCount[c_old]--, freqCount[c_new]++, update modeFreq
            // remove similarly
            for (int i = 1; i <= k; i++) {
                int x = Cc[i];
                int c0 = cnt[x]++;
                if (c0 >= 1) freqCount[c0]--;
                freqCount[c0 + 1]++;
                if (c0 + 1 > modeFreq) modeFreq = c0 + 1;
            }
            int M = n - k + 1;
            w[1] = modeFreq;

            for (int s = 2; s <= M; s++) {
                // remove Cc[s-1]
                {
                    int x = Cc[s - 1];
                    int c0 = cnt[x];
                    freqCount[c0]--;
                    cnt[x]--;
                    if (c0 - 1 >= 1) freqCount[c0 - 1]++;
                    if (freqCount[modeFreq] == 0) modeFreq--;
                }
                // add Cc[s+k-1]
                {
                    int x = Cc[s + k - 1];
                    int c0 = cnt[x]++;
                    if (c0 >= 1) freqCount[c0]--;
                    freqCount[c0 + 1]++;
                    if (c0 + 1 > modeFreq) modeFreq = c0 + 1;
                }
                w[s] = modeFreq;
            }

            // Build next‐greater-to-right in w[1..M]
            int top = 0;
            for (int i = M; i >= 1; i--) {
                while (top > 0 && w[stack[top - 1]] <= w[i]) top--;
                parent[0][i] = (top == 0 ? M + 1 : stack[top - 1]);
                stack[top++] = i;
            }
            // sentinel
            parent[0][M + 1] = M + 1;

            // build fullSum[0][i] = w[i]*(parent[0][i] - i)
            for (int i = 1; i <= M; i++) {
                fullSum[0][i] = (long)w[i] * (parent[0][i] - i);
            }
            fullSum[0][M + 1] = 0;

            // binary‐lift
            for (int lvl = 1; lvl < LOG; lvl++) {
                for (int i = 1; i <= M + 1; i++) {
                    int p = parent[lvl - 1][i];
                    parent[lvl][i] = parent[lvl - 1][p];
                    fullSum[lvl][i] = fullSum[lvl - 1][i] + fullSum[lvl - 1][p];
                }
            }

            // answer queries
            while (q-- > 0) {
                st = new StringTokenizer(br.readLine());
                int L = Integer.parseInt(st.nextToken());
                int Rbig = Integer.parseInt(st.nextToken());
                int R = Rbig - k + 1;  // endpoints in w‐space
                int len = R - L + 1;

                long acc = 0;
                int cur = L;
                // jump up the "next greater" chain as far as possible
                for (int lvl = LOG - 1; lvl >= 0; lvl--) {
                    int p = parent[lvl][cur];
                    if (p <= R) {
                        acc += fullSum[lvl][cur];
                        cur = p;
                    }
                }
                // partial block at the end
                acc += (long)w[cur] * ( (R + 1L) - cur );

                long ans = (long)len * k - acc;
                out.append(ans).append('\n');
            }
        }

        System.out.print(out.toString());
    }
}
```

**Explanation of the main steps**

1. **Compute** \(C_i = a_i - i\).  
2. **Compress** the \(C_i\) into a small range \([0..U-1]\).  
3. **Sliding‐window “mode‐count”** of length \(k\) in \(O(n)\):  
   - Maintain `cnt[val]` = count of each compressed value in the window,  
   - `freqCount[c]` = how many values appear exactly `c` times,  
   - `modeFreq` = the current highest `c` with `freqCount[c]>0`.  
   This gives us  
   \[
     w_s = \max\{\text{freq of any }C\text{-value in }C_s\ldots C_{s+k-1}\}.
   \]
4. **Next‐greater‐to‐right** on the array \(W[1..M]\) (\(M=n-k+1\)) in \(O(M)\) using a stack:
   \[
     \text{nxt}[i] = \min\{j>i: W[j]>W[i]\} \quad(\text{or }M+1).
   \]
5. **Binary‐lifting** on the “nxt” pointers.  We store  
   \(\texttt{parent}[0][i]=\text{nxt}[i]\) and
   \(\texttt{fullSum}[0][i] = W[i]\times(\text{nxt}[i]-i)\),  
   then build up to \(\texttt{parent}[j],\texttt{fullSum}[j]\) for \(2^j\)-steps.  
6. **Answer query** \((\ell,r)\):  
   - In terms of \(W\), let \(L=\ell\), \(R=r-k+1\).  
   - We need 
     \(\sum_{i=L}^R \max_{s=L}^i W[s]\).  
   - We jump up the “next‐greater” chain by largest \(2^j\)-steps that stay \(\le R\), summing the full‐blocks in `acc`.  
   - Finally add the “partial” last block: \(W[cur]\times((R+1)-cur)\).  
   - The query answer is \((R-L+1)\cdot k\;-\)\(that\_sum\).  

All preprocessing is \(O(n\!+\!k)\), building the `next` array is \(O(n)\), binary‐lifting is \(O(n\log n)\), and each of the \(q\) queries in \(O(\log n)\), which fits easily under the given constraints.