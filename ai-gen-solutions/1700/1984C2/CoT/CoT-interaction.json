[
    {
        "request_timestamp": "2025-07-23T18:23:34.331125",
        "response_timestamp": "2025-07-23T18:26:31.795745",
        "sent_messages": [
            {
                "role": "user",
                "content": "Codeforces Problem:\n\nC2. Magnitude (Hard Version)\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nThe two versions of the problem are different. You may want to read both versions. You can make hacks only if both versions are solved.\n\n\n\nYou are given an array a\n\n of length n\n\n. Start with c=0\n\n. Then, for each i\n\n from 1\n\n to n\n\n (in increasing order) do exactly one of the following:\n\n\n\nOption 1\n\n: set c\n\n to c+ai\n\n.\n\nOption 2\n\n: set c\n\n to |c+ai|\n\n, where |x|\n\n is the absolute value of x\n\n.\n\nLet the maximum final value of c\n\n after the procedure described above be equal to k\n\n. Find the number of unique procedures that result in c=k\n\n. Two procedures are different if at any index i\n\n, one procedure chose option 1\n\n and another chose option 2\n\n, even if the value of c\n\n is equal for both procedures after that turn.\n\n\n\nSince the answer may be large, output it modulo 998244353\n\n.\n\n\n\nInput\n\nThe first line contains a single integer t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nThe first line of each test case contains a single integer n\n\n (2≤n≤2⋅105\n\n).\n\n\n\nThe second line of each test case contains n\n\n integers a1,a2,…,an\n\n (−109≤ai≤109\n\n).\n\n\n\nThe sum of n\n\n over all test cases does not exceed 3⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output a single integer — the number of unique procedures that result in c=k\n\n, modulo 998244353\n\n.\n\n\n\nExample\n\nInputCopy\n\n5\n\n4\n\n2 -5 3 -3\n\n8\n\n1 4 3 4 1 4 3 4\n\n3\n\n-1 -2 -3\n\n4\n\n-1000000000 1000000000 1000000000 1000000000\n\n4\n\n1 9 8 4\n\nOutputCopy\n\n12\n\n256\n\n1\n\n8\n\n16\n\nNote\n\nIn the first test case, it can be shown that our maximal final value of c\n\n is 3\n\n. There are 12\n\n ways to achieve this because in order to get 3\n\n, we have to take absolute value at indices 2\n\n or 4\n\n, or both, resulting in 3\n\n ways. For the other two indices, it doesn't change the value whether we take absolute value or not, so we have 2⋅2=4\n\n ways for them. In total, we have 3⋅4=12\n\n ways.\n\n\n\nIn the second test case, taking the absolute value will never change anything, so we can either take absolute value or not, for every index. This gives us 28=256\n\n possible ways.\n\n---\n\nLet's think step-by-step so we don't make mistakes. Use Java. Avoid syntax errors or infinite loops."
            }
        ],
        "received_response": "{\n  \"id\": \"chatcmpl-BwcA5BwKsQX9WigaWCTKlqUnJPIFa\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"**Analysis**\\n\\nLet \\n\\\\(S_i = a_1 + a_2 + \\\\cdots + a_i\\\\)\\nbe the prefix‐sums of the array, and let\\n\\\\[\\n\\\\min S = \\\\min_{1\\\\le i\\\\le n} S_i.\\n\\\\]\\nWe claim:\\n\\n1.  The maximum achievable final value \\n   \\\\[\\n     c_n\\n   \\\\]\\n   is\\n   \\\\[\\n     k \\\\;=\\\\;\\n     \\\\begin{cases}\\n       S_n, & \\\\min S \\\\ge 0,\\\\\\\\\\n       S_n + 2\\\\bigl(-\\\\min S\\\\bigr), & \\\\min S<0.\\n     \\\\end{cases}\\n   \\\\]\\n   Equivalently when all prefixes are nonnegative we never gain anything by any \\\\(\\\\lvert\\\\cdot\\\\rvert\\\\)-operation (so we end up with \\\\(S_n\\\\)), and if the smallest prefix sum is \\\\(\\\\min S<0\\\\), then one optimal strategy is to “flip” exactly at one index \\\\(j\\\\) where \\\\(S_j=\\\\min S\\\\), which increases the final sum by \\\\(2(-\\\\min S)\\\\).\\n\\n2.  If \\\\(\\\\min S\\\\ge0\\\\), every choice of “take abs or not” at each of the \\\\(n\\\\) positions produces exactly the final value \\\\(S_n\\\\), so the answer is simply\\n\\\\[\\n   2^n \\\\pmod{998244353}.\\n\\\\]\\n   (Even if \\\\(\\\\lvert c_{i-1}+a_i\\\\rvert\\\\) or not makes no numeric change when \\\\(c_{i-1}+a_i\\\\ge0\\\\), each position still offers 2 distinct choices.)\\n\\n3.  If \\\\(\\\\min S<0\\\\), write\\n\\\\[\\n   M = -\\\\,\\\\min S > 0,\\n   \\\\quad\\n   k = S_n + 2M.\\n\\\\]\\n   Let\\n\\\\[\\n   P = \\\\{\\\\,j\\\\mid S_j = \\\\min S\\\\}\\n\\\\]\\n   be the set of all indices \\\\(j\\\\) where the running sum achieves its global minimum.  One can show that **any** procedure that (a) does not apply a “\\\\(\\\\lvert\\\\cdot\\\\rvert\\\\)” on any earlier negative prefix and then (b) does apply a “\\\\(\\\\lvert\\\\cdot\\\\rvert\\\\)” at exactly one \\\\(j\\\\in P\\\\), and (c) afterwards can do anything, will end up with \\\\(c_n=k\\\\).  All other procedures end up strictly below \\\\(k\\\\).\\n\\n   -  Before that chosen \\\\(j\\\\), every time \\\\(S_i<0\\\\) you must choose “no‐abs” (otherwise you would flip an earlier prefix and ruin getting the true minimum).  But whenever \\\\(S_i\\\\ge0\\\\), abs‐or‐no‐abs makes no numeric difference, so you get a factor of \\\\(2\\\\).\\n   -  At the chosen \\\\(j\\\\in P\\\\), you **must** take the abs so as to flip that minimum prefix.  (Exactly one choice.)\\n   -  After index \\\\(j\\\\), the partial sum is always \\\\(\\\\ge0\\\\) (you have lifted it up by \\\\(2M\\\\)), so from then on each position again contributes a factor of \\\\(2\\\\) (abs or not gives the same result).\\n\\n   Hence for each \\\\(j\\\\in P\\\\) the number of ways is\\n   \\\\[\\n     2^{\\\\#\\\\{\\\\,1\\\\le i<j: S_i\\\\ge0\\\\}}\\\\;\\\\times\\\\;1\\\\;\\\\times\\\\;2^{\\\\,n-j}\\n     \\\\;=\\\\;\\n     2^{(j-1 - \\\\#\\\\{i<j:S_i<0\\\\}) + (n-j)}\\n     \\\\;=\\\\;\\n     2^{\\\\,n - 1 - \\\\#\\\\{i<j:S_i<0\\\\}\\\\!}\\\\,.\\n   \\\\]\\n   Summing over all \\\\(j\\\\in P\\\\) gives the total count of maximum‐ending procedures.\\n\\nOverall algorithm per test:\\n\\n1.  Read \\\\(n\\\\) and the array \\\\(a\\\\).\\n2.  Compute prefix‐sums \\\\(S_1,\\\\dots,S_n\\\\) and find \\\\(\\\\min S\\\\).\\n3.  If \\\\(\\\\min S\\\\ge0\\\\), answer = \\\\(2^n\\\\pmod{998244353}\\\\).\\n4.  Otherwise:\\n    -  Let \\\\(\\\\mathrm{negBefore}[i]\\\\) = the number of indices \\\\(k<i\\\\) with \\\\(S_k<0\\\\).  We can build this in one scan.\\n    -  Collect all positions \\\\(j\\\\) for which \\\\(S_j = \\\\min S\\\\).\\n    -  The answer is\\n      \\\\[\\n        \\\\sum_{j:\\\\,S_j=\\\\min S}\\n          2^{\\\\,n - 1 - \\\\mathrm{negBefore}[j]}\\n        \\\\;\\\\bmod\\\\;998244353.\\n      \\\\]\\n5.  Precompute powers of two up to the largest \\\\(n\\\\) needed (sum of all \\\\(n\\\\le3\\\\cdot10^5\\\\)).\\n\\nThis runs in \\\\(O(n)\\\\) time per test, with a total of \\\\(O(\\\\sum n)\\\\le3\\\\times10^5\\\\), which is easily within the 2 s limit.\\n\\nBelow is a complete Java implementation.\\n\\n```java\\nimport java.io.*;\\nimport java.util.*;\\n\\npublic class Main {\\n    static final int MOD = 998244353;\\n    public static void main(String[] args) throws IOException {\\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\\n        StringTokenizer st;\\n\\n        // Precompute powers of two up to 300,000\\n        int MAX = 300000;\\n        long[] pow2 = new long[MAX+1];\\n        pow2[0] = 1;\\n        for (int i = 1; i <= MAX; i++) {\\n            pow2[i] = (pow2[i-1] << 1) % MOD;\\n        }\\n\\n        int t = Integer.parseInt(in.readLine().trim());\\n        while (t-- > 0) {\\n            int n = Integer.parseInt(in.readLine().trim());\\n            st = new StringTokenizer(in.readLine());\\n            long[] a = new long[n+1];\\n            for (int i = 1; i <= n; i++) {\\n                a[i] = Long.parseLong(st.nextToken());\\n            }\\n\\n            // 1) Build prefix-sums S and track minimum\\n            long[] S = new long[n+1];\\n            long minS = Long.MAX_VALUE;\\n            for (int i = 1; i <= n; i++) {\\n                S[i] = S[i-1] + a[i];\\n                if (S[i] < minS) minS = S[i];\\n            }\\n\\n            // If no prefix ever went negative, all choices yield the same final sum S[n]\\n            if (minS >= 0) {\\n                // 2^n mod\\n                System.out.println(pow2[n]);\\n                continue;\\n            }\\n\\n            // Otherwise we must flip at one of the positions j where S[j] == minS\\n            // Build negBefore[i] = count of k<i with S[k]<0\\n            int[] negBefore = new int[n+1];\\n            int cntN = 0;\\n            for (int i = 1; i <= n; i++) {\\n                negBefore[i] = cntN;\\n                if (S[i] < 0) cntN++;\\n            }\\n\\n            // Sum over those j with S[j] == minS\\n            long ans = 0;\\n            for (int j = 1; j <= n; j++) {\\n                if (S[j] == minS) {\\n                    // exponent = n - 1 - negBefore[j]\\n                    int exp = n - 1 - negBefore[j];\\n                    ans = (ans + pow2[exp]) % MOD;\\n                }\\n            }\\n\\n            System.out.println(ans);\\n        }\\n    }\\n}\\n```\\n\\n**Explanation of Key Steps**\\n\\n-  We only ever need **one** “flip” (absolute‐value application) at one of the indices where the prefix‐sum first reaches its global minimum.  Flipping there yields the maximal possible uplift in the final sum.\\n-  Before that index, every time the prefix was negative you are **forced** to *not* take the absolute‐value (otherwise you would lose that global minimum).  Whenever the prefix‐sum was nonnegative, taking or not taking absolute makes *no* numerical difference, so it contributes a factor of 2 of “distinct ways.”\\n-  At the chosen minimum‐achieving index you **must** apply the absolute‐value to effect the sign‐flip, i.e.\\\\ exactly 1 choice.\\n-  Afterwards, all partial sums remain nonnegative, so every subsequent index again contributes a factor of 2 (abs or no‐abs looks identical numerically).\\n\\nAdding up the contributions over *which* minimal‐index \\\\(j\\\\) one chooses leads to the final summation in step 4. The overall complexity is \\\\(O(n)\\\\) per test and easily fits the constraints.\",\n        \"refusal\": null,\n        \"role\": \"assistant\",\n        \"annotations\": [],\n        \"audio\": null,\n        \"function_call\": null,\n        \"tool_calls\": null\n      },\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"protected_material_code\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"protected_material_text\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ],\n  \"created\": 1753309417,\n  \"model\": \"o4-mini-2025-04-16\",\n  \"object\": \"chat.completion\",\n  \"service_tier\": null,\n  \"system_fingerprint\": null,\n  \"usage\": {\n    \"completion_tokens\": 24477,\n    \"prompt_tokens\": 637,\n    \"total_tokens\": 25114,\n    \"completion_tokens_details\": {\n      \"accepted_prediction_tokens\": 0,\n      \"audio_tokens\": 0,\n      \"reasoning_tokens\": 22528,\n      \"rejected_prediction_tokens\": 0\n    },\n    \"prompt_tokens_details\": {\n      \"audio_tokens\": 0,\n      \"cached_tokens\": 0\n    }\n  },\n  \"prompt_filter_results\": [\n    {\n      \"prompt_index\": 0,\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"jailbreak\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ]\n}"
    }
]