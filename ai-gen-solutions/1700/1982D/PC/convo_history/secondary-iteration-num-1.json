[
  {
    "role": "user",
    "content": "D. Beauty of the mountains\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nNikita loves mountains and has finally decided to visit the Berlyand mountain range! The range was so beautiful that Nikita decided to capture it on a map. The map is a table of n\n\n rows and m\n\n columns, with each cell containing a non-negative integer representing the height of the mountain.\n\n\n\nHe also noticed that mountains come in two types:\n\n\n\nWith snowy caps.\n\nWithout snowy caps.\n\nNikita is a very pragmatic person. He wants the sum of the heights of the mountains with snowy caps to be equal to the sum of the heights of the mountains without them. He has arranged with the mayor of Berlyand, Polikarp Polikarpovich, to allow him to transform the landscape.\n\n\n\nNikita can perform transformations on submatrices of size k×k\n\n as follows: he can add an integer constant c\n\n to the heights of the mountains within this area, but the type of the mountain remains unchanged. Nikita can choose the constant c\n\n independently for each transformation. Note that c\n\n can be negative.\n\n\n\nBefore making the transformations, Nikita asks you to find out if it is possible to achieve equality of the sums, or if it is impossible. It doesn't matter at what cost, even if the mountains turn into canyons and have negative heights.\n\n\n\nIf only one type of mountain is represented on the map, then the sum of the heights of the other type of mountain is considered to be zero.\n\n\n\nInput\n\nEach test consists of several test cases. The first line contains an integer t\n\n (1≤t≤104\n\n) — the number of test cases. This is followed by a description of test cases.\n\n\n\nThe first line of each test case contains three integers n,m,k\n\n (1≤n,m≤500,1≤k≤min(n,m)\n\n).\n\n\n\nThe next n\n\n lines of each test case contain m\n\n integers aij\n\n (0≤aij≤109\n\n) — the initial heights of the mountains.\n\n\n\nThe next n\n\n binary strings of length m\n\n for each test case determine the type of mountain, '0\n\n' — with snowy caps, '1\n\n' — without them.\n\n\n\nIt is guaranteed that the sum of n⋅m\n\n for all test cases does not exceed 250000\n\n.\n\n\n\nOutput\n\nFor each test case, output \"YES\" without quotes if it is possible to equalize the sums of the mountain heights, otherwise output \"NO\" without quotes. You can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\n\n\nExample\n\nInputCopy\n\n8\n\n3 3 2\n\n7 11 3\n\n4 2 3\n\n0 1 15\n\n100\n\n010\n\n000\n\n4 4 3\n\n123 413 24 233\n\n123 42 0 216\n\n22 1 1 53\n\n427 763 22 6\n\n0101\n\n1111\n\n1010\n\n0101\n\n3 3 2\n\n2 1 1\n\n1 1 2\n\n1 5 4\n\n010\n\n101\n\n010\n\n3 3 2\n\n2 1 1\n\n1 1 2\n\n1 5 3\n\n010\n\n101\n\n010\n\n3 4 3\n\n46 49 50 1\n\n19 30 23 12\n\n30 25 1 46\n\n1000\n\n0100\n\n0010\n\n5 4 4\n\n39 30 0 17\n\n22 42 30 13\n\n10 44 46 35\n\n12 19 9 39\n\n21 0 45 40\n\n1000\n\n1111\n\n0011\n\n0111\n\n1100\n\n2 2 2\n\n3 4\n\n6 7\n\n00\n\n00\n\n2 2 2\n\n0 0\n\n2 0\n\n01\n\n00\n\nOutputCopy\n\nYES\n\nNO\n\nYES\n\nNO\n\nYES\n\nNO\n\nYES\n\nYES\n\nNote\n\nThe mountain array from the first test case looks like this:\n\n\n\n\n\nInitially, the sum of the heights of the mountains with snowy caps is 11+3+4+3+0+1+15=37\n\n, and without them is 7+2=9\n\n.\n\n\n\nTo equalize these sums, we can perform two transformations:\n\n\n\nFirst transformation:\n\n\n\n\n\nNote that the constant c\n\n can be negative.\n\n\n\nAfter the first transformation, the mountain array looks like this:\n\n\n\n\n\nSecond transformation:\n\n\n\n\n\nAs a result, the mountain array looks like this:\n\n\n\n\n\nThe sum of the heights of the mountains with snowy caps is 17+9+9−16−20−19+15=−5\n\n, and without them is 7−12=−5\n\n, thus the answer is YES.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nLabel the mountains of the two types by weights\n\n-  +1 for the “snowy‐cap” mountains (input character `'0'`),  \n-  −1 for the “no‐snow”   mountains (input character `'1'`).\n\nLet\n\n \\(w_{ij}\\in\\{+1,-1\\}\\)\n\nbe that weight on cell \\((i,j)\\), and let\n\n \\(a_{ij}\\)\n\nbe its height.\n\nWe want the total height of the \\(+1\\)‐cells to equal the total height of the \\(-1\\)‐cells.  Equivalently,\n\n\\[\n  \\sum_{i,j} w_{ij}\\,h_{ij} \\;=\\; 0,\n\\]\n\nwhere \\(h_{ij}\\) is the _final_ height of cell \\((i,j)\\).  Initially \\(h_{ij}=a_{ij}\\), so the initial “difference”\n\n\\[\n  D \\;=\\;\\sum_{i,j} w_{ij}\\,a_{ij}\n\\]\n\nmay be nonzero.\n\nWe are allowed to pick any \\(k\\times k\\) submatrix and add an integer \\(c\\) (which can be positive, negative, or zero) to _all_ its cells (without changing the \\(w\\)‐labels).  Call an operation centered at top‐left corner \\((u,v)\\) with addition amount \\(x_{u,v}\\).  Then each cell \\((i,j)\\) in the final configuration is\n\n\\[\n  h_{ij}\n  \\;=\\;\n  a_{ij}\\;+\\;\n  \\sum_{\\substack{u\\le i\\le u+k-1 \\\\ v\\le j\\le v+k-1}}\n    x_{u,v}.\n\\]\n\nHence the change in our weighted sum is\n\n\\[\n  \\sum_{i,j} w_{ij}\\bigl(h_{ij}-a_{ij}\\bigr)\n  \\;=\\;\n  \\sum_{u,v} \\Bigl(\\sum_{i=u..u+k-1,\\;j=v..v+k-1} w_{ij}\\Bigr)\\;x_{u,v}.\n\\]\n\nDefine\n\n\\[\n  C_{u,v}\\;=\\;\\sum_{i=u}^{u+k-1}\\sum_{j=v}^{v+k-1}w_{ij},\n\\]\n\nthe total weight inside the \\(k\\times k\\) block whose top‐left corner is \\((u,v)\\).  Then the final weighted sum is\n\n\\[\n  D + \\sum_{u,v}C_{u,v}\\,x_{u,v}.\n\\]\n\nWe want to know whether we can choose integer \\(x_{u,v}\\) so that the final sum is exactly zero.  That is, can we solve\n\n\\[\n  D + \\sum_{u,v}C_{u,v}\\,x_{u,v} \\;=\\; 0\n  \\quad\\Longleftrightarrow\\quad\n  \\sum_{u,v}C_{u,v}\\,x_{u,v} \\;=\\;-D?\n\\]\n\nFrom elementary number theory, an integer linear combination of the \\(C_{u,v}\\) can produce exactly the multiples of\n\n\\[\n  g \\;=\\;\\gcd\\bigl(\\{\\,|C_{u,v}|\\}\\bigr).\n\\]\n\nThus it is possible to hit \\(-D\\) precisely if and only if\n\n1. either \\(g>0\\) and \\(g\\) divides \\(D\\),  \n2. or all \\(C_{u,v}=0\\) (so \\(g=0\\)) in which case no combination can change \\(D\\), and we must already have \\(D=0\\).\n\nHence the procedure for each test case is:\n\n1. Compute \\(w_{ij}=+1\\) if type is `'0'`, else \\(-1\\).  \n2. Compute the initial difference  \n   \\(\\displaystyle D=\\sum_{i,j} w_{ij}\\,a_{ij}.\\)  \n3. Build a 2D prefix‐sum array of the \\(w_{ij}\\).  \n4. For each valid top‐left corner \\((u,v)\\) of a \\(k\\times k\\) submatrix, extract  \n   \\(\\displaystyle\n     C_{u,v}\n     =\n     \\sum_{i=u}^{u+k-1}\\sum_{j=v}^{v+k-1} w_{ij}\n   \\)\n   in \\(O(1)\\) via the prefix sums, and let\n   \\(\\;g\\;=\\;\\gcd(g,\\;|C_{u,v}|)\\).\n5. If \\(g=0\\), answer YES exactly when \\(D=0\\).  Otherwise answer YES iff \\(D\\) is divisible by \\(g\\).\n\nThis runs in \\(O(nm)\\) per test, and since the sum of \\(nm\\) over all tests is at most \\(250\\,000\\), it is comfortably within time limits.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    // Utility: compute gcd of two nonnegative integers\n    static int gcd(int a, int b) {\n        while (b != 0) {\n            int t = a % b;\n            a = b;\n            b = t;\n        }\n        return a;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        int t = Integer.parseInt(in.readLine().trim());\n        while (t-- > 0) {\n            StringTokenizer st = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(st.nextToken());\n            int k = Integer.parseInt(st.nextToken());\n            \n            // Read heights\n            long[][] a = new long[n+1][m+1];\n            for (int i = 1; i <= n; i++) {\n                st = new StringTokenizer(in.readLine());\n                for (int j = 1; j <= m; j++) {\n                    a[i][j] = Long.parseLong(st.nextToken());\n                }\n            }\n            \n            // Read types and build w[i][j]\n            // w = +1 for '0', w = -1 for '1'\n            int[][] w = new int[n+1][m+1];\n            for (int i = 1; i <= n; i++) {\n                String s = in.readLine();\n                for (int j = 1; j <= m; j++) {\n                    w[i][j] = (s.charAt(j-1) == '0') ? +1 : -1;\n                }\n            }\n            \n            // Compute initial difference D = sum_{i,j} w[i][j] * a[i][j]\n            long D = 0;\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j <= m; j++) {\n                    D += w[i][j] * a[i][j];\n                }\n            }\n            \n            // Build 2D prefix sums of w\n            int[][] pref = new int[n+1][m+1];\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j <= m; j++) {\n                    pref[i][j] = w[i][j]\n                                + pref[i-1][j]\n                                + pref[i][j-1]\n                                - pref[i-1][j-1];\n                }\n            }\n            \n            // Compute gcd of all C_{u,v} = sum of w[] in the k x k block\n            int g = 0;\n            for (int u = 1; u + k - 1 <= n; u++) {\n                for (int v = 1; v + k - 1 <= m; v++) {\n                    int i2 = u + k - 1;\n                    int j2 = v + k - 1;\n                    int blockSum = pref[i2][j2]\n                                 - pref[u-1][j2]\n                                 - pref[i2][v-1]\n                                 + pref[u-1][v-1];\n                    // incorporate into gcd\n                    blockSum = Math.abs(blockSum);\n                    g = gcd(g, blockSum);\n                }\n            }\n            \n            // If g == 0, we cannot change D at all, so we need D == 0\n            // Otherwise, we need D % g == 0\n            if (g == 0) {\n                out.println(D == 0 ? \"YES\" : \"NO\");\n            } else {\n                out.println((D % g) == 0 ? \"YES\" : \"NO\");\n            }\n        }\n\n        out.flush();\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Weighting the two types**  \n   We define a weight \\(w_{ij}=+1\\) if the cell has a “snowy cap” (input character `'0'`), and \\(w_{ij}=-1\\) if it does not (character `'1'`).  Our goal \\(\\sum w_{ij}\\,h_{ij}=0\\) enforces “sum of heights of +1‐cells = sum of heights of −1‐cells.”\n\n2. **The initial difference**  \n   Compute  \n   \\[\n     D \\;=\\; \\sum_{i,j} w_{ij}\\,a_{ij}.\n   \\]\n   If \\(D\\neq 0\\), the two sums are not equal yet.\n\n3. **Block updates and their effect**  \n   An update on a \\(k\\times k\\) block with top‐left corner \\((u,v)\\) and integer addition \\(x_{u,v}\\) adds \\(x_{u,v}\\) to each cell in that block.  The change in our weighted sum is\n   \\[\n     \\sum_{i,j} w_{ij}\\bigl(h_{ij}-a_{ij}\\bigr)\n     =\n     \\sum_{u,v}\n     \\Bigl(\\sum_{\\substack{i=u..u+k-1\\\\j=v..v+k-1}}w_{ij}\\Bigr)\n     x_{u,v}\n     =\n     \\sum_{u,v} C_{u,v}\\,x_{u,v}.\n   \\]\n   Hence the final weighted sum is \\(D + \\sum_{u,v}C_{u,v}\\,x_{u,v}\\).\n\n4. **Reachable differences**  \n   All integer combinations of the numbers \\(\\{\\,C_{u,v}\\}\\) form exactly the multiples of\n   \\[\n     g \\;=\\;\\gcd\\bigl(\\{|C_{u,v}|\\}\\bigr).\n   \\]\n   Thus we can reach zero iff \\(-D\\) is a multiple of \\(g\\).  If \\(g=0\\), that means _every_ \\(C_{u,v}=0\\), so we can’t change \\(D\\) at all—hence we must already have \\(D=0\\).\n\n5. **Implementation**  \n   We build a simple 2D prefix‐sum array to extract each block‐sum \\(C_{u,v}\\) in \\(O(1)\\).  We accumulate the GCD of \\(\\bigl|C_{u,v}\\bigr|\\), then check divisibility of \\(D\\) by that GCD in the end.  This runs in \\(O(nm)\\) per test, well within the given limits."
  },
  {
    "role": "system",
    "content": "Identify any errors in this response and output a prompt to help the AI resolve said issues. Your response MUST be in one of two formats: 1. If the response looks perfect, return \"Perfect\". Do not return this if there are any issues. Use this very sparingly as any errors in the final output from the AI will be considered a failure on your part. 2. Otherwise, return \"{prompt}\" where {prompt} is replaced with your concise prompt. This should be done most often, even if the AI's response is mostly correct. Ensure the entire response is enclosed in double quotations if it's a prompt. Make sure your prompt asks the AI to return one block of code for submission."
  },
  {
    "role": "assistant",
    "content": "\"Please provide only the final Java code solution as one code block suitable for submission, without additional commentary.\""
  }
]