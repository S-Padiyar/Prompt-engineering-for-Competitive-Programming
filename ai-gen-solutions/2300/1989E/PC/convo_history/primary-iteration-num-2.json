[
  {
    "role": "user",
    "content": "E. Distance to Different\n\ntime limit per test2 seconds\n\nmemory limit per test512 megabytes\n\nConsider an array a\n\n of n\n\n integers, where every element is from 1\n\n to k\n\n, and every integer from 1\n\n to k\n\n appears at least once.\n\n\n\nLet the array b\n\n be constructed as follows: for the i\n\n-th element of a\n\n, bi\n\n is the distance to the closest element in a\n\n which is not equal to ai\n\n. In other words, bi=minj∈[1,n],aj≠ai|i−j|\n\n.\n\n\n\nFor example, if a=[1,1,2,3,3,3,3,1]\n\n, then b=[2,1,1,1,2,2,1,1]\n\n.\n\n\n\nCalculate the number of different arrays b\n\n you can obtain if you consider all possible arrays a\n\n, and print it modulo 998244353\n\n.\n\n\n\nInput\n\nThe only line of the input contains two integers n\n\n and k\n\n (2≤n≤2⋅105\n\n; 2≤k≤min(n,10)\n\n).\n\n\n\nOutput\n\nPrint one integer — the number of different arrays b\n\n you can obtain, taken modulo 998244353\n\n.\n\n\n\nExamples\n\nInputCopy\n\n2 2\n\nOutputCopy\n\n1\n\nInputCopy\n\n4 3\n\nOutputCopy\n\n3\n\nInputCopy\n\n6 2\n\nOutputCopy\n\n20\n\nInputCopy\n\n6 5\n\nOutputCopy\n\n3\n\nInputCopy\n\n133 7\n\nOutputCopy\n\n336975971\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nLet us restate the problem in our own words:\n\n- We have unknown arrays  \n  \\(a_1,a_2,\\dots,a_n\\)  \n  taking values in \\(\\{1,2,\\dots,k\\}\\), each value in \\(\\{1,\\dots,k\\}\\) used at least once.\n\n- We define an array  \n  \\[\n    b_i \\;=\\;\\min_{1\\le j\\le n,\\;a_j\\ne a_i}|i-j|\\;,\n  \\]\n  i.e.\\ the distance from position \\(i\\) to the nearest position with a different color/value.\n\n- We wish to count how many *distinct* arrays \\(b\\) can arise (from *some* choice of \\(a\\) using all \\(k\\) colors at least once), and output that number modulo \\(998244353\\).\n\nA key combinatorial insight is:\n\n1.  We can view the array \\(a\\) as a sequence of monochromatic *runs* (maximal contiguous blocks of the same color).  Suppose there are \\(r\\) runs, of lengths  \n    \\[\n       L_1,\\;L_2,\\;\\dots,\\;L_r\\,,\\qquad L_i\\ge1,\\;\\sum L_i=n,\n    \\]\n    with the first run in color \\(c_1\\), the second in color \\(c_2\\neq c_1\\), etc.\n\n2.  Once the runs \\(L_1,\\dots,L_r\\) are fixed, the array \\(b\\) is *uniquely* determined.  Indeed:\n    -  If run \\(i\\) is an *internal* run (neither the first nor the last), its \\(b\\)-pattern is\n       \\[\n         \\bigl[1,2,\\dots,\\lfloor\\tfrac{L_i}{2}\\rfloor,\\,\n               \\lceil\\tfrac{L_i}{2}\\rceil,\\dots,2,1\\bigr],\n       \\]\n       i.e.\\ it goes up by \\(+1\\), then (if \\(L_i\\) is even) a brief plateau, then down by \\(-1\\).\n    -  The *first* run gives a strictly *decreasing* pattern \\([L_1,L_1-1,\\dots,1]\\).\n    -  The *last* run gives a strictly *increasing* pattern \\([1,2,\\dots,L_r]\\).\n\n3.  Hence every composition of \\(n\\) into run‐lengths\n    \\[\n       n=L_1+L_2+\\cdots+L_r,\n       \\quad L_i\\ge1,\n    \\]\n    yields *some* \\(b\\).  However *different* compositions can give the *same* \\(b\\).  In fact the *only* collision is that an internal run of length \\(2\\), whose pattern is \\([1,1]\\), is *identical* to two consecutive internal runs each of length \\(1\\).  In other words\n    \\[\n       \\dots[1,1]\\dots\n       \\quad\\longleftrightarrow\\quad\n       \\dots[1]\\;[1]\\dots\n    \\]\n    both give the same little block \\([1,1]\\) of \\(b\\).  \n\n4.  To avoid *double‐counting* those collisions, we adopt a simple canonical rule: **in our “canonical” compositions, we forbid any *internal* part of size exactly \\(2\\).**  (The first and last parts are unconstrained, but interior parts must not be 2.)  One checks that this gives a *bijection* between distinct \\(b\\)-arrays and these canonical compositions.\n\n5.  Finally, the problem requires that *all* \\(k\\) colors appear in \\(a\\).  One shows easily that this is possible if and only if the number of runs \\(r\\ge k\\).  (Indeed on a path of \\(r\\) runs one can use up to \\(r\\) distinct colors, and to use *all* \\(k\\), one needs \\(r\\ge k\\).)\n\nThus the total number of *distinct* \\(b\\)-arrays that come from some valid \\(a\\) with all \\(k\\) colors is exactly the number of canonical compositions of \\(n\\) into \\(r\\ge k\\) parts, with \n\n- \\(L_1\\ge1\\), \n- \\(L_r\\ge1\\), \n- and for \\(2\\le i\\le r-1\\) we require \\(L_i\\neq2\\).  \n\nWe will compute\n\n\\[\n   \\text{Answer} \n   \\;=\\;\n   \\sum_{r=k}^n\\;\n   \\Bigl|\\{\\, (L_1,\\dots,L_r)\\colon L_i\\ge1,\\;\\sum L_i=n,\\;L_i\\neq2\\text{ for }2\\le i\\le r-1\\}\\Bigr|.\n\\]\n\nWe break it into two steps:\n\n(A) Let\n\\[\n  c[n]\n  \\;=\\;\n  \\text{(number of *all* canonical compositions of $n$, with any $r\\ge1$).}\n\\]\nWe will compute \\(c[n]\\) in \\(O(n)\\) time by a single‐array DP that handles the “no internal 2” rule.\n\n(B) Let\n\\[\n  \\text{dp}[n][j]\n  \\;=\\;\n  \\text{(number of canonical compositions of $n$ into exactly $j$ parts).}\n\\]\nWe only need that for \\(j=1,2,\\dots,k-1\\) because we want to *exclude* those with \\(j<k\\).  Since \\(k\\le10\\), a small DP in \\(O(k\\,n)\\) suffices to get\n\\[\n  \\sum_{j=1}^{k-1}\\text{dp}[n][j].\n\\]\n\nFinally\n\\[\n  \\boxed{\n     \\text{Answer}\n     \\;=\\;\n     c[n]\\;-\\;\\sum_{j=1}^{k-1}\\text{dp}[n][j]\n     \\pmod{998244353}.\n  }\n\\]\n\nBoth parts run in \\(O(k\\,n + n)\\), perfectly fine for \\(n\\) up to \\(2\\times10^5\\) and \\(k\\le10\\).\n\n---\n\n**Implementation in Java**\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int MOD = 998244353;\n\n    // Add modulo\n    static int add(int a, int b) {\n        a += b;\n        if (a >= MOD) a -= MOD;\n        return a;\n    }\n    // Subtract modulo\n    static int sub(int a, int b) {\n        a -= b;\n        if (a < 0) a += MOD;\n        return a;\n    }\n    // Multiply modulo\n    static int mul(long a, long b) {\n        return (int)( (a*b) % MOD );\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n\n        // ----------------------------------------------------------------\n        // (1) Compute c[n] = total number of canonical compositions of n\n        //     with any number of parts, forbidding internal parts == 2.\n        //\n        // We do an auxiliary array a[m]:\n        //   a[m] = number of ways to compose m with parts in {1} U {3,4,5,...}\n        //         (this is for the internal‐middle fragments).\n        // Recurrence:\n        //   a[0]=1, a[1]=1, a[2]=1\n        //   for m>=3: a[m] = a[m-1] + sum_{i=0..m-3} a[i].\n        // We keep prefix sums S[m] = sum_{i=0..m} a[i], so\n        //   a[m] = a[m-1] + S[m-3].\n        //\n        // Then one shows easily that\n        //   c[n] = 1   (the single‐part composition [n])\n        //          + sum_{M=0..n-2}  a[M] * (n - 1 - M),\n        // because if we use >=2 parts we pick an internal block of total length M\n        // (split among internal parts) and then two border lengths L1,Lr >=1\n        // with L1+Lr = n - M, which has (n-M-1) choices.\n        // ----------------------------------------------------------------\n        int[] a = new int[n+1], S = new int[n+1];\n        a[0] = 1;  S[0] = 1;\n        if (n >= 1) { a[1] = 1; S[1] = 2; }\n        if (n >= 2) { a[2] = 1; S[2] = 3; }\n        for (int i = 3; i <= n; i++) {\n            int val = add(a[i-1], S[i-3]);\n            a[i] = val;\n            S[i] = add(S[i-1], a[i]);\n        }\n\n        // Now build c[n]:\n        int cn = 1;  // the single‐part composition\n        for (int M = 0; M <= n-2; M++) {\n            // each M contributes a[M] * (n - 1 - M)\n            int ways = mul(a[M], n-1-M);\n            cn = add(cn, ways);\n        }\n\n        // ----------------------------------------------------------------\n        // (2) Compute dp[n][j] for j=1..(k-1), the number of canonical\n        //     compositions of n into exactly j parts.\n        //\n        // dp[n][1] = 1  (that is just [n]).\n        // For j>=2, we do a small DP over \"the last (j-1) parts\",\n        // remembering that internal parts ≠ 2 but the last part may be ≥1 freely.\n        //\n        // We build dp2[t][s] = number of ways to choose t parts summing to s,\n        //   where the first (t-1) of them are \"internal\" (≠2) and\n        //   the t-th is \"last\" (any ≥1).\n        //\n        // Then\n        //   dp[n][j] = sum_{m=1..n-1} dp2[j-1][m]\n        //            = prefixSum(dp2[j-1])[n-1].\n        // ----------------------------------------------------------------\n        int maxT = Math.max(1, k-1); // we only need t up to (k-1)\n        int[][] dp2 = new int[maxT+1][n]; // dp2[t][s], s up to n-1\n        int[][] dp2sum = new int[maxT+1][n];  // prefix sums\n\n        // t=1: one part which is also \"last\", so any s>=1 gives exactly 1 way.\n        for (int s = 1; s < n; s++) {\n            dp2[1][s] = 1;\n        }\n        for (int s = 0; s < n; s++) {\n            dp2sum[1][s] = (s==0 ? dp2[1][0] : add(dp2sum[1][s-1], dp2[1][s]));\n        }\n\n        // for t >= 2 we do an O(t * n) prefix‐sum DP\n        for (int t = 2; t <= k-1; t++) {\n            // dp over positions pos=1..t\n            // pos < t => \"internal\", allowed part-size L>=1 but L≠2\n            // pos = t => \"last\", allowed L>=1\n            int[] cur = new int[n+1], nxt = new int[n+1];\n            cur[0] = 1;  // zero sum with zero parts so far\n\n            for (int pos = 1; pos <= t; pos++) {\n                // build prefix sums of cur\n                int[] prefix = new int[n+1];\n                prefix[0] = cur[0];\n                for (int i = 1; i <= n; i++)\n                    prefix[i] = add(prefix[i-1], cur[i]);\n                Arrays.fill(nxt, 0);\n\n                if (pos < t) {\n                    // internal: dp'[s] = sum_{L=1..s, L≠2} cur[s-L]\n                    for (int s = 1; s <= n; s++) {\n                        // sum_{i=0..s-1} cur[i]  minus cur[s-2] if s-2>=0\n                        int ways = prefix[s-1];\n                        if (s-2 >= 0) ways = sub(ways, cur[s-2]);\n                        nxt[s] = ways;\n                    }\n                } else {\n                    // pos==t => last: dp'[s] = sum_{L=1..s} cur[s-L]\n                    for (int s = 1; s <= n; s++) {\n                        nxt[s] = prefix[s-1];\n                    }\n                }\n\n                // swap cur,nxt\n                int[] tmp = cur; cur = nxt; nxt = tmp;\n            }\n            // cur[s] now = dp2[t][s], but we only needed s< n\n            for (int s = 0; s < n; s++) {\n                dp2[t][s] = cur[s];\n            }\n            dp2sum[t][0] = dp2[t][0];\n            for (int s = 1; s < n; s++) {\n                dp2sum[t][s] = add(dp2sum[t][s-1], dp2[t][s]);\n            }\n        }\n\n        // Now sum up dp[n][j] for j=1..k-1\n        int dpSmall = 0;\n        // j=1 => exactly one part => dp[n][1] = 1 (assuming n>=1)\n        dpSmall = add(dpSmall, 1);\n        for (int j = 2; j <= k-1; j++) {\n            // dp[n][j] = sum_{m=1..n-1} dp2[j-1][m] = dp2sum[j-1][n-1]\n            dpSmall = add(dpSmall, dp2sum[j-1][n-1]);\n        }\n\n        // Final answer\n        int ans = sub(cn, dpSmall);\n        System.out.println(ans);\n    }\n}\n```\n\n**Explanation of the Main Steps**\n\n1. **Counting *all* canonical compositions**  \n   We let \\(a[m]\\) be the number of ways to compose \\(m\\) out of “internal‐only” parts which must be \\(\\{1\\}\\cup\\{3,4,5,\\dots\\}\\).  One shows\n   \\[\n     a[0]=1,\\;a[1]=1,\\;a[2]=1,\\quad\n     a[m]=a[m-1]+\\sum_{i=0}^{m-3}a[i]\\quad(m\\ge3).\n   \\]\n   We keep prefix‐sums \\(S[m]=a[0]+\\cdots+a[m]\\) so that\n   \\[\n     a[m] \\;=\\; a[m-1]+S[m-3].\n   \\]\n   Then the total number of *canonical* compositions of \\(n\\) is\n   \\[\n     c[n]\n     = 1  \\;+\\;\n       \\sum_{M=0}^{n-2} \\; a[M]\\;\\cdot\\;(n-1-M).\n   \\]\n   The “\\(+1\\)” is for the single‐part composition \\([n]\\), and the sum accounts for all compositions with at least two parts (choosing an “internal block” of total length \\(M\\), and splitting the remaining \\(n-M\\) into two border runs in \\((n-1-M)\\) ways.)\n\n2. **Excluding compositions with fewer than \\(k\\) parts**  \n   We only want those canonical compositions having \\(\\ge k\\) parts.  Equivalently we subtract off those with \\(1,2,\\dots,k-1\\) parts.  \n   \n   For exactly \\(j\\) parts, the first part and the last part are free (\\(\\ge1\\) each), but each of the “internal” parts (those in positions \\(2,\\dots,j-1\\)) must be \\(\\neq2\\).  We build a small DP\n   \\[\n     \\text{dp2}[t][s]\n     \\;=\\;\n     \\#\\{\\text{ways to pick $t$ parts summing to $s$, \n        first $t-1$ parts $\\neq2$, last part $\\ge1$}\\}.\n   \\]\n   Then\n   \\[\n     \\text{dp}[n][j]\n     \\;=\\;\n     \\sum_{m=1}^{n-1}\\,\\text{dp2}[\\,j-1\\,][m],\n     \\quad j\\ge2,\n     \\quad\n     \\text{dp}[n][1]=1.\n   \\]\n   Since \\(k\\le10\\), we only need to do this DP for \\(t\\le k-1\\), each in \\(O(n)\\) time by prefix‐sum optimization.\n\nFinally\n\\[\n   \\boxed{\\text{Answer} = c[n]\\;-\\;\\sum_{j=1}^{k-1}\\text{dp}[n][j]\\pmod{998244353}.}\n\\]\n\nThis runs in \\(O(n + k\\cdot n)\\), which is plenty fast for \\(n\\) up to \\(2\\cdot10^5\\) and \\(k\\le10\\)."
  },
  {
    "role": "user",
    "content": "Please provide ONLY the final Java solution in one block of code (a complete, self-contained submission) without additional explanation."
  },
  {
    "role": "assistant",
    "content": "```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int MOD = 998244353;\n    static int add(int a, int b) {\n        a += b;\n        if (a >= MOD) a -= MOD;\n        return a;\n    }\n    static int sub(int a, int b) {\n        a -= b;\n        if (a < 0) a += MOD;\n        return a;\n    }\n    static int mul(long a, long b) {\n        return (int)((a*b) % MOD);\n    }\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        int[] a = new int[n+1], S = new int[n+1];\n        a[0] = 1;  S[0] = 1;\n        if (n >= 1) { a[1] = 1; S[1] = 2; }\n        if (n >= 2) { a[2] = 1; S[2] = 3; }\n        for (int i = 3; i <= n; i++) {\n            int val = add(a[i-1], S[i-3]);\n            a[i] = val;\n            S[i] = add(S[i-1], a[i]);\n        }\n        int cn = 1;\n        for (int M = 0; M <= n-2; M++) {\n            int ways = mul(a[M], n-1-M);\n            cn = add(cn, ways);\n        }\n        int maxT = Math.max(1, k-1);\n        int[][] dp2 = new int[maxT+1][n];\n        int[][] dp2sum = new int[maxT+1][n];\n        for (int s = 1; s < n; s++) {\n            dp2[1][s] = 1;\n        }\n        for (int s = 0; s < n; s++) {\n            dp2sum[1][s] = (s==0 ? dp2[1][0] : add(dp2sum[1][s-1], dp2[1][s]));\n        }\n        for (int t = 2; t <= k-1; t++) {\n            int[] cur = new int[n+1], nxt = new int[n+1];\n            cur[0] = 1;\n            for (int pos = 1; pos <= t; pos++) {\n                int[] prefix = new int[n+1];\n                prefix[0] = cur[0];\n                for (int i = 1; i <= n; i++)\n                    prefix[i] = add(prefix[i-1], cur[i]);\n                Arrays.fill(nxt, 0);\n                if (pos < t) {\n                    for (int s = 1; s <= n; s++) {\n                        int ways = prefix[s-1];\n                        if (s-2 >= 0) ways = sub(ways, cur[s-2]);\n                        nxt[s] = ways;\n                    }\n                } else {\n                    for (int s = 1; s <= n; s++) {\n                        nxt[s] = prefix[s-1];\n                    }\n                }\n                int[] tmp = cur; cur = nxt; nxt = tmp;\n            }\n            for (int s = 0; s < n; s++) {\n                dp2[t][s] = cur[s];\n            }\n            dp2sum[t][0] = dp2[t][0];\n            for (int s = 1; s < n; s++) {\n                dp2sum[t][s] = add(dp2sum[t][s-1], dp2[t][s]);\n            }\n        }\n        int dpSmall = 0;\n        dpSmall = add(dpSmall, 1);\n        for (int j = 2; j <= k-1; j++) {\n            dpSmall = add(dpSmall, dp2sum[j-1][n-1]);\n        }\n        int ans = sub(cn, dpSmall);\n        System.out.println(ans);\n    }\n}\n```"
  }
]