[
  {
    "role": "user",
    "content": "F1. Field Division (easy version)\n\ntime limit per test3 seconds\n\nmemory limit per test256 megabytes\n\nThis is an easy version of the problem; it differs from the hard version only by the question. The easy version only needs you to print whether some values are non-zero or not. The hard version needs you to print the exact values.\n\n\n\nAlice and Bob are dividing the field. The field is a rectangle of size n×m\n\n (2≤n,m≤109\n\n), the rows are numbered from 1\n\n to n\n\n from top to bottom, and the columns are numbered from 1\n\n to m\n\n from left to right. The cell at the intersection of row r\n\n and column c\n\n is denoted as (r,c\n\n).\n\n\n\nBob has k\n\n (2≤k≤2⋅105\n\n) fountains, all of them are located in different cells of the field. Alice is responsible for dividing the field, but she must meet several conditions:\n\n\n\nTo divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field.\n\nAlice's path will divide the field into two parts — one part will belong to Alice (this part includes the cells of her path), the other part — to Bob.\n\nAlice will own the part that includes the cell (n,1\n\n).\n\nBob will own the part that includes the cell (1,m\n\n).\n\nAlice wants to divide the field in such a way as to get as many cells as possible.\n\n\n\nBob wants to keep ownership of all the fountains, but he can give one of them to Alice. First, output the integer α\n\n — the maximum possible size of Alice's plot, if Bob does not give her any fountain (i.e., all fountains will remain on Bob's plot). Then output k\n\n non-negative integers a1,a2,…,ak\n\n, where:\n\n\n\nai=0\n\n, if after Bob gives Alice the i\n\n-th fountain, the maximum possible size of Alice's plot does not increase (i.e., remains equal to α\n\n);\n\nai=1\n\n, if after Bob gives Alice the i\n\n-th fountain, the maximum possible size of Alice's plot increases (i.e., becomes greater than α\n\n).\n\nInput\n\nThe first line contains a single integer t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nThe first line of each test case contains three integers n\n\n, m\n\n, and k\n\n (2≤n,m≤109\n\n, 2≤k≤2⋅105\n\n) — the field sizes and the number of fountains, respectively.\n\n\n\nThen follow k\n\n lines, each containing two numbers ri\n\n and ci\n\n (1≤ri≤n\n\n, 1≤ci≤m\n\n) — the coordinates of the cell with the i\n\n-th fountain. It is guaranteed that all cells are distinct and none of them is (n,1\n\n).\n\n\n\nIt is guaranteed that the sum of k\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, first output α\n\n — the maximum size of the plot that can belong to Alice if Bob does not give her any of the fountains. Then output k\n\n non-negative integers a1,a2,…,ak\n\n, where:\n\n\n\nai=0\n\n, if after Bob gives Alice the i\n\n-th fountain, the maximum possible size of Alice's plot does not increase compared to the case when all k\n\n fountains belong to Bob;\n\nai=1\n\n, if after Bob gives Alice the i\n\n-th fountain, the maximum possible size of Alice's plot increases compared to the case when all k\n\n fountains belong to Bob.\n\nIf you output any other positive number instead of 1\n\n that fits into a 64-bit signed integer type, it will also be recognized as 1\n\n. Thus, a solution to the hard version of this problem will also pass the tests for the easy version.\n\n\n\nExample\n\nInputCopy\n\n5\n\n2 2 3\n\n1 1\n\n1 2\n\n2 2\n\n5 5 4\n\n1 2\n\n2 2\n\n3 4\n\n4 3\n\n2 5 9\n\n1 2\n\n1 5\n\n1 1\n\n2 2\n\n2 4\n\n2 5\n\n1 4\n\n2 3\n\n1 3\n\n6 4 4\n\n6 2\n\n1 3\n\n1 4\n\n1 2\n\n3 4 5\n\n2 1\n\n3 2\n\n1 4\n\n1 3\n\n2 4\n\nOutputCopy\n\n1\n\n1 0 1 \n\n11\n\n0 1 0 1 \n\n1\n\n0 0 1 1 0 0 0 0 0 \n\n6\n\n1 0 0 0 \n\n1\n\n1 1 0 0 0 \n\nNote\n\nBelow are the images for the second example:\n\n\n\nThe indices of the fountains are labeled in green. The cells belonging to Alice are marked in blue.\n\nNote that if Bob gives Alice fountain 1\n\n or fountain 3\n\n, then that fountain cannot be on Alice's plot.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have an \\(n\\times m\\) grid and \\(k\\) “fountains” (forbidden cells) at distinct positions \\((r_i,c_i)\\).  Alice must draw a monotonic (only “down” or “right”) path \\(P\\) from some free cell on the top or left border to some free cell on the bottom or right border.  The path itself belongs to Alice, and it carves the grid into two pieces:\n\n- Alice’s piece is the component containing the cell \\((n,1)\\).\n- Bob’s piece is the component containing the cell \\((1,m)\\).\n\nBecause Bob wants to keep all fountains on his side, the path \\(P\\) may *not* pass through any fountain cell, and every fountain must lie in the *Bob* component (i.e.\\ “northeast” of \\(P\\)).  On the other hand Alice wants to maximize the number of cells she gets.  One can show that\n\n\\[\n\\text{Alice\\_size} \\;=\\; nm \\;-\\;\\sum_{c=1}^m (\\text{row of }P\\text{ in column }c \\;-\\;1),\n\\]\n\nwhere “row of \\(P\\) in column \\(c\\)” we denote by \\(f(c)\\).  Since \\(P\\) moves only down or right, the sequence \\(f(1),f(2),\\dots,f(m)\\) is non‐decreasing.  To keep a fountain at \\((r,c)\\) on Bob’s side (i.e.\\ strictly above the path), we need\n\n\\[\nf(c)\\;>\\;r.\n\\]\n\nThus if in column \\(c\\) the maximal fountain‐row is \\(r_{\\max}(c)\\), we get the lower‐bound\n\n\\[\nf(c)\\;\\ge\\;r_{\\max}(c)+1\\;=:L(c).\n\\]\n\nTo maximize Alice’s size is equivalent to minimizing\n\\(\\sum_{c=1}^m (f(c)-1)\\), subject to\n\n1. \\(f\\) non‐decreasing,\n2. \\(f(c)\\ge L(c)\\) wherever column \\(c\\) has fountains,\n3. elsewhere \\(f(c)\\ge1\\).\n\nA classical greedy shows that the unique minimum\\--sum choice is\n\\[\nf(c)\\;=\\;\\max_{1\\le j\\le c}\\,L(j),\n\\]\nwhere we take \\(L(j)=1\\) for columns \\(j\\) with no fountain.\n\nSince \\(m\\) can be up to \\(10^9\\) but \\(k\\) only up to \\(2\\cdot10^5\\), we do the following:\n\n1.  **Group fountains by column**.  For each column \\(c\\) that has fountains, let\n   \\[\n     r_{\\max}(c)\\;=\\;\\max\\{r_i\\mid c_i=c\\},\n     \\quad L(c)=r_{\\max}(c)+1.\n   \\]\n2.  Sort these special columns \\(c_1<c_2<\\dots<c_u\\).  Between those columns, \\(L\\) is “1” and so\n   \\(f\\) is just the running maximum of the \\(L\\)-values.\n3.  We can compute Bob’s piece size\n   \\[\n     B \\;=\\;\\sum_{c=1}^m \\bigl(f(c)-1\\bigr)\n   \\]\n   by noting that on any interval of columns \\([c_j,c_{j+1}-1]\\) (or to \\(m\\) at the end), \n   \\(f(c)\\) is constant, so we only need\n   \\[\n     B \\;=\\;\\sum_{j=1}^u \\bigl(f(c_j)-1\\bigr)\\times\\bigl(\\,c_{j+1}-c_j\\bigr),\n     \\quad c_{u+1}=m+1.\n   \\]\n4.  Thus\n   \\[\n     \\alpha \\;=\\; nm \\;-\\; B.\n   \\]\n5.  Now we must decide, for each fountain \\(i\\), whether *giving* that fountain to Alice\n   (i.e.\\ removing its constraint) would strictly increase \\(\\alpha\\).  It is not hard to show\n   that the only way removing a fountain changes \\(\\alpha\\) is if it was the *unique* top\n   fountain in its column and that column's \\(L(c_j)\\) was strictly *above* the running\n   maximum so far.  In that case the prefix‐maximum \\(f(c_j)\\) would drop, thus decreasing\n   Bob’s area and *increasing* \\(\\alpha\\).  Otherwise \\(\\alpha\\) is unchanged.\n\nAll of the above can be done in \\(O(k\\log k)\\) per test (sorting the \\(k\\) fountains by column\nand picking off the column‐wise maximum).  Across all tests, \\(\\sum k\\le2\\cdot10^5\\), which\nis efficient enough in 3 s.\n\nBelow is a Java implementation.\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class Fountain {\n        int r, c, idx;\n        Fountain(int r, int c, int idx) {\n            this.r = r; this.c = c; this.idx = idx;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(in.readLine());\n        int t = Integer.parseInt(st.nextToken());\n\n        StringBuilder out = new StringBuilder();\n        while (t-- > 0) {\n            st = new StringTokenizer(in.readLine());\n            long n = Long.parseLong(st.nextToken());\n            long m = Long.parseLong(st.nextToken());\n            int k = Integer.parseInt(st.nextToken());\n\n            // Read the fountains\n            Fountain[] F = new Fountain[k];\n            for (int i = 0; i < k; i++) {\n                st = new StringTokenizer(in.readLine());\n                int r = Integer.parseInt(st.nextToken());\n                int c = Integer.parseInt(st.nextToken());\n                F[i] = new Fountain(r, c, i);\n            }\n\n            // Sort by column asc, then row desc\n            Arrays.sort(F, (a,b) -> {\n                if (a.c != b.c) return Integer.compare(a.c, b.c);\n                return -Integer.compare(a.r, b.r);\n            });\n\n            // Group by column: pick the single top fountain in each column\n            ArrayList<int[]> cols = new ArrayList<>();\n            // each entry is { col, r_max, idx_of_that_max }\n            for (int i = 0; i < k; ) {\n                int c = F[i].c;\n                int rMax = F[i].r;\n                int idxMax = F[i].idx;\n                int j = i + 1;\n                // skip any others in same column\n                while (j < k && F[j].c == c) j++;\n                cols.add(new int[]{ c, rMax, idxMax });\n                i = j;\n            }\n\n            int u = cols.size();\n            long[] prevF = new long[u], fVal = new long[u];\n            long cur = 1L;\n\n            // Compute the non‐decreasing f(c_j) = max so far of L(c_j)=r_max+1\n            for (int j = 0; j < u; j++) {\n                prevF[j] = cur;\n                long L = (long)cols.get(j)[1] + 1L;\n                if (L > cur) cur = L;\n                fVal[j] = cur;\n            }\n\n            // Compute Bob's area B = sum_{columns} (f(c)-1).\n            // We only need to do it in O(u) by noticing f(c) is constant\n            // between c_j..(c_{j+1}-1).\n            long B = 0;\n            for (int j = 0; j < u; j++) {\n                long c_j = cols.get(j)[0];\n                long nextC = (j+1 < u ? cols.get(j+1)[0] : m+1L);\n                long len = nextC - c_j;\n                B += (fVal[j] - 1L) * len;\n            }\n\n            // Alice's max area:\n            long alpha = n*m - B;\n            out.append(alpha).append('\\n');\n\n            // Which fountains are \"critical\"?  Only the unique max‐of‐column\n            // for which L(c_j)=r_max+1 > prevF[j].\n            int[] ans = new int[k];\n            for (int j = 0; j < u; j++) {\n                long L = (long)cols.get(j)[1] + 1L;\n                if (L > prevF[j]) {\n                    int idxMax = cols.get(j)[2];\n                    ans[idxMax] = 1;\n                }\n            }\n\n            // Print the k answers in the original order\n            for (int i = 0; i < k; i++) {\n                out.append(ans[i]).append(i+1<k ? ' ' : '\\n');\n            }\n        }\n        System.out.print(out);\n    }\n}\n```\n\n**Explanation of key steps**\n\n1. We only need, for each column that actually has fountains, the *highest* fountain row `r_max`.  That produces a lower‐bound  \n   \\[\n     f(c)\\ge L(c)\\;=\\;r_{\\max}(c)+1.\n   \\]\n2. Because the path moves only *down* (increasing row) or *right* (increasing column), the sequence  \n   \\(f(1),f(2),\\dots,f(m)\\) is non‐decreasing, and we want to minimize  \n   \\(\\sum_{c=1}^m (f(c)-1)\\).  \n   A well‐known greedy shows the minimum possible is  \n   \\[\n     f(c)\\;=\\;\\max_{1\\le j\\le c}\\;L(j)\\quad(\\text{with }L(j)=1\\text{ if column }j\\text{ has no fountain}).\n   \\]\n3. From that \\(f\\)-profile one obtains Bob’s area \\(B=\\sum_{c=1}^m(f(c)-1)\\).  Since \\(f\\) is constant on large intervals of columns (between columns that actually have fountains), one can compute \\(B\\) in \\(O(u)\\) time, where \\(u\\) is the number of distinct columns that contain fountains.\n4. Alice’s area is then \\(\\alpha = nm - B\\).\n5. Finally, deciding which individual fountain (if “given” to Alice) strictly raises \\(\\alpha\\) amounts to checking whether that fountain was the *unique* top‐row in its column *and* its \\(L(c)\\) actually pushed up the running maximum at that column.  If so, removing it drops the path’s height there (and thus shrinks Bob’s area), strictly increasing Alice’s score.\n\nThis runs in \\(O(k\\log k)\\) per test (dominated by sorting the \\(k\\) fountains), and \\(\\sum k\\le2\\cdot10^5\\) over all tests is perfectly fine in 3 seconds."
  },
  {
    "role": "system",
    "content": "Identify any errors in this response and output a prompt to help the AI resolve said issues. Your response MUST be in one of two formats: 1. If the response looks perfect, return \"Perfect\". Do not return this if there are any issues. Use this very sparingly as any errors in the final output from the AI will be considered a failure on your part. 2. Otherwise, return \"{prompt}\" where {prompt} is replaced with your concise prompt. This should be done most often, even if the AI's response is mostly correct. Ensure the entire response is enclosed in double quotations if it's a prompt. Make sure your prompt asks the AI to return one block of code for submission."
  },
  {
    "role": "assistant",
    "content": "Perfect"
  }
]