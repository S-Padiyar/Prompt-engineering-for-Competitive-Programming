[
  {
    "timestamp": "2025-07-24T05:53:24.819723",
    "role": "user",
    "content": "Please provide the Java solution as a single code block ready for submission, without markdown fences."
  },
  {
    "timestamp": "2025-07-24T05:54:26.767325",
    "role": "assistant",
    "content": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class DivInfo {\n        int m;                    // number of divisors\n        int[] divs;               // the list of divisors\n        int idxX;                 // index of divisor x itself\n        Map<Integer,Integer> indexOf;    // maps divisor -> its index in divs[]\n        @SuppressWarnings(\"unchecked\")\n        ArrayList<int[]>[] mapping = new ArrayList[0]; // for each gi, list of (oldIdx, newIdx)\n    }\n\n    // Precompute divisors of x, their indices, and the transition mapping.\n    static DivInfo build(int x) {\n        DivInfo D = new DivInfo();\n        // 1) gather divisors\n        List<Integer> tmp = new ArrayList<>();\n        for (int d = 1; d * d <= x; d++) {\n            if (x % d == 0) {\n                tmp.add(d);\n                if (d * d != x) tmp.add(x / d);\n            }\n        }\n        Collections.sort(tmp);\n        D.m = tmp.size();\n        D.divs = new int[D.m];\n        D.indexOf = new HashMap<>(D.m * 2);\n        for (int i = 0; i < D.m; i++) {\n            D.divs[i] = tmp.get(i);\n            D.indexOf.put(D.divs[i], i);\n        }\n        D.idxX = D.indexOf.get(x);\n\n        // 2) build mapping: for each divisor g = divs[gi],\n        //    for each old divisor d_j, see if d_j*g divides x\n        @SuppressWarnings(\"unchecked\")\n        ArrayList<int[]>[] map = new ArrayList[D.m];\n        for (int gi = 0; gi < D.m; gi++) {\n            int gval = D.divs[gi];\n            map[gi] = new ArrayList<>();\n            for (int j = 0; j < D.m; j++) {\n                long prod = 1L * D.divs[j] * gval;\n                if (prod <= x && x % (int)prod == 0) {\n                    int nxt = D.indexOf.get((int)prod);\n                    map[gi].add(new int[]{j, nxt});\n                }\n            }\n        }\n        D.mapping = map;\n        return D;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(in.readLine().trim());\n        StringBuilder out = new StringBuilder();\n\n        while (t-- > 0) {\n            StringTokenizer st = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int x = Integer.parseInt(st.nextToken());\n            int[] a = new int[n];\n            st = new StringTokenizer(in.readLine());\n            for (int i = 0; i < n; i++) {\n                a[i] = Integer.parseInt(st.nextToken());\n            }\n\n            DivInfo D = build(x);\n\n            int segments = 1;\n            BitSet dp = new BitSet(D.m);\n            dp.set(D.indexOf.get(1));  // start: we can form product=1 with empty subset\n\n            for (int val : a) {\n                if (x % val != 0) {\n                    // this card never contributes to reaching exactly x\n                    continue;\n                }\n                int gi = D.indexOf.get(val);\n                // 1) try to incorporate val into current segment\n                BitSet nextDp = (BitSet) dp.clone();\n                for (int[] pr : D.mapping[gi]) {\n                    if (dp.get(pr[0])) {\n                        nextDp.set(pr[1]);\n                    }\n                }\n                dp = nextDp;\n\n                // 2) if we can now form x, segment turned \"good\" => we must cut\n                if (dp.get(D.idxX)) {\n                    segments++;\n                    // reset dp for new segment\n                    dp.clear();\n                    dp.set(D.indexOf.get(1));\n                    // re-apply this card into the new segment\n                    nextDp = (BitSet) dp.clone();\n                    for (int[] pr : D.mapping[gi]) {\n                        if (dp.get(pr[0])) {\n                            nextDp.set(pr[1]);\n                        }\n                    }\n                    dp = nextDp;\n                }\n            }\n            out.append(segments).append('\\n');\n        }\n\n        System.out.print(out);\n    }\n}"
  }
]