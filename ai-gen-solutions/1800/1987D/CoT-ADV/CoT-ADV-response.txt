**Problem Restatement**

We have a multiset of \(n\) cakes, each with an integer tastiness \(a_i\). Alice and Bob play a turn‐based game:

- Alice always goes first. On her turn, she must pick (and remove) **any** remaining cake whose tastiness is strictly greater than the maximum tastiness she has already eaten. On her very first turn she can pick any cake.
- Bob, on his turn, picks **any** remaining cake (no restriction except it must exist).

They alternate turns until the player to move cannot pick a cake (Alice has no remaining cake strictly above her personal “last” value, or Bob has no remaining cakes at all). Let \(x\) be the number of cakes Alice has eaten by the end. Alice tries to **maximize** \(x\), Bob tries to **minimize** it. We must compute the resulting \(x\) under optimal play.

---

**Key Observation & Greedy Strategy**

1.  **Alice’s best move** at any time is to pick the *smallest* cake that is still strictly above her last eaten tastiness.  By doing so she keeps her “last” as small as possible, preserving the maximum future options.

2.  **Bob’s best countermove** is to pick the *largest* remaining cake.  Removing the largest cake each time most effectively chops off Alice’s tail of potential future picks, since Alice must always pick increasingly.

It turns out that this pair of greedy choices for Alice and Bob simulates the minimax outcome of the full game:

- On Alice’s turn: remove the smallest element \(> \text{lastAlice}\).  
- On Bob’s turn: remove the largest remaining element.

We loop until Alice cannot find any cake strictly above her last eaten, or until the multiset becomes empty after Bob’s move.

---

**Complexities**

- We will maintain a balanced‐tree multiset (Java’s `TreeMap<Integer,Integer>`), giving \(O(\log n)\) insertions, deletions, and predecessor/successor queries.
- Each cake is removed exactly once, giving \(O(n)\) removal operations.        
- Total per test case: \(O(n\log n)\).  Since \(\sum n \le 5000\), this is fast enough.

---

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            // Build multiset of cake tastiness values
            TreeMap<Integer,Integer> multiset = new TreeMap<>();
            for (int i = 0; i < n; i++) {
                int v = sc.nextInt();
                multiset.put(v, multiset.getOrDefault(v, 0) + 1);
            }
            
            int ans = 0;        // number of cakes Alice eats
            int last = 0;       // Alice's last eaten tastiness
            
            while (true) {
                // Alice's turn: pick smallest key > last
                Integer aliceChoice = multiset.higherKey(last);
                if (aliceChoice == null) {
                    // No suitable cake for Alice -- game ends
                    break;
                }
                // Remove one occurrence of aliceChoice
                decrementCount(multiset, aliceChoice);
                ans++;
                last = aliceChoice;
                
                // Bob's turn: pick largest remaining cake (if any)
                if (multiset.isEmpty()) {
                    // No cake left for Bob, game ends
                    break;
                }
                Integer bobChoice = multiset.lastKey();
                decrementCount(multiset, bobChoice);
                // Bob's pick does not affect 'last'
            }
            
            System.out.println(ans);
        }
        sc.close();
    }
    
    // Helper to decrement a key's count in the multiset, removing if it hits zero
    private static void decrementCount(TreeMap<Integer,Integer> map, int key) {
        int cnt = map.get(key);
        if (cnt == 1) {
            map.remove(key);
        } else {
            map.put(key, cnt - 1);
        }
    }
}
```

---

**Walk‐through on a Sample**

Take the test case  
```
n = 7  
a = [6, 1, 1, 3, 5, 3, 1]
```
Sorted multiset (as a `TreeMap`): {1×3,3×2,5×1,6×1}.

- Alice turn 1: picks the smallest > last(=0) → 1.  
  Remaining {1×2,3×2,5,6}, last=1, ans=1.

- Bob turn 1: picks largest → 6.  
  Remaining {1×2,3×2,5}.

- Alice turn 2: picks smallest > last(=1) → 3.  
  Remaining {1×2,3,5}, last=3, ans=2.

- Bob turn 2: picks largest → 5.  
  Remaining {1×2,3}.

- Alice turn 3: tries to pick > last(=3).  The only keys are 1 or 3, none >3.  
  **Game ends**, Alice has eaten **2** cakes.  

This matches the provided example output.

---

**Time & Space Complexity**

- Each test case does up to \(n\) removals (Alice \(+\) Bob combined), each in \(O(\log n)\) time for the TreeMap operations (finding higher key / last key and updating counts).  
- Thus per test case: \(O(n\log n)\).  
- Sum of all \(n\) over all test cases is \(\le 5000\), so the total work is under \(5000\log 5000\approx 5000\times12\), easily within the 2 s limit.
- Extra space is \(O(n)\) for the multiset.