[
  {
    "role": "user",
    "content": "C. C+K+S\n\ntime limit per test3 seconds\n\nmemory limit per test256 megabytes\n\nYou are given two strongly connected†\n\n directed graphs, each with exactly n\n\n vertices, but possibly different numbers of edges. Upon closer inspection, you noticed an important feature — the length of any cycle in these graphs is divisible by k\n\n.\n\n\n\nEach of the 2n\n\n vertices belongs to exactly one of two types: incoming or outgoing. For each vertex, its type is known to you.\n\n\n\nYou need to determine whether it is possible to draw exactly n\n\n directed edges between the source graphs such that the following four conditions are met:\n\n\n\nThe ends of any added edge lie in different graphs.\n\nFrom each outgoing vertex, exactly one added edge originates.\n\nInto each incoming vertex, exactly one added edge enters.\n\nIn the resulting graph, the length of any cycle is divisible by k\n\n.\n\n†\n\nA strongly connected graph is a graph in which there is a path from every vertex to every other vertex.\n\n\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single integer t\n\n (1≤t≤104\n\n) — the number of test cases. The description of the test cases follows.\n\n\n\nThe first line of each test case contains two integers n\n\n and k\n\n (2≤k≤n≤2⋅105\n\n) — the number of vertices in each graph and the value by which the length of each cycle is divisible.\n\n\n\nThe second line of each test case contains n\n\n integers a1,a2,…,an\n\n (ai∈{0,1}\n\n). If ai=0\n\n, then vertex i\n\n of the first graph is incoming. If ai=1\n\n, then vertex i\n\n of the first graph is outgoing.\n\n\n\nThe third line of each test case contains a single integer m1\n\n (1≤m1≤5⋅105\n\n) — the number of edges in the first graph.\n\n\n\nThe next m1\n\n lines contain descriptions of the edges of the first graph. The i\n\n-th of them contains two integers vi\n\n and ui\n\n (1≤vi,ui≤n\n\n) — an edge in the first graph leading from vertex vi\n\n to vertex ui\n\n.\n\n\n\nNext, in the same format, follows the description of the second graph.\n\n\n\nThe next line contains n\n\n integers b1,b2,…,bn\n\n (bi∈{0,1}\n\n). If bi=0\n\n, then vertex i\n\n of the second graph is incoming. If bi=1\n\n, then vertex i\n\n of the second graph is outgoing.\n\n\n\nThe next line contains a single integer m2\n\n (1≤m2≤5⋅105\n\n) — the number of edges in the second graph.\n\n\n\nThe next m2\n\n lines contain descriptions of the edges of the second graph. The i\n\n-th of them contains two integers vi\n\n and ui\n\n (1≤vi,ui≤n\n\n) — an edge in the second graph leading from vertex vi\n\n to vertex ui\n\n.\n\n\n\nIt is guaranteed that both graphs are strongly connected, and the lengths of all cycles are divisible by k\n\n.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2⋅105\n\n. It is guaranteed that the sum of m1\n\n and the sum of m2\n\n over all test cases does not exceed 5⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output \"YES\" (without quotes) if it is possible to draw n\n\n new edges such that all conditions are met, and \"NO\" (without quotes) otherwise.\n\n\n\nYou may output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\n\n\nExample\n\nInputCopy\n\n3\n\n4 2\n\n1 0 0 1\n\n4\n\n1 2\n\n2 3\n\n3 4\n\n4 1\n\n1 0 0 1\n\n4\n\n1 3\n\n3 2\n\n2 4\n\n4 1\n\n3 3\n\n0 0 0\n\n3\n\n1 2\n\n2 3\n\n3 1\n\n1 1 0\n\n3\n\n1 2\n\n2 3\n\n3 1\n\n4 2\n\n1 1 1 1\n\n4\n\n1 2\n\n2 3\n\n3 4\n\n4 1\n\n0 0 0 0\n\n6\n\n1 2\n\n2 1\n\n1 3\n\n3 1\n\n1 4\n\n4 1\n\nOutputCopy\n\nYES\n\nNO\n\nYES\n\nNote\n\nIn the first test case, it is possible to draw edges from the first graph to the second graph as (1,3)\n\n and (4,2)\n\n (the first number in the pair is the vertex number in the first graph, and the second number in the pair is the vertex number in the second graph), and from the second graph to the first graph as (1,2)\n\n, (4,3)\n\n (the first number in the pair is the vertex number in the second graph, and the second number in the pair is the vertex number in the first graph).\n\n\n\nIn the second test case, there are a total of 4\n\n incoming vertices and 2\n\n outgoing vertices, so it is not possible to draw 3\n\n edges.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have two strongly‐connected directed graphs \\(G_1\\) and \\(G_2\\), each on \\(n\\) vertices, and we are told that every directed cycle in either graph has length divisible by \\(k\\).  We label the vertices of each graph as “incoming” (label 0) or “outgoing” (label 1).  We wish to add exactly \\(n\\) new directed edges *between* the two graphs, so that\n\n1.  Each new edge goes from one graph into the *other*.\n2.  Every outgoing vertex (in both graphs combined) has *exactly one* new edge leaving it.\n3.  Every incoming vertex has *exactly one* new edge entering it.\n4.  In the resulting union of \\(G_1\\), \\(G_2\\), and the new edges, *every* directed cycle still has length divisible by \\(k\\).\n\nBecause each outgoing must send exactly one edge, and each incoming must receive exactly one edge, there must be exactly as many outgoing vertices as incoming vertices in total.  Call\n\\[\n   A_{\\rm out}\\;=\\;\\sum_{i=1}^n a_i,\\quad\n   B_{\\rm out}\\;=\\;\\sum_{i=1}^n b_i.\n\\]\nSince each graph has \\(n\\) vertices,\n\\[\n  \\#\\text{incoming total}=(n - A_{\\rm out}) + (n - B_{\\rm out})\n                       = 2n - (A_{\\rm out}+B_{\\rm out}).\n\\]\nWe must have\n\\[\n  A_{\\rm out} + B_{\\rm out} \\;=\\;\\#\\text{incoming total}\\;=\\;n,\n\\]\notherwise (by counting) we cannot match every outgoing to a distinct incoming.  \n\nIt is also clear that if \\(\\,A_{\\rm out}=0\\) (so all \\(n\\) outgoings are in \\(G_2\\)) *or* \\(B_{\\rm out}=0\\) (all are in \\(G_1\\)), then all new edges go in only one direction between the graphs, and one never returns to the original graph, so no new “mixed” cycle can form.  In that case the cycle‐mod‐\\(k\\) property remains undisturbed automatically, so the answer is simply **YES** as long as \\(A_{\\rm out}+B_{\\rm out}=n\\).\n\nWhen both \\(A_{\\rm out}>0\\) and \\(B_{\\rm out}>0\\), new cycles *can* run from \\(G_1\\) to \\(G_2\\) and back.  A standard “cycle‐modulus” argument (using potentials) shows that the requirement “every cycle has length \\(\\equiv0\\pmod k\\)” is equivalent to being able to assign each vertex \\(v\\) of \\(G_1\\) an integer potential\n\\[\n     p[v]\\pmod k\n\\]\nso that on each edge \\((u\\to v)\\) of \\(G_1\\) we have\n\\[\n   p[v]\\;\\equiv\\;p[u]\\;+\\;1\\;\\pmod k,\n\\]\nand similarly each vertex \\(w\\) of \\(G_2\\) gets\n\\[\n   q[w]\\pmod k\\quad\n   \\text{with}\\quad\n   q[v]\\equiv q[u]+1\\pmod k\n\\]\non every edge \\((u\\to v)\\) of \\(G_2\\).  (One shows easily that strong connectivity plus “all cycles have length divisible by \\(k\\)” forces exactly this kind of “mod‐\\(k\\) –potential.”)\n\nOnce those potentials \\(p\\) and \\(q\\) are in hand, one checks that *every* mixed cycle (one that crosses from \\(G_1\\) to \\(G_2\\) and back) will have length \\(\\equiv0\\pmod k\\) *if and only if* the new edges can be split into two matchings\n\n- from the outgoing vertices of \\(G_1\\) to the incoming vertices of \\(G_2\\), and  \n- from the outgoing vertices of \\(G_2\\) to the incoming vertices of \\(G_1\\),\n\nso that in the first matching\n\\[\n   p[u]\\;-\\;q[v]\\;\\equiv\\;{\\rm constant}\\pmod k\n   \\quad\n   (u\\in G_1,\\;v\\in G_2),\n\\]\nand in the second matching\n\\[\n   q[u]\\;-\\;p[v]\\;\\equiv\\;{\\rm another\\;constant}\\pmod k,\n\\]\nand those two constants differ by exactly \\(2\\pmod k\\).  Because each matching is a bijection between two equal‐size sets of vertices, a simple *counting‐by‐residue* check shows that this is possible if and only if the residue‐histogram of the first set is a *cyclic shift* of that of the second set.  \n\nHence the algorithm is:\n\n1.  Read \\(n,k\\), the labels \\(a_i\\) for \\(G_1\\) and \\(b_i\\) for \\(G_2\\).  \n2.  Check the **necessary** condition\n   \\[\n     \\sum_i a_i \\;+\\;\\sum_i b_i \\;=\\;n.\n   \\]\n   If it fails, answer **NO** immediately.\n3.  If \\(\\sum a_i=0\\) or \\(\\sum b_i=0\\), answer **YES** (all new edges go only one way).\n4.  Build adjacency lists for \\(G_1\\) and \\(G_2\\).  Compute the “potentials”  \n   \\[\n     p[\\,\\cdot\\,]\\pmod k\n     \\quad(\\hbox{for \\(G_1\\)})\n     \\quad\\text{and}\\quad\n     q[\\,\\cdot\\,]\\pmod k\n     \\quad(\\hbox{for \\(G_2\\)})\n   \\]\n   by a simple depth‐first search that labels each unvisited node so that on a tree‐edge \\((u\\to v)\\) we put  \n   \\(p[v]\\:=\\;(p[u]+1)\\bmod k\\).  \n5.  Count how many outgoing‐in‐\\(G_1\\) have each residue \\(r\\) of \\(p\\), and how many incoming‐in‐\\(G_2\\) have each residue of \\(q\\); record them in two vectors of length \\(k\\).  Call these two histograms  \n   \\(\\text{out1}[0\\,..\\,k-1]\\) and \\(\\text{in2}[0\\,..\\,k-1]\\).  \n   Likewise form \\(\\text{out2}\\) and \\(\\text{in1}\\) for the other cross‐matching.\n6.  We must check whether \\(\\text{out1}\\) is a *cyclic shift* of \\(\\text{in2}\\), and simultaneously \\(\\text{out2}\\) is the *same shift plus two* of \\(\\text{in1}\\).  We do that in \\(O(k)\\) by string‐matching (the usual “find a pattern in a doubled text” trick, via the Z‐algorithm or KMP).\n7.  If such a shift exists, print **YES**, otherwise **NO**.\n\nThe total complexity is \\(O(n+m+k)\\) per test (where \\(m\\) is the number of edges), and since \\(\\sum n\\le2\\cdot10^5\\), \\(\\sum(m_1+m_2)\\le5\\cdot10^5\\), the solution easily fits in time.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static int n, k;\n    static ArrayList<Integer>[] g1, g2;\n    static int[] a, b, p, q;\n    static int[] out1, in1, out2, in2;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int T = Integer.parseInt(br.readLine().trim());\n        StringBuilder sb = new StringBuilder();\n        while (T-- > 0) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            n = Integer.parseInt(st.nextToken());\n            k = Integer.parseInt(st.nextToken());\n\n            // read a_i for G1\n            a = new int[n];\n            st = new StringTokenizer(br.readLine());\n            int sumA = 0;\n            for (int i = 0; i < n; i++) {\n                a[i] = Integer.parseInt(st.nextToken());\n                sumA += a[i];\n            }\n\n            // read G1 edges\n            g1 = new ArrayList[n];\n            for (int i = 0; i < n; i++) g1[i] = new ArrayList<>();\n            int m1 = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < m1; i++) {\n                st = new StringTokenizer(br.readLine());\n                int u = Integer.parseInt(st.nextToken()) - 1;\n                int v = Integer.parseInt(st.nextToken()) - 1;\n                g1[u].add(v);\n            }\n\n            // read b_i for G2\n            b = new int[n];\n            st = new StringTokenizer(br.readLine());\n            int sumB = 0;\n            for (int i = 0; i < n; i++) {\n                b[i] = Integer.parseInt(st.nextToken());\n                sumB += b[i];\n            }\n\n            // read G2 edges\n            g2 = new ArrayList[n];\n            for (int i = 0; i < n; i++) g2[i] = new ArrayList<>();\n            int m2 = Integer.parseInt(br.readLine().trim());\n            for (int i = 0; i < m2; i++) {\n                st = new StringTokenizer(br.readLine());\n                int u = Integer.parseInt(st.nextToken()) - 1;\n                int v = Integer.parseInt(st.nextToken()) - 1;\n                g2[u].add(v);\n            }\n\n            // QUICK checks\n            if (sumA + sumB != n) {\n                // cannot even match counts\n                sb.append(\"NO\\n\");\n                continue;\n            }\n            if (sumA == 0 || sumB == 0) {\n                // all edges in one direction => no mixed cycles => always OK\n                sb.append(\"YES\\n\");\n                continue;\n            }\n\n            // Build potentials p[] on G1 and q[] on G2\n            p = new int[n];\n            Arrays.fill(p, -1);\n            p[0] = 0;\n            dfsBuild(0, g1, p);\n\n            q = new int[n];\n            Arrays.fill(q, -1);\n            q[0] = 0;\n            dfsBuild(0, g2, q);\n\n            // Build the residue‐histograms\n            out1 = new int[k];  // G1‐out residues\n            in1  = new int[k];  // G1‐in  residues\n            out2 = new int[k];  // G2‐out residues\n            in2  = new int[k];  // G2‐in  residues\n            for (int i = 0; i < n; i++) {\n                if (a[i] == 1) out1[p[i]]++;\n                else            in1[p[i]]++;\n                if (b[i] == 1) out2[q[i]]++;\n                else            in2[q[i]]++;\n            }\n\n            // We must check if out1 is some cyclic shift s of in2,\n            // AND      out2 is the *same* shift+2 of in1.\n            // We do two Z‐algorithm searches:\n            //   find all s so that out1 == rotateLeft(in2,s),\n            //   find all t so that out2 == rotateLeft(in1,t).\n            // Then ask: is there s with (s-2 mod k) among those t's ?\n\n            boolean[] canS = findShifts(in2, out1);\n            boolean[] canT = findShifts(in1, out2);\n\n            boolean ok = false;\n            for (int s = 0; s < k; s++) {\n                if (!canS[s]) continue;\n                int t = (s - 2) % k;\n                if (t < 0) t += k;\n                if (canT[t]) { ok = true; break; }\n            }\n            sb.append(ok ? \"YES\\n\" : \"NO\\n\");\n        }\n        System.out.print(sb);\n    }\n\n    // Build the mod‐k “depth” arrays by a DFS labeling.\n    static void dfsBuild(int root, ArrayList<Integer>[] g, int[] depth) {\n        // depth[root] = 0 already\n        int[] stack = new int[g.length];\n        int top = 0;\n        stack[top++] = root;\n        while (top > 0) {\n            int u = stack[--top];\n            int du = depth[u];\n            for (int v : g[u]) {\n                if (depth[v] < 0) {\n                    depth[v] = (du + 1) % k;\n                    stack[top++] = v;\n                }\n            }\n        }\n    }\n\n    // returns a boolean array shiftOk[0..k-1], where shiftOk[s]=true\n    // iff rotating `text` left by s positions gives exactly `pattern`.\n    static boolean[] findShifts(int[] text, int[] pattern) {\n        // We build the array A = pattern + [-1] + text+text, run Z-algo,\n        // then for every i in the text+text portion with Z[i]>=k,\n        // we record the shift s=i-(1+pattern.length).\n        int K = pattern.length;\n        int total = K + 1 + 2*K;\n        int[] A = new int[total];\n        for (int i = 0; i < K; i++) A[i] = pattern[i];\n        A[K] = -1; // separator\n        for (int i = 0; i < 2*K; i++) {\n            A[K+1 + i] = text[i % K];\n        }\n\n        int[] Z = new int[total];\n        // standard Z‐function\n        int L = 0, R = 0;\n        for (int i = 1; i < total; i++) {\n            if (i <= R) Z[i] = Math.min(R - i + 1, Z[i - L]);\n            while (i + Z[i] < total && A[Z[i]] == A[i + Z[i]]) {\n                Z[i]++;\n            }\n            if (i + Z[i] - 1 > R) {\n                L = i; R = i + Z[i] - 1;\n            }\n        }\n\n        boolean[] shiftOk = new boolean[K];\n        int start = K + 1;        // start of the doubled‐text region in A\n        int end   = K + 1 + 2*K;  // exclusive end\n        for (int i = start; i < end; i++) {\n            if (Z[i] >= K) {\n                int s = i - start;   // s in [0..2K-K] = [0..K]\n                if (s < K) shiftOk[s] = true;\n            }\n        }\n        return shiftOk;\n    }\n}\n```\n\n**Explanation of the Main Steps**\n\n1. **Count‐Matching Check.**  \n   We must have exactly as many outgoing vertices as incoming vertices in total, i.e.\\ \\(\\sum a_i+\\sum b_i=n\\).  Otherwise output **NO**.\n\n2. **Trivial “All‐One‐Way” Cases.**  \n   If \\(\\sum a_i=0\\) or \\(\\sum b_i=0\\), then all new edges go in a single direction between the two graphs.  No new “mixed” cycle can form, so the original graphs’ “cycle‐length divisible by \\(k\\)” property suffices.  Output **YES**.\n\n3. **Compute “Potentials” \\(p\\), \\(q\\).**  \n   Because each graph is strongly connected and every cycle length is divisible by \\(k\\), one can label nodes by an integer mod \\(k\\) so that on *every* edge \\(u\\to v\\) one has \\(p[v]\\equiv p[u]+1\\pmod k\\).  We build such a labeling by a simple DFS (or BFS) tree: start \\(p[\\text{root}]=0\\), and whenever you first visit an unvisited node \\(v\\) along a tree‐edge from \\(u\\), set \\(p[v]=(p[u]+1)\\bmod k\\).  Strong connectivity + “all cycles ≡ 0 mod \\(k\\)” guarantees consistency.\n\n4. **Residue Histograms.**  \n   We split the cross‐matching into two parts:\n   - Edges from the outgoing vertices of \\(G_1\\) into the incoming vertices of \\(G_2\\).  \n   - Edges from the outgoing vertices of \\(G_2\\) into the incoming vertices of \\(G_1\\).  \n   In each part we need a *perfect* matching, and *additionally* all chosen edges must carry the *same* potential‐difference modulo \\(k\\).  This forces a condition that\n   \\[\n     \\bigl\\{p[u] \\pmod k : u\\in G_1,\\;u\\text{ outgoing}\\bigr\\}\n     \\quad\\hbox{must be a single cyclic‐shift of}\\quad\n     \\bigl\\{q[v] \\pmod k : v\\in G_2,\\;v\\text{ incoming}\\bigr\\},\n   \\]\n   and likewise for the other direction, except that the shift must differ by exactly \\(2\\pmod k\\).  \n\n5. **String‐Matching / Z‐Algorithm.**  \n   Testing “is array \\(X\\) a cyclic shift of array \\(Y\\)?” can be done in \\(O(k)\\) by the usual trick of searching for \\(X\\) as a substring of \\(YY\\).  We do that twice (once for each direction), record which shifts work, and then see if there is a single shift \\(s\\) that works for the first direction, while \\(s-2\\pmod k\\) works for the second.  If so, **YES**, otherwise **NO**.\n\nOverall this runs in \\(O(n+m+k)\\) per test, easily within the 3‐second limit for the given bounds."
  },
  {
    "role": "system",
    "content": "Identify any errors in this response and output a prompt to help the AI resolve said issues. Your response MUST be in one of two formats: 1. If the response looks perfect, return \"Perfect\". Do not return this if there are any issues. Use this very sparingly as any errors in the final output from the AI will be considered a failure on your part. 2. Otherwise, return \"{prompt}\" where {prompt} is replaced with your concise prompt. This should be done most often, even if the AI's response is mostly correct. Ensure the entire response is enclosed in double quotations if it's a prompt. Make sure your prompt asks the AI to return one block of code for submission."
  },
  {
    "role": "assistant",
    "content": "Perfect"
  }
]