[
  {
    "role": "user",
    "content": "D. Determine Winning Islands in Race\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nMOOOOOOOOOOOOOOOOO\n\n— Bessie the Cow, The Art of Racing on Islands\n\nTwo of Farmer John's cows, Bessie and Elsie, are planning to race on n\n\n islands. There are n−1\n\n main bridges, connecting island i\n\n to island i+1\n\n for all 1≤i≤n−1\n\n. Additionally, there are m\n\n alternative bridges. Elsie can use both main and alternative bridges, while Bessie can only use main bridges. All bridges are one way and can only be used to travel from an island with a lower index to an island with a higher index.\n\n\n\nInitially, Elsie starts on island 1\n\n, and Bessie starts on island s\n\n. The cows alternate turns, with Bessie making the first turn. Suppose the cow is on island i\n\n. During a cow's turn, if there are any bridges connecting island i\n\n to island j\n\n, then the cow can move to island j\n\n. Then, island i\n\n collapses, and all bridges connecting to island i\n\n also collapse. Also, note the following:\n\n\n\nIf there are no bridges connecting island i\n\n to another island, then island i\n\n collapses, and this cow is eliminated from the race.\n\nIf the other cow is also on island i\n\n, then after this cow moves to another island, the island collapses, and the other cow is eliminated from the race.\n\nAfter an island or bridge collapses, no cows may use them.\n\nIf a cow is eliminated, their turn is skipped for the rest of the race.\n\nThe race ends once either cow reaches island n\n\n. It can be shown that regardless of the cows' strategies, at least one cow reaches island n\n\n. Bessie wins if and only if she reaches island n\n\n first.\n\n\n\nFor each 1≤s≤n−1\n\n, determine whether Bessie wins if she starts the race on island s\n\n. Assume both cows follow optimal strategies to ensure their own respective victories.\n\n\n\nInput\n\nThe first line contains t\n\n (1≤t≤104\n\n) – the number of test cases.\n\n\n\nThe first line of each test case contains n\n\n and m\n\n (2≤n≤2⋅105\n\n, 0≤m≤2⋅105\n\n) – the number of islands and the number of alternative bridges.\n\n\n\nThe next m\n\n lines of each test case contain u\n\n and v\n\n (1≤u<v≤n\n\n) – the islands that the alternative bridge connects. It is guaranteed all alternative bridges are distinct, and they do not coincide with the main bridges.\n\n\n\nIt is guaranteed that neither the sum of n\n\n nor the sum of m\n\n over all test cases exceeds 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output a binary string of length n−1\n\n on a new line. The i\n\n'th character is 1\n\n if it is possible for Bessie to win if she starts on island i\n\n. Otherwise, it is 0\n\n.\n\n\n\nExample\n\nInputCopy\n\n5\n\n6 0\n\n6 1\n\n2 6\n\n6 1\n\n1 5\n\n10 4\n\n1 3\n\n1 6\n\n2 7\n\n3 8\n\n15 3\n\n2 8\n\n4 9\n\n8 15\n\nOutputCopy\n\n11111\n\n11011\n\n10011\n\n100001111\n\n11000111000111\n\nNote\n\nIn the first test case, there are no alternative bridges for Elsie to overtake Bessie and reach island n\n\n first, so Bessie will win on all islands because she always moves first.\n\n\n\nIn the second case, Bessie will lose if she starts on island 3\n\n because:\n\n\n\nBessie's Turn: Take a main bridge from island 3\n\n to island 4\n\n.\n\nElsie's Turn: Take a main bridge from island 1\n\n to island 2\n\n.\n\nBessie's Turn: Take a main bridge from island 4\n\n to island 5\n\n.\n\nElsie's Turn: Take an alternative bridge from island 2\n\n to island 6\n\n. Elsie reaches island n\n\n first.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have two cows, Bessie and Elsie, racing on a directed acyclic graph of \\(n\\) “islands” (vertices) \\(1,2,\\dots,n\\).  There are two kinds of one‐way edges:\n\n 1. **Main bridges**: for each \\(i=1,2,\\dots,n-1\\) there is an edge \\(i\\to i+1\\).  Bessie may use **only** these main bridges; Elsie may use **both** main bridges and \\(m\\) extra “alternative” bridges \\((u\\to v)\\) with \\(1\\le u<v\\le n\\).\n\n 2. **Alternative bridges**: \\(m\\) arbitrary edges \\(u\\to v\\) (distinct from the main edges), all one‐way and with \\(u<v\\).\n\nBoth cows only move “forward” (to higher‐indexed islands).  They alternate turns, Bessie first.  On her turn, a cow **must** move along one of the outgoing bridges from her current island; immediately after moving, the island she departed collapses (it disappears, and so do all bridges touching it).  If on a cow’s turn there are no outgoing bridges, then that cow is eliminated.  If one cow ever occupies the same island as the other (after that cow’s move), and then the other cow on her very next move leaves that shared island, the collapse of the shared island eliminates the cow who stayed behind.  Finally the race ends as soon as **either** cow reaches island \\(n\\), and Bessie **wins** if and only if she is the first to island \\(n\\).\n\nWe must answer, for **each** starting position \\(s=1,2,\\dots,n-1\\) of Bessie (with Elsie always starting at 1), whether Bessie can force a win, assuming **optimal** play.\n\n---\n\n### 1.  Why one‐way and “collapsing” reduces to a “timing” condition\n\n1.  Because all edges go from lower to higher indices, the underlying directed graph is acyclic.\n\n2.  Bessie’s path is **forced** to be \n\\[\n   s\\;\\to\\;s+1\\;\\to\\;s+2\\;\\to\\;\\cdots\\;\\to\\;n,\n\\]\nusing exactly \\(n-s\\) moves (one per Bessie‐turn).  She has no choice of “skips.”\n\n3.  Elsie’s path can use shortcuts (the alternative bridges), so let us compute the **shortest‐path** distances\n   \\[\n     \\mathrm{dist}_E[i]\\;=\\;\\min\\bigl\\{\\text{number of Elsie‐moves from 1 to }i\\bigr\\}\n   \\]\n   over the combined graph (main \\(+\\) alternative).  In particular \n   \\[\n     L \\;=\\;\\mathrm{dist}_E[n]\n   \\]\n   is the fewest moves Elsie needs to reach \\(n\\).\n\n4.  **If nothing collapsed**, Bessie would win exactly when Bessie’s \\((n-s)\\) th move occurs **no later** than Elsie’s \\(L\\)th move.  Since they alternate (B first), Bessie’s \\(k\\)th move occurs on the \\((2k\\!-\\!1)\\)th overall turn, and Elsie’s \\(L\\)th move on the \\((2L)\\)th turn.  Bessie reaches on turn \\(2(n-s)-1\\); Elsie on turn \\(2L\\).  Bessie beats Elsie iff\n   \\[\n     2(n-s)-1 \\;<\\;2L,\n   \\]\n   i.e. \n   \\[\n     n-s \\;\\le\\; L.\n   \\]\n   Equivalently Elsie would win if \\(L\\le n-s-1\\).\n\n5.  However, each move **collapses** the island just departed, and that can destroy future edges.  \n   In particular when Bessie moves off island \\(j\\) (on her turn) she collapses \\(j\\).  Hence if Elsie ever wanted to use island \\(j\\ge s\\) as an intermediate, she must **arrive there** *before* Bessie collapses it.  \n\n   One checks that Bessie collapses island \\(j\\ge s\\) on her \\((j-s+1)\\)th move, i.e.\\ at overall time\n   \\[\n     T_B(j)\\;=\\;2\\,(j-s+1)\\;-\\;1\\;=\\;2(j-s)+1.\n   \\]\n   Elsie arrives at island \\(j\\) after exactly \\(\\mathrm{dist}_E[j]\\) of her moves, i.e.\\ at time\n   \\[\n     T_E(j)\\;=\\;2\\,\\mathrm{dist}_E[j].\n   \\]\n   To keep \\(j\\) *un*-collapsed when Elsie steps onto it we require\n   \\[\n     T_E(j)\\;<\\;T_B(j)\n     \\quad\\Longrightarrow\\quad\n     2\\,\\mathrm{dist}_E[j]\\;<\\;2(j-s)+1\n     \\quad\\Longrightarrow\\quad\n     \\mathrm{dist}_E[j]\\;\\le\\;j-s.\n   \\]\n   If \\(j<s\\), Bessie never collapses \\(j\\), so there is no constraint for \\(j<s\\).\n\n6.  Thus for **every** island \\(j\\) on the route Elsie uses (except 1 initially), if \\(j\\ge s\\) we must have\n   \\[\n     \\mathrm{dist}_E[j]\\;\\le\\;j - s.\n   \\]\n   In particular to actually reach \\(n\\), Elsie’s entire chosen path must obey that “safety” constraint at each intermediary node.\n\n7.  Finally the **winning condition** becomes:\n   \n   “There exists an Elsie‐path from \\(1\\to n\\) of length \\(L\\), using only islands \\(j\\) which satisfy \\(\\mathrm{dist}_E[j]\\le j-s\\) (if \\(j\\ge s\\)), **and** \\(L\\le n-s-1\\).  If so, Elsie can beat Bessie; otherwise Bessie wins.”\n\n8.  We must decide this for every \\(s=1,2,\\dots,n-1\\).  \n\n   -  **Special case** \\(s=1\\).  Both start at island 1.  Bessie moves first, collapses 1 immediately and **eliminates** Elsie outright.  Hence Bessie trivially wins for \\(s=1\\).\n\n   -  For \\(s\\ge2\\), we check existence of a “safe‐and‐short” Elsie path.  If none exists, Bessie wins at \\(s\\).\n\n---\n\n### 2.  Algorithm outline\n\n1.  **Compute \\(\\mathrm{dist}_E[i]\\)** = the fewest Elsie‐moves from 1 to \\(i\\).  This is a simple DP / single‐source shortest paths on a DAG with unit edge‐weights.  We process in increasing order of \\(i\\), keeping\n\n     \\[\n       \\mathrm{dist}_E[1]=0,\n       \\quad\n       \\mathrm{dist}_E[i]\n         =1+\\!\\min\\bigl\\{\\mathrm{dist}_E[i-1]\\bigr\\}\n           \\;\\cup\\;\\bigl\\{\\mathrm{dist}_E[u]\\;\\big|\\;(u\\to i)\\text{ alt}\\bigr\\}.\n     \\]\n\n   Complexity \\(O(n+m)\\).\n\n2.  We now have for each island \\(j\\) its arrival‐time in Elsie‐moves, \\(\\mathrm{dist}_E[j]\\).  \n\n3.  We must test, *for each* \\(s=2..n-1\\), whether there is a path from \\(1\\) to \\(n\\) using only islands \\(j\\) that satisfy\n\n      – if \\(j<s\\), no constraint (always safe),\n      \n      – if \\(j\\ge s\\), must have \\(\\mathrm{dist}_E[j]\\le j-s\\),\n\n   and whether the total path‐length \\(\\le n-s-1\\).\n\n   A **direct** re‐DP for each \\(s\\) would cost \\(O(n+m)\\) each, too big when \\(n\\) up to \\(2\\times10^5\\).\n\n4.  **Key observation** (“sweep‐line in \\(s\\)”)  \n\n   -  Define for each island \\(j\\) an **unsafe** interval of \\(s\\) in which \\(j\\) is disallowed:\n     \n       \\[\n         \\text{unsafe}_j \n         \\;=\\;\\bigl\\{\\,s\\;\\big|\\;2\\le s\\le n-1,\\;\n            j\\ge s,\\;\n            \\mathrm{dist}_E[j]>j-s\n         \\bigr\\}.\n       \\]\n     One checks that this is precisely\n       \\[\n         s\\in\\bigl[\\,\\,(j-\\mathrm{dist}_E[j]+1)\\;,\\;j\\,\\bigr].\n       \\]\n     (When \\(s\\) leaves that interval, either \\(j<s\\) or the inequality \\(\\mathrm{dist}_E[j]\\le j-s\\) holds again.)\n\n   -  As \\(s\\) runs from \\(2\\) to \\(n-1\\), each island \\(j\\) **enters** the forbidden set at \\(s=j-\\mathrm{dist}_E[j]+1\\) and **leaves** it at \\(s=j+1\\).  Thus over all \\(j\\) there are only \\(O(n)\\) “enter/leave” events.\n\n5.  We maintain a data‐structure that **dynamically** keeps track of which vertices are allowed, and recomputes (by a **single** forward‐DAG DP pass) the shortest allowed‐vertex path from \\(1\\to n\\).  We only need to re‐run the DP at those \\(O(n)\\) event-points, not for every single \\(s\\).\n\n6.  Since each DP pass is \\(O(n+m)\\), and there are \\(O(n)\\) events, a naïve “recompute” still would be too big.  **But** in fact one can do an *incremental* DAG‐DP (using a queue of just the vertices whose status changed) and maintain the current best distance to each vertex in **total** \\(O((n+m)\\,\\log n)\\).  \n\n   -  We keep a segment‐tree or a balanced‐BST keyed by the vertex‐index \\(i\\), storing whether \\(i\\) is currently allowed.  \n   -  Whenever an island “enters” or “leaves” the forbidden set, we update that single island’s allowed‐flag in \\(O(\\log n)\\).  \n   -  We also keep a priority‐queue (or multiset) of “those edges \\(u\\to v\\)” whose *cost* \\(\\mathrm{dp}[u]+1\\) might improve \\(\\mathrm{dp}[v]\\); but only if **both** \\(u\\) and \\(v\\) are allowed.  \n   -  One can update distances in total \\(O((n+m)\\log n)\\).\n\n7.  As we march \\(s\\) from \\(2\\) to \\(n-1\\), after processing all “enter/leave” events at that \\(s\\), we read off\n   \\[\n     \\mathrm{dp}_s[n]\\;=\\;\\text{current shortest distance from }1\\to n\\text{ in the allowed sub‐DAG},\n   \\]\n   and compare\n   \\[\n     \\mathrm{dp}_s[n]\\;\\le\\;n-s-1?\n   \\]\n   -  If “yes,” then Elsie can still finish in \\(n-s-1\\) or fewer moves, so **Bessie loses** at \\(s\\) (we write `0`).\n   -  If “no,” then even the best Elsie‐path is too long or impossible, so **Bessie wins** at \\(s\\) (we write `1`).\n\n8.  Finally force the special case \\(s=1\\) to `1` (Bessie wins by collapsing island 1 immediately).\n\nOverall complexity:  \n  – Computing \\(\\mathrm{dist}_E\\) in \\(O(n+m)\\).  \n  – Sorting the \\(2n\\) events in \\(O(n\\log n)\\).  \n  – Maintaining a dynamic DAG‐DP with \\(O(n+m)\\) edge‐updates in total \\(O((n+m)\\log n)\\).  \n  – Output the \\(n-1\\)-bit answer.\n\n---\n\n**Implementation in Java**\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int INF = 1000000007;\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        int T = Integer.parseInt(in.readLine());\n        final int MAXNM = 200_000;\n\n        // We'll reuse these arrays across test‐cases (cleared by resizing lists).\n        List<Integer>[] altFrom = new List[MAXNM+5];  // altFrom[u] = list of v for edges u->v\n        for(int i = 0; i <= MAXNM; i++){\n            altFrom[i] = new ArrayList<>();\n        }\n\n        // We will also need the reverse for computing dist_E efficiently:\n        List<Integer>[] altTo = new List[MAXNM+5];    // altTo[v] = list of u for edges u->v\n        for(int i = 0; i <= MAXNM; i++){\n            altTo[i] = new ArrayList<>();\n        }\n\n        while(T-- > 0){\n            StringTokenizer st = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(st.nextToken());\n\n            // clear out-of-range lists\n            for(int i = 1; i <= n; i++){\n                altFrom[i].clear();\n                altTo[i].clear();\n            }\n\n            for(int i = 0; i < m; i++){\n                st = new StringTokenizer(in.readLine());\n                int u = Integer.parseInt(st.nextToken());\n                int v = Integer.parseInt(st.nextToken());\n                altFrom[u].add(v);\n                altTo[v].add(u);\n            }\n\n            // 1) Compute distE[i] = min # of Elsie moves from 1->i\n            int[] distE = new int[n+1];\n            Arrays.fill(distE, INF);\n            distE[1] = 0;\n            for(int i = 2; i <= n; i++){\n                // main edge (i-1) -> i\n                distE[i] = Math.min(distE[i], distE[i-1] + 1);\n                // alternative edges\n                for(int u : altTo[i]){\n                    distE[i] = Math.min(distE[i], distE[u] + 1);\n                }\n            }\n\n            // 2) Build the list of \"events\" in s=2..n-1\n            //    For each island j, it becomes forbidden at s0 = (j - distE[j] + 1)\n            //    and becomes allowed again at s1 = j+1.\n            //    We'll sweep s from 2..n-1 and keep track.\n            List<Event> events = new ArrayList<>();\n            for(int j = 2; j <= n; j++){\n                int lim = j - distE[j];    // want distE[j] <= j - s  =>  s <= lim\n                // unsafe when s > lim  AND s <= j\n                // so s in [lim+1..j]\n                int enter = lim + 1;\n                int leave = j + 1;\n                if(enter < 2) enter = 2;\n                if(enter <= n-1){\n                    if(enter <= n-1) events.add(new Event(enter, +1, j));\n                    if(leave <= n-1) events.add(new Event(leave, -1, j));\n                }\n            }\n            // sort events by s\n            Collections.sort(events, Comparator.comparingInt(e->e.s));\n\n            // 3) We now do a “dynamic shortest‐path‐in‐a‐DAG” maintenance.\n            //    dp[i] = current shortest distance from 1->i in the subgraph of all currently-allowed vertices.\n            int[] dp = new int[n+1];\n            Arrays.fill(dp, INF);\n            dp[1] = 0;\n\n            // We will keep a min‐heap of (dp[u]+1, v) for every allowed edge u->v, so that\n            // we can pop the smallest candidate and relax dp[v] if still valid (both u,v allowed).\n            // We store edges by listing for each u its outgoing (main u->u+1) and alt edges.\n            class Candidate implements Comparable<Candidate> {\n                int d, v;\n                Candidate(int _d, int _v){ d=_d; v=_v; }\n                public int compareTo(Candidate o){\n                    return Integer.compare(d,o.d);\n                }\n            }\n            PriorityQueue<Candidate> pq = new PriorityQueue<>();\n\n            // allowed[v] = how many \"forbid\" counts on v  (0 => allowed, >0 => forbidden)\n            int[] forbidCount = new int[n+1];\n            // initially s=2 we have no forbids (we'll add as we sweep)\n            // build initial edge‐candidates for s=2\n            autoAddEdges:\n            for(int u = 1; u < n; u++){\n                // main edge\n                pq.add(new Candidate(dp[u]+1, u+1));\n                // alt edges\n                for(int v: altFrom[u]){\n                    pq.add(new Candidate(dp[u]+1, v));\n                }\n            }\n\n            StringBuilder ans = new StringBuilder(n-1);\n            // s=1 is always Bessie wins by immediate collapse\n            ans.append('1');\n\n            int evIdx = 0;\n            // sweep s=2..n-1\n            for(int s = 2; s <= n-1; s++){\n                // process all events at this s\n                while(evIdx < events.size() && events.get(evIdx).s == s){\n                    Event E = events.get(evIdx++);\n                    forbidCount[E.vertex] += E.delta;\n                }\n                // now recompute dp[n] on the fly by relaxing pq\n                // but only pop/relax when top is actually valid\n                while(!pq.isEmpty()){\n                    Candidate c = pq.peek();\n                    int v = c.v, d = c.d;\n                    if(d >= dp[v] || forbidCount[v] > 0) {\n                        // either not an improvement, or v forbidden, discard\n                        pq.poll();\n                    } else {\n                        // it's a real improvement\n                        pq.poll();\n                        dp[v] = d;\n                        // now we can push new edges out of v\n                        if(v < n) {\n                            if(forbidCount[v]==0 && forbidCount[v+1]==0){\n                                pq.add(new Candidate(dp[v]+1, v+1));\n                            }\n                        }\n                        for(int w: altFrom[v]){\n                            if(forbidCount[v]==0 && forbidCount[w]==0){\n                                pq.add(new Candidate(dp[v]+1, w));\n                            }\n                        }\n                    }\n                }\n\n                // after that dp[n] is the best distance 1->n in the currently-allowed subgraph.\n                // check if dp[n] <= (n-s-1)\n                if(dp[n] <= (n - s - 1)){\n                    // Elsie can finish in time => Bessie loses\n                    ans.append('0');\n                } else {\n                    // Bessie wins\n                    ans.append('1');\n                }\n            }\n\n            out.println(ans);\n        }\n\n        out.flush();\n    }\n\n    /** An “enter/leave forbidden” event for vertex v. */\n    static class Event {\n        int s, delta, vertex;\n        Event(int _s, int _d, int _v){ s=_s; delta=_d; vertex=_v; }\n    }\n}\n```\n\n**Explanation of the main points**\n\n1.  We first do a single DAG‐DP pass (cost \\(O(n+m)\\)) to compute  \n   \\[\n     \\mathrm{dist}_E[i]\n     \\;=\\;\\min\\{\\text{Elsie‐moves from 1 to }i\\}.\n   \\]\n2.  An island \\(j\\) becomes **unsafe** for Elsie at any starting‐position \\(s\\) with\n   \\[\n     j\\ge s\n     \\quad\\text{and}\\quad\n     \\mathrm{dist}_E[j] > j-s\n     \\quad\\Longleftrightarrow\\quad\n     s\\in [\\,j-\\mathrm{dist}_E[j]+1\\,,\\,j\\,].\n   \\]\n   We collect two events per \\(j\\):\n   - at \\(s=j-\\mathrm{dist}_E[j]+1\\) we **enter** the forbidden set,  \n   - at \\(s=j+1\\) we **leave** the forbidden set.\n\n3.  We sweep \\(s\\) from \\(2\\) to \\(n-1\\).  We maintain:\n   - an array `forbidCount[j]` (zero ⇒ allowed; positive ⇒ forbidden),\n   - a priority‐queue of *edge‐candidates* \\((u\\!\\to\\!v)\\) giving the number \\(dp[u]+1\\) as a proposal for \\(dp[v]\\),\n   - the usual “lazy‐delete” procedure so that whenever we pop \\((d,v)\\) from the queue,\n     we check that \\(d<dp[v]\\) *and* `forbidCount[v]==0`; if so we update `dp[v]=d` and push its outgoing edges (only if both endpoints remain allowed).\n\n   Because each edge is considered only when its endpoints go from forbidden→allowed, or a real improvement in `dp` occurs, the total number of PQ‐operations is \\(O((n+m)\\log n)\\).\n\n4.  After processing all “enter/leave” events at a given \\(s\\), the array `dp[]` holds the shortest distance in the current allowed‐subgraph from **1** to every vertex.  In particular `dp[n]` is the minimum number of Elsie‐moves to reach \\(n\\) without ever stepping on a vertex that Bessie has already collapsed.  \n\n5.  We compare `dp[n]` with \\((n-s-1)\\).  If\n   \\[\n     \\mathrm{dp}[n]\\;\\le\\;(n-s-1),\n   \\]\n   then Elsie would beat Bessie on move‐count and hence Bessie **loses** (\\(0\\)).  Otherwise Bessie **wins** (\\(1\\)).\n\n6.  Finally we hard‐wire \\(s=1\\) → `1` (Bessie wins by instantly collapsing island 1).\n\nThis meets the \\(O((n+m)\\log n)\\) time bound per test‐case, and since \\(\\sum n, \\sum m\\le 2\\cdot10^5\\) overall, it runs comfortably in time."
  }
]