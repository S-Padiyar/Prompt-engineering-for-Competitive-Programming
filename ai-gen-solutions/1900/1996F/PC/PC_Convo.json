[
  {
    "timestamp": "2025-07-24T05:52:31.640484",
    "role": "user",
    "content": "F. Bomb\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nSparkle gives you two arrays a\n\n and b\n\n of length n\n\n. Initially, your score is 0\n\n. In one operation, you can choose an integer i\n\n and add ai\n\n to your score. Then, you must set ai\n\n = max(0,ai−bi)\n\n.\n\n\n\nYou only have time to perform k\n\n operations before Sparkle sets off a nuclear bomb! What is the maximum score you can acquire after k\n\n operations?\n\n\n\nInput\n\nThe first line contains t\n\n (1≤t≤1000\n\n) — the number of test cases.\n\n\n\nThe first line of each test case contains n\n\n and k\n\n (1≤n≤2⋅105,1≤k≤109\n\n) — the length of the arrays and the number of operations you can perform.\n\n\n\nThe following line contains n\n\n integers a1,a2,...an\n\n (1≤ai≤109\n\n).\n\n\n\nThe following line contains n\n\n integers b1,b2,...bn\n\n (1≤bi≤109\n\n).\n\n\n\nIt is guaranteed that the sum of n\n\n for all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output an integer, the maximum score you can acquire after k\n\n operations.\n\n\n\nExample\n\nInputCopy\n\n5\n\n3 4\n\n5 6 7\n\n2 3 4\n\n5 9\n\n32 52 68 64 14\n\n18 14 53 24 8\n\n5 1000\n\n1 2 3 4 5\n\n5 4 3 2 1\n\n1 1000000\n\n1000000\n\n1\n\n10 6\n\n3 3 5 10 6 8 6 8 7 7\n\n6 1 7 4 1 1 8 9 3 1\n\nOutputCopy\n\n21\n\n349\n\n27\n\n500000500000\n\n47\n\nUse Java."
  },
  {
    "timestamp": "2025-07-24T05:53:47.377728",
    "role": "assistant",
    "content": "**Analysis**\n\nWe have \\(n\\) \"piles\" (indexed by \\(i\\)), each pile initially has value \\(a_i\\).  On each operation you may choose any pile \\(i\\), collect its current value (adding it to your score) and then decrease the pile by \\(b_i\\), but not below 0; i.e.\n\\[\n\\text{score} \\;+\\!=\\; a_i,\\quad\na_i\\;\\gets\\;\\max(0,\\;a_i - b_i).\n\\]\nWe have in total \\(k\\) operations, and we want to maximize the total score.\n\nEquivalently, each pile \\(i\\) generates a finite arithmetic sequence of positive terms\n\n\\[\na_i,\\;a_i - b_i,\\;a_i - 2b_i,\\;\\dots\n\\]\n\nuntil it would go non‐positive.  The length of that sequence is\n\\[\nL_i \\;=\\;\\Bigl\\lceil \\tfrac{a_i}{b_i}\\Bigr\\rceil,\n\\]\nsince after \\(L_i\\) decrements it would be \\(\\le0\\).  We may choose up to \\(k\\) total terms from all these sequences (in any order) so as to maximize their sum.\n\nHence our answer is just \"take the \\(k\\) largest numbers among the union of all these sequences.\"  There are two wrinkles:\n\n1.  **If** the total number of positive terms in all piles,\n   \\(\\displaystyle \\sum_i L_i\\), is \\(\\le k\\), then we simply take *every* positive term (any further operations would collect only zeros, which do not increase the score).  \n   In that case the answer is\n   \\[\n     \\sum_{i=1}^n \\;\\sum_{t=0}^{L_i-1}\\;\\bigl(a_i - t\\,b_i\\bigr)\n     \\;=\\;\\sum_{i=1}^n \\Bigl(L_i\\,a_i \\;-\\; b_i\\frac{L_i(L_i-1)}{2}\\Bigr).\n   \\]\n\n2.  Otherwise \\(\\sum_i L_i > k\\).  We must pick exactly \\(k\\) of the (in total more than \\(k\\)) positive terms, namely the top \\(k\\).  A standard approach:\n\n   - Binary‐search a threshold \\(X\\) so that *at least* \\(k\\) terms are \\(\\ge X\\), but *fewer* than \\(k\\) terms are \\(\\ge X+1\\).\\!\n   - We then *must* take every term \\(>X\\), and then take just enough terms equal to \\(X\\) to reach a total of \\(k\\) picks.\n\n   Concretely, for each pile \\(i\\) and a threshold \\(M\\), the count of terms \\(\\ge M\\) is\n   \\[\n     \\#\\{\\,t\\ge0 : a_i - t\\,b_i \\ge M\\}\n     = \n     \\max\\Bigl(0,\n       \\Bigl\\lfloor \\tfrac{a_i - M}{b_i}\\Bigr\\rfloor + 1\n     \\Bigr),\n   \\]\n   and if that count is \\(c\\), the *sum* of those \\(c\\) terms\n   \\[\n     a_i + (a_i - b_i) + \\dots + \\bigl(a_i - (c-1)b_i\\bigr)\n     = c\\,a_i \\;-\\; b_i\\,\\frac{c(c-1)}2.\n   \\]\n   We do a binary‐search on \\(X\\in[1,\\max_i a_i]\\) to locate the largest \\(X\\) such that\n   \\(\\sum_i \\bigl\\lfloor(a_i-X)/b_i\\rfloor+1 \\ge k\\).  Then we recompute:\n\n   - Let\n     \\[\n       C_{>}\\;=\\;\\sum_i\n       \\Bigl\\lfloor\\frac{a_i - (X+1)}{b_i}\\Bigr\\rfloor +1 \n       \\quad\\text{(all terms strictly \\(>X\\))},\n     \\]\n     and\n     \\[\n       S_{>}\\;=\\;\\sum_i \\Bigl[\n         c_i\\,a_i \\;-\\; b_i\\,\\frac{c_i(c_i-1)}2\n       \\Bigr]\n       \\quad\\text{where }c_i = \\max\\bigl(0,\\lfloor(a_i-(X+1))/b_i\\rfloor+1\\bigr).\n     \\]\n   - We still need \\(k - C_{>}\\) more picks, all of value exactly \\(X\\).  So the final answer is\n     \\[\n       S_{>}\\;+\\;(k - C_{>})\\,X.\n     \\]\n\nBoth steps run in \\(O(n)\\), and we only do \\(O(\\log(\\max a_i))\\) such steps when \\(\\sum L_i>k\\).  Since \\(\\sum n\\le2\\cdot10^5\\) over all test‐cases, this is efficient.\n\n---\n\n**Code**\n\n```java\nimport java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        FastReader in = new FastReader();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int t = in.nextInt();\n        while (t-- > 0) {\n            int n = in.nextInt();\n            long k = in.nextLong();\n            long[] a = new long[n];\n            long[] b = new long[n];\n            long maxA = 0;\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextLong();\n                maxA = Math.max(maxA, a[i]);\n            }\n            for (int i = 0; i < n; i++) {\n                b[i] = in.nextLong();\n            }\n\n            // 1) Compute total number of positive terms sum L_i\n            long totalTerms = 0;\n            for (int i = 0; i < n; i++) {\n                // L_i = ceil(a[i]/b[i])\n                long Li = (a[i] + b[i] - 1) / b[i];\n                totalTerms += Li;\n                if (totalTerms > k) {\n                    // We only care if it exceeds k or not\n                    break;\n                }\n            }\n\n            // Case A: sum L_i <= k  --> Just take all positive terms\n            if (totalTerms <= k) {\n                long ans = 0;\n                for (int i = 0; i < n; i++) {\n                    long Li = (a[i] + b[i] - 1) / b[i];\n                    // Sum of arithmetic sequence:\n                    // Li*a[i] - b[i]*(Li*(Li-1)/2)\n                    long sumSeq = Li * a[i] - b[i] * (Li * (Li - 1) / 2);\n                    ans += sumSeq;\n                }\n                out.println(ans);\n                continue;\n            }\n\n            // Case B: sum L_i > k  --> We must pick exactly k of the top values\n            // Binary search threshold X\n            long lo = 1, hi = maxA, best = 1;\n            while (lo <= hi) {\n                long mid = (lo + hi) >>> 1;\n                // Count how many terms >= mid\n                long cnt = 0;\n                for (int i = 0; i < n; i++) {\n                    if (a[i] >= mid) {\n                        cnt += ( (a[i] - mid) / b[i] ) + 1;\n                        if (cnt >= k) break;  // no need to count more\n                    }\n                }\n                if (cnt >= k) {\n                    best = mid;    // we can afford to raise the threshold\n                    lo = mid + 1;\n                } else {\n                    hi = mid - 1;\n                }\n            }\n\n            long X = best;  // final threshold\n\n            // Count how many are strictly > X, and sum them\n            long countGT = 0;    // how many terms > X\n            long sumGT   = 0;    // sum of those terms\n            for (int i = 0; i < n; i++) {\n                if (a[i] >= X + 1) {\n                    long t = (a[i] - (X + 1)) / b[i] + 1;  // number of terms >= X+1\n                    countGT += t;\n                    // sum of the first t terms: a[i] + (a[i]-b[i]) + ... + (a[i]-(t-1)*b[i])\n                    // = t*a[i] - b[i] * (t*(t-1)/2)\n                    long sumSeq = t * a[i] - b[i] * ( t * (t - 1) / 2 );\n                    sumGT += sumSeq;\n                }\n            }\n\n            // We still need (k - countGT) more picks, all worth exactly X\n            long rem = k - countGT;\n            long answer = sumGT + rem * X;\n\n            out.println(answer);\n        }\n        out.flush();\n    }\n\n    // Fast IO template\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n        int nextInt() throws IOException { return Integer.parseInt(next()); }\n        long nextLong() throws IOException { return Long.parseLong(next()); }\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1.  **Counting total possible positive picks**  \n    Each pile \\(i\\) yields exactly\n    \\[\n       L_i = \\Bigl\\lceil \\tfrac{a_i}{b_i}\\Bigr\\rceil\n    \\]\n    positive contributions.  We sum \\(\\sum_i L_i\\).  \n    - If this sum \\(\\le k\\), we simply take *all* those positive contributions.  \n      Their total is\n      \\[\n        \\sum_{i=1}^n \\sum_{t=0}^{L_i-1} \\bigl(a_i - t\\,b_i\\bigr)\n        \\;=\\;\n        \\sum_{i=1}^n \\Bigl(L_i\\,a_i - b_i\\,\\tfrac{L_i(L_i-1)}2\\Bigr).\n      \\]\n\n2.  **Otherwise** \\(\\sum_i L_i>k\\).  We must pick exactly \\(k\\) items out of a larger pool of positive numbers, choosing the largest \\(k\\).  \n    - We binary‐search a threshold \\(X\\) in \\([1,\\max_i a_i]\\) such that\n      \\[\n        \\#\\{\\text{terms}\\ge X\\} \\;\\ge\\; k,\\quad\n        \\#\\{\\text{terms}\\ge X+1\\} \\;<\\; k.\n      \\]\n    - Then we *must* pick all terms strictly above \\(X\\), and to make up exactly \\(k\\) total picks, we pick exactly\n      \\(\\;k - \\#\\{\\text{terms}>X\\}\\) \n      terms of value \\(X\\).  \n    - We can compute both the **count** and **sum** of all terms \\(\\ge M\\) in \\(O(n)\\) by noting that\n      \\[\n        \\#\\{t\\ge0: a_i - t\\,b_i \\ge M\\}\n        = \\max\\!\\Bigl(0,\\bigl\\lfloor\\tfrac{a_i - M}{b_i}\\bigr\\rfloor + 1\\Bigr),\n      \\]\n      and if that count is \\(c\\), the sum of those \\(c\\) terms is\n      \\[\n        c\\,a_i \\;-\\; b_i\\,\\frac{c(c-1)}2.\n      \\]\n\nSince each test is \\(O(n\\log(\\max a_i))\\) and the total \\(\\sum n\\) over all tests is up to \\(2\\cdot10^5\\), this solution is efficient."
  }
]