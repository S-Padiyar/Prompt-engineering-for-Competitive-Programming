[
  {
    "role": "user",
    "content": "E1. Deterministic Heap (Easy Version)\n\ntime limit per test3 seconds\n\nmemory limit per test512 megabytes\n\nThis is the easy version of the problem. The difference between the two versions is the definition of deterministic max-heap, time limit, and constraints on n\n\n and t\n\n. You can make hacks only if both versions of the problem are solved.\n\n\n\nConsider a perfect binary tree with size 2n−1\n\n, with nodes numbered from 1\n\n to 2n−1\n\n and rooted at 1\n\n. For each vertex v\n\n (1≤v≤2n−1−1\n\n), vertex 2v\n\n is its left child and vertex 2v+1\n\n is its right child. Each node v\n\n also has a value av\n\n assigned to it.\n\n\n\nDefine the operation pop\n\n as follows:\n\n\n\ninitialize variable v\n\n as 1\n\n;\n\nrepeat the following process until vertex v\n\n is a leaf (i.e. until 2n−1≤v≤2n−1\n\n);\n\namong the children of v\n\n, choose the one with the larger value on it and denote such vertex as x\n\n; if the values on them are equal (i.e. a2v=a2v+1\n\n), you can choose any of them;\n\nassign ax\n\n to av\n\n (i.e. av:=ax\n\n);\n\nassign x\n\n to v\n\n (i.e. v:=x\n\n);\n\nassign −1\n\n to av\n\n (i.e. av:=−1\n\n).\n\nThen we say the pop\n\n operation is deterministic if there is a unique way to do such operation. In other words, a2v≠a2v+1\n\n would hold whenever choosing between them.\n\n\n\nA binary tree is called a max-heap if for every vertex v\n\n (1≤v≤2n−1−1\n\n), both av≥a2v\n\n and av≥a2v+1\n\n hold.\n\n\n\nA max-heap is deterministic if the pop\n\n operation is deterministic to the heap when we do it for the first time.\n\n\n\nInitially, av:=0\n\n for every vertex v\n\n (1≤v≤2n−1\n\n), and your goal is to count the number of different deterministic max-heaps produced by applying the following operation add\n\n exactly k\n\n times:\n\n\n\nChoose an integer v\n\n (1≤v≤2n−1\n\n) and, for every vertex x\n\n on the path between 1\n\n and v\n\n, add 1\n\n to ax\n\n.\n\nTwo heaps are considered different if there is a node which has different values in the heaps.\n\n\n\nSince the answer might be large, print it modulo p\n\n.\n\n\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n\n (1≤t≤500\n\n). The description of the test cases follows.\n\n\n\nThe first line of each test case contains three integers n,k,p\n\n (1≤n,k≤500\n\n, 108≤p≤109\n\n, p\n\n is a prime).\n\n\n\nIt is guaranteed that the sum of n\n\n and the sum of k\n\n over all test cases does not exceed 500\n\n.\n\n\n\nOutput\n\nFor each test case, output a single line containing an integer: the number of different deterministic max-heaps produced by applying the aforementioned operation add\n\n exactly k\n\n times, modulo p\n\n.\n\n\n\nExamples\n\nInputCopy\n\n7\n\n1 13 998244353\n\n2 1 998244353\n\n3 2 998244853\n\n3 3 998244353\n\n3 4 100000037\n\n4 2 100000039\n\n4 3 100000037\n\nOutputCopy\n\n1\n\n2\n\n12\n\n52\n\n124\n\n32\n\n304\n\nInputCopy\n\n1\n\n500 500 100000007\n\nOutputCopy\n\n76297230\n\nInputCopy\n\n6\n\n87 63 100000037\n\n77 77 100000039\n\n100 200 998244353\n\n200 100 998244353\n\n32 59 998244853\n\n1 1 998244353\n\nOutputCopy\n\n26831232\n\n94573603\n\n37147649\n\n847564946\n\n727060898\n\n1\n\nNote\n\nFor the first testcase, there is only one way to generate a\n\n, and such sequence is a deterministic max-heap, so the answer is 1\n\n.\n\n\n\nFor the second testcase, if we choose v=1\n\n and do the operation, we would have a=[1,0,0]\n\n, and since a2=a3\n\n, we can choose either of them when doing the first pop\n\n operation, so such heap is not a deterministic max-heap.\n\n\n\nAnd if we choose v=2\n\n, we would have a=[1,1,0]\n\n, during the first pop\n\n, the following would happen:\n\n\n\ninitialize v\n\n as 1\n\nsince a2v>a2v+1\n\n, choose 2v\n\n as x\n\n, then x=2\n\nassign ax\n\n to av\n\n, then a=[1,1,0]\n\nassign x\n\n to v\n\n, then v=2\n\nsince v\n\n is a leaf, assign −1\n\n to av\n\n, then a=[1,−1,0]\n\nSince the first pop\n\n operation is deterministic, this is a deterministic max-heap. Also, if we choose v=3\n\n, a\n\n would be a deterministic max-heap, so the answer is 2\n\n.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have a perfect binary tree of depth \\(n\\), i.e.\\ \\(2^n-1\\) nodes, initially all zeros.  An “add” operation picks any node \\(v\\) and increments by \\(1\\) each node on the root-to-\\(v\\) path.  After exactly \\(k\\) such adds, we obtain a nonnegative integer labeling \\(a_v\\).  It is easy to check that if we record how many times we chose each node \\(v\\) (call it \\(b_v\\)), then\n\n\\[\n   a_v \\;=\\;\\sum_{u\\in\\text{subtree of }v} b_u,\n   \\quad\n   \\sum_v b_v \\;=\\; k.\n\\]\n\nMoreover such an \\((a_v)\\) automatically satisfies the max-heap condition \\(a_v\\ge a_{\\sf left}\\) and \\(a_v\\ge a_{\\sf right}\\).\n\nWe also require that performing a single **pop** from the root is *deterministic*, i.e.\\ at every visited internal node in the pop process its two children have *distinct* \\(a\\)-values so there is no tie.  But the only nodes visited by the pop are those on the unique “heavy‐child” path that follows the strictly larger child at each step.  Hence the condition is:\n\n  **At each internal node \\(v\\) on that chosen path,**  \n  \\(\\;a_{2v}\\neq a_{2v+1}.\\)\n\nWe want to **count** the number of ways to distribute the nonnegative integers \\(\\{b_v\\}\\) summing to \\(k\\) so that the resulting heap is *deterministic* in the above sense.  Two heaps are considered different if their arrays \\((a_v)\\) differ at at least one node; equivalently two different distributions \\(\\{b_v\\}\\) produce distinct \\(\\{a_v\\}\\).\n\n---\n\n### A clean recurrence\n\nLet\n\n  - \\(f[d][s]\\) = number of *deterministic* ways on a perfect tree of depth \\(d\\) with total sum of all \\(b_v\\) equal to \\(s\\),\n  - \\(g[d][s]\\) = number of *all* ways (no determinism constraint) on a depth-\\(d\\) tree with total \\(s\\).\n\nSince a depth-\\(d\\) tree is a root plus two identical depth-\\((d-1)\\) subtrees, if the root’s own count is \\(b_0=t\\), and the left subtree uses total \\(L\\), the right uses total \\(R\\), we have\n\\[\n   t + L + R \\;=\\; s,\n   \\quad\n   t\\ge0,\\; L\\ge0,\\; R\\ge0.\n\\]\nThe heap is deterministic **iff** \\(L\\neq R\\) (so the first choice at the root is strict) and *then* we recurse deterministically into the larger-sum side, while the smaller-sum side is unconstrained.  Thus\n\n\\[\n  f[d][s]\n  \\;=\\;\n  \\sum_{\\substack{L+R\\le s\\\\L\\neq R}}\n    \\Bigl[\\,\n      \\begin{cases}\n         f[d-1][L]\\;\\times\\;g[d-1][R], & L>R,\\\\[6pt]\n         f[d-1][R]\\;\\times\\;g[d-1][L], & R>L\n      \\end{cases}\n    \\Bigr].\n\\]\nOne can rearrange it into a simpler double‐sum of size \\(O(s^2)\\).  \n\nOn the other hand, counting **all** ways \\(\\{b_v\\}\\ge0\\), \\(\\sum b_v=k\\) on a tree with \\(2^d-1\\) nodes is just\n\\[\n   g[d][k]\\;=\\;\\binom{(2^d-1)+k-1}{k}\n             \\;=\\;\\binom{2^d + k -2}{\\,k\\,},\n\\]\nwhich for small \\(k\\) we can compute in \\(O(k)\\) by the product\n\\[\n   g[d][0]=1,\\quad\n   g[d][j] \\;=\\; g[d][j-1]\\;\\times\\;\\frac{(2^d +j-2)}{\\,j\\,}\n   \\quad(j\\ge1),\n\\]\ntaking everything \\(\\bmod p\\).\n\nSince \\(n,k\\le500\\) and \\(\\sum n,\\sum k\\le500\\) over all cases, we can afford an \\(O(n\\,k^2)\\) DP per test.  This is about \\(500\\cdot500^2\\approx125\\times10^6\\) inner steps in the worst single test, which runs comfortably in a few seconds in optimized Java.\n\n---\n\n**Implementation in Java**\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int T = Integer.parseInt(br.readLine().trim());\n        \n        while (T-- > 0) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int K = Integer.parseInt(st.nextToken());\n            int p = Integer.parseInt(st.nextToken());\n            \n            // Edge case: depth=1 tree is just one node; any total k is deterministic.\n            if (n == 1) {\n                System.out.println(1);\n                continue;\n            }\n            \n            // Precompute inv[1..K] modulo p via fast exponentiation.\n            long[] inv = new long[K+1];\n            inv[0] = 0;  // unused\n            for (int i = 1; i <= K; i++) {\n                inv[i] = modPow(i, p-2, p);\n            }\n            \n            // Precompute 2^d mod p for d=0..n\n            long[] pow2 = new long[n+1];\n            pow2[0] = 1;\n            for (int d = 1; d <= n; d++) {\n                pow2[d] = (pow2[d-1] << 1) % p;\n            }\n            \n            // f[d][s] in rolling array prevF[], g[d][s] in prevG[]:\n            long[] prevF = new long[K+1];\n            long[] prevG = new long[K+1];\n            \n            // Base for depth=1:\n            //   exactly one way to put sum s into single node\n            for (int s = 0; s <= K; s++) {\n                prevF[s] = 1;\n                prevG[s] = 1;\n            }\n            \n            // We'll build from depth=2 up to depth=n\n            for (int depth = 2; depth <= n; depth++) {\n                // 1) Build prefix sums of prevG for quick range sums\n                long[] prefixG = new long[K+1];\n                prefixG[0] = prevG[0];\n                for (int s = 1; s <= K; s++) {\n                    prefixG[s] = (prefixG[s-1] + prevG[s]) % p;\n                }\n                \n                // 2) Compute currF[s] via the double‐sum formula but\n                //    organized in O(K^2) time:\n                long[] currF = new long[K+1];\n                for (int s = 0; s <= K; s++) {\n                    long sum = 0;\n                    // sum over l=1..s of prevF[l] * sum_{r=0..min(l-1,s-l)} prevG[r]\n                    // then double.\n                    for (int l = 1; l <= s; l++) {\n                        int bound = Math.min(l - 1, s - l);\n                        if (bound >= 0) {\n                            sum = (sum + prevF[l] * prefixG[bound]) % p;\n                        }\n                    }\n                    currF[s] = (sum * 2) % p;\n                }\n                \n                // 3) Compute currG for this depth\n                long[] currG = new long[K+1];\n                currG[0] = 1;\n                for (int s = 1; s <= K; s++) {\n                    // g[d][s] = g[d][s-1] * (2^d + s - 2) / s\n                    long numerator = (pow2[depth] + s - 2) % p;\n                    if (numerator < 0) numerator += p;\n                    currG[s] = currG[s-1] * numerator % p * inv[s] % p;\n                }\n                \n                // Roll\n                prevF = currF;\n                prevG = currG;\n            }\n            \n            // The answer is f[n][K] in prevF[K]\n            System.out.println(prevF[K]);\n        }\n    }\n    \n    // fast exponentiation mod\n    static long modPow(long a, long e, int mod) {\n        long r = 1 % mod;\n        a %= mod;\n        while (e > 0) {\n            if ((e & 1) == 1) r = (r * a) % mod;\n            a = (a * a) % mod;\n            e >>= 1;\n        }\n        return r;\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1.  **`g[d][s] =` “all” ways**  \n    There are \\(2^d-1\\) nodes at depth \\(d\\).  Counting nonnegative solutions to\n    \\(\\sum b_v=s\\) over that many variables is the stars-and-bars\n    binomial \\(\\displaystyle\\binom{(2^d-1)+s-1}{s}=\\binom{2^d+s-2}{s}\\).\n    For small \\(s\\le500\\) we expand\n    \\[\n       g[d][s]\n       \\;=\\;\n       \\frac{(2^d -1 + s-1)\\,(2^d -1+s-2)\\,\\cdots\\,(2^d-1)}{s!}\n       \\;=\\;\n       \\frac{(2^d + s -2)}{s}\\;g[d][s-1]\n    \\]\n    all taken \\(\\bmod p\\).\n\n2.  **`f[d][s] =` “deterministic” ways**  \n    We split the total \\(s\\) into \\(\\bigl(b_{\\rm root}=t,\\;L,\\;R\\bigr)\\).\n    To be deterministic at the root we insist \\(L\\neq R\\).  Whichever side\n    has the larger sum must itself be a *deterministic* sub-problem\n    \\(f[d-1][\\cdot]\\), while the other side is *unrestricted* \\(g[d-1][\\cdot]\\).\n    \n3.  **Optimization of the double sum**  \n    A naive triple loop over \\(s,L,R\\) is \\(O(n\\,k^3)\\).  We reorganize\n    it into an \\(O(n\\,k^2)\\) DP by noticing\n    \\[\n      f[d][s]\n      \\;=\\;\n      2\\;\\sum_{L>R,\\;L+R\\le s}\n         \\Bigl(\\,f[d-1][L]\\;\\times\\;g[d-1][R]\\Bigr),\n    \\]\n    and then computing that by prefix-sums on \\(g[d-1]\\).\n\nOverall time per test is \\(O(n\\,k^2)\\).  With \\(n,k\\le500\\) and total \\(\\sum n,\\sum k\\le500\\), this easily runs under the 3 s limit in Java."
  },
  {
    "role": "user",
    "content": "Please provide a single Java code block (with class Main and main method) that solves the problem as described, without any additional explanation or commentary."
  },
  {
    "role": "assistant",
    "content": "```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int T = Integer.parseInt(br.readLine().trim());\n        while (T-- > 0) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int K = Integer.parseInt(st.nextToken());\n            int p = Integer.parseInt(st.nextToken());\n            if (n == 1) {\n                System.out.println(1);\n                continue;\n            }\n            long[] inv = new long[K+1];\n            for (int i = 1; i <= K; i++) {\n                inv[i] = modPow(i, p-2, p);\n            }\n            long[] pow2 = new long[n+1];\n            pow2[0] = 1;\n            for (int d = 1; d <= n; d++) {\n                pow2[d] = (pow2[d-1] << 1) % p;\n            }\n            long[] prevF = new long[K+1], prevG = new long[K+1];\n            for (int s = 0; s <= K; s++) {\n                prevF[s] = 1;\n                prevG[s] = 1;\n            }\n            for (int depth = 2; depth <= n; depth++) {\n                long[] prefixG = new long[K+1];\n                prefixG[0] = prevG[0];\n                for (int s = 1; s <= K; s++) {\n                    prefixG[s] = (prefixG[s-1] + prevG[s]) % p;\n                }\n                long[] currF = new long[K+1];\n                for (int s = 0; s <= K; s++) {\n                    long sum = 0;\n                    for (int l = 1; l <= s; l++) {\n                        int bound = Math.min(l - 1, s - l);\n                        if (bound >= 0) {\n                            sum = (sum + prevF[l] * prefixG[bound]) % p;\n                        }\n                    }\n                    currF[s] = (sum * 2) % p;\n                }\n                long[] currG = new long[K+1];\n                currG[0] = 1;\n                for (int s = 1; s <= K; s++) {\n                    long num = (pow2[depth] + s - 2) % p;\n                    if (num < 0) num += p;\n                    currG[s] = currG[s-1] * num % p * inv[s] % p;\n                }\n                prevF = currF;\n                prevG = currG;\n            }\n            System.out.println(prevF[K]);\n        }\n    }\n    static long modPow(long a, long e, int mod) {\n        long r = 1 % mod;\n        a %= mod;\n        while (e > 0) {\n            if ((e & 1) == 1) r = (r * a) % mod;\n            a = (a * a) % mod;\n            e >>= 1;\n        }\n        return r;\n    }\n}\n```"
  }
]