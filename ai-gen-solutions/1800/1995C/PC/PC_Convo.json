[
  {
    "timestamp": "2025-07-24T05:51:38.002231",
    "role": "user",
    "content": "C. Squaring\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nikrpprpp found an array a\n\n consisting of integers. He likes justice, so he wants to make a\n\n fair — that is, make it non-decreasing. To do that, he can perform an act of justice on an index 1≤i≤n\n\n of the array, which will replace ai\n\n with a2i\n\n (the element at position i\n\n with its square). For example, if a=[2,4,3,3,5,3]\n\n and ikrpprpp chooses to perform an act of justice on i=4\n\n, a\n\n becomes [2,4,3,9,5,3]\n\n.\n\n\n\nWhat is the minimum number of acts of justice needed to make the array non-decreasing?\n\n\n\nInput\n\nFirst line contains an integer t\n\n (1≤t≤1000\n\n) — the number of test cases. It is followed by the description of test cases.\n\n\n\nFor each test case, the first line contains an integer n\n\n — size of the array a\n\n. The second line contains n\n\n (1≤n≤2⋅105\n\n) integers a1,a2,…,an\n\n (1≤ai≤106\n\n).\n\n\n\nThe sum of n\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each testcase, print an integer — minimum number of acts of justice required to make the array a\n\n non-decreasing. If it is impossible to do that, print −1\n\n.\n\n\n\nExample\n\nInputCopy\n\n7\n\n3\n\n1 2 3\n\n2\n\n3 2\n\n3\n\n3 1 5\n\n4\n\n1 1 2 3\n\n3\n\n4 3 2\n\n9\n\n16 2 4 2 256 2 4 2 8\n\n11\n\n10010 10009 10008 10007 10006 10005 10004 10003 10002 10001 10000\n\nOutputCopy\n\n0\n\n1\n\n-1\n\n0\n\n3\n\n15\n\n55\n\nNote\n\nIn the first test case, there's no need to perform acts of justice. The array is fair on its own!\n\n\n\nIn the third test case, it can be proven that the array cannot become non-decreasing.\n\n\n\nIn the fifth test case, ikrpprppp can perform an act of justice on index 3, then an act of justice on index 2, and finally yet another act of justice on index 3. After that, a\n\n will become [4,9,16]\n\n.\n\nUse Java."
  },
  {
    "timestamp": "2025-07-24T05:53:05.947333",
    "role": "assistant",
    "content": "**Analysis**\n\nWe have an array of positive integers \\(a_1,a_2,\\dots,a_n\\).  We may choose any index \\(i\\) and replace \n\\[\n  a_i \\;\\longleftarrow\\; (a_i)^2\n\\]\nas many times as we like (each “squaring” counts as one operation).  We wish, after some sequence of such operations, to have a non‐decreasing array\n\\[\n  b_1\\le b_2\\le \\dots\\le b_n,\n\\]\nwhere \\(b_i\\) is the final value of \\(a_i\\).  We want the *minimum* total number of squarings, or report \\(-1\\) if it cannot be made non‐decreasing.\n\n---\n\n**Key observations**\n\n1.  **Squaring only increases** (or leaves unchanged, in the case \\(a_i=1\\)) each entry:\n   \\[\n     a_i\\;\\longmapsto\\;(a_i)^2\\;\\ge\\;a_i.\n   \\]\n   Hence, once we raise an entry, it never drops back down.\n\n2.  To make the final array \\(b\\) non‐decreasing, it suffices to insist\n   \\[\n     b_i \\;\\ge\\; b_{i-1}\\quad\\text{for }i=2,\\dots,n.\n   \\]\n   Since each \\(b_i\\) must be some \\((a_i)^{2^{\\,k_i}}\\), we only ever need to compare \\(b_i\\) to the immediately preceding value \\(b_{i-1}\\).\n\n3.  A natural greedy strategy: process left to right, keeping track of the current value  \n   \\[\n     \\text{prev} = b_{i-1},\n   \\]\n   and for the next \\(a_i\\) choose the *smallest* number \\(k_i\\) of squarings so that\n   \\[\n     (a_i)^{2^{\\,k_i}}\\;\\ge\\;\\text{prev}.\n   \\]\n   -  If \\(a_i\\ge\\text{prev}\\) already, then \\(k_i=0\\).\n   -  If \\(a_i=1<\\text{prev}\\), no matter how many times you square it it stays 1, so it is *impossible*.\n   -  Otherwise, \\(a_i>1\\).  We need the smallest \\(k\\) such that\n     \\[\n       \\underbrace{(a_i)\\;2\\hbox{-fold power}\\;\\cdots\\;2\\text{ times}}_{2^k\\text{th power}}\n       = (a_i)^{2^k}\\;\\ge\\;\\text{prev}.\n     \\]\n     Equivalently in logarithms (say \\(\\log=\\ln\\)) we want\n     \\[\n       2^k\\;\\ln(a_i)\\;\\ge\\;\\ln(\\text{prev})\n       \\quad\\Longleftrightarrow\\quad\n       (\\ln(a_i))\\;2^k\\;\\ge\\;\\ln(\\text{prev}).\n     \\]\n     We can keep both sides in floating‐point:\n     - Maintain \\(\\displaystyle P=\\ln(\\text{prev})\\).\n     - Let \\(c=\\ln(a_i)\\).\n     - If \\(c\\ge P\\), no squaring needed.\n     - Else repeatedly double \\(c\\mapsto 2c\\) until \\(c\\ge P\\).  The number of doublings is exactly the number of squarings \\(k_i\\).\n\n   After that, we set\n   \\[\n     \\text{prev}\\;=\\;(a_i)^{2^{k_i}},\n   \\]\n   but in the code we simply keep \n   \\[\n     P \\;=\\; \\ln\\bigl((a_i)^{2^{k_i}}\\bigr)\n           \\;=\\;2^{k_i}\\,\\ln(a_i)\\;=\\;\\text{(the doubled‐up }c\\text{)}.\n   \\]\n\n4.  Each squaring step (doubling \\(c\\)) takes \\(O(1)\\) time, and the total number of squarings across the entire array is the answer.  In the worst case each element might require up to, say, 50 squarings (in practice much less), and \\(n\\) is up to \\(2\\cdot10^5\\).  A simple left‐to‐right pass with a small inner loop easily runs in time.\n\n---\n\n**Solution Code (Java)**\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        int t = Integer.parseInt(br.readLine().trim());\n        final double EPS = 1e-12;\n\n        while (t-- > 0) {\n            int n = Integer.parseInt(br.readLine().trim());\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = Integer.parseInt(st.nextToken());\n            }\n\n            // prevLog = ln of the previous array value b[i-1].\n            double prevLog = Math.log(a[0]);\n            long ops = 0;\n            boolean ok = true;\n\n            for (int i = 1; i < n; i++) {\n                double curLog = Math.log(a[i]);\n                // If already non-decreasing, no ops needed\n                if (curLog + EPS >= prevLog) {\n                    prevLog = curLog;\n                } else {\n                    // If a[i]==1 but prevLog>0 => impossible\n                    if (a[i] == 1) {\n                        ok = false;\n                        break;\n                    }\n                    // Otherwise keep squaring a[i] until its log >= prevLog\n                    double tlog = curLog;\n                    int cnt = 0;\n                    while (tlog + EPS < prevLog) {\n                        tlog *= 2.0;\n                        cnt++;\n                    }\n                    ops += cnt;\n                    prevLog = tlog;\n                }\n            }\n\n            out.println(ok ? ops : -1);\n        }\n\n        out.flush();\n    }\n}\n```\n\n**Explanation of the Main Steps**\n\n1.  We read \\(t\\) test‐cases.\n2.  For each test:  \n    - Read \\(n\\) and the array \\(a[0\\dots n-1]\\).  \n    - Initialize  \n       \\(\\displaystyle\\text{prevLog} = \\ln(a[0])\\),  \n       `ops = 0`,  \n       `ok = true`.  \n    - Walk through \\(i=1\\) to \\(n-1\\):  \n      * Compute `curLog = ln(a[i])`.  \n      * If `curLog >= prevLog` (within a tiny epsilon), no squaring is needed, we just set `prevLog = curLog`.  \n      * Otherwise, if `a[i] == 1`, it can never catch up (since \\(1^2=1\\)), so we mark `ok=false` and break.  \n      * Else we repeatedly do `tlog *= 2.0; cnt++;` until `tlog >= prevLog`.  Each doubling corresponds to one squaring of the integer \\(a[i]\\).  We accumulate `cnt` into `ops`, and set `prevLog = tlog`.  \n3.  If we ever detect impossibility (`ok==false`), we print `-1`.  Otherwise, we print the total `ops`.\n\nThis runs in \\(O(n\\cdot K)\\) per test (where \\(K\\) is the number of squaring‐doubles, in practice tiny, say \\(\\le50\\)), very fast for total \\(n\\le2\\times10^5\\)."
  }
]