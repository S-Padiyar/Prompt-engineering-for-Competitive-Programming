[
  {
    "timestamp": "2025-07-24T06:05:29.683576",
    "role": "user",
    "content": "E1. Digital Village (Easy Version)\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nThis is the easy version of the problem. In the three versions, the constraints on n\n\n and m\n\n are different. You can make hacks only if all the versions of the problem are solved.\n\n\n\nPak Chanek is setting up internet connections for the village of Khuntien. The village can be represented as a connected simple graph with n\n\n houses and m\n\n internet cables connecting house ui\n\n and house vi\n\n, each with a latency of wi\n\n.\n\n\n\nThere are p\n\n houses that require internet. Pak Chanek can install servers in at most k\n\n of the houses. The houses that need internet will then be connected to one of the servers. However, since each cable has its latency, the latency experienced by house si\n\n requiring internet will be the maximum latency of the cables between that house and the server it is connected to.\n\n\n\nFor each k=1,2,…,n\n\n, help Pak Chanek determine the minimum total latency that can be achieved for all the houses requiring internet.\n\n\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n\n (1≤t≤100\n\n). The description of the test cases follows.\n\n\n\nThe first line of each test case contains three integers n\n\n, m\n\n, p\n\n (2≤n≤400\n\n; n−1≤m≤400\n\n; 1≤p≤n\n\n) — the number of houses, the number of cables and the number of houses that need internet.\n\n\n\nThe second line of each test case contains p\n\n integers s1,s2,…,sp\n\n (1≤si≤n\n\n) — the houses that need internet. It is guaranteed that all elements of s\n\n are distinct.\n\n\n\nThe i\n\n-th of the next m\n\n lines of each test case contains three integers ui\n\n, vi\n\n, and wi\n\n (1≤ui<vi≤n\n\n; 1≤wi≤109\n\n) — the internet cable connecting house ui\n\n and house vi\n\n with latency of wi\n\n. It is guaranteed that the given edges form a connected simple graph.\n\n\n\nIt is guaranteed that the sum of n3\n\n and the sum of m3\n\n do not exceed 108\n\n.\n\n\n\nOutput\n\nFor each test case, output n\n\n integers: the minimum total latency that can be achieved for all the houses requiring internet for each k=1,2,…,n\n\n.\n\n\n\nExample\n\nInputCopy\n\n2\n\n9 8 5\n\n2 5 6 8 9\n\n1 2 1\n\n1 3 2\n\n3 4 10\n\n4 5 3\n\n4 6 5\n\n1 7 10\n\n7 8 4\n\n7 9 2\n\n3 3 2\n\n3 1\n\n1 2 1\n\n2 3 3\n\n1 3 2\n\nOutputCopy\n\n34 19 9 4 0 0 0 0 0\n\n2 0 0\n\nNote\n\nIn the first test case for k=3\n\n, a possible optimal solution is to install servers at vertices 2\n\n, 6\n\n and 8\n\n and obtain the following latency:\n\n\n\nlatency(2)=0\n\nlatency(5)=max(3,5)=5\n\nlatency(6)=0\n\nlatency(8)=0\n\nlatency(9)=max(2,4)=4\n\nSo the total latency is 9\n\n.\n\nUse Java."
  },
  {
    "timestamp": "2025-07-24T06:08:12.015496",
    "role": "assistant",
    "content": "**Analysis**\n\nWe have an undirected connected graph of \\(n\\) nodes (houses) and \\(m\\) edges (cables) with latencies \\(w_i\\).  A subset \\(S\\) of \\(p\\) of these nodes require internet service.  We may place up to \\(k\\) servers (for \\(k=1,2,\\dots,n\\)) on any nodes, and each special node \\(s\\in S\\) will connect to the chosen server \\(c\\) that minimizes the _maximum_ edge‐latency along the path from \\(s\\) to \\(c\\).  We want, for each \\(k\\), the minimum possible sum of those per‐special‐node maximum‐edge latencies.\n\n---\n\n**Key observations**\n\n1.  **Minimax path metric = minimum‐spanning‐tree metric**  \n    The latency a node experiences when it connects to a server is the minimum over all paths of the _maximum_ edge on that path.  It is well known that this _minimax_ distance between any two nodes in a connected graph is realized on its Minimum Spanning Tree (MST).  Hence we can discard all but an MST of the original graph, without changing any of these minimax distances.\n\n2.  **Kruskal “reconstruction tree”**  \n    If we run Kruskal’s algorithm (sorting edges ascending by weight, then union‐find to keep the MST), we can build a _binary_ tree (sometimes called the Kruskal reconstruction tree):  \n      -  Each original vertex \\(1\\ldots n\\) becomes a leaf (with weight \\(0\\)).  \n      -  Whenever in Kruskal we unite two components (roots \\(u,v\\)) by an edge of weight \\(w\\), we create a new internal node \\(x\\) of weight \\(w\\) and make its two children be \\(u\\) and \\(v\\).  The new component’s representative is \\(x\\).  \n    After all \\(n-1\\) unions, we end up with a tree of size \\(2n-1\\), whose leaves are the original nodes, and each internal node has a weight equal to the edge‐latency that united its two children.  \n    In that tree, the maximum‐edge on the path between two leaves \\(a,b\\) is exactly the weight of their LCA in the reconstruction tree.\n\n3.  **DP on the reconstruction tree**  \n    We must choose up to \\(k\\) leaves to be “servers.”  Each special leaf \\(s\\) travels _up_ the tree until it hits the first ancestor that has at least one server in its subtree; the cost for \\(s\\) is that ancestor’s weight.  We sum over all special \\(s\\).  \n\n    We do a bottom‐up DP on that binary tree.  At each node \\(u\\) we keep an array\n    \\[\n       \\mathrm{dp}[u][j]\n       =\\min_{\\substack{\\text{ways to pick exactly \\(j\\) servers}\\\\\n                       \\text{in the subtree of \\(u\\)}}}\n       \\Bigl(\\sum\\text{costs of those special nodes that get served at or below \\(u\\)}\\Bigr),\n    \\]\n    and also\n    \\[\n       t[u][j]\n       =\\text{number of special nodes in \\(u\\)’s subtree \\emph{not yet served}}\n         \\text{ by any of those \\(j\\) servers.}\n    \\]\n    When we combine two children \\(v,w\\) under an internal node \\(u\\) of weight \\(W\\), we do the usual knapsack‐convolution:\n    \\[\n      \\text{for each }j_1\\le \\bigl|\\text{leaves}(v)\\bigr|,\\;\n        j_2\\le \\bigl|\\text{leaves}(w)\\bigr|,\\;\n        j=j_1+j_2,\n    \\]\n    we form\n    \\[\n      \\mathrm{dpTemp}=\\mathrm{dp}[v][j_1]+\\mathrm{dp}[w][j_2],\\quad\n      tTemp=t[v][j_1]+t[w][j_2].\n    \\]\n    If \\(j>0\\), we have placed at least one server in \\(u\\)’s subtree, so _all_ those \\(tTemp\\) as yet unserved special nodes will now be served _at_ node \\(u\\), each at cost \\(W\\).  Hence\n    \\[\n      \\mathrm{dpNew}\n        = \\mathrm{dpTemp} + tTemp\\times W,\n      \\quad\n      tNew = 0.\n    \\]\n    If \\(j=0\\), we still have no server in \\(u\\)’s whole subtree, so nobody gets served here, and\n    \\[\n      \\mathrm{dpNew}=\\mathrm{dpTemp},\\quad\n      tNew=tTemp.\n    \\]\n    We take the minimum over all splits \\((j_1,j_2)\\).\n\n    At a leaf \\(u\\):  \n      – If \\(u\\) is special, then\n        \\(\\mathrm{dp}[u][0]=0,\\;t[u][0]=1\\),  \n        \\(\\mathrm{dp}[u][1]=0,\\;t[u][1]=0\\).  \n      – If \\(u\\) is not special,\n        \\(\\mathrm{dp}[u][0]=0,\\;t[u][0]=0\\) and\n        \\(\\mathrm{dp}[u][1]=0,\\;t[u][1]=0\\).\n\n4.  **Extracting the answers**  \n    After processing the root \\(R\\), we get \\(\\mathrm{dp}[R][k]\\) = minimum sum of latencies using _exactly_ \\(k\\) servers.  The problem allows _up to_ \\(k\\) servers, so for each \\(k\\) we must take \n    \\(\\min_{1\\le i\\le k}\\mathrm{dp}[R][i]\\).  \n    (Once \\(k\\ge p\\), we can serve every special node with its own server at cost 0, so the suffix of answers is all \\(0\\).)\n\nThe reconstruction‐tree has size \\(2n-1\\)\\(\\le 799\\) for \\(n\\le 400\\).  The DP at each internal node is a double loop over the sizes of the two children’s leaf‐counts.  In the worst case that is \\(\\sum(\\text{leaves in left})\\times(\\text{leaves in right})\\), bounded by \\(O(n^2)\\) overall.  Repeated over all testcases, the total work is \\(O(\\sum n^3)\\), which the problem guarantees is \\(\\le10^8\\).  This easily runs within the 2‐second limit in Java.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int MAXN = 400;\n    static final int MAXNODES = 2*MAXN;        // up to 2n-1\n    static final long INF = (long)1e18;\n\n    // The reconstruction tree\n    static int leftCh[] = new int[MAXNODES+1], rightCh[] = new int[MAXNODES+1];\n    static long  nodeWeight[] = new long[MAXNODES+1];\n    static int   dsuParent[] = new int[MAXNODES+1];\n    static int   leafCount[] = new int[MAXNODES+1];\n    static boolean isSpecial[] = new boolean[MAXNODES+1];\n\n    // DP arrays\n    // dp[u][j] = minimal cost to serve all special nodes within u's subtree\n    //            that are actually served at or below u, using exactly j servers in u's subtree.\n    // t[u][j]  = how many special nodes in u's subtree remain unserved if we used j servers.\n    static long  dp[][] = new long[MAXNODES+1][MAXN+1];\n    static int   t [][] = new int [MAXNODES+1][MAXN+1];\n\n    // Edge for Kruskal\n    static class Edge implements Comparable<Edge> {\n        int u, v;\n        long w;\n        Edge(int _u, int _v, long _w) { u=_u; v=_v; w=_w; }\n        public int compareTo(Edge o) {\n            return Long.compare(this.w, o.w);\n        }\n    }\n\n    // DSU find\n    static int findp(int x) {\n        if (dsuParent[x] != x) \n            dsuParent[x] = findp(dsuParent[x]);\n        return dsuParent[x];\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st;\n        int T = Integer.parseInt(br.readLine().trim());\n        StringBuilder output = new StringBuilder();\n\n        while (T-- > 0) {\n            st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(st.nextToken());\n            int p = Integer.parseInt(st.nextToken());\n\n            // read specials\n            st = new StringTokenizer(br.readLine());\n            for (int i = 1; i <= n; i++) {\n                isSpecial[i] = false;\n            }\n            for (int i = 0; i < p; i++) {\n                int s = Integer.parseInt(st.nextToken());\n                isSpecial[s] = true;\n            }\n\n            // read edges\n            ArrayList<Edge> edges = new ArrayList<>();\n            for (int i = 0; i < m; i++) {\n                st = new StringTokenizer(br.readLine());\n                int u = Integer.parseInt(st.nextToken());\n                int v = Integer.parseInt(st.nextToken());\n                long w = Long.parseLong(st.nextToken());\n                edges.add(new Edge(u, v, w));\n            }\n            Collections.sort(edges);\n\n            // initialize DSU\n            int maxNode = 2*n - 1;\n            for (int i = 1; i <= maxNode; i++) {\n                dsuParent[i] = i;\n                leftCh[i] = rightCh[i] = 0;\n                nodeWeight[i] = 0;\n            }\n\n            // build Kruskal‐reconstruction‐tree\n            int nxt = n;\n            for (Edge e : edges) {\n                int ru = findp(e.u), rv = findp(e.v);\n                if (ru != rv) {\n                    nxt++;\n                    nodeWeight[nxt] = e.w;\n                    leftCh [nxt] = ru;\n                    rightCh[nxt] = rv;\n                    dsuParent[ru] = nxt;\n                    dsuParent[rv] = nxt;\n                    dsuParent[nxt] = nxt;\n                    if (nxt == maxNode) break;\n                }\n            }\n            int root = nxt; // should be 2n-1\n\n            // compute leafCount[] = number of original‐node leaves under u\n            for (int u = 1; u <= root; u++) {\n                if (u <= n) {\n                    leafCount[u] = 1;\n                } else {\n                    leafCount[u] = leafCount[leftCh[u]] + leafCount[rightCh[u]];\n                }\n            }\n\n            // DP bottom‐up\n            for (int u = 1; u <= root; u++) {\n                int sz = leafCount[u];\n                if (u <= n) {\n                    // a leaf\n                    // dp[u][0], t[u][0]\n                    dp[u][0] = 0;\n                    t [u][0] = isSpecial[u] ? 1 : 0;\n                    // dp[u][1], t[u][1]\n                    dp[u][1] = 0;\n                    t [u][1] = 0;\n                } else {\n                    // an internal node\n                    int L = leftCh[u], R = rightCh[u];\n                    int lsz = leafCount[L], rsz = leafCount[R];\n\n                    // initialize dp[u][*]\n                    for (int j = 0; j <= sz; j++) {\n                        dp[u][j] = INF;\n                    }\n\n                    // knapsack‐style combine\n                    for (int j1 = 0; j1 <= lsz; j1++) {\n                        for (int j2 = 0; j2 <= rsz; j2++) {\n                            int j = j1 + j2;\n                            long baseCost = dp[L][j1] + dp[R][j2];\n                            int  unserved = t[L][j1] + t[R][j2];\n                            long newCost;\n                            int  newUnserved;\n                            if (j > 0) {\n                                // we do have at least one server in this subtree\n                                newCost = baseCost + unserved * nodeWeight[u];\n                                newUnserved = 0;\n                            } else {\n                                // still zero servers\n                                newCost = baseCost;\n                                newUnserved = unserved;\n                            }\n                            if (newCost < dp[u][j]) {\n                                dp[u][j] = newCost;\n                                t [u][j] = newUnserved;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // dp[root][k] = cost with exactly k servers.\n            // problem wants \"up to k\" servers, so we take prefix‐min.\n            long best = INF;\n            for (int k = 1; k <= n; k++) {\n                best = Math.min(best, dp[root][k]);\n                if (k > 1) output.append(' ');\n                output.append(best);\n            }\n            output.append('\\n');\n\n            // clear specials for next test\n            for (int i = 1; i <= n; i++) {\n                isSpecial[i] = false;\n            }\n        }\n\n        System.out.print(output.toString());\n    }\n}\n```\n\n**Explanation of the main steps**:\n\n1. **Read input**.  We read \\(n,m,p\\), then the \\(p\\) special nodes, then the \\(m\\) edges.\n\n2. **Build an MST‐reconstruction tree** using Kruskal’s algorithm plus a DSU (union‐find).  Each time we unite two DSU components \\(u,v\\) by an edge of weight \\(w\\), we create a new node \\(x\\) whose children are the roots of those components, and store its weight as \\(w\\).  In the end we have exactly \\(2n-1\\) nodes.\n\n3. **Bottom‐up DP** on the reconstruction tree.  \n   - For a leaf \\(u\\), either we pick \\(0\\) or \\(1\\) server there; if that leaf is special, then with 0 servers it remains unserved (\\(t[u][0]=1\\)), and with 1 server it is served (\\(t[u][1]=0\\)), all with zero immediate cost.  \n   - For an internal node \\(u\\) of weight \\(W\\), with children \\(L,R\\), we convolve the two DPs exactly as one does knapsack‐style, summing the costs and unserved counts, and _if_ we place at least one server in the combined subtree, we serve all remaining unserved specials at this node for cost \\(W\\) each.\n\n4. **Answer retrieval**.  \n   At the root we have `dp[root][k]` = best cost with _exactly_ \\(k\\) servers.  The problem asks for “up to \\(k\\) servers,” so we form a prefix‐minimum over \\(k=1\\ldots n\\).\n\nThis runs in \\(O(n^2)\\) per test case (the convolution over all internal nodes) and fits easily within the problem’s \\(2\\)-second limit for \\(n\\le400\\)."
  }
]