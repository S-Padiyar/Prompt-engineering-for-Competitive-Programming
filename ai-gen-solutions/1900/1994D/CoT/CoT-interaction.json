[
    {
        "request_timestamp": "2025-07-23T18:29:45.422684",
        "response_timestamp": "2025-07-23T18:30:27.781549",
        "sent_messages": [
            {
                "role": "user",
                "content": "Codeforces Problem:\n\nD. Funny Game\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nVanya has a graph with n\n\n vertices (numbered from 1\n\n to n\n\n) and an array a\n\n of n\n\n integers; initially, there are no edges in the graph. Vanya got bored, and to have fun, he decided to perform n−1\n\n operations.\n\n\n\nOperation number x\n\n (operations are numbered in order starting from 1\n\n) is as follows:\n\n\n\nChoose 2\n\n different numbers 1≤u,v≤n\n\n, such that |au−av|\n\n is divisible by x\n\n.\n\nAdd an undirected edge between vertices u\n\n and v\n\n to the graph.\n\nHelp Vanya get a connected∗\n\n graph using the n−1\n\n operations, or determine that it is impossible.\n\n\n\n∗\n\nA graph is called connected if it is possible to reach any vertex from any other by moving along the edges.\n\n\n\nInput\n\nEach test consists of multiple test cases. The first line contains an integer t\n\n (1≤t≤103\n\n) — the number of test cases. Then follows the description of the test cases.\n\n\n\nThe first line of each test case contains the number n\n\n (1≤n≤2000\n\n) — the number of vertices in the graph.\n\n\n\nThe second line of each test case contains n\n\n numbers a1,a2,⋯an\n\n (1≤ai≤109\n\n).\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2000\n\n.\n\n\n\nOutput\n\nFor each test case, if there is no solution, then output \"No\" (without quotes).\n\n\n\nOtherwise, output \"Yes\" (without quotes), and then output n−1\n\n lines, where in the i\n\n-th line, output the numbers u\n\n and v\n\n that need to be chosen for operation i\n\n.\n\n\n\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\n\n\nExample\n\nInputCopy\n\n8\n\n2\n\n1 4\n\n4\n\n99 7 1 13\n\n5\n\n10 2 31 44 73\n\n5\n\n87 6 81 44 32\n\n5\n\n62 35 33 79 16\n\n5\n\n6 51 31 69 42\n\n5\n\n52 63 25 21 5\n\n12\n\n33 40 3 11 31 43 37 8 50 5 12 22\n\nOutputCopy\n\nYES\n\n2 1\n\nYES\n\n4 1\n\n2 1\n\n3 2\n\nYES\n\n5 1\n\n4 1\n\n3 1\n\n2 1\n\nYES\n\n4 1\n\n3 1\n\n2 1\n\n5 4\n\nYES\n\n3 1\n\n5 1\n\n2 1\n\n4 2\n\nYES\n\n4 1\n\n5 1\n\n2 1\n\n3 2\n\nYES\n\n2 1\n\n5 2\n\n3 1\n\n4 3\n\nYES\n\n9 1\n\n12 9\n\n11 1\n\n10 1\n\n6 1\n\n7 6\n\n2 1\n\n8 2\n\n5 2\n\n3 1\n\n4 1\n\nNote\n\nLet's consider the second test case.\n\n\n\nFirst operation (x=1)\n\n: we can connect vertices 4\n\n and 1\n\n, since |a4−a1|=|13−99|=|−86|=86\n\n, and 86\n\n is divisible by 1\n\n.\n\n\n\nSecond operation (x=2)\n\n: we can connect vertices 2\n\n and 1\n\n, since |a2−a1|=|7−99|=|−92|=92\n\n, and 92\n\n is divisible by 2\n\n.\n\n\n\nThird operation (x=3)\n\n: we can connect vertices 3\n\n and 2\n\n, since |a3−a2|=|1−7|=|−6|=6\n\n, and 6\n\n is divisible by 3\n\n.\n\nFrom the picture, it can be seen that a connected graph is obtained.\n\n---\n\nLet's think step-by-step so we don't make mistakes. Use Java. Avoid syntax errors or infinite loops."
            }
        ],
        "received_response": "{\n  \"id\": \"chatcmpl-BwcG1V6EHQ3UDCCLHjOu5rUIYhAT6\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"**Analysis**\\n\\nWe have \\\\(n\\\\) vertices labeled \\\\(1\\\\ldots n\\\\), an array of values \\\\(a_1,\\\\dots,a_n\\\\), and we must perform exactly \\\\(n-1\\\\) operations indexed \\\\(x=1\\\\ldots n-1\\\\).  In the \\\\(x\\\\)-th operation we must choose two distinct vertices \\\\(u,v\\\\) such that\\n\\\\[\\n\\\\bigl|a_u - a_v\\\\bigr| \\\\;\\\\equiv\\\\;0 \\\\pmod{x},\\n\\\\]\\nand add the undirected edge \\\\((u,v)\\\\).  After all \\\\(n-1\\\\) operations, the resulting graph must be connected.  If it is impossible, we must print “No”; otherwise we print “Yes” and one edge \\\\((u_x,v_x)\\\\) for each \\\\(x\\\\) in order.\\n\\nA clean way to guarantee connectivity is to build a star centered at a single “root” vertex \\\\(r\\\\).  Suppose we pick the vertex \\\\(r\\\\) whose \\\\(a_r\\\\) is minimal (any fixed choice of one vertex would do).  Then we only ever add edges of the form \\\\((r,i)\\\\) for \\\\(i\\\\neq r\\\\).  This will certainly produce a connected graph (in fact a star).  \\n\\nWhat remains is to assign *each* operation-index \\\\(x=1\\\\ldots n-1\\\\) to *one* distinct “other” vertex \\\\(i\\\\neq r\\\\), so that\\n\\\\[\\n|a_i - a_r|\\\\;\\\\bigr|\\\\;x,\\n\\\\]\\ni.e.\\\\ \\\\(x\\\\) divides \\\\(\\\\bigl|a_i - a_r\\\\bigr|\\\\).  We have exactly \\\\(n-1\\\\) other vertices \\\\(i\\\\), and we have exactly \\\\(n-1\\\\) operation-indices \\\\(x\\\\).  Thus we need a *perfect matching* in the bipartite graph\\n\\n- Left side \\\\(X = \\\\{1,2,\\\\dots,n-1\\\\}\\\\) (the operation-indices).\\n- Right side \\\\(I = \\\\{\\\\) the \\\\(n-1\\\\) vertices other than \\\\(r\\\\}\\\\).\\n- Put an edge \\\\((x,i)\\\\) if and only if \\\\(x\\\\) divides \\\\(\\\\bigl|a_i - a_r\\\\bigr|\\\\).\\n\\nIf we find a perfect matching \\\\(x\\\\mapsto i\\\\), then in operation \\\\(x\\\\) we connect \\\\((r,i)\\\\).  That uses each \\\\(x\\\\) exactly once, connects to a distinct \\\\(i\\\\neq r\\\\), and so yields a star graph which is connected and satisfies all divisibility constraints.\\n\\nWe can find a bipartite perfect matching in \\\\(O(V\\\\cdot E)\\\\) time by the classic “Kuhn” (DFS‐based) algorithm, or if you prefer, Hopcroft–Karp in \\\\(O(E\\\\sqrt V)\\\\).  Since \\\\(n\\\\le2000\\\\) in total, a well‐written Kuhn will pass easily.\\n\\n**Implementation (Java)**\\n\\n```java\\nimport java.io.*;\\nimport java.util.*;\\n\\npublic class Main {\\n    static int n;\\n    static long[] a;\\n    // adj[x] = list of right‐side nodes j that x can match to\\n    static ArrayList<Integer>[] adj;\\n    // matchL[x] = matched right‐node for left‐node x  (or -1)\\n    // matchR[j] = matched left‐node for right‐node j (or -1)\\n    static int[] matchL, matchR;\\n    static boolean[] seen;  // for DFS on right side\\n\\n    // Try to find augmenting path starting from left‐node x\\n    static boolean dfs(int x) {\\n        for (int j : adj[x]) {\\n            if (seen[j]) continue;\\n            seen[j] = true;\\n            // either j is free, or we can re-route its current match\\n            if (matchR[j] == -1 || dfs(matchR[j])) {\\n                matchL[x] = j;\\n                matchR[j] = x;\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String[] args) throws IOException {\\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n        PrintWriter out = new PrintWriter(System.out);\\n\\n        int t = Integer.parseInt(br.readLine().trim());\\n        while (t-- > 0) {\\n            n = Integer.parseInt(br.readLine().trim());\\n            a = new long[n];\\n            StringTokenizer st = new StringTokenizer(br.readLine());\\n            for (int i = 0; i < n; i++) {\\n                a[i] = Long.parseLong(st.nextToken());\\n            }\\n            // If n=1, no edges needed, always connected trivially\\n            if (n == 1) {\\n                out.println(\\\"Yes\\\");\\n                continue;\\n            }\\n\\n            // 1) Pick r = index of minimal a[i]\\n            int r = 0;\\n            for (int i = 1; i < n; i++) {\\n                if (a[i] < a[r]) r = i;\\n            }\\n\\n            // 2) Build list of the other n-1 vertices\\n            int M = n - 1;\\n            int[] ids = new int[M]; // ids[j] = original vertex index for right‐node j\\n            {\\n                int ptr = 0;\\n                for (int i = 0; i < n; i++) {\\n                    if (i == r) continue;\\n                    ids[ptr++] = i;\\n                }\\n            }\\n\\n            // 3) Build adjacency for x=1..M\\n            adj = new ArrayList[M+1];\\n            for (int x = 1; x <= M; x++) {\\n                adj[x] = new ArrayList<>();\\n            }\\n            for (int j = 0; j < M; j++) {\\n                long diff = Math.abs(a[ids[j]] - a[r]);\\n                // For each x in [1..M], if x divides diff, add edge\\n                // (We could factor diff, but for M<=2000 a simple loop is fine.)\\n                for (int x = 1; x <= M; x++) {\\n                    if (diff % x == 0) {\\n                        adj[x].add(j);\\n                    }\\n                }\\n            }\\n\\n            // 4) Try to find a perfect matching from {1..M} -> {right‐nodes}\\n            matchL = new int[M+1];\\n            matchR = new int[M];\\n            Arrays.fill(matchL, -1);\\n            Arrays.fill(matchR, -1);\\n\\n            boolean ok = true;\\n            // We can improve speed by sorting x's by increasing adjacency size\\n            Integer[] ops = new Integer[M];\\n            for (int i = 0; i < M; i++) ops[i] = i+1;\\n            Arrays.sort(ops, Comparator.comparingInt(x -> adj[x].size()));\\n\\n            for (int x : ops) {\\n                seen = new boolean[M];\\n                if (!dfs(x)) {\\n                    ok = false;\\n                    break;\\n                }\\n            }\\n\\n            if (!ok) {\\n                out.println(\\\"No\\\");\\n            } else {\\n                out.println(\\\"Yes\\\");\\n                // We must print the edges in order x=1..M\\n                // operation x connects (r, ids[ matchL[x] ])\\n                for (int x = 1; x <= M; x++) {\\n                    int j = matchL[x];\\n                    int v = ids[j];\\n                    // +1 to convert 0-based to 1-based\\n                    out.printf(\\\"%d %d\\\\n\\\", r+1, v+1);\\n                }\\n            }\\n        }\\n        out.flush();\\n    }\\n}\\n```\\n\\n**Explanation of the Key Steps**\\n\\n1. **Root choice**  \\n   We pick a single vertex `r` (e.g.\\\\ the one with smallest `a[r]`) that will serve as the center of our star.  Every edge we add will be of the form \\\\((r,i)\\\\).\\n\\n2. **Bipartite graph**  \\n   - Left side nodes are the operation‐indices \\\\(x=1\\\\ldots n-1\\\\).  \\n   - Right side nodes are the \\\\(n-1\\\\) other vertices \\\\(i\\\\neq r\\\\).  \\n   - We put an edge \\\\((x,i)\\\\) if and only if\\n     \\\\[\\n       x \\\\;|\\\\;\\\\bigl|a_i - a_r\\\\bigr|.\\n     \\\\]\\n   Finding a *perfect matching* in this bipartite graph ensures that each \\\\(x\\\\) is matched to exactly one distinct \\\\(i\\\\).\\n\\n3. **Kuhn’s algorithm (DFS‐based matching)**  \\n   We run a DFS‐based bipartite matcher (“Kuhn”) attempting to match each left node \\\\(x\\\\).  If all left nodes can be matched, we have our perfect matching.\\n\\n4. **Building the answer**  \\n   If matching succeeds, for each \\\\(x=1\\\\ldots n-1\\\\) we look up which vertex \\\\(i\\\\) it is matched to, say `matchL[x] = j`, and then print the edge\\n   \\\\[\\n     (r,\\\\; \\\\text{ids}[j])\\n   \\\\]\\n   in the \\\\(x\\\\)-th operation.  This forms a star around `r` and uses each operation‐index exactly once in a valid way.\\n\\nIf at any point we fail to find a perfect matching, we output “No”.\\n\\nThis runs in \\\\(O(n\\\\cdot n)\\\\) to build the adjacency (since \\\\(n\\\\le2000\\\\)), and the DFS‐matching is in practice fast enough for \\\\(n\\\\le2000\\\\) in Java.\",\n        \"refusal\": null,\n        \"role\": \"assistant\",\n        \"annotations\": [],\n        \"audio\": null,\n        \"function_call\": null,\n        \"tool_calls\": null\n      },\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"protected_material_code\": {\n          \"filtered\": false,\n          \"detected\": true,\n          \"citation\": {\n            \"URL\": \"https://github.com/Pandit98himanshu/Competitive_Coding/tree/632bb0a1aad50983fb6b87634978e8992842b10d/Codechef%2FPractice%2FBeginner%2FFindingSquareRoots.java\",\n            \"license\": \"NOASSERTION\"\n          }\n        },\n        \"protected_material_text\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ],\n  \"created\": 1753309785,\n  \"model\": \"o4-mini-2025-04-16\",\n  \"object\": \"chat.completion\",\n  \"service_tier\": null,\n  \"system_fingerprint\": null,\n  \"usage\": {\n    \"completion_tokens\": 5121,\n    \"prompt_tokens\": 907,\n    \"total_tokens\": 6028,\n    \"completion_tokens_details\": {\n      \"accepted_prediction_tokens\": 0,\n      \"audio_tokens\": 0,\n      \"reasoning_tokens\": 3072,\n      \"rejected_prediction_tokens\": 0\n    },\n    \"prompt_tokens_details\": {\n      \"audio_tokens\": 0,\n      \"cached_tokens\": 0\n    }\n  },\n  \"prompt_filter_results\": [\n    {\n      \"prompt_index\": 0,\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"jailbreak\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ]\n}"
    }
]