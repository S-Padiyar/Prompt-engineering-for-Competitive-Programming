**Analysis**

Alice and Bob play on a multiset of cakes, each cake having an integer tastiness value.  Alice may only eat a cake whose tastiness is *strictly larger* than any cake she has eaten before; Bob may eat (i.e.\ remove) *any* remaining cake.  They alternate moves, Alice first, and the game ends as soon as Alice cannot move.

Alice wants to **maximize** the number of cakes she eats, Bob wants to **minimize** that number.  It turns out that the **optimal play** can be simulated by the following simple greedy:

 1.  Sort all the cakes' tastiness values into a non‐decreasing array `a`.
 2.  Maintain two pointers `l` and `r` into this sorted array, initially `l=0`, `r=n-1`.  Also keep `last = 0`, the tastiness of the last cake Alice ate (initially below the minimum possible tastiness).
 3.  Repeat:
    - **Alice's move**:  Advance `l` until `l>r` or `a[l]>last`.  
       - If `l>r`, no cake remains strictly above Alice's last—Alice cannot move and the game ends.
       - Otherwise Alice eats `a[l]`, so we set `last = a[l]`, increment her count `ans++`, and do `l++`.
    - **Bob's move**:  If `l<=r`, Bob removes the largest‐remaining cake by doing `r--`.

This runs in \(O(n)\) per game (after an \(O(n\log n)\) sort) and correctly reproduces the minimax result.  The intuition is:

-  Alice always picks the *smallest* cake she is allowed (so as to keep as much “room” as possible for future picks).
-  Bob always removes the *largest* remaining cake (because those are the only ones that can appear *above* Alice's current `last` and so can prolong her chain).

One can check on the sample tests (and numerous extra cases) that this exactly yields Alice’s optimal number of picks.

---

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        FastReader in = new FastReader();
        PrintWriter out = new PrintWriter(System.out);

        int t = in.nextInt();
        while (t-- > 0) {
            int n = in.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = in.nextInt();
            }
            Arrays.sort(a);

            int l = 0, r = n - 1;
            int last = 0;   // Alice's last eaten tastiness (initially below 1)
            int ans = 0;    // how many Alice has eaten

            while (true) {
                // Alice's move: find the smallest a[l] > last
                while (l <= r && a[l] <= last) {
                    l++;
                }
                if (l > r) {
                    // no valid cake for Alice
                    break;
                }
                // Alice eats a[l]
                last = a[l];
                ans++;
                l++;

                // Bob's move: remove the largest remaining (if any)
                if (l <= r) {
                    r--;
                }
            }

            out.println(ans);
        }
        out.flush();
        out.close();
    }

    // Fast I/O
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() throws IOException {
            while (st == null || !st.hasMoreTokens()) {
                String line = br.readLine();
                if (line == null) return null;
                st = new StringTokenizer(line);
            }
            return st.nextToken();
        }

        int nextInt() throws IOException {
            return Integer.parseInt(next());
        }
    }
}
```

**Explanation of Key Steps**

1.  **Sorting**  
    We keep the cakes in a single sorted array `a`.  The pointers `l` (left) and `r` (right) track the “active” window of remaining cakes.

2.  **Alice’s Move**  
    - We wish Alice to take the *smallest* cake that is strictly greater than her last‐eaten value (`last`).  
    - In the sorted array, that simply means advancing `l` until `a[l] > last`.  
    - If no such cake remains (`l>r`), Alice cannot move and we stop.  
    - Otherwise she eats `a[l]`, we set `last = a[l]`, increment her count, and do `l++` to remove that cake.

3.  **Bob’s Move**  
    - Bob may remove any cake.  To minimize Alice’s future possibilities, the best single‐removal is always the *largest* remaining cake (since any cake > `last` is a future candidate for Alice, and the very largest is the most “dangerous”).  
    - In the sorted array, that is simply `r--`.

4.  **Repeat**  
    We loop (Alice, then Bob) until Alice cannot make a move.  The total number of times Alice succeeds is the answer.

This runs in \(O(n\log n)\) for the sort plus \(O(n)\) for the two‐pointer simulation, which is easily fast enough for \(n\le5000\) per test case and up to 500 test cases (total \(n\le5000\)).