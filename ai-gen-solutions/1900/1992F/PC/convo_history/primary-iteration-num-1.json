[
  {
    "role": "user",
    "content": "F. Valuable Cards\n\ntime limit per test4 seconds\n\nmemory limit per test512 megabytes\n\nIn his favorite cafe Kmes once again wanted to try the herring under a fur coat. Previously, it would not have been difficult for him to do this, but the cafe recently introduced a new purchasing policy.\n\n\n\nNow, in order to make a purchase, Kmes needs to solve the following problem: n\n\n cards with prices for different positions are laid out in front of him, on the i\n\n-th card there is an integer ai\n\n, among these prices there is no whole positive integer x\n\n.\n\n\n\nKmes is asked to divide these cards into the minimum number of bad segments (so that each card belongs to exactly one segment). A segment is considered bad if it is impossible to select a subset of cards with a product equal to x\n\n. All segments, in which Kmes will divide the cards, must be bad.\n\n\n\nFormally, the segment (l,r)\n\n is bad if there are no indices i1<i2<…<ik\n\n such that l≤i1,ik≤r\n\n, and ai1⋅ai2…⋅aik=x\n\n.\n\n\n\nHelp Kmes determine the minimum number of bad segments in order to enjoy his favorite dish.\n\n\n\nInput\n\nThe first line contains a single integer t\n\n (1≤t≤103\n\n) — the number of test cases.\n\n\n\nThe first line of each set of input data gives you 2\n\n integers n\n\n and x\n\n (1≤n≤105,2≤x≤105\n\n) — the number of cards and the integer, respectively.\n\n\n\nThe second line of each set of input data contains n\n\n integers ai\n\n (1≤ai≤2⋅105,ai≠x\n\n) — the prices on the cards.\n\n\n\nIt is guaranteed that the sum of n\n\n over all sets of test data does not exceed 105\n\n.\n\n\n\nOutput\n\nFor each set of input data, output the minimum number of bad segments.\n\n\n\nExample\n\nInputCopy\n\n8\n\n6 4\n\n2 3 6 2 1 2\n\n9 100000\n\n50000 25000 12500 6250 3125 2 4 8 16\n\n5 2\n\n1 1 1 1 1\n\n8 6\n\n4 3 4 3 4 3 4 3\n\n7 12\n\n6 11 1 3 11 10 2\n\n10 5\n\n2 4 4 2 4 4 4 3 1 1\n\n7 8\n\n4 6 5 1 2 4 1\n\n8 27\n\n3 9 17 26 2 20 9 3\n\nOutputCopy\n\n3\n\n2\n\n1\n\n1\n\n2\n\n1\n\n3\n\n3\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have an array \\(a_1,a_2,\\dots,a_n\\) of “card‐prices” and a target integer \\(x\\).  We must cut the array into the fewest contiguous segments so that in *each* segment there is **no** sub‐multiset of its elements whose product equals \\(x\\).  We call such a segment *bad*.  Equivalently, we want to scan left to right, growing one segment until it would become *good* (i.e.\\ one can pick some of its elements whose product is exactly \\(x\\)); as soon as it becomes good, we close that segment just *before* the current card and start a new one.  This greedy is clearly optimal (you always make each segment as long as possible before it fails the “bad” condition, hence you get the fewest segments).\n\nThe core sub‐problem is: given a multiset of integers that *divide* \\(x\\), how can we test quickly whether some sub‐multiset has product exactly \\(x\\)?  We do standard subset‐product DP, except:\n\n1.  We only care about divisors of \\(x\\).  Let the divisors of \\(x\\) be\n    \\[\n      D=\\{d_0=1,d_1,\\dots,d_{m-1}=x\\}.\n    \\]\n2.  We keep a bitset `dp` of length \\(m\\), where `dp[j] = 1` means “we can\n    form the divisor \\(d_j\\) as the product of some chosen subset so far.”\n3.  Initialization: `dp[ index‐of(1) ] = 1`, all others 0.\n4.  When a new card \\(a_i\\) arrives, if \\(a_i\\nmid x\\) we ignore it (it\n    can never help form exactly \\(x\\), since it brings in a prime factor\n    not in \\(x\\) or an excess power).  Otherwise, let\n    \\(g=a_i\\).  We then do the usual “convolution” over the divisors:\n    \n      for every divisor \\(d_j\\) such that \\(d_j\\cdot g\\) also divides \\(x\\),\n      we set\n      \\[\n         \\mathrm{dp\\_new}[\\text{index‐of}(d_j\\cdot g)] \n            \\;=\\;\\mathrm{dp\\_new}[\\text{index‐of}(d_j\\cdot g)]\n            \\;\\lor\\;\\mathrm{dp}[j].\n      \\]\n      \n    If at any point \\(\\mathrm{dp}\\bigl(\\text{index‐of}(x)\\bigr)=1\\),\n    we have found a subset whose product is \\(x\\), so our current segment\n    is “good.”  We must immediately close it (increment our segment‐count,\n    reset the DP to only `dp[ index‐of(1) ]=1`, and *then* re‐process the\n    current \\(a_i\\) into the *new* segment, which by hypothesis cannot\n    finish it at once because \\(a_i\\neq x\\) by problem statement).\n\nDivisor‐count \\(\\tau(x)\\) is at most a few hundred for \\(x\\le10^5\\), so the\nDP table has manageable size.  Scanning all \\(n\\) cards and doing an\n\\(O(\\tau(x)^2)\\) prebuild of the “who‐maps‐to‐whom” table is perfectly\nfine in \\(O\\bigl(n\\,\\tau(x)\\bigr)\\), well under the given limits.\n\n**Implementation in Java**\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class DivInfo {\n        int m;            // number of divisors\n        int[] divs;       // divs[k] = k-th divisor of x\n        int idxX;         // index of divisor x itself\n        Map<Integer,Integer> indexOf;    // divisor -> its index\n        ArrayList<int[]>[] mapping;      // mapping[g_idx] = list of (prevIdx, nextIdx)\n    }\n\n    // Build the divisors of x, their index map, and the multiplication mapping.\n    static DivInfo build(int x) {\n        DivInfo D = new DivInfo();\n        // 1) find divisors\n        ArrayList<Integer> temp = new ArrayList<>();\n        for (int d = 1; d * d <= x; d++) {\n            if (x % d == 0) {\n                temp.add(d);\n                if (d * d != x) temp.add(x / d);\n            }\n        }\n        Collections.sort(temp);\n        D.m = temp.size();\n        D.divs = new int[D.m];\n        D.indexOf = new HashMap<>(D.m * 2);\n        for (int i = 0; i < D.m; i++) {\n            D.divs[i] = temp.get(i);\n            D.indexOf.put(D.divs[i], i);\n        }\n        D.idxX = D.indexOf.get(x);\n\n        // 2) precompute, for each divisor g, how existing dp-positions j map\n        //    to new positions when we multiply by g.\n        D.mapping = new ArrayList[D.m];\n        for (int gi = 0; gi < D.m; gi++) {\n            int gval = D.divs[gi];\n            D.mapping[gi] = new ArrayList<>();\n            // Try all old \"d_j\" and see if d_j*gval is still a divisor\n            for (int j = 0; j < D.m; j++) {\n                long prod = (long)D.divs[j] * gval;\n                if (prod <= x && x % (int)prod == 0) {\n                    int nxt = D.indexOf.get((int)prod);\n                    D.mapping[gi].add(new int[]{j, nxt});\n                }\n            }\n        }\n        return D;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(in.readLine().trim());\n        StringBuilder sb = new StringBuilder();\n\n        while (t-- > 0) {\n            StringTokenizer st = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int x = Integer.parseInt(st.nextToken());\n            int[] a = new int[n];\n            st = new StringTokenizer(in.readLine());\n            for (int i = 0; i < n; i++) {\n                a[i] = Integer.parseInt(st.nextToken());\n            }\n\n            // Build DP machinery for this x\n            DivInfo D = build(x);\n\n            // Current segment count\n            int segments = 1;\n\n            // A bitset of reachable divisors in the current segment\n            BitSet dp = new BitSet(D.m);\n            dp.set(D.indexOf.get(1));  // we can always make product = 1 with empty subset\n\n            for (int val : a) {\n                // Only values that exactly divide x can ever help form x\n                if (x % val != 0) {\n                    continue; \n                }\n                int gi = D.indexOf.get(val);\n\n                // 1) Try to add this card into the DP\n                BitSet nextDp = (BitSet) dp.clone();\n                for (int[] p : D.mapping[gi]) {\n                    if (dp.get(p[0])) {\n                        nextDp.set(p[1]);\n                    }\n                }\n                dp = nextDp;\n\n                // 2) If we can now reach divisor x, segment turned \"good\" => cut!\n                if (dp.get(D.idxX)) {\n                    segments++;\n                    // reset dp for new segment\n                    dp.clear();\n                    dp.set(D.indexOf.get(1));\n                    // re-process current card into new segment\n                    nextDp = (BitSet) dp.clone();\n                    for (int[] p : D.mapping[gi]) {\n                        if (dp.get(p[0])) {\n                            nextDp.set(p[1]);\n                        }\n                    }\n                    dp = nextDp;\n                }\n            }\n\n            sb.append(segments).append('\\n');\n        }\n\n        System.out.print(sb);\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Divisor enumeration**: We list all divisors of \\(x\\) in \\(O(\\sqrt{x})\\), sort them, and build a map from divisor–value to its index.  \n2. **Subset‐product DP**: We keep a bitset `dp` of length `m` (# of divisors), where `dp[j]` being set means “we can form divisor `divs[j]` as the product of some chosen subset in the current segment.”  \n3. **Transition**: When we see a new card \\(a_i\\) that **does** divide \\(x\\), we take our old set of reachable divisors, clone it, and for every old divisor `d_j` we check if `d_j * a_i` is still a divisor of \\(x\\).  If so, we turn on its bit.  \n4. **CUT on success**: As soon as the bit for the divisor \\(x\\) itself becomes 1, our segment is *good* (because we have found a subset whose product is \\(x\\)).  We immediately close that segment (increment the counter), reset the DP to only “1=product of the empty subset,” and *then* re‐insert the current card into the fresh DP for the new segment (it cannot by itself complete the product to \\(x\\) because \\(a_i\\neq x\\) per problem statement).  \n\nThis runs in \\(O(n\\tau(x) + \\tau(x)^2)\\) per test, which is fast enough for \\(n\\le10^5\\), \\(x\\le10^5\\)."
  }
]