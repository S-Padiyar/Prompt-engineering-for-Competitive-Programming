[
  {
    "timestamp": "2025-07-24T06:01:23.150362",
    "role": "user",
    "content": "G. Sakurako's Task\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nSakurako has prepared a task for you:\n\n\n\nShe gives you an array of n\n\n integers and allows you to choose i\n\n and j\n\n such that i≠j\n\n and ai≥aj\n\n, and then assign ai=ai−aj\n\n or ai=ai+aj\n\n. You can perform this operation any number of times for any i\n\n and j\n\n, as long as they satisfy the conditions.\n\n\n\nSakurako asks you what is the maximum possible value of mexk\n\n∗\n\n of the array after any number of operations.\n\n\n\n∗\n\nmexk\n\n is the k\n\n-th non-negative integer that is absent in the array. For example, mex1({1,2,3})=0\n\n, since 0\n\n is the first element that is not in the array, and mex2({0,2,4})=3\n\n, since 3\n\n is the second element that is not in the array.\n\n\n\nInput\n\nThe first line contains a single integer t\n\n (1≤t≤104\n\n)  — the number of test cases.\n\n\n\nThe first line of each test case contains two integers n\n\n and k\n\n (1≤n≤2⋅105,1≤k≤109\n\n)  — the number of elements in the array and the value k\n\n for mexk\n\n.\n\n\n\nThe second line of each test case contains n\n\n integers a1,a2,…,an\n\n (1≤ai≤109\n\n)  — the elements of the array.\n\n\n\nIt is guaranteed that the sum of n\n\n across all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output the maximum mexk\n\n that can be achieved through the operations.\n\n\n\nExample\n\nInputCopy\n\n6\n\n1 3\n\n3\n\n2 10\n\n1 1\n\n3 1\n\n1 2 3\n\n3 2\n\n1 2 4\n\n4 5\n\n2 2 2 16\n\n4 5\n\n2 2 2 3\n\nOutputCopy\n\n2\n\n11\n\n3\n\n4\n\n8\n\n8\n\nUse Java."
  },
  {
    "timestamp": "2025-07-24T06:04:14.476278",
    "role": "assistant",
    "content": "**Analysis**\n\nWe are given an array $a$ of length $n$ (with $a_i\\ge1$) and an integer $k$.  We may repeatedly pick two distinct indices $i\\neq j$ with $a_i\\ge a_j$ and either replace\n$$\na_i\\leftarrow a_i-a_j\n\\quad\\text{or}\\quad\na_i\\leftarrow a_i+a_j.\n$$\nWe want to maximize \n$$\n\\mathrm{mex}_k(A),\n$$\nthe $k$-th missing nonnegative integer of the final multiset $A$.\n\nThere are two cases:\n\n1. **$n=1$.**  \n   No operation is possible (you need two distinct indices), so the array remains $\\{a_1\\}$.  \n   - The missing nonnegatives are\n     $$\n       0,1,2,\\dots,a_1-1,\\;a_1+1,a_1+2,\\dots\n     $$\n     i.e. the first $a_1$ missing numbers are $0,1,2,\\dots,a_1-1$.  Thus\n     $$\n       \\mathrm{mex}_k = \n       \\begin{cases}\n         k-1,&k\\le a_1,\\\\\n         k,  &k>a_1.\n       \\end{cases}\n     $$\n\n2. **$n\\ge2$.**  \n   One shows easily by using subtraction until one slot becomes $\\gcd(a_1,\\dots,a_n)=d$, and then using the “add”‐operation to create arbitrarily large multiples of $d$, that the final array can be made to consist of any $n$ (not necessarily distinct) multiples of $d= \\gcd(a_1,\\dots,a_n)$, and no other values.  \n\n   Hence effectively we choose a *set* \n   $$\n     S\\subseteq\\{\\,0,d,2d,3d,\\dots\\},\\quad |S|\\le n,\n   $$\n   in order to maximize the $k$-th missing nonnegative integer.  (Duplicates only hurt, so one never wants duplicates; one picks $|S|\\le n$ distinct multiples.)\n\n   Write all nonnegative integers in *blocks* of length $d$:\n   $$\n     [0..d-1],\\;[d..2d-1],\\;[2d..3d-1],\\;\\dots\n   $$\n   In block $i$ the only multiple of $d$ is exactly $id$ at the very start.  If we choose $id\\in S$ then that block contributes exactly $(d-1)$ missing numbers (all the non-multiples in that block).  If we do *not* choose $id\\in S$, that block contributes $d$ missing numbers (including the multiple itself).  \n\n   To **delay** the appearance of the $k$-th missing number as far to the right as possible, we should choose *all* of the first $n$ multiples \n   $$\n     \\{0\\cdot d,\\;1\\cdot d,\\;2\\cdot d,\\;\\dots,\\;(n-1)d\\}\n   $$\n   (that uses up our $n$ picks on the earliest blocks).  Then:\n\n   - For the first $n$ blocks (block $0$ through block $n-1$) each block contributes exactly $d-1$ missing numbers.\n   - From block $n$ onward, we have used up all our picks, so every block contributes $d$ missing numbers.\n\n   Let\n   $$\n     N_1 \\;=\\; n\\,(d-1)\n   $$\n   be the total missing count in the first $n$ blocks.  There are now two regimes:\n\n   a)  If $k\\le N_1$, the $k$-th missing lies in one of the *picked* (first $n$) blocks, each of which has $(d-1)$ missing and *omits* the multiple $id$ itself.  A simple division‐with‐remainder locates the exact block and offset.\n\n   b)  If $k>N_1$, the $k$-th missing lies in one of the *unpicked* blocks (block $n,n+1,\\dots$), each of which contributes $d$ missing including its multiple.  Again division‐with‐remainder gives its position.\n\nPutting all this together yields an $O(n)$–scan to compute $d$, then $O(1)$ arithmetic to get the answer per test case.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tok = new StringTokenizer(in.readLine());\n        int t = Integer.parseInt(tok.nextToken());\n        \n        StringBuilder sb = new StringBuilder();\n        while (t-- > 0) {\n            tok = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tok.nextToken());\n            long k = Long.parseLong(tok.nextToken());\n            \n            tok = new StringTokenizer(in.readLine());\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = Long.parseLong(tok.nextToken());\n            }\n            \n            // Case 1: n == 1, cannot change the single element\n            if (n == 1) {\n                long x = a[0];\n                if (k <= x) {\n                    sb.append(k - 1).append('\\n');\n                } else {\n                    sb.append(k).append('\\n');\n                }\n                continue;\n            }\n            \n            // Case 2: n >= 2\n            // Compute d = gcd(a[0], a[1], ..., a[n-1])\n            long d = a[0];\n            for (int i = 1; i < n; i++) {\n                d = gcd(d, a[i]);\n            }\n            \n            // Let N1 = n*(d-1) be the number of missing in the first n blocks\n            long N1 = (long)n * (d - 1);\n            \n            long answer;\n            if (k <= N1) {\n                // The k-th missing is in one of the first n \"picked\" blocks\n                // Each such block contributes (d-1) missing,\n                // and the missing in block b are exactly\n                // b*d+1, b*d+2, ..., b*d+(d-1).\n                long zeroBased = k - 1;                   // zero-based missing index\n                long block = zeroBased / (d - 1);        // which block\n                long offset = zeroBased % (d - 1);       // offset in that block\n                answer = block * d + 1 + offset;\n            } else {\n                // The k-th missing is in one of the unpicked blocks,\n                // each contributes d missing including its multiple.\n                long rem = k - N1 - 1;  // zero-based among the \"unpicked\" blocks\n                long block = n + (rem / d);\n                long offset = rem % d;\n                answer = block * d + offset;\n            }\n            \n            sb.append(answer).append('\\n');\n        }\n        \n        System.out.print(sb);\n    }\n    \n    // gcd helper\n    private static long gcd(long x, long y) {\n        while (y != 0) {\n            long r = x % y;\n            x = y;\n            y = r;\n        }\n        return x;\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **When $n=1$**  \n   No operation is possible.  The single element $a_1$ remains.  \n   - The missing nonnegative integers are\n     $$\n       0,1,2,\\dots,a_1-1,\\quad a_1+1,a_1+2,\\dots\n     $$\n     so the first $a_1$ missing numbers are $0,1,\\dots,a_1-1$.  \n   - Hence $\\mathrm{mex}_k=a_1$’s contribution is\n     $$\n       \\mathrm{mex}_k = \n       \\begin{cases}\n         k-1, & k\\le a_1,\\\\\n         k,   & k>a_1.\n       \\end{cases}\n     $$\n\n2. **When $n\\ge2$**  \n   By repeated subtraction we can bring one slot down to the global gcd  \n   $d=\\gcd(a_1,\\dots,a_n)$, and then by additions we can generate *arbitrarily large* multiples of $d$.  Moreover one can produce the value 0 as well.  Consequently the array can be made into *any* $n$ (not necessarily distinct) multiples of $d$.  Duplicates never help our mex, so we might as well choose at most $n$ *distinct* multiples of $d$.\n\n   We divide the nonnegative integers into consecutive “blocks” of length $d$:\n   \\[\n     [0..d-1],\\;[d..2d-1],\\;[2d..3d-1],\\;\\dots\n   \\]\n   In the $i$-th block, the only multiple of $d$ is $i\\cdot d$ at the start.\n   - If we *choose* $i\\cdot d$ in our final set, that block contributes exactly $d-1$ missing numbers (all the non-multiples).\n   - If we *skip* $i\\cdot d$, the block contributes all $d$ missing numbers (including $i\\cdot d$ itself).\n\n   To *postpone* the $k$-th missing as far as possible, we select the first $n$ multiples\n   $$\n     0\\cdot d,\\;1\\cdot d,\\;2\\cdot d,\\;\\dots,\\;(n-1)\\,d,\n   $$\n   thus “picking” blocks $0,1,\\dots,n-1$.  Those first $n$ blocks each yield $d-1$ missing numbers; beyond that, every block yields $d$ missing numbers.  A little division‐with‐remainder tells you exactly in which block and at which offset the $k$-th missing falls.\n\n\nThis runs in $O(n)$ per test for the gcd plus $O(1)$ for the final arithmetic, easily handling $\\sum n\\le2\\cdot10^5\\,$ and $t\\le10^4\\,$."
  }
]