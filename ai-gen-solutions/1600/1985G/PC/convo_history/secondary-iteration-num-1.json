[
  {
    "role": "user",
    "content": "G. D-Function\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nLet D(n)\n\n represent the sum of digits of n\n\n. For how many integers n\n\n where 10l≤n<10r\n\n satisfy D(k⋅n)=k⋅D(n)\n\n? Output the answer modulo 109+7\n\n.\n\n\n\nInput\n\nThe first line contains an integer t\n\n (1≤t≤104\n\n) – the number of test cases.\n\n\n\nEach test case contains three integers l\n\n, r\n\n, and k\n\n (0≤l<r≤109\n\n, 1≤k≤109\n\n).\n\n\n\nOutput\n\nFor each test case, output an integer, the answer, modulo 109+7\n\n.\n\n\n\nExample\n\nInputCopy\n\n6\n\n0 1 4\n\n0 2 7\n\n1 2 1\n\n1 2 3\n\n582 74663 3\n\n0 3 1\n\nOutputCopy\n\n2\n\n3\n\n90\n\n12\n\n974995667\n\n999\n\nNote\n\nFor the first test case, the only values of n\n\n that satisfy the condition are 1\n\n and 2\n\n.\n\n\n\nFor the second test case, the only values of n\n\n that satisfy the condition are 1\n\n, 10\n\n, and 11\n\n.\n\n\n\nFor the third test case, all values of n\n\n between 10\n\n inclusive and 100\n\n exclusive satisfy the condition.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe want to count all integers \\(n\\) in the interval\n\\[\n10^l \\;\\le\\; n \\;<\\; 10^r\n\\]\nsuch that\n\\[\nD(k\\cdot n)\\;=\\;k\\;D(n),\n\\]\nwhere \\(D(x)\\) is the digit‐sum of \\(x\\), and finally take the count modulo \\(10^9+7\\).\n\nIt is a well‐known fact that for any nonnegative integers \\(n\\) and \\(k\\),\n\n\\[\nD(k\\,n)\\;\\le\\;k\\,D(n),\n\\]\n\nwith equality if and only if the (base‐10) “grade‐school” multiplication \\(k\\times n\\) incurs no carries at any digit.  Concretely, if the decimal digits of \\(n\\) are \\(\\dots,d_2,d_1,d_0\\), then when you form\n\n\\[\nk\\cdot n\n\\;=\\;\\dots\\;\\bigl(k\\,d_2+\\text{carry}_2\\bigr)\\,\n\\bigl(k\\,d_1+\\text{carry}_1\\bigr)\\,\n\\bigl(k\\,d_0+\\text{carry}_0\\bigr)\n\\]\nyou only ever get \\(\\text{carry}_i=0\\) if and only if\n\\[\nk\\,d_i<10\n\\quad\\text{for every digit }d_i.\n\\]\n\nHence the necessary and sufficient condition for\n\\(\\;D(k\\,n)=k\\,D(n)\\)\nis\n\\[\n\\max\\{d_i\\}\\;\\le\\;\\left\\lfloor\\frac{9}{k}\\right\\rfloor.\n\\]\nSet\n\\[\nc=\\left\\lfloor\\frac{9}{k}\\right\\rfloor.\n\\]\n- If \\(k\\ge10\\), then \\(c=0\\).  The only digit that is allowed is 0, so the only “number” with all digits 0 is \\(n=0\\); but our range \\(\\;10^l\\le n<10^r\\) never includes 0, so there are **no** valid \\(n\\).  The answer is 0.\n- If \\(1\\le k\\le9\\), then \\(1\\le c\\le9\\).  Every decimal digit of \\(n\\) must lie in \\(\\{0,1,\\dots,c\\}\\), and in addition the leading digit of \\(n\\) (to make it a true \\(d\\)-digit number) must be in \\(\\{1,2,\\dots,c\\}\\).\n\nNumbers \\(n\\) with exactly \\(d\\) digits (in base 10) contributing to our range \\([10^l,10^r)\\) are those with\n\\[\nd\\;=\\;l+1,\\;l+2,\\;\\dots,\\;r,\n\\]\nbecause \\(10^l\\) has exactly \\(l+1\\) digits, and we go up to but not including \\(10^r\\).  The count of \\(d\\)-digit numbers whose digits all lie in \\(\\{0,1,\\dots,c\\}\\) and whose first (most significant) digit is nonzero is\n\n\\[\n\\underbrace{c}_{\\text{choices for leading digit }1\\ldots c}\n\\;\\times\\;\n\\underbrace{(c+1)^{\\,d-1}}_{\\text{choices for the remaining }d-1\\text{ digits}}.\n\\]\n\nHence the total count is\n\\[\n\\sum_{d=l+1}^{\\,r}\nc\\,(c+1)^{\\,d-1}\n\\;=\\;\nc\\;\\sum_{d=l+1}^{r}(c+1)^{d-1}\n\\;=\\;\nc\\;\\sum_{j=l}^{r-1}(c+1)^j.\n\\]\nThis is a geometric series.  One finds a closed‐form\n\n\\[\n\\sum_{j=l}^{r-1}(c+1)^j\n\\;=\\;\n\\frac{(c+1)^l\\bigl((c+1)^{(r-l)}-1\\bigr)}{(c+1)-1}\n\\;=\\;\n\\frac{(c+1)^l\\bigl((c+1)^{r-l}-1\\bigr)}{c}.\n\\]\nMultiplying back by the factor of \\(c\\) up front gives the final simple formula\n\n\\[\n\\boxed{\n\\text{Answer}\n\\;=\\;\n(c+1)^l\\;\\bigl((c+1)^{\\,r-l}-1\\bigr)\\;\\bmod(10^9+7),\n}\n\\]\nwhere\n\\[\nc \\;=\\;\\left\\lfloor\\frac{9}{k}\\right\\rfloor,\n\\]\nand if \\(k\\ge10\\) then \\(c=0\\) so the answer is 0 automatically.\n\nAll we need is fast modular exponentiation to compute \\((c+1)^l\\) and \\((c+1)^{\\,r-l}\\bmod10^9+7\\).\n\n**Complexity.**\n- We have up to \\(10^4\\) test‐cases.\n- For each test we do two modular exponentiations with exponents up to \\(10^9\\); each exponentiation takes \\(O(\\log(\\text{exponent}))\\approx O(30)\\) multiplications.  \n- Total complexity is comfortably within the 2‐second limit.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int MOD = 1_000_000_007;\n\n    // fast exponentiation mod\n    static long modPow(long base, long exp) {\n        long result = 1 % MOD;\n        base %= MOD;\n        while (exp > 0) {\n            if ((exp & 1) == 1) {\n                result = (result * base) % MOD;\n            }\n            base = (base * base) % MOD;\n            exp >>= 1;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st;\n\n        int t = Integer.parseInt(br.readLine().trim());\n        StringBuilder sb = new StringBuilder();\n\n        for (int _case = 0; _case < t; _case++) {\n            st = new StringTokenizer(br.readLine());\n            long l = Long.parseLong(st.nextToken());\n            long r = Long.parseLong(st.nextToken());\n            long k = Long.parseLong(st.nextToken());\n\n            // Compute c = floor(9/k).  If k>=10 then c=0 => no valid numbers\n            long c = (k >= 10 ? 0 : 9 / k);\n\n            if (c == 0) {\n                sb.append(0).append('\\n');\n                continue;\n            }\n\n            // Let base = c+1\n            long base = c + 1;\n\n            // We want (c+1)^l * ((c+1)^(r-l) - 1) mod MOD\n            long part1 = modPow(base, l);       // (c+1)^l % MOD\n            long part2 = modPow(base, r - l);   // (c+1)^(r-l) % MOD\n\n            long ans = part1 * ((part2 - 1 + MOD) % MOD) % MOD;\n            sb.append(ans).append('\\n');\n        }\n\n        System.out.print(sb);\n    }\n}\n```\n\nExplanation of the key steps:\n\n1. **No‐carry criterion**  \n   We require each digit \\(d_i\\) of \\(n\\) to satisfy \\(k\\,d_i < 10\\).  Equivalently \\(d_i \\le \\lfloor9/k\\rfloor\\).  \n\n2. **Counting \\(d\\)-digit numbers**  \n   If each digit is in \\(\\{0,1,\\dots,c\\}\\) and the leading digit is nonzero (so in \\(\\{1,\\dots,c\\}\\)), there are  \n   \\[\n     c\\;\\times\\;(c+1)^{d-1}\n   \\]\n   such \\(d\\)-digit numbers.\n\n3. **Summation over lengths**  \n   We sum \\(d\\) from \\(l+1\\) up to \\(r\\).  This becomes a geometric series in \\((c+1)\\).\n\n4. **Closed‐form**  \n   The sum simplifies to\n   \\[\n     (c+1)^l\\,\\bigl((c+1)^{\\,r-l}-1\\bigr)\\pmod{10^9+7}.\n   \\]\n\n5. **Edge cases**  \n   - If \\(k\\ge10\\), then \\(c=0\\) and the answer is 0.\n   - We take all final answers modulo \\(10^9+7\\).\n\nThis runs in \\(O(t\\log(r))\\) which is efficient for \\(t\\le10^4\\) and \\(r\\) up to \\(10^9\\)."
  },
  {
    "role": "system",
    "content": "Identify any errors in this response and output a prompt to help the AI resolve said issues. Your response MUST be in one of two formats: 1. If the response looks perfect, return \"Perfect\". Do not return this if there are any issues. Use this very sparingly as any errors in the final output from the AI will be considered a failure on your part. 2. Otherwise, return \"{prompt}\" where {prompt} is replaced with your concise prompt. This should be done most often, even if the AI's response is mostly correct. Ensure the entire response is enclosed in double quotations if it's a prompt. Make sure your prompt asks the AI to return one block of code for submission."
  },
  {
    "role": "assistant",
    "content": "Perfect"
  }
]