[
    {
        "request_timestamp": "2025-07-23T18:36:35.342246",
        "response_timestamp": "2025-07-23T18:38:06.385873",
        "sent_messages": [
            {
                "role": "user",
                "content": "Codeforces Problem:\n\nE. Common Generator\n\ntime limit per test2 seconds\n\nmemory limit per test512 megabytes\n\nFor two integers x\n\n and y\n\n (x,y≥2\n\n), we will say that x\n\n is a generator of y\n\n if and only if x\n\n can be transformed to y\n\n by performing the following operation some number of times (possibly zero):\n\n\n\nChoose a divisor d\n\n (d≥2\n\n) of x\n\n, then increase x\n\n by d\n\n.\n\nFor example,\n\n\n\n3\n\n is a generator of 8\n\n since we can perform the following operations: 3−→−d=36−→−d=28\n\n;\n\n4\n\n is a generator of 10\n\n since we can perform the following operations: 4−→−d=48−→−d=210\n\n;\n\n5\n\n is not a generator of 6\n\n since we cannot transform 5\n\n into 6\n\n with the operation above.\n\nNow, Kevin gives you an array a\n\n consisting of n\n\n pairwise distinct integers (ai≥2\n\n).\n\n\n\nYou have to find an integer x≥2\n\n such that for each 1≤i≤n\n\n, x\n\n is a generator of ai\n\n, or determine that such an integer does not exist.\n\n\n\nInput\n\nEach test contains multiple test cases. The first line of the input contains a single integer t\n\n (1≤t≤104\n\n) — the number of test cases. The description of test cases follows.\n\n\n\nThe first line of each test case contains a single integer n\n\n (1≤n≤105\n\n) — the length of the array a\n\n.\n\n\n\nThe second line contains n\n\n integers a1,a2,…,an\n\n (2≤ai≤4⋅105\n\n) — the elements in the array a\n\n. It is guaranteed that the elements are pairwise distinct.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 105\n\n.\n\n\n\nOutput\n\nFor each test case, output a single integer x\n\n — the integer you found. Print −1\n\n if there does not exist a valid x\n\n.\n\n\n\nIf there are multiple answers, you may output any of them.\n\n\n\nExample\n\nInputCopy\n\n4\n\n3\n\n8 9 10\n\n4\n\n2 3 4 5\n\n2\n\n147 154\n\n5\n\n3 6 8 25 100000\n\nOutputCopy\n\n2\n\n-1\n\n7\n\n3\n\nNote\n\nIn the first test case, for x=2\n\n:\n\n\n\n2\n\n is a generator of 8\n\n, since we can perform the following operations: 2−→−d=24−→−d=48\n\n;\n\n2\n\n is a generator of 9\n\n, since we can perform the following operations: 2−→−d=24−→−d=26−→−d=39\n\n.\n\n2\n\n is a generator of 10\n\n, since we can perform the following operations: 2−→−d=24−→−d=26−→−d=28−→−d=210\n\n.\n\nIn the second test case, it can be proven that it is impossible to find a common generator of the four integers.\n\n---\n\nLet's think step-by-step so we don't make mistakes. Use Java. Avoid syntax errors or infinite loops."
            }
        ],
        "received_response": "{\n  \"id\": \"chatcmpl-BwcMpB7wV8hfYnx9SDoNavWML8ma6\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"**Analysis**\\n\\nWe are given \\\\(n\\\\) distinct integers\\n\\\\[\\na_1,a_2,\\\\dots,a_n\\\\;(\\\\ge2),\\n\\\\]\\nand we want to find an integer \\\\(x\\\\ge2\\\\) such that for every \\\\(i\\\\), starting from \\\\(x\\\\) we can reach \\\\(a_i\\\\) by repeatedly doing\\n\\n  – pick a divisor \\\\(d\\\\ge2\\\\) of the current value \\\\(v\\\\),\\n  – replace \\\\(v\\\\) by \\\\(v+d\\\\),\\n\\npossibly zero times.  We call such an \\\\(x\\\\) a “common generator” of all the \\\\(a_i\\\\).\\n\\nA direct approach of trying all \\\\(x\\\\) and doing a forward BFS up to each \\\\(a_i\\\\) would be too slow in the worst case.  The key observations are:\\n\\n 1.  If \\\\(x\\\\) can generate \\\\(y\\\\), then in the *reverse* direction \\\\(y\\\\) can step to \\\\(y-d\\\\) for every divisor \\\\(d\\\\ge2\\\\) of \\\\(y\\\\), provided \\\\(y-d\\\\ge2\\\\).  Thus for a fixed \\\\(y\\\\), its *backward*-reachable set (“predecessors”) are\\n    \\\\[\\n      \\\\{\\\\,y-d \\\\mid d\\\\mid y,\\\\ d\\\\ge2,\\\\ y-d\\\\ge2\\\\}.\\n    \\\\]\\n    Call that set \\\\(\\\\mathrm{Pre}(y)\\\\).  Iterating that gives all \\\\(x\\\\) that can generate \\\\(y\\\\).\\n\\n 2.  If we pick the minimum of the \\\\(a_i\\\\), call it \\\\(L\\\\), then any common generator \\\\(x\\\\) must lie in \\\\(\\\\mathrm{Pre}^*(L)\\\\), the full backward‐reachable set of \\\\(L\\\\).  (Otherwise \\\\(x\\\\) could not reach \\\\(L\\\\).)\\n\\nHence the plan:\\n\\n 1.  Precompute for every integer up to \\\\(4\\\\times10^5\\\\) its list of divisors \\\\(\\\\ge2\\\\).  This is \\\\(O(N\\\\log N)\\\\) once.\\n\\n 2.  For each test case:\\n    - Read \\\\(n\\\\) and the array \\\\(\\\\{a_i\\\\}\\\\).\\n    - Let \\\\(L=\\\\min_i a_i\\\\) and \\\\(M=\\\\max_i a_i\\\\).\\n    - Do a backward‐BFS from \\\\(L\\\\) (using the precomputed divisors) to collect\\n      \\\\[\\n        \\\\mathrm{cand}=\\\\{\\\\,x\\\\ge2\\\\mid x\\\\text{ can reach }L\\\\}.\\n      \\\\]\\n    - Sort \\\\(\\\\mathrm{cand}\\\\) in descending order.  We try the largest candidates first because a larger \\\\(x\\\\) typically has fewer forward‐reachables, so we either fail quickly or succeed.\\n    - For each candidate \\\\(x\\\\in\\\\mathrm{cand}\\\\):\\n      * Do a forward BFS from \\\\(x\\\\), only ever pushing \\\\(v+d\\\\le M\\\\) for divisors \\\\(d\\\\ge2\\\\) of \\\\(v\\\\).\\n      * Keep a hash/count of how many of the \\\\(a_i\\\\) we have visited.  If we manage to visit all \\\\(n\\\\) of them, we output that \\\\(x\\\\) and stop.\\n    - If none of the candidates works, print \\\\(-1\\\\).\\n\\nEach test case spends\\n  - \\\\(O(|\\\\mathrm{cand}|\\\\times\\\\) (cost of one forward BFS)\\\\() \\\\).\\nIn practice \\\\(|\\\\mathrm{cand}|\\\\) is small enough (the backward BFS from \\\\(L\\\\) does not explode), and the forward BFS for a wrong candidate usually fails quickly.\\n\\nOverall complexity is about\\n\\n  – \\\\(O(N\\\\log N)\\\\) to precompute divisors for \\\\(N=4\\\\cdot10^5\\\\),\\n  – plus \\\\(\\\\sum_{\\\\text{tests}} (\\\\text{back‐BFS}+\\\\sum_{\\\\text{cands}} \\\\text{forward‐BFS})\\\\),\\n\\nwhich runs comfortably in 2 s for the given limits.\\n\\n---\\n\\n```java\\nimport java.io.*;\\nimport java.util.*;\\n\\npublic class Main {\\n    static final int MAXA = 400_000;\\n    // divisors[v] will hold all d >= 2 that divide v\\n    static ArrayList<Integer>[] divisors = new ArrayList[MAXA+1];\\n\\n    public static void main(String[] args) throws IOException {\\n        // 1) Precompute divisors >= 2 for every number up to MAXA\\n        for (int i = 0; i <= MAXA; i++) {\\n            divisors[i] = new ArrayList<>();\\n        }\\n        for (int d = 2; d <= MAXA; d++) {\\n            for (int m = d; m <= MAXA; m += d) {\\n                divisors[m].add(d);\\n            }\\n        }\\n\\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n        PrintWriter out = new PrintWriter(System.out);\\n        int t = Integer.parseInt(br.readLine().trim());\\n\\n        // scratch arrays we will reuse\\n        boolean[] visPre = new boolean[MAXA+1];\\n        boolean[] visF   = new boolean[MAXA+1];\\n        boolean[] isTarget = new boolean[MAXA+1];\\n        boolean[] counted  = new boolean[MAXA+1];\\n\\n        while (t-- > 0) {\\n            int n = Integer.parseInt(br.readLine().trim());\\n            StringTokenizer st = new StringTokenizer(br.readLine());\\n            int[] a = new int[n];\\n            int L = MAXA, M = 2;\\n            for (int i = 0; i < n; i++) {\\n                a[i] = Integer.parseInt(st.nextToken());\\n                if (a[i] < L) L = a[i];\\n                if (a[i] > M) M = a[i];\\n                isTarget[a[i]] = true;  // mark which are our ai\\n            }\\n\\n            // 2) Backward-BFS from L to build the candidate set\\n            Queue<Integer> q = new ArrayDeque<>();\\n            ArrayList<Integer> preList = new ArrayList<>();\\n            q.add(L);\\n            visPre[L] = true;\\n            preList.add(L);\\n\\n            while (!q.isEmpty()) {\\n                int y = q.poll();\\n                for (int d : divisors[y]) {\\n                    int xCand = y - d;\\n                    if (xCand >= 2 && !visPre[xCand]) {\\n                        visPre[xCand] = true;\\n                        preList.add(xCand);\\n                        q.add(xCand);\\n                    }\\n                }\\n            }\\n\\n            // We have a backward-reachable set of L in preList\\n            // Clear visPre for the next test reuse\\n            for (int v : preList) {\\n                visPre[v] = false;\\n            }\\n\\n            // Sort candidates descending so that large x get tried first\\n            Collections.sort(preList, Collections.reverseOrder());\\n\\n            int answer = -1;\\n\\n            // We will need to quickly check how many of the a[i] we visit\\n            // in the forward BFS, so we use counted[] and reset it after each attempt\\n            ArrayList<Integer> countedList = new ArrayList<>();\\n\\n            outer:\\n            for (int x : preList) {\\n                // Forward BFS from x, we only push v+d <= M\\n                Queue<Integer> qf = new ArrayDeque<>();\\n                ArrayList<Integer> visList = new ArrayList<>();\\n                qf.add(x);\\n                visF[x] = true;\\n                visList.add(x);\\n\\n                int found = 0;\\n\\n                if (isTarget[x]) {\\n                    counted[x] = true;\\n                    countedList.add(x);\\n                    found++;\\n                }\\n\\n                while (!qf.isEmpty() && found < n) {\\n                    int u = qf.poll();\\n                    for (int d : divisors[u]) {\\n                        int v = u + d;\\n                        if (v <= M && !visF[v]) {\\n                            visF[v] = true;\\n                            visList.add(v);\\n                            if (isTarget[v] && !counted[v]) {\\n                                counted[v] = true;\\n                                countedList.add(v);\\n                                found++;\\n                                if (found == n) {\\n                                    answer = x;\\n                                    break;\\n                                }\\n                            }\\n                            qf.add(v);\\n                        }\\n                    }\\n                    if (answer != -1) break;\\n                }\\n\\n                // clear visF\\n                for (int v2 : visList) {\\n                    visF[v2] = false;\\n                }\\n                // clear counted\\n                for (int v2 : countedList) {\\n                    counted[v2] = false;\\n                }\\n                countedList.clear();\\n\\n                if (answer != -1) {\\n                    break outer;\\n                }\\n            }\\n\\n            out.println(answer);\\n\\n            // clear isTarget for next test\\n            for (int v : a) {\\n                isTarget[v] = false;\\n            }\\n        }\\n\\n        out.flush();\\n    }\\n}\\n```\\n\\n**Explanation of Key Steps**\\n\\n1. **Precomputation of divisors**  \\n   We build `divisors[v]` = list of all integers `d ≥ 2` that divide `v`, for every `v ≤ 400 000`.  \\n   This costs\\n   \\\\[\\n     \\\\sum_{d=2}^{N}\\\\frac{N}{d} \\\\;=\\\\; O(N\\\\log N),\\n   \\\\]\\n   which is fine once for all test cases.\\n\\n2. **Backward BFS from the minimum \\\\(L\\\\)**  \\n   Any common generator \\\\(x\\\\) *must* be able to generate \\\\(L\\\\).  By reversing the step\\n   \\\\[\\n     v\\\\;\\\\xrightarrow{\\\\,+d\\\\,}\\\\;v+d,\\n   \\\\]\\n   we see from a node \\\\(y\\\\) one can move to \\\\(y-d\\\\) for any divisor \\\\(d\\\\ge2\\\\) of \\\\(y\\\\), provided \\\\(y-d\\\\ge2\\\\).  \\n   A BFS from \\\\(L\\\\) downwards therefore finds exactly the set of all \\\\(x\\\\ge2\\\\) that can generate \\\\(L\\\\).  We call that our candidate list.\\n\\n3. **Trying candidates in descending order**  \\n   For each candidate \\\\(x\\\\) in decreasing order, we do one forward BFS (and stop as soon as we see *all* the \\\\(a_i\\\\) or exhaust possible values up to \\\\(\\\\max a_i\\\\)).  \\n   - We keep a boolean array `isTarget[v]` marking which `v` are in the input \\\\(\\\\{a_i\\\\}\\\\).  \\n   - During the BFS we also maintain `counted[v]` to avoid double‐counting the same \\\\ensuremath{a_i} if we revisit it by two paths.  \\n   - As soon as we discover all \\\\(n\\\\) targets, we print this \\\\(x\\\\) and break out.\\n\\n4. **Failure**  \\n   If no candidate succeeds, we print `-1`.\\n\\nBecause the backward‐BFS from \\\\(L\\\\) usually does not produce an enormous candidate set, and the forward‐BFS for wrong candidates typically fails early, this runs efficiently for \\\\(n\\\\) up to \\\\(10^5\\\\) and values up to \\\\(4\\\\cdot10^5\\\\).\",\n        \"refusal\": null,\n        \"role\": \"assistant\",\n        \"annotations\": [],\n        \"audio\": null,\n        \"function_call\": null,\n        \"tool_calls\": null\n      },\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"protected_material_code\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"protected_material_text\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ],\n  \"created\": 1753310207,\n  \"model\": \"o4-mini-2025-04-16\",\n  \"object\": \"chat.completion\",\n  \"service_tier\": null,\n  \"system_fingerprint\": null,\n  \"usage\": {\n    \"completion_tokens\": 11257,\n    \"prompt_tokens\": 688,\n    \"total_tokens\": 11945,\n    \"completion_tokens_details\": {\n      \"accepted_prediction_tokens\": 0,\n      \"audio_tokens\": 0,\n      \"reasoning_tokens\": 8896,\n      \"rejected_prediction_tokens\": 0\n    },\n    \"prompt_tokens_details\": {\n      \"audio_tokens\": 0,\n      \"cached_tokens\": 0\n    }\n  },\n  \"prompt_filter_results\": [\n    {\n      \"prompt_index\": 0,\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"jailbreak\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ]\n}"
    }
]