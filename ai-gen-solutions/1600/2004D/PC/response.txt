**Analysis**

We have \(n\) cities on a line (numbered \(1\) through \(n\)), each city equipped with exactly two different-colored portals chosen from \(\{\text{B},\text{G},\text{R},\text{Y}\}\).  A move is allowed between city \(i\) and city \(j\) if they share at least one portal color, at cost \(\lvert i-j\rvert\).  We must answer \(q\) queries, each asking for the minimum cost to move from city \(x\) to city \(y\) (or \(-1\) if impossible).

A direct graph approach would have potentially \(\mathcal O(n^2)\) edges (since within each color the cities form a clique), which is too large for \(n\) up to \(2\times10^5\).  Instead we exploit the fact that there are only 4 colors \(\{\text{B},\text{G},\text{R},\text{Y}\}\), hence only \(\binom{4}{2}=6\) distinct pairs of colors.  Each city belongs to exactly one of those 6 pairs. 

Let us label the colors by integers:
\[
\text{B}\mapsto 0,\quad
\text{G}\mapsto 1,\quad
\text{R}\mapsto 2,\quad
\text{Y}\mapsto 3.
\]
There are \(\{0,1\},\{0,2\},\{0,3\},\{1,2\},\{1,3\},\{2,3\}\) as the six possible unordered pairs.  We maintain, for each pair \(p\), a sorted list of all city‐indices whose portal‐pair is exactly \(p\).

To answer a query \((x,y)\):

1.  **Direct check.**  If cities \(x\) and \(y\) share a portal color, we can go straight at cost \(\lvert x-y\rvert\).

2.  **Two‐step via a city that “bridges” one color of \(x\) with one color of \(y\).**  
    - City \(x\) has two colors \(c_1,c_2\).  
    - City \(y\) has two colors \(d_1,d_2\).  
    - If we do not have a direct move, we try all four cross‐pairs \((c_i,d_j)\), \(i,j\in\{1,2\}\), with \(c_i\neq d_j\).  
    - For each such unordered color‐pair \(p=\{c_i,d_j\}\), let \(S_p\) be the sorted list of city‐indices of that pair.  
      We look for a position \(k\in S_p\) minimizing
      \[
         |x-k| + |k-y|.
      \]
      By sorting \(x\le y\), one shows that the minimum comes from one of at most three candidates:
      - any \(k\in S_p\cap [x,y]\), which gives cost \(y-x\), or
      - the largest \(k\le x\) in \(S_p\), giving cost \((x-k)+(y-k)=x+y-2k\), or
      - the smallest \(k\ge y\) in \(S_p\), giving cost \((k-x)+(k-y)=2k-x-y\).

   Each of these can be found by one binary‐search (lower bound) in the list \(S_p\).  Since there are at most 4 cross‐pairs we check, each query costs \(O(\log n)\).  With up to \(2\times 10^5\) queries total, this is efficient enough.

Overall preprocessing is \(O(n)\) per test to build and store the 6 lists of city‐indices, and each query is \(O(\log n)\).  Across all tests the sum of \(n\) and of \(q\) is at most \(2\times10^5\), so this passes easily in time.

---

```java
import java.io.*;
import java.util.*;

public class Main {
    static final int INF = 1_000_000_000;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out);

        // Map unordered color-pairs to IDs 0..5
        int[][] pairID = new int[4][4];
        for (int i = 0; i < 4; i++)
            Arrays.fill(pairID[i], -1);
        int id = 0;
        int[][] pairs = {{0,1},{0,2},{0,3},{1,2},{1,3},{2,3}};
        for (int i = 0; i < 6; i++) {
            int c1 = pairs[i][0], c2 = pairs[i][1];
            pairID[c1][c2] = pairID[c2][c1] = i;
        }

        // Read number of testcases
        int t = Integer.parseInt(br.readLine().trim());
        while (t-- > 0) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            int q = Integer.parseInt(st.nextToken());

            // For each of the 6 color-pairs, store a sorted list of city-indices
            List<Integer>[] pos = new ArrayList[6];
            for (int i = 0; i < 6; i++) {
                pos[i] = new ArrayList<>();
            }

            // Record each city's two colors
            int[] c1 = new int[n+1], c2 = new int[n+1];

            // Read the n portal-strings
            st = new StringTokenizer(br.readLine());
            for (int i = 1; i <= n; i++) {
                String s = st.nextToken();
                int colA = charToColor(s.charAt(0));
                int colB = charToColor(s.charAt(1));
                c1[i] = colA;
                c2[i] = colB;
                int pid = pairID[colA][colB];
                pos[pid].add(i);
            }

            // The lists are filled in increasing order of i, so they are already sorted.

            // Process queries
            while (q-- > 0) {
                st = new StringTokenizer(br.readLine());
                int x = Integer.parseInt(st.nextToken());
                int y = Integer.parseInt(st.nextToken());

                // Gather colors of x and y
                int ax = c1[x], bx = c2[x];
                int ay = c1[y], by = c2[y];

                int best = INF;

                // 1) Direct move if they share a color
                if (ax == ay || ax == by || bx == ay || bx == by) {
                    best = Math.abs(x - y);
                }

                // 2) Two-step via a city that bridges one color of x to one color of y
                // We will normalize so x <= y
                if (x > y) {
                    int tmp = x; x = y; y = tmp;
                    // swap the color pairs of x,y too
                    tmp = ax; ax = ay; ay = tmp;
                    tmp = bx; bx = by; by = tmp;
                }

                // Try all 4 cross-pairs (c in {ax,bx}, d in {ay,by}) with c!=d
                int[] xcols = {ax, bx};
                int[] ycols = {ay, by};

                for (int cx : xcols) {
                    for (int cy : ycols) {
                        if (cx == cy) continue;  // would be direct, already handled
                        int pid = pairID[cx][cy];
                        List<Integer> list = pos[pid];
                        if (list.isEmpty()) continue;

                        // lowerBound for x
                        int idx = lowerBound(list, x);
                        // 2a) If there's an element in [x, y], cost = y-x
                        if (idx < list.size() && list.get(idx) <= y) {
                            best = Math.min(best, y - x);
                        } else {
                            // 2b) Predecessor <= x
                            if (idx > 0) {
                                int k = list.get(idx - 1);
                                int cost = (x - k) + (y - k); // = x+y -2k
                                best = Math.min(best, cost);
                            }
                            // 2c) Successor >= y (if idx < size, and list.get(idx)>y or idx==size)
                            if (idx < list.size()) {
                                int k = list.get(idx);
                                int cost = (k - x) + (k - y); // = 2k - x - y
                                best = Math.min(best, cost);
                            }
                        }
                    }
                }

                out.println((best == INF) ? -1 : best);
            }
        }

        out.flush();
        out.close();
    }

    // Map portal letter to integer 0..3
    static int charToColor(char c) {
        switch (c) {
            case 'B': return 0;
            case 'G': return 1;
            case 'R': return 2;
            case 'Y': return 3;
        }
        return -1;
    }

    // Classic lower_bound in an ArrayList<Integer>
    static int lowerBound(List<Integer> list, int key) {
        int lo = 0, hi = list.size();
        while (lo < hi) {
            int mid = (lo + hi) >>> 1;
            if (list.get(mid) < key) {
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }
        return lo;
    }
}
```

**Explanation of Key Steps**

1. **Color‐Pair Indexing**  
   We only have 4 colors, so there are \(\binom{4}{2}=6\) distinct unordered pairs.  We assign each pair an ID from 0 to 5, and for each city we parse its two‐letter code (e.g.\ “BG”) into the corresponding pair‐ID.  

2. **Building Position Lists**  
   For pair‐ID \(p\), we keep a sorted list of all city‐indices \(i\) whose portals form exactly that pair.  Since we read in increasing \(i\), the list is automatically sorted.

3. **Answering a Query**  
   - **Direct move**: If city \(x\) and city \(y\) share a color, cost is \(\lvert x-y\rvert\).  
   - **Two‐step bridge**: Otherwise, pick one color \(c\in\{\text{colors of }x\}\) and one \(d\in\{\text{colors of }y\}\) with \(c\neq d\).  Look up the list \(S\) of cities whose pair is \(\{c,d\}\).  We want
     \[
        \min_{k\in S}\bigl(|x-k| + |k-y|\bigr).
     \]
     If \(x\le y\), one shows the minimum occurs either at
     - some \(k\in [x,y]\) (giving cost \(y-x\)),
     - the largest \(k\le x\) in \(S\), or
     - the smallest \(k\ge y\) in \(S\).
     We locate those by a single binary‐search (lowerBound) each time.

Overall each query does a constant (\(\le4\)) number of binary searches on lists of total length \(n\).  Thus the solution runs in \(O((n + q)\log n)\) time, which is efficient for \(n,q\) up to \(2\times10^5\).