[
  {
    "role": "user",
    "content": "A. Cards Partition\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nDJ Genki vs Gram - Einherjar Joker\n\n⠀\n\nYou have some cards. An integer between 1\n\n and n\n\n is written on each card: specifically, for each i\n\n from 1\n\n to n\n\n, you have ai\n\n cards which have the number i\n\n written on them.\n\n\n\nThere is also a shop which contains unlimited cards of each type. You have k\n\n coins, so you can buy at most k\n\n new cards in total, and the cards you buy can contain any integer between 1\n\n and n\n\n, inclusive.\n\n\n\nAfter buying the new cards, you must partition all your cards into decks, according to the following rules:\n\n\n\nall the decks must have the same size;\n\nthere are no pairs of cards with the same value in the same deck.\n\nFind the maximum possible size of a deck after buying cards and partitioning them optimally.\n\n\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n\n (1≤t≤104\n\n). The description of the test cases follows.\n\n\n\nThe first line of each test case contains two integers n\n\n, k\n\n (1≤n≤2⋅105\n\n, 0≤k≤1016\n\n) — the number of distinct types of cards and the number of coins.\n\n\n\nThe second line of each test case contains n\n\n integers a1,a2,…,an\n\n (0≤ai≤1010\n\n, ∑ai≥1\n\n) — the number of cards of type i\n\n you have at the beginning, for each 1≤i≤n\n\n.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output a single integer: the maximum possible size of a deck if you operate optimally.\n\n\n\nExample\n\nInputCopy\n\n9\n\n3 1\n\n3 2 2\n\n5 4\n\n2 6 1 2 4\n\n2 100\n\n1410065408 10000000000\n\n10 8\n\n7 4 6 6 9 3 10 2 8 7\n\n2 12\n\n2 2\n\n2 70\n\n0 1\n\n1 0\n\n1\n\n3 0\n\n2 1 2\n\n3 1\n\n0 3 3\n\nOutputCopy\n\n2\n\n3\n\n1\n\n7\n\n2\n\n2\n\n1\n\n1\n\n2\n\nNote\n\nIn the first test case, you can buy one card with the number 1\n\n, and your cards become [1,1,1,1,2,2,3,3]\n\n. You can partition them into the decks [1,2],[1,2],[1,3],[1,3]\n\n: they all have size 2\n\n, and they all contain distinct values. You can show that you cannot get a partition with decks of size greater than 2\n\n, so the answer is 2\n\n.\n\n\n\nIn the second test case, you can buy two cards with the number 1\n\n and one card with the number 3\n\n, and your cards become [1,1,1,1,2,2,2,2,2,2,3,3,4,4,5,5,5,5]\n\n, which can be partitioned into [1,2,3],[1,2,4],[1,2,5],[1,2,5],[2,3,5],[2,4,5]\n\n. You can show that you cannot get a partition with decks of size greater than 3\n\n, so the answer is 3\n\n.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have n card‐types (labels 1…n), and initially we own aᵢ copies of label i.  We are allowed to “buy” up to k additional cards; each card we buy can be any label 1…n.  After our buys, we must partition **all** our cards into decks so that\n\n 1. Every deck has the **same** size s.\n 2. Within each deck, all labels are **distinct**.\n\nWe want to choose our buys (how many of each label to purchase, up to a total of k) so as to make the resulting maximum possible deck‐size s.\n\n---\n\nLet\n\n A = ∑_{i=1}^n aᵢ   (initial total cards),\n M = max_{i}(aᵢ)    (the largest initial count of any single label).\n\nAny feasible deck‐size s must satisfy:\n\n  • You cannot “throw away” cards.  If you decide to make t decks of size s, you will have exactly m = s·t cards in total, so you must use exactly m cards.  You start with A cards and can buy up to k more, so\n\n     A  ≤  m  =  s·t  ≤  A + k.  \n\n  • Because in each deck every label is distinct, each label i can appear at most once per deck.  So if you form t decks, you can accommodate at most t copies of any given label.  But you must use your **all** of your original aᵢ copies as well (you cannot discard them), hence\n\n     t  ≥  max_i aᵢ  =  M.  \n\nSummarizing, (s, t) is feasible exactly if\n\n  (1)  A   ≤  s·t  ≤  A + k,\n  (2)  t  ≥  M,\n\nand s·t, t are integers of course.\n\nThus for a given s, we only need to check whether there is an integer t in the interval\n\n   [ max(M, ⌈A/s⌉),  ⌊(A+k)/s⌋  ].\n\nIf that interval is non‐empty, we can pick t in it, buy exactly s·t–A new cards (≤k), and then t ≥ M guarantees we can place the original aᵢ cards (no label has more than t copies).\n\nWe want the **maximum** s with that property.  We also clearly need s ≤ n (because a deck of size s must consist of s distinct labels among n possible).  \n\nSince ∑n over all test‐cases ≤2·10^5, we can for each test simply:\n\n 1. Compute A =∑aᵢ and M = max aᵢ in O(n).\n 2. Let S_max_candidate = min(n, ⌊(A+k)/M⌋).  (Clearly if s>⌊(A+k)/M⌋ then even with t=M we have s·M > A+k, so impossible.)\n 3. For s = 1…S_max_candidate, check\n\n       L = ⌊(A+k)/s⌋,    R = max( M,  ⌈A/s⌉ ),\n\n     if L ≥ R then s is feasible.  Take the largest feasible s.\n\nOverall cost is O(n) per test, and ∑n≤2·10^5 is fine in 2s.  \n\n---\n\n**Implementation in Java**\n\n```java\nimport java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st;\n        \n        int t = Integer.parseInt(in.readLine().trim());\n        StringBuilder sb = new StringBuilder();\n        while (t-- > 0) {\n            st = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            long k = Long.parseLong(st.nextToken());\n            \n            long A = 0;      // sum of a_i\n            long M = 0;      // max of a_i\n            st = new StringTokenizer(in.readLine());\n            for (int i = 0; i < n; i++) {\n                long ai = Long.parseLong(st.nextToken());\n                A += ai;\n                if (ai > M) {\n                    M = ai;\n                }\n            }\n            \n            // Upper bound on s: s*M <= A+k  =>  s <= (A+k)/M\n            long maxByM = (A + k) / M;\n            int upper = (int)Math.min(n, maxByM);\n            \n            int answer = 0;\n            // Try every s from 1..upper\n            for (int s = 1; s <= upper; s++) {\n                // L = floor((A+k)/s)\n                long L = (A + k) / s;\n                // ceil(A/s) = (A + s - 1) / s\n                long needT = (A + s - 1) / s;\n                // R = max(M, ceil(A/s))\n                long R = Math.max(M, needT);\n                \n                if (L >= R) {\n                    answer = s;\n                }\n            }\n            \n            sb.append(answer).append('\\n');\n        }\n        \n        System.out.print(sb);\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Bounds on the number of decks t**  \n   - We must have enough “slots” to place all original cards: if we build t decks of size s, total slots is s·t.  We own A cards and can buy up to k more, so  \n       A ≤ s·t ≤ A+k.  \n     This forces  \n       ⌈A/s⌉ ≤ t ≤ ⌊(A+k)/s⌋.  \n   - We cannot place more than one copy of the same label in a deck, so a label that originally had `aᵢ` copies (and we cannot discard them) requires at least `aᵢ` different decks.  Hence  \n       t ≥ max_i aᵢ = M.  \n\n2. **Putting it together**  \n   We require an integer t in the intersection  \n       [⌈A/s⌉, ⌊(A+k)/s⌋]  ∩  [M, ∞).  \n   Equivalently  \n       max(M, ⌈A/s⌉)  ≤  ⌊(A+k)/s⌋.  \n\n3. **Searching for maximum s**  \n   - Clearly s cannot exceed n (n distinct labels per deck) or exceed `(A+k)/M` (otherwise even with only M decks you cannot fit all cards into s·M slots).  \n   - We loop s=1…min(n,⌊(A+k)/M⌋), compute  \n       L = ⌊(A+k)/s⌋,   R₁=⌈A/s⌉,  R = max(M,R₁),  \n     and check L≥R.  If so, `s` is feasible, we remember the largest feasible.\n\nBecause ∑n≤2·10^5 over all test‐cases, the total cost of O(n) per case is O(2·10^5) and runs easily within the 2 s limit."
  },
  {
    "role": "system",
    "content": "Identify any errors in this response and output a prompt to help the AI resolve said issues. Your response MUST be in one of two formats: 1. If the response looks perfect, return \"Perfect\". Do not return this if there are any issues. Use this very sparingly as any errors in the final output from the AI will be considered a failure on your part. 2. Otherwise, return \"{prompt}\" where {prompt} is replaced with your concise prompt. This should be done most often, even if the AI's response is mostly correct. Ensure the entire response is enclosed in double quotations if it's a prompt. Make sure your prompt asks the AI to return one block of code for submission."
  },
  {
    "role": "assistant",
    "content": "Perfect"
  }
]