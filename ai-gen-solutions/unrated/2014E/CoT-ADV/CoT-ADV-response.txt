**Problem Restatement**

We have an undirected weighted graph with \(n\) vertices and \(m\) edges.  Marian starts at vertex 1, Robin at vertex \(n\).  Some vertices each have exactly one horse.  Travelling along an edge of weight \(w\) takes \(w\) seconds on foot, or \(w/2\) seconds if you are already riding a horse (all \(w\) are even, so \(w/2\) is integral).  Mounting a horse is instantaneous, and once you mount you keep riding it until you meet (you cannot dismount).  A horse is a one‐time resource: only one of the two can use any particular horse.  Meeting must occur at a vertex (they may wait arbitrarily on vertices).  

We want the earliest time \(T\) such that both can arrive (possibly waiting) at the same vertex at time \(T\).  If they can never meet, print \(-1\).

---

**Input**

- \(t\) — number of test cases \((1\le t\le10^4)\).  
- For each test case:
  - \(n,m,h\) \((2\le n\le2\cdot10^5,\;1\le m\le2\cdot10^5,\;1\le h\le n)\).  
  - A list of \(h\) distinct vertices that each have one horse.
  - \(m\) undirected edges \((u_i,v_i,w_i)\) \((2\le w_i\le10^6\), even).
  
The sum of all \(n\) and all \(m\) over all test cases does not exceed \(2\cdot10^5\).

---

**Output**

For each test case, output the minimal meeting time, or \(-1\) if meeting is impossible.

---

**Constraints & Edge Cases**

- Graph may be disconnected; if 1 and \(n\) live in distinct components, answer is \(-1\).
- Either may choose not to use any horse.
- At most one uses each horse; we cannot let both riders use the same horse.
- We have only two riders—but \(h\) can be large—so we must avoid per‐horse \(\mathrm{Dijkstra}\).
- We will consider four scenarios:
  1. Neither uses a horse.
  2. Only Marian uses a horse.
  3. Only Robin uses a horse.
  4. Both use horses, but they must be distinct horses.

---

**Algorithmic Pattern**

We use variants of Dijkstra's algorithm:

1. **Standard Dijkstra** from Marian's start (vertex 1), yielding `distM[v]`: min time on foot to \(v\).
2. **Standard Dijkstra** from Robin's start (vertex n), yielding `distR[v]`.
3. **Multi‐label (2-best) Dijkstra** on the *half-weight* graph with all horses as sources, to find for each vertex the best two distinct “(horseID → vertex)” arrival times:
   - For Marian: we initialize each horse vertex \(a_j\) with distance = `distM[a_j]`.  Then we run Dijkstra on edges of weight \(\tfrac{w}{2}\), but each propagated label carries which horse it came from.  At each node we keep only the two best distances from two different horses.  This yields up to two best “Marian-using-horse” times at each vertex.
   - Similarly for Robin, using `distR[a_j]` as initial labels.

At the end:

- **Case 1 (no horses)**: \(\min_v\max(\,distM[v],distR[v]\,)\).
- **Case 2 (only Marian uses)**: \(\min_v\max(\,bestHorseM[v],distR[v]\,)\).
- **Case 3 (only Robin uses)**: \(\min_v\max(\,distM[v],bestHorseR[v]\,)\).
- **Case 4 (both use distinct horses)**: for each \(v\), we have up to two best horse‐labels for Marian \((m_1,m_2)\) and Robin \((r_1,r_2)\).  If \(m_1\)'s horse ID \(\neq r_1\)'s horse ID, we take \(\max(m_1,r_1)\).  Otherwise we try pairing \((m_2,r_1)\) or \((m_1,r_2)\) if defined, taking the best feasible \(\max\).

We take the minimum over all four cases.  If it remains “infinity,” we print \(-1\).

---

**Time Complexity**

- Two ordinary Dijkstras: \(O(m\log n)\) each.
- Two multi‐label Dijkstras that keep up to 2 labels per node and relax each edge at most twice: \(O(m\log n)\) each.
- A final \(O(n)\) scan to combine cases.

Overall \(O(m\log n)\) per test, summing to \(O((\sum m)\log(\sum n))\approx O(2\times10^5\log2\times10^5)\), which fits in 5 s in Java.

---

**Java Implementation**

```java
import java.io.*;
import java.util.*;

public class Main {
    static final long INF = Long.MAX_VALUE / 4;
    
    static class Edge {
        int to;
        int w;
        Edge(int _t, int _w) { to = _t; w = _w; }
    }
    
    static class State {
        int node;
        long dist;
        int horseId;
        State(int _n, long _d, int _h) {
            node = _n; dist = _d; horseId = _h;
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        
        int t = Integer.parseInt(br.readLine());
        StringBuilder sb = new StringBuilder();
        
        while (t-- > 0) {
            st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            int m = Integer.parseInt(st.nextToken());
            int h = Integer.parseInt(st.nextToken());
            
            // Read horse locations
            st = new StringTokenizer(br.readLine());
            int[] horseAt = new int[h];
            for (int i = 0; i < h; i++) {
                horseAt[i] = Integer.parseInt(st.nextToken());
            }
            
            // Build graph
            List<Edge>[] adj = new ArrayList[n+1];
            for (int i = 1; i <= n; i++) adj[i] = new ArrayList<>();
            for (int i = 0; i < m; i++) {
                st = new StringTokenizer(br.readLine());
                int u = Integer.parseInt(st.nextToken());
                int v = Integer.parseInt(st.nextToken());
                int w = Integer.parseInt(st.nextToken());
                adj[u].add(new Edge(v, w));
                adj[v].add(new Edge(u, w));
            }
            
            // 1) Dijkstra on foot from Marian (1)
            long[] distM = new long[n+1];
            dijkstra(1, distM, adj, n);
            // 2) Dijkstra on foot from Robin (n)
            long[] distR = new long[n+1];
            dijkstra(n, distR, adj, n);
            
            // Prepare 2-label arrays for horses:
            // bestHorseM[v][0..1], horseIdM[v][..], same for Robin.
            long[][] bestHM = new long[n+1][2];
            int[][]  idHM   = new int[n+1][2];
            long[][] bestHR = new long[n+1][2];
            int[][]  idHR   = new int[n+1][2];
            for (int i = 1; i <= n; i++) {
                bestHM[i][0] = bestHM[i][1] = INF;
                idHM[i][0] = idHM[i][1] = -1;
                bestHR[i][0] = bestHR[i][1] = INF;
                idHR[i][0] = idHR[i][1] = -1;
            }
            
            // 3) Multi‐label Dijkstra for Marian using horses
            multiLabelDijkstra(distM, horseAt, adj, bestHM, idHM);
            // 4) Multi‐label Dijkstra for Robin using horses
            multiLabelDijkstra(distR, horseAt, adj, bestHR, idHR);
            
            // Now combine the four cases:
            long answer = INF;
            
            // Case 1: no horses
            for (int v = 1; v <= n; v++) {
                if (distM[v] < INF && distR[v] < INF) {
                    long time = Math.max(distM[v], distR[v]);
                    if (time < answer) answer = time;
                }
            }
            
            // Case 2: only Marian uses
            for (int v = 1; v <= n; v++) {
                if (bestHM[v][0] < INF && distR[v] < INF) {
                    long time = Math.max(bestHM[v][0], distR[v]);
                    if (time < answer) answer = time;
                }
            }
            
            // Case 3: only Robin uses
            for (int v = 1; v <= n; v++) {
                if (bestHR[v][0] < INF && distM[v] < INF) {
                    long time = Math.max(distM[v], bestHR[v][0]);
                    if (time < answer) answer = time;
                }
            }
            
            // Case 4: both use distinct horses
            for (int v = 1; v <= n; v++) {
                long m1 = bestHM[v][0], m2 = bestHM[v][1];
                long r1 = bestHR[v][0], r2 = bestHR[v][1];
                int jm1 = idHM[v][0], jm2 = idHM[v][1];
                int jr1 = idHR[v][0], jr2 = idHR[v][1];
                
                if (m1 == INF || r1 == INF) continue;
                long best = INF;
                // If top horses differ, take them
                if (jm1 != jr1) {
                    best = Math.max(m1, r1);
                } else {
                    // try (m2, r1) or (m1, r2)
                    if (jm2 >= 0) {
                        best = Math.min(best, Math.max(m2, r1));
                    }
                    if (jr2 >= 0) {
                        best = Math.min(best, Math.max(m1, r2));
                    }
                }
                if (best < answer) answer = best;
            }
            
            sb.append(answer >= INF/2 ? -1 : answer).append('\n');
        }
        
        System.out.print(sb.toString());
    }
    
    /** Standard Dijkstra from source s, on foot (full edge weights). */
    static void dijkstra(int s, long[] dist, List<Edge>[] adj, int n) {
        Arrays.fill(dist, INF);
        PriorityQueue<long[]> pq = new PriorityQueue<>(Comparator.comparingLong(a -> a[0]));
        dist[s] = 0;
        pq.add(new long[]{0, s});
        
        while (!pq.isEmpty()) {
            long[] cur = pq.poll();
            long cd = cur[0];
            int u = (int)cur[1];
            if (cd > dist[u]) continue;
            for (Edge e: adj[u]) {
                int v = e.to;
                long nd = cd + e.w;
                if (nd < dist[v]) {
                    dist[v] = nd;
                    pq.add(new long[]{nd, v});
                }
            }
        }
    }
    
    /**
     * Multi‐label Dijkstra for up to two best horse‐based arrivals at each node.
     * distSrc[v] is time on foot to v.  horseAt[j] is vertex of horse j.
     * We run Dijkstra in the half‐weight graph, seeded with (horseAt[j], distSrc[horseAt[j]]).
     * We keep at each node only the two best (horseId, dist) pairs.
     */
    static void multiLabelDijkstra(
            long[] distSrc,
            int[] horseAt,
            List<Edge>[] adj,
            long[][] bestD,
            int[][] bestId)
    {
        int n = distSrc.length - 1;
        // Min‐heap by distance
        PriorityQueue<State> pq = new PriorityQueue<>(Comparator.comparingLong(a -> a.dist));
        
        // Seed with all reachable horses
        for (int j = 0; j < horseAt.length; j++) {
            int node = horseAt[j];
            long d0 = distSrc[node];
            if (d0 < INF) {
                pq.add(new State(node, d0, j));
            }
        }
        
        while (!pq.isEmpty()) {
            State st = pq.poll();
            int u = st.node;
            long cd = st.dist;
            int hid = st.horseId;
            
            // Try to insert this label into bestD[u]/bestId[u]
            // If it's not among the top two distinct, skip
            boolean inserted = false;
            // 1) If this horse is already present and we found a better dist, update it
            for (int k = 0; k < 2; k++) {
                if (bestId[u][k] == hid) {
                    if (cd < bestD[u][k]) {
                        bestD[u][k] = cd;
                        // we'll re‐sort below
                        inserted = true;
                    }
                    break;
                }
            }
            if (!inserted) {
                // If there's room for a new second entry
                if (bestId[u][0] < 0) {
                    bestId[u][0] = hid;
                    bestD[u][0] = cd;
                    inserted = true;
                } else if (bestId[u][1] < 0) {
                    bestId[u][1] = hid;
                    bestD[u][1] = cd;
                    inserted = true;
                } else {
                    // If we have two, see if we can replace the worse
                    // Only if new dist is strictly smaller
                    int worseIdx = bestD[u][0] > bestD[u][1] ? 0 : 1;
                    if (cd < bestD[u][worseIdx]) {
                        bestD[u][worseIdx] = cd;
                        bestId[u][worseIdx] = hid;
                        inserted = true;
                    }
                }
            }
            if (!inserted) {
                // This label is not among the best two for u
                continue;
            }
            // Re‐sort the two entries so that [0] is best
            if (bestId[u][1] >= 0 && bestD[u][1] < bestD[u][0]) {
                long tmpd = bestD[u][0]; bestD[u][0] = bestD[u][1]; bestD[u][1] = tmpd;
                int tmpi = bestId[u][0]; bestId[u][0] = bestId[u][1]; bestId[u][1] = tmpi;
            }
            
            // Relax edges in the half‐weight graph
            for (Edge e: adj[u]) {
                int v = e.to;
                long nd = cd + (e.w >> 1); // w/2
                pq.add(new State(v, nd, hid));
            }
        }
    }
}
```

**Explanation of Key Steps**

1. **`dijkstra(s, dist, adj, n)`** computes the shortest “on‐foot” distance `dist[v]` from source `s` to all `v` in \(O(m\log n)\).
2. **Multi‐label Dijkstra**  
   We want the two best arrival times at each node \(v\), of the form  
     \[
       \min_{j}\bigl(\,\text{distSrc}[a_j]\;+\;\mathrm{(half\mbox{-}graph\,dist\,from}\;a_j\mbox{ to }v)\bigr)
     \]  
   but ensuring we also know the *horse ID* that gave each of those two best times, so we can enforce that Marian and Robin don’t pick the same horse.  
   - We initialize the priority queue with `(horse_vertex, distSrc[horse_vertex], horseID)`.  
   - We run a standard Dijkstra in the half‐weight graph (`w/2`), carrying along the origin `horseID`.  
   - At each node we keep only the top two distinct `(horseID, dist)` pairs, so each edge is relaxed at most twice per node.  

3. **Combining Cases**  
   - **No horses**: meet time = \(\min_v \max(distM[v],distR[v])\).  
   - **Only Marian uses**: \(\min_v \max(bestHorseM[v], distR[v])\).  
   - **Only Robin uses**: \(\min_v \max(distM[v], bestHorseR[v])\).  
   - **Both use**: for each node \(v\), take Marian’s best pair \((m_1,j_m)\) and Robin’s best \((r_1,j_r)\).  If \(j_m\ne j_r\), they can use them together.  Otherwise try the second‐best of one and the best of the other, etc.

If all four options stay infinite, we output \(-1\).

---

**Complexity**

- Building the graph and reading input: \(O(n + m)\).
- Two standard Dijkstras: \(O(m\log n)\).
- Two multi‐label Dijkstras, each \(O(m\log n)\) (each edge can be relaxed twice, one for each label).
- Final scan over \(n\) vertices: \(O(n)\).

Overall \(O(m\log n)\) per test, summing to about \(O((\sum m)\log(\sum n))\approx O(2\times10^5\times18)\) in the worst case, which runs well under the 5-second limit in Java.