[
    {
        "request_timestamp": "2025-07-23T18:31:23.943485",
        "response_timestamp": "2025-07-23T18:32:50.113985",
        "sent_messages": [
            {
                "role": "user",
                "content": "Codeforces Problem:\n\nC. Perform Operations to Maximize Score\n\ntime limit per test3 seconds\n\nmemory limit per test256 megabytes\n\nI see satyam343. I'm shaking. Please more median problems this time. I love those. Please satyam343 we believe in you.\n\n— satyam343's biggest fan\n\nYou are given an array a\n\n of length n\n\n and an integer k\n\n. You are also given a binary array b\n\n of length n\n\n.\n\n\n\nYou can perform the following operation at most k\n\n times:\n\n\n\nSelect an index i\n\n (1≤i≤n\n\n) such that bi=1\n\n. Set ai=ai+1\n\n (i.e., increase ai\n\n by 1\n\n).\n\nYour score is defined to be maxi=1n(ai+median(ci))\n\n, where ci\n\n denotes the array of length n−1\n\n that you get by deleting ai\n\n from a\n\n. In other words, your score is the maximum value of ai+median(ci)\n\n over all i\n\n from 1\n\n to n\n\n.\n\n\n\nFind the maximum score that you can achieve if you perform the operations optimally.\n\n\n\nFor an arbitrary array p\n\n, median(p)\n\n is defined as the ⌊|p|+12⌋\n\n-th smallest element of p\n\n. For example, median([3,2,1,3])=2\n\n and median([6,2,4,5,1])=4\n\n.\n\n\n\nInput\n\nThe first line contains an integer t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nEach test case begins with two integers n\n\n and k\n\n (2≤n≤2⋅105\n\n, 0≤k≤109\n\n) — the length of the a\n\n and the number of operations you can perform.\n\n\n\nThe following line contains n\n\n space separated integers a1,a2,…,an\n\n (1≤ai≤109\n\n) — denoting the array a\n\n.\n\n\n\nThe following line contains n\n\n space separated integers b1,b2,…,bn\n\n (bi\n\n is 0\n\n or 1\n\n) — denoting the array b\n\n.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output the maximum value of score you can get on a new line.\n\n\n\nExample\n\nInputCopy\n\n8\n\n2 10\n\n3 3\n\n1 1\n\n3 10\n\n3 3 3\n\n0 0 0\n\n4 4\n\n2 1 5 1\n\n0 1 0 1\n\n5 4\n\n7 5 2 5 4\n\n0 0 1 0 1\n\n5 1\n\n5 15 15 2 11\n\n1 0 0 1 1\n\n5 2\n\n10 11 4 10 15\n\n1 1 0 1 0\n\n4 4\n\n1 1 2 5\n\n1 1 0 0\n\n2 1000000000\n\n1000000000 1000000000\n\n1 1\n\nOutputCopy\n\n16\n\n6\n\n8\n\n13\n\n21\n\n26\n\n8\n\n3000000000\n\nNote\n\nFor the first test case, it is optimal to perform 5\n\n operations on both elements so a=[8,8]\n\n. So, the maximum score we can achieve is max(8+median[8],8+median[8])=16\n\n, as c1=[a2]=[8]\n\n. It can be proven that you cannot get a better score.\n\n\n\nFor the second test case, you are not able to perform operations on any elements, so a\n\n remains [3,3,3]\n\n. So, the maximum score we can achieve is 3+median[3,3]=6\n\n, as c1=[a2,a3]=[3,3]\n\n. It can be proven that you cannot get a better score.\n\n---\n\nLet's think step-by-step so we don't make mistakes. Use Java. Avoid syntax errors or infinite loops."
            }
        ],
        "received_response": "{\n  \"id\": \"chatcmpl-BwcHgXdLy6YloKDgNjqiyDhfSkfoQ\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"Below is a Java solution in O((n + m) log R) per test, where n is the size of the array and R is the answer‐range (up to ~10^18 in the worst case).  We binary‐search the final score X, and for each X we check in O(n log n) (dominated by one sort and one prefix‐sum scan) whether it is possible to spend at most k increments to reach a configuration with a[i] + median(c_i) ≥ X for some i.\\n\\nKey steps of the check(X) routine:\\n\\n1. Let s = ⌊n/2⌋.  We will try to make median(c_i) ≥ T for each candidate i, where T = X − a[i] − d, and d is how much we “over‐boost” a[i] (d ≤ k, and only if b[i]==1).\\n\\n2.  Equivalently, for each possible “median threshold” M we can ask: can we choose one index i and a distribution of increments so that\\n     •  median(c_i) ≥ M, and\\n     •  a[i] + increments_on_i ≥ X−M,\\n     •  total increments ≤ k ?\\n\\n   We invert the loops by first guessing M, then computing for every i the minimum “rest‐cost” to bring median(c_i) up to M, and then seeing whether with that rest‐cost we have enough leftover (≤k) to bump a[i] to X−M.\\n\\n3.  It turns out you only need to try O(log R) values of X by binary‐search, and for each X you only need to do one global sort of the “cost to bring each b[j]==1, a[j]<M up to M” array (call that C[]), build its prefix sums, and then in one O(n) scan over i compute what would be its rest‐cost, and whether with the leftover you can push a[i] up to X−M.\\n\\nOverall complexity per test is O(n log n + log R · n), which easily passes for n up to 2·10^5 and t up to 10^4 (sum n ≤ 2·10^5).\\n\\nHere is the Java code.  I have tried to keep it as close as possible to “contest style” and to avoid corner‐case errors.  Please test carefully on your own local cases before submitting.\\n\\n```java\\nimport java.io.*;\\nimport java.util.*;\\n\\npublic class Main {\\n    static BufferedReader in;\\n    static StringTokenizer tok;\\n\\n    static String nextToken() throws IOException {\\n        while (tok == null || !tok.hasMoreTokens()) {\\n            String line = in.readLine();\\n            if (line == null) return null;\\n            tok = new StringTokenizer(line);\\n        }\\n        return tok.nextToken();\\n    }\\n    static int nextInt() throws IOException {\\n        return Integer.parseInt(nextToken());\\n    }\\n    static long nextLong() throws IOException {\\n        return Long.parseLong(nextToken());\\n    }\\n\\n    public static void main(String[] args) throws IOException {\\n        in = new BufferedReader(new InputStreamReader(System.in));\\n        tok = null;\\n        PrintWriter out = new PrintWriter(System.out);\\n\\n        int t = nextInt();\\n        while (t-- > 0) {\\n            int n = nextInt();\\n            long K = nextLong();\\n            long[] a = new long[n];\\n            for (int i = 0; i < n; i++) a[i] = nextLong();\\n            int[] b = new int[n];\\n            for (int i = 0; i < n; i++) b[i] = nextInt();\\n\\n            // Binary search on answer X\\n            // Possible X lies in [0 .. max(a)+K + max(a)+K].\\n            long left = 0, right = (long)2e9 + K + (long)2e9 + 5; \\n            // we do a standard \\\"first X that is NOT achievable\\\" search\\n            while (left < right) {\\n                long mid = (left + right + 1) >>> 1;\\n                if (canAchieve(mid, n, K, a, b)) {\\n                    left = mid;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            }\\n\\n            out.println(left);\\n        }\\n\\n        out.flush();\\n    }\\n\\n    /**\\n     * Check whether it is possible to achieve a score >= X\\n     * by spending at most K increments.\\n     */\\n    static boolean canAchieve(long X, int n, long K, long[] a, int[] b) {\\n        // s = floor(n/2)\\n        int s = n >>> 1;\\n\\n        // We will pick a candidate median value M, which must\\n        // satisfy M <= X - a[i] for some i, so M in [0 .. X].\\n        // But we avoid an inner loop over M; instead we note\\n        // that the best M for each X is actually X - max(a[i]+possibleIncOnI).\\n        // So we try M = X - a[i] for each i, but we only need\\n        // the overall maximum leftover from one global sort + scan.\\n\\n        // Build a list of (cost to bring each j with b[j]==1, a[j]<M\\n        // up to M), for all M we will consider.  But we don't know M\\n        // in advance---we only know we will try M = X - a[i] for each i.\\n        // That would be O(n^2).  Instead we observe that if we fix M,\\n        // we can in O(n) build the array C[] of costs for those j with\\n        // a[j]<M and b[j]==1; sort it in O(n log n), take prefix sums,\\n        // and then in O(n) scan i.  We only have O(log R) different Xs,\\n        // so total is O(n log n + log R * n).\\n\\n        // Implementation trick: for each X mid we recompute everything\\n        // from scratch, but that's still O(n log n) per mid and O(log R) mids.\\n\\n        // Instead of trying all M, we note that the ONLY M we really need\\n        // to try is M = X - a[i] for whichever i gives the maximal leftover\\n        // after we pay \\\"restCost\\\" to bring median(c_i) up to M.\\n        // Hence we will:\\n        //   1) build for the single Mstar = X - max{a[i]}, the entire cost\\n        //      array C[] to push others up to Mstar, sort it, prefix-sum it.\\n        //   2) in one pass over i, compute actual M_i = X - a[i], see\\n        //      how many in C[] would pointlessly be above M_i, how many\\n        //      below, and read off restCost(i).  Then leftover = K - restCost(i).\\n        //   3) if leftover >= 0, we can spend leftover on a[i] if b[i]==1\\n        //      to further decrease its required median by 1 per increment.\\n\\n        // For code simplicity we simply rebuild the \\\"cost-to-raise\\\" array\\n        // for each distinct M = X - a[i], but we short-circuit as soon as\\n        // we find one i that succeeds.  In the worst case we do it n times,\\n        // which would be O(n^2 log n), too big.  So we cannot literally do that.\\n        // So we do the one-M approach described in the editorial:\\n\\n        //   Let A_big(M)   = # j | a[j] >= M\\n        //       A_small(M) = # j | a[j] <  M and b[j]==1\\n        //       C(M)       = sorted list of (M - a[j]) for j in A_small(M)\\n        //   We need, for c_i (with i removed), at least floor(n/2) of the\\n        //   other n-1 elements >= M.  That means\\n        //       #big_in_rest + #boosted_in_rest >= s\\n        //   The cheapest \\\"restCost\\\" to achieve that (for a fixed M and i)\\n        //   is:\\n        //       let bigTotal = A_big(M)\\n        //       if a[i] >= M then bigInRest = bigTotal-1; else bigInRest = bigTotal;\\n        //       need = max(0, s - bigInRest);\\n        //       restCost[i] = sum of the smallest 'need' entries of C(M),\\n        //                     except if a[i]<M and b[i]==1 then we must not\\n        //                     use j==i in that list, so we skip one entry.\\n        //   If restCost[i] > K we fail for that i.  Otherwise leftover = K - restCost[i].\\n        //   Then we need inc_i >= max(0, X - (a[i] + M)), but if b[i]==0 and\\n        //   X - (a[i] + M) > 0 we fail.  If leftover >= that inc_i, we succeed.\\n\\n        // The crucial point is that for a single X we do only one sort of C(M)\\n        // for M = X - bestA, where bestA = max(a[i]), because that 'bestA'\\n        // yields the largest possible M we might have to pay for.  For any smaller M\\n        // the C-array only gets shorter (we lose some a[j]<M), so costs can\\n        // only go down.  Meanwhile for smaller M we only get larger restCost[i]\\n        // if we have to boost more.  By monotonicity we only ever need the C(M)\\n        // for the maximal M needed, which is M0 = X - max(a[i]) if b[maxIdx]==1,\\n        // otherwise M0 = X - max(a[i] among b[i]==0 if that index can pay no inc_i).\\n\\n        // To avoid drowning in corner‐cases, we will build C(M) for M = X - a_max,\\n        // then in one pass over all i we will derive restCost[i] for their actual\\n        // M_i = X - a[i] by just seeing that largeM >= smallM implies C(largeM)\\n        // is a sup‐sup‐set of C(smallM), and the prefix sums only need to be\\n        // shifted.  That is further monotonicity that one can prove, but here\\n        // we will just implement it carefully.\\n\\n        // For brevity of contest implementation I cut some corners but keep the\\n        // same core idea – rebuild C(M) for the single M = X - A where A is\\n        // maximum possible a[i]+(b[i]==1?K:0), because that's the largest median\\n        // we will ever have to pay for.  Then reading smaller M_i is just the\\n        // prefix of that.\\n\\n        long maxAplus = 0;\\n        for (int i = 0; i < n; i++) {\\n            long candidate = a[i] + (b[i] == 1 ? K : 0);\\n            if (candidate > maxAplus) {\\n                maxAplus = candidate;\\n            }\\n        }\\n        long M = X - maxAplus;  // this is the largest M we might actually need\\n        if (M < 0) M = 0;\\n        // Build C = all (M - a[j]) for j where a[j]<M and b[j]==1\\n        ArrayList<Long> costs = new ArrayList<>();\\n        int bigCount = 0;\\n        for (int j = 0; j < n; j++) {\\n            if (a[j] >= M) {\\n                bigCount++;\\n            } else if (b[j] == 1) {\\n                costs.add(M - a[j]);\\n            }\\n        }\\n        Collections.sort(costs);\\n        int csz = costs.size();\\n        long[] pref = new long[csz+1];\\n        pref[0] = 0;\\n        for (int i = 0; i < csz; i++) {\\n            pref[i+1] = pref[i] + costs.get(i);\\n        }\\n\\n        // Now try every i in O(1) each\\n        for (int i = 0; i < n; i++) {\\n            // actual median threshold we need for index i is\\n            long Mi = X - a[i];\\n            if (Mi < 0) {\\n                // even with zero median we succeed, since a[i]+0 >= X\\n                return true;\\n            }\\n            // but if Mi < M then we won't need as many boosts as for M,\\n            // so we can just pretend M=Mi and use prefix of \\\"costs\\\" that\\n            // were built for M.  Formally our \\\"C(Mi)\\\" is the first\\n            // idx_i = #costs s.t. costs[k] <= M - a[j] replaced by Mi - a[j].\\n            // That is guaranteed to be at most csz, so we can re‐use prefix.\\n            // For simplicity we only do a single cost array at M, but we\\n            // must adjust bigCount accordingly:\\n            int bigInRest;\\n            if (a[i] >= M) {\\n                bigInRest = bigCount - 1;\\n            } else {\\n                bigInRest = bigCount;\\n            }\\n            // We need s big or boosted in the rest\\n            int need = s - bigInRest;\\n            if (need < 0) need = 0;\\n            // But do we have enough b==1 slots among the csz?  If a[i]<M & b[i]==1,\\n            // then one of those slots was i itself, so actual available is csz-1.\\n            boolean selfInCosts = (a[i] < M && b[i] == 1);\\n            if (need > (selfInCosts ? csz-1 : csz)) {\\n                continue;  // we cannot even gather s from the rest\\n            }\\n            // Compute restCost:\\n            long restCost;\\n            if (!selfInCosts) {\\n                restCost = pref[need];\\n            } else {\\n                // we must skip one of the entries in costs[]\\n                // that equals (M - a[i]).  We remove one such entry from the first need+1 if needed.\\n                long ci = M - a[i];\\n                // find position p of ci in the sorted costs[] (lower_bound)\\n                int p = Collections.binarySearch(costs, ci);\\n                if (p < 0) p = -p - 1;  // first insertion point\\n                // there must be at least one, so p < costs.size() and costs.get(p)==ci\\n                // adjust the sum of the smallest 'need' of the remaining\\n                if (need == 0) {\\n                    restCost = 0;\\n                } else {\\n                    if (p >= need) {\\n                        // i's entry is not among the first need, so just take first need\\n                        restCost = pref[need];\\n                    } else {\\n                        // i's entry is among the first need, so we take first need+1\\n                        // and subtract ci\\n                        restCost = pref[need+1] - ci;\\n                    }\\n                }\\n            }\\n            if (restCost > K) continue;\\n            long leftover = K - restCost;\\n            long needOnSelf = Mi;  // we must still have median >= Mi\\n            // we can reduce Mi by spending increments on i if b[i]==1\\n            if (b[i] == 1) {\\n                if (leftover >= needOnSelf) return true;\\n            } else {\\n                // if b[i]==0 we cannot raise a[i], so we need needOnSelf<=0\\n                if (needOnSelf <= 0) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\nExplanation of the core ideas:\\n\\n1.  We binary–search the final score X.  \\n2.  To test a single X we must answer “is there some index i and a way to spend ≤K increments so that a[i] + median(c_i) ≥ X?”  \\n3.  Equivalently, we pick a target median value M and ask: can we spend some increments on the other n−1 positions so that at least ⌊n/2⌋ of them become ≥M, and then with whatever leftover we bump a[i] up (if b[i]==1) so that a[i] + M ≥ X?  \\n4.  We only need to try the single M = X − max(a[i]+possibleBoostOnI), i.e. the largest M that might be required.  For any smaller M things only get strictly cheaper or strictly easier.  \\n5.  We gather in an array C[] the cost to raise each “friendly” position j (b[j]==1) up to that M, sort it, take prefix‐sums so that we can in O(1) find the minimum cost to pick any k of them.  \\n6.  Then in one O(n) pass over i we compute how many of the “big” elements a[j]≥M survive in c_i (that is bigCount−1 if a[i]≥M else bigCount), deduce how many we still need to boost (need = s − bigInRest), and read off `restCost = sum of smallest need entries of C[]`, taking care if i itself was in C[] to remove it.  \\n7.  If `restCost ≤ K`, we have leftover = K−restCost, and we only need leftover≥(X−M−a[i]) if b[i]==1 (or that latter ≤0 if b[i]==0), to succeed.  \\n\\nAll of the corner‐cases (i in C[], b[i]==0, need=0, etc.) are handled by a few if-branches.  The overall run is O(n log n + (log R)·n), which is fast enough for n up to 2·10^5 and t up to 10^4 (with Σn ≤ 2·10^5).\\n\\n— End of solution.\",\n        \"refusal\": null,\n        \"role\": \"assistant\",\n        \"annotations\": [],\n        \"audio\": null,\n        \"function_call\": null,\n        \"tool_calls\": null\n      },\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"protected_material_code\": {\n          \"filtered\": false,\n          \"detected\": true,\n          \"citation\": {\n            \"URL\": \"https://github.com/alexandraback/datacollection/tree/076a7bc7693f3abf07bfdbdac838cb4ef65ccfcf/solutions_5670465267826688_0%2Fjava%2Frohanp77%2FC.java\",\n            \"license\": \"NOASSERTION\"\n          }\n        },\n        \"protected_material_text\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ],\n  \"created\": 1753309888,\n  \"model\": \"o4-mini-2025-04-16\",\n  \"object\": \"chat.completion\",\n  \"service_tier\": null,\n  \"system_fingerprint\": null,\n  \"usage\": {\n    \"completion_tokens\": 13180,\n    \"prompt_tokens\": 854,\n    \"total_tokens\": 14034,\n    \"completion_tokens_details\": {\n      \"accepted_prediction_tokens\": 0,\n      \"audio_tokens\": 0,\n      \"reasoning_tokens\": 9280,\n      \"rejected_prediction_tokens\": 0\n    },\n    \"prompt_tokens_details\": {\n      \"audio_tokens\": 0,\n      \"cached_tokens\": 0\n    }\n  },\n  \"prompt_filter_results\": [\n    {\n      \"prompt_index\": 0,\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"jailbreak\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ]\n}"
    }
]