[
  {
    "role": "user",
    "content": "A. Iris and Game on the Tree\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nIris has a tree rooted at vertex 1\n\n. Each vertex has a value of 0\n\n or 1\n\n.\n\n\n\nLet's consider a leaf of the tree (the vertex 1\n\n is never considered a leaf) and define its weight. Construct a string formed by the values of the vertices on the path starting at the root and ending in this leaf. Then the weight of the leaf is the difference between the number of occurrences of 10\n\n and 01\n\n substrings in it.\n\n\n\nTake the following tree as an example. Green vertices have a value of 1\n\n while white vertices have a value of 0\n\n.\n\n\n\n\n\nLet's calculate the weight of the leaf 5\n\n: the formed string is 10110\n\n. The number of occurrences of substring 10\n\n is 2\n\n, the number of occurrences of substring 01\n\n is 1\n\n, so the difference is 2−1=1\n\n.\n\nLet's calculate the weight of the leaf 6\n\n: the formed string is 101\n\n. The number of occurrences of substring 10\n\n is 1\n\n, the number of occurrences of substring 01\n\n is 1\n\n, so the difference is 1−1=0\n\n.\n\nThe score of a tree is defined as the number of leaves with non-zero weight in the tree.\n\n\n\nBut the values of some vertices haven't been decided and will be given to you as ?\n\n. Filling the blanks would be so boring, so Iris is going to invite Dora to play a game. On each turn, one of the girls chooses any of the remaining vertices with value ?\n\n and changes its value to 0\n\n or 1\n\n, with Iris going first. The game continues until there are no vertices with value ?\n\n left in the tree. Iris aims to maximize the score of the tree, while Dora aims to minimize that.\n\n\n\nAssuming that both girls play optimally, please determine the final score of the tree.\n\n\n\nInput\n\nEach test consists of multiple test cases. The first line contains a single integer t\n\n (1≤t≤5⋅104\n\n) — the number of test cases. The description of the test cases follows.\n\n\n\nThe first line of each test case contains a single integer n\n\n (2≤n≤105\n\n) — the number of vertices in the tree.\n\n\n\nThe following n−1\n\n lines each contain two integers u\n\n and v\n\n (1≤u,v≤n\n\n) — denoting an edge between vertices u\n\n and v\n\n.\n\n\n\nIt's guaranteed that the given edges form a tree.\n\n\n\nThe last line contains a string s\n\n of length n\n\n. The i\n\n-th character of s\n\n represents the value of vertex i\n\n. It's guaranteed that s\n\n only contains characters 0\n\n, 1\n\n and ?\n\n.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases doesn't exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output a single integer — the final score of the tree.\n\n\n\nExample\n\nInputCopy\n\n6\n\n4\n\n1 2\n\n1 3\n\n4 1\n\n0101\n\n4\n\n1 2\n\n3 2\n\n2 4\n\n???0\n\n5\n\n1 2\n\n1 3\n\n2 4\n\n2 5\n\n?1?01\n\n6\n\n1 2\n\n2 3\n\n3 4\n\n5 3\n\n3 6\n\n?0????\n\n5\n\n1 2\n\n1 3\n\n1 4\n\n1 5\n\n11?1?\n\n2\n\n2 1\n\n??\n\nOutputCopy\n\n2\n\n1\n\n1\n\n2\n\n1\n\n0\n\nNote\n\nIn the first test case, all the values of the vertices have been determined. There are three different paths from the root to a leaf:\n\n\n\nFrom vertex 1\n\n to vertex 2\n\n. The string formed by the path is 01\n\n, so the weight of the leaf is 0−1=−1\n\n.\n\nFrom vertex 1\n\n to vertex 3\n\n. The string formed by the path is 00\n\n, so the weight of the leaf is 0−0=0\n\n.\n\nFrom vertex 1\n\n to vertex 4\n\n. The string formed by the path is 01\n\n, so the weight of the leaf is 0−1=−1\n\n.\n\nThus, there are two leaves with non-zero weight, so the score of the tree is 2\n\n.\n\n\n\nIn the second test case, one of the sequences of optimal choices for the two players can be:\n\n\n\nIris chooses to change the value of the vertex 3\n\n to 1\n\n.\n\nDora chooses to change the value of the vertex 1\n\n to 0\n\n.\n\nIris chooses to change the value of the vertex 2\n\n to 0\n\n.\n\nThe final tree is as follows:\n\n\n\n\n\nThe only leaf with non-zero weight is 3\n\n, so the score of the tree is 1\n\n. Note that this may not be the only sequence of optimal choices for Iris and Dora.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have a rooted tree (root = 1), each vertex initially labeled either 0, 1, or `?`.  A **leaf** is any non‐root vertex of degree 1 in the tree.  After all `?`‐labels are eventually replaced by 0 or 1, the **score** is\n\n  “the number of leaves whose root‐to‐leaf string has nonzero weight,”\n\nwhere one can show easily that the only thing that matters for the weight of a root–leaf path \nis whether the leaf‐label equals the root‐label or not.  In fact\n\n  •  If the root‐bit is \\(r\\), and a leaf ends in bit \\(b\\),  \n     then the path’s “weight” is nonzero exactly when \\(b\\neq r\\).  \n\nHence the final score is simply\n\n  **(number of leaves whose final bit is \\(\\neq\\) the root’s bit).**\n\nWe have three types of vertices:\n\n  1.  The root itself (vertex 1), if it is `?` this is a special “root‐choice” variable.\n  2.  The leaves, some of which are pre‐fixed to 0 or 1, and some of which are `?`.\n  3.  All the other internal non‐leaf vertices that are `?`—we call these **irrelevant** because their bits do *not* affect the final score at all.\n\nPutting it all together, define\n\n  •  \\(F_0\\)= # of leaves pre‐fixed to 0  \n  •  \\(F_1\\)= # of leaves pre‐fixed to 1  \n  •  \\(u\\)= # of leaves whose bit is `\\?`  \n  •  \\(e\\)= # of internal non‐leaf vertices (other than the root) whose bit is `\\?`  \n\nThen there are three cases:\n\n**Case A.  Root is already fixed**  \nIf \\(s_1\\in\\{0,1\\}\\), let \\(r=s_1\\).  Every future assignment of a `?`‐leaf is a contest between Iris (who wants that leaf to *not* match \\(r\\)) and Dora (who wants it to match \\(r\\)).  They alternately pick a remaining `?`­leaf and assign it.  Since Iris moves first on the leaves, she ends up with\n\\[\n  \\bigl\\lceil \\tfrac u2\\bigr\\rceil\n\\]\nof the \\(u\\) leaves mismatching \\(r\\).  Hence\n\\[\n  \\text{Score}\n  \\;=\\;\n  \\begin{cases}\n     F_1\\;+\\;\\lceil u/2\\rceil,  &\\text{if }r=0,\\\\\n     F_0\\;+\\;\\lceil u/2\\rceil,  &\\text{if }r=1.\n  \\end{cases}\n\\]\n\n**Case B.  Root is `?`**  \nNow either Iris or Dora may eventually *choose* the root’s bit, and likewise they will assign the \\(u\\) `?`‐leaves in turns, but there are \\(e\\) “irrelevant” `?`s in the internal nodes that do not affect the score at all—they merely serve as “pass” moves to shift parity.  One checks by a small minimax‐DP or by the usual “pass‐move” parity argument that:\n\n1.  **If Iris herself takes the root** (which she can do immediately on her first move), she will choose whichever root–bit maximizes the final score, namely \\(\\max(F_0,F_1)\\), *and* thereafter Dora will never waste a move on an internal irrelevant (he would rather assign a leaf and reduce Iris’s mismatches).  Thus Dora actually starts the \\(u\\)‐leaf game, so Iris only gets \\(\\lfloor u/2\\rfloor\\) leaves mismatching.  Altogether that plan yields\n   \\[\n     \\text{option}_1\n     \\;=\\;\n     \\max(F_0,F_1)\\;+\\;\\bigl\\lfloor\\tfrac u2\\bigr\\rfloor.\n   \\]\n\n2.  **If Iris prefers to let Dora set the root** (by spending her first move on either an internal “pass” or on a leaf), then *eventually* Dora will be forced to pick the root (on one of his turns).  He will choose it so as to *minimize* the final score, i.e.\\ \\(\\min(F_0,F_1)\\).  After that, Iris will actually *start* the leaf‐assignment game, giving her \\(\\lceil u/2\\rceil\\) mismatches.  Hence that plan yields\n   \\[\n     \\text{option}_2\n     \\;=\\;\n     \\min(F_0,F_1)\\;+\\;\\bigl\\lceil\\tfrac u2\\bigr\\rceil.\n   \\]\n\nOf course Iris will choose the better of those two options—but if there are *no* internal “pass” moves (\\(e=0\\)), one checks that letting Dora set the root first can never help Iris (because Dora can then time it so that Dora also starts the leaf‐game, cutting Iris’s mismatches back down to \\(\\lfloor u/2\\rfloor\\)).  Thus when \\(e=0\\) Iris is best off by simply grabbing the root immediately.\n\nPutting these subcases together:\n\n● If \\(s_1\\in\\{0,1\\}\\) (root fixed):\n\\[\n   \\text{Score}\n   =\n   \\begin{cases}\n     F_1+\\lceil u/2\\rceil,&\n       \\text{if }s_1=0,\\\\\n     F_0+\\lceil u/2\\rceil,&\n       \\text{if }s_1=1.\n   \\end{cases}\n\\]\n\n● If \\(s_1=\\?\\) (root free):\n\\[\n   \\text{let }\n     \\text{opt}_1=\\max(F_0,F_1)+\\lfloor u/2\\rfloor,\n     \\quad\n     \\text{opt}_2=\\min(F_0,F_1)+\\lceil u/2\\rceil.\n\\]\n\\[\n   \\text{Score}\n   =\n   \\begin{cases}\n     \\text{opt}_1, \n     & \\text{if }e=0,\\\\\n     \\max(\\text{opt}_1,\\;\\text{opt}_2),\n     & \\text{if }e>0.\n   \\end{cases}\n\\]\n\nAll of that can be implemented in \\(O(n)\\) per test by a single DFS/BFS to find which vertices are leaves, count \\((F_0,F_1,u)\\), count the irrelevant `?`-nodes \\(e\\), and then apply the above formula.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static FastInput in = new FastInput();\n    static StringBuilder sb = new StringBuilder();\n\n    public static void main(String[] args) throws IOException {\n        int t = in.nextInt();\n        while(t-- > 0) {\n            int n = in.nextInt();\n            List<Integer>[] adj = new ArrayList[n+1];\n            for(int i = 1; i <= n; i++) adj[i] = new ArrayList<>();\n            for(int i = 0; i < n-1; i++) {\n                int u = in.nextInt(), v = in.nextInt();\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n            char[] s = (\" \" + in.next()).toCharArray();\n\n            // We root at 1, do a BFS to identify parent & leaves\n            int[] parent = new int[n+1];\n            parent[1] = -1;\n            Deque<Integer> dq = new ArrayDeque<>();\n            dq.add(1);\n            // BFS\n            while(!dq.isEmpty()) {\n                int u = dq.poll();\n                for(int v: adj[u]) {\n                    if(v == parent[u]) continue;\n                    parent[v] = u;\n                    dq.add(v);\n                }\n            }\n\n            // Count leaves: a leaf is (v!=1 && adj[v].size()==1)\n            int F0 = 0, F1 = 0, uLeaves = 0, eIrrelevant = 0;\n            for(int v = 2; v <= n; v++) {\n                if(adj[v].size() == 1) {\n                    // it's a leaf\n                    if(s[v] == '0')      F0++;\n                    else if(s[v] == '1') F1++;\n                    else                 uLeaves++;\n                } else {\n                    // interior non-leaf\n                    if(v != 1 && s[v] == '?') {\n                        eIrrelevant++;\n                    }\n                }\n            }\n\n            // Case A: root is fixed\n            if(s[1] == '0' || s[1] == '1') {\n                int r = s[1] - '0';\n                // leaves mismatching r = if r==0, count of 1-leaves; else count of 0-leaves\n                int base = (r == 0 ? F1 : F0);\n                // in the leaf-game, Iris goes first on uLeaves leaves => she gets ceil(uLeaves/2).\n                int leafGain = (uLeaves + 1) / 2;\n                sb.append(base + leafGain).append('\\n');\n            }\n            else {\n                // root = '?'\n                // option 1: Iris grabs root => gets max(F0,F1), then Dora starts leaves => Iris only floor(u/2)\n                int opt1 = Math.max(F0, F1) + (uLeaves / 2);\n\n                // option 2: Iris lets Dora set root => Dora picks min(F0,F1), then Iris starts leaves => Iris ceil(u/2)\n                int opt2 = Math.min(F0, F1) + ((uLeaves + 1) / 2);\n\n                // if no irrelevant passes are available, Iris must do opt1.\n                // otherwise she can choose the better of the two.\n                int ans = (eIrrelevant == 0 ? opt1 : Math.max(opt1, opt2));\n                sb.append(ans).append('\\n');\n            }\n        }\n        System.out.print(sb);\n    }\n\n    // FastInput for speed\n    static class FastInput {\n        BufferedReader br;\n        StringTokenizer st;\n        FastInput() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n    }\n}\n```\n\n**Explanation of key steps**\n\n1.  We do a simple BFS from the root (= 1) just to mark each node’s parent; this lets us identify “leaves” easily (any non‐root node of undirected degree 1 is a leaf in the rooted sense) and also which non‐leaves are “irrelevant” if they carry a `\\?`.\n\n2.  We count  \n   - \\(F_0\\)= fixed‐0 leaves,  \n   - \\(F_1\\)= fixed‐1 leaves,  \n   - \\(u\\)= leaves that are `?`,  \n   - \\(e\\)= internal “irrelevant” `?`s (they do not affect score but serve as parity‐passes in the game).\n\n3.  If the root is already fixed to 0 or 1, the game on the \\(u\\) leaves is simple alternation starting with Iris, so she gets \\(\\lceil u/2\\rceil\\) mismatches, added to the appropriate \\(F_0\\) or \\(F_1\\).\n\n4.  If the root is itself `?`, one shows by a small minimax‐analysis that Iris has two competing ways to play:\n\n   -  **Iris sets the root** on her first move and thus claims `max(F_0,F_1)` of the fixed‐leaf mismatches; then Dora will *never* waste a move on an irrelevant node (he’d rather assign a leaf match), so Dora actually starts the \\(u\\)‐leaf alternation, leaving Iris only \\(\\lfloor u/2\\rfloor\\) more.\n   \n   -  **Iris passes root‐assignment** (by using an irrelevant or assigning one leaf) so that *eventually* Dora must be the one to set the root (on one of his turns), giving Dora `min(F_0,F_1)` mismatches; after that Iris *does* start the \\(u\\)‐leaf alternation, netting \\(\\lceil u/2\\rceil\\).\n\n   If there are no irrelevant passes, Dora can always arrange to move second on the leaves in the second plan, so it never helps Iris—she simply does the first plan.  If there *are* irrelevant passes, she may do whichever of the two plans yields the larger total.\n\nThis runs in \\(O(n)\\) per test case, well within the \\(2\\)\\,sec / \\(2\\cdot10^5\\)-sum ‑of-\\(n\\) limit."
  }
]