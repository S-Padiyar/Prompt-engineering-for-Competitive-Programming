[
    {
        "request_timestamp": "2025-07-23T18:42:20.577614",
        "response_timestamp": "2025-07-23T18:44:22.465498",
        "sent_messages": [
            {
                "role": "user",
                "content": "Codeforces Problem:\n\nE. Manhattan Triangle\n\ntime limit per test3 seconds\n\nmemory limit per test256 megabytes\n\nThe Manhattan distance between two points (x1,y1)\n\n and (x2,y2)\n\n is defined as:\n\n|x1−x2|+|y1−y2|.\n\n\n\nWe call a Manhattan triangle three points on the plane, the Manhattan distances between each pair of which are equal.\n\n\n\nYou are given a set of pairwise distinct points and an even integer d\n\n. Your task is to find any Manhattan triangle, composed of three distinct points from the given set, where the Manhattan distance between any pair of vertices is equal to d\n\n.\n\n\n\nInput\n\nEach test consists of multiple test cases. The first line contains one integer t\n\n (1≤t≤104\n\n) — the number of test cases. The description of the test cases follows.\n\n\n\nThe first line of each test case contains two integers n\n\n and d\n\n (3≤n≤2⋅105\n\n, 2≤d≤4⋅105\n\n, d\n\n is even) — the number of points and the required Manhattan distance between the vertices of the triangle.\n\n\n\nThe (i+1)\n\n-th line of each test case contains two integers xi\n\n and yi\n\n (−105≤xi,yi≤105\n\n) — the coordinates of the i\n\n-th point. It is guaranteed that all points are pairwise distinct.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output three distinct integers i\n\n, j\n\n, and k\n\n (1≤i,j,k≤n\n\n) — the indices of the points forming the Manhattan triangle. If there is no solution, output \"0 0 0\n\n\" (without quotes).\n\n\n\nIf there are multiple solutions, output any of them.\n\n\n\nExample\n\nInputCopy\n\n6\n\n6 4\n\n3 1\n\n0 0\n\n0 -2\n\n5 -3\n\n3 -5\n\n2 -2\n\n5 4\n\n0 0\n\n0 -2\n\n5 -3\n\n3 -5\n\n2 -2\n\n6 6\n\n3 1\n\n0 0\n\n0 -2\n\n5 -3\n\n3 -5\n\n2 -2\n\n4 4\n\n3 0\n\n0 3\n\n-3 0\n\n0 -3\n\n10 8\n\n2 1\n\n-5 -1\n\n-4 -1\n\n-5 -3\n\n0 1\n\n-2 5\n\n-4 4\n\n-4 2\n\n0 0\n\n-4 1\n\n4 400000\n\n100000 100000\n\n-100000 100000\n\n100000 -100000\n\n-100000 -100000\n\nOutputCopy\n\n2 6 1\n\n4 3 5\n\n3 5 1\n\n0 0 0\n\n6 1 3\n\n0 0 0\n\nNote\n\nIn the first test case:\n\n\n\nPoints A\n\n, B\n\n, and F\n\n form a Manhattan triangle, the Manhattan distance between each pair of vertices is 4\n\n. Points D\n\n, E\n\n, and F\n\n can also be the answer.\n\nIn the third test case:\n\n\n\nPoints A\n\n, C\n\n, and E\n\n form a Manhattan triangle, the Manhattan distance between each pair of vertices is 6\n\n.\n\nIn the fourth test case, there are no two points with a Manhattan distance of 4\n\n, and therefore there is no suitable Manhattan triangle.\n\n---\n\nUse Java."
            }
        ],
        "received_response": "{\n  \"id\": \"chatcmpl-BwcSCJzEN6dEDgaLpNMejhv6jhSXG\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"**Analysis**\\n\\nWe are given \\\\(n\\\\) points \\\\((x_i,y_i)\\\\) and an even distance \\\\(d\\\\).  We call three of these points a *Manhattan triangle* if the Manhattan distance between every pair among them is exactly \\\\(d\\\\).  Recall\\n\\n\\\\[\\n\\\\text{dist}_{\\\\mathrm{man}}((x_1,y_1),(x_2,y_2))\\n\\\\;=\\\\;|x_1-x_2| + |y_1-y_2|\\n\\\\;=\\\\;d.\\n\\\\]\\n\\nA classic trick is to make the change of coordinates\\n\\n\\\\[\\nu \\\\;=\\\\; x+y,\\\\quad\\nv \\\\;=\\\\; x-y.\\n\\\\]\\n\\nUnder \\\\((u,v)\\\\) the Manhattan distance becomes the Chebyshev distance\\n\\n\\\\[\\n\\\\lvert x_1-x_2\\\\rvert + \\\\lvert y_1-y_2\\\\rvert\\n\\\\;=\\\\;\\n\\\\max\\\\bigl(\\\\lvert u_1-u_2\\\\rvert,\\\\lvert v_1-v_2\\\\rvert\\\\bigr).\\n\\\\]\\n\\nThus in \\\\((u,v)\\\\)–space we are looking for three points each at \\\\(\\\\ell_\\\\infty\\\\)–distance exactly \\\\(d\\\\) from each other.\\n\\nA key geometric fact about \\\\(\\\\ell_\\\\infty\\\\)–geometry is:\\n\\n  – If two points \\\\(P,Q\\\\) satisfy \\n    \\\\(\\\\max(|u_P-u_Q|,|v_P-v_Q|)=d\\\\), \\n    then any third point \\\\(R\\\\) that also lies at \\\\(\\\\ell_\\\\infty\\\\)–distance \\\\(d\\\\) from both \\\\(P\\\\) and \\\\(Q\\\\) must share either the same \\\\(u\\\\)–coordinate (and differ by \\\\(\\\\pm d\\\\) in \\\\(v\\\\)) or the same \\\\(v\\\\)–coordinate (and differ by \\\\(\\\\pm d\\\\) in \\\\(u\\\\)).  \\n\\nIn particular one checks that *any* \\\\(\\\\ell_\\\\infty\\\\)–equilateral triangle has at least one side which is horizontal in \\\\((u,v)\\\\)–space (i.e.\\\\ same \\\\(v\\\\), \\\\(u\\\\) differing by \\\\(d\\\\)) or vertical (same \\\\(u\\\\), \\\\(v\\\\) differing by \\\\(d\\\\)).  \\n\\nHence a very efficient search is:\\n\\n  1.  Compute for each point \\\\(i\\\\):\\n     \\\\[\\n       u_i = x_i + y_i,\\\\quad v_i = x_i - y_i.\\n     \\\\]\\n  \\n  2.  Build two maps\\n     \\\\(\\\\mathtt{mapU}\\\\colon u\\\\mapsto\\\\{(v,i)\\\\}\\\\)\\n     and\\n     \\\\(\\\\mathtt{mapV}\\\\colon v\\\\mapsto\\\\{(u,i)\\\\}\\\\),\\n     each listing the points at a given \\\\(u\\\\) or \\\\(v\\\\).\\n\\n  3.  In \\\\(\\\\mathtt{mapU}\\\\), for each fixed \\\\(u\\\\) take its list of points \\\\((v,i)\\\\) and sort by \\\\(v\\\\).  \\n     Whenever two *adjacent* \\\\(v\\\\)-values differ exactly by \\\\(d\\\\), say\\n     \\\\[\\n       (u,v_1)\\\\leftrightarrow i_1,\\n       \\\\quad\\n       (u,v_2)\\\\leftrightarrow i_2,\\n       \\\\qquad\\n       v_2 - v_1 \\\\;=\\\\; d,\\n     \\\\]\\n     then these two points are at Chebyshev distance \\\\(d\\\\) (they lie on the same vertical line \\\\(u=\\\\text{const}\\\\)).  \\n     To complete a triangle we need *any* third point whose \\\\(u\\\\)-coordinate is \\\\(u\\\\pm d\\\\).  \\n     We look up whether \\\\(\\\\mathtt{mapU}\\\\) has key \\\\(u+d\\\\) or \\\\(u-d\\\\); if it does, choose *any* one point from that list and we have a triple \\\\(\\\\{i_1,i_2,i_3\\\\}\\\\).  \\n\\n  4.  Symmetrically scan \\\\(\\\\mathtt{mapV}\\\\).  If two adjacent \\\\(u\\\\)-values differ by \\\\(d\\\\) on the same \\\\(v\\\\)-line, look for a third point at \\\\(v\\\\pm d\\\\).  \\n\\n  5.  If we find any such triple, we output it.  Otherwise we print `0 0 0`.\\n\\nThis runs in \\\\(O(n\\\\log n)\\\\) per test (sorting each bucket) and in total \\\\(O(n\\\\log n)\\\\) over all tests, which is well within the problem’s limits.\\n\\n----\\n\\n```java\\nimport java.io.*;\\nimport java.util.*;\\n\\npublic class Main {\\n    public static void main(String[] args) throws IOException {\\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\\n        StringBuilder sb = new StringBuilder();\\n        int t = Integer.parseInt(in.readLine().trim());\\n\\n        while (t-- > 0) {\\n            StringTokenizer st = new StringTokenizer(in.readLine());\\n            int n = Integer.parseInt(st.nextToken());\\n            int d = Integer.parseInt(st.nextToken());\\n\\n            int[] U = new int[n];\\n            int[] V = new int[n];\\n            int[] X = new int[n];\\n            int[] Y = new int[n];\\n\\n            // Read points, compute (u,v)\\n            for (int i = 0; i < n; i++) {\\n                st = new StringTokenizer(in.readLine());\\n                int x = Integer.parseInt(st.nextToken());\\n                int y = Integer.parseInt(st.nextToken());\\n                X[i] = x;\\n                Y[i] = y;\\n                U[i] = x + y;\\n                V[i] = x - y;\\n            }\\n\\n            // Build mapU: u -> list of (v, index)\\n            //      mapV: v -> list of (u, index)\\n            HashMap<Integer, ArrayList<int[]>> mapU = new HashMap<>();\\n            HashMap<Integer, ArrayList<int[]>> mapV = new HashMap<>();\\n\\n            for (int i = 0; i < n; i++) {\\n                mapU.computeIfAbsent(U[i], k -> new ArrayList<>()).add(new int[]{V[i], i});\\n                mapV.computeIfAbsent(V[i], k -> new ArrayList<>()).add(new int[]{U[i], i});\\n            }\\n\\n            // Sort each bucket by the other coordinate\\n            for (ArrayList<int[]> lst : mapU.values()) {\\n                lst.sort(Comparator.comparingInt(a -> a[0]));\\n            }\\n            for (ArrayList<int[]> lst : mapV.values()) {\\n                lst.sort(Comparator.comparingInt(a -> a[0]));\\n            }\\n\\n            boolean found = false;\\n\\n            // 1) Scan vertical lines in (u,v)-space => same u, v differs by d\\n            outer:\\n            for (Map.Entry<Integer, ArrayList<int[]>> entry : mapU.entrySet()) {\\n                int u = entry.getKey();\\n                ArrayList<int[]> lst = entry.getValue();\\n                for (int j = 0; j + 1 < lst.size(); j++) {\\n                    int v1 = lst.get(j)[0], i1 = lst.get(j)[1];\\n                    int v2 = lst.get(j+1)[0], i2 = lst.get(j+1)[1];\\n                    if (v2 - v1 == d) {\\n                        // these two are at Chebyshev distance d\\n                        // look for any third point at u ± d\\n                        if (mapU.containsKey(u + d)) {\\n                            int i3 = mapU.get(u + d).get(0)[1];\\n                            sb.append((i1+1)).append(' ')\\n                              .append((i2+1)).append(' ')\\n                              .append((i3+1)).append('\\\\n');\\n                            found = true;\\n                            break outer;\\n                        }\\n                        if (mapU.containsKey(u - d)) {\\n                            int i3 = mapU.get(u - d).get(0)[1];\\n                            sb.append((i1+1)).append(' ')\\n                              .append((i2+1)).append(' ')\\n                              .append((i3+1)).append('\\\\n');\\n                            found = true;\\n                            break outer;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // 2) If not found, scan horizontal lines => same v, u differs by d\\n            if (!found) {\\n                outer:\\n                for (Map.Entry<Integer, ArrayList<int[]>> entry : mapV.entrySet()) {\\n                    int v = entry.getKey();\\n                    ArrayList<int[]> lst = entry.getValue();\\n                    for (int j = 0; j + 1 < lst.size(); j++) {\\n                        int u1 = lst.get(j)[0], i1 = lst.get(j)[1];\\n                        int u2 = lst.get(j+1)[0], i2 = lst.get(j+1)[1];\\n                        if (u2 - u1 == d) {\\n                            // these two are at Chebyshev distance d\\n                            // look for any third at v ± d\\n                            if (mapV.containsKey(v + d)) {\\n                                int i3 = mapV.get(v + d).get(0)[1];\\n                                sb.append((i1+1)).append(' ')\\n                                  .append((i2+1)).append(' ')\\n                                  .append((i3+1)).append('\\\\n');\\n                                found = true;\\n                                break outer;\\n                            }\\n                            if (mapV.containsKey(v - d)) {\\n                                int i3 = mapV.get(v - d).get(0)[1];\\n                                sb.append((i1+1)).append(' ')\\n                                  .append((i2+1)).append(' ')\\n                                  .append((i3+1)).append('\\\\n');\\n                                found = true;\\n                                break outer;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // If still not found, no such triangle\\n            if (!found) {\\n                sb.append(\\\"0 0 0\\\\n\\\");\\n            }\\n        }\\n\\n        System.out.print(sb.toString());\\n    }\\n}\\n```\\n\\n**Explanation of the key steps**\\n\\n1. **\\\\(u,v\\\\)–transform**  \\n   We set  \\n   \\\\[\\n     u = x+y,\\\\quad v = x-y.\\n   \\\\]  \\n   Then  \\n   \\\\(\\\\lvert x_1-x_2\\\\rvert + \\\\lvert y_1-y_2\\\\rvert\\n     = \\\\max\\\\bigl(\\\\lvert u_1-u_2\\\\rvert,\\\\lvert v_1-v_2\\\\rvert\\\\bigr).\\\\)\\n\\n2. **Bucket by constant \\\\(u\\\\) or constant \\\\(v\\\\)**  \\n   - `mapU` groups all points with the same \\\\(u\\\\).  Within that group we sort by \\\\(v\\\\).  \\n   - `mapV` groups all points with the same \\\\(v\\\\).  Within that group we sort by \\\\(u\\\\).\\n\\n3. **Detect an “axis‐aligned” side of length \\\\(d\\\\)**  \\n   - On a fixed \\\\(u\\\\)–line, if two *adjacent* \\\\(v\\\\)-coordinates differ by \\\\(d\\\\), those two points are at distance \\\\(d\\\\).  To form a triangle we only need any third point whose \\\\(u\\\\)–coordinate is offset by \\\\(\\\\pm d\\\\).  \\n   - Similarly on a fixed \\\\(v\\\\)–line.\\n\\n4. **Why this finds *every* Manhattan‐equilateral triangle**  \\n   In the Chebyshev (\\\\(\\\\ell_\\\\infty\\\\)) metric, every equilateral triangle has at least one side which is either horizontal or vertical.  Hence it suffices to look for pairs of points on the same \\\\(u\\\\)–line or on the same \\\\(v\\\\)–line at Chebyshev‐distance \\\\(d\\\\), and then grab any third point at the appropriate offset.  \\n\\nThis runs in \\\\(O(n\\\\log n)\\\\) overall per test and easily handles up to \\\\(2\\\\times10^5\\\\) total points.\",\n        \"refusal\": null,\n        \"role\": \"assistant\",\n        \"annotations\": [],\n        \"audio\": null,\n        \"function_call\": null,\n        \"tool_calls\": null\n      },\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"protected_material_code\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"protected_material_text\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ],\n  \"created\": 1753310540,\n  \"model\": \"o4-mini-2025-04-16\",\n  \"object\": \"chat.completion\",\n  \"service_tier\": null,\n  \"system_fingerprint\": null,\n  \"usage\": {\n    \"completion_tokens\": 18728,\n    \"prompt_tokens\": 737,\n    \"total_tokens\": 19465,\n    \"completion_tokens_details\": {\n      \"accepted_prediction_tokens\": 0,\n      \"audio_tokens\": 0,\n      \"reasoning_tokens\": 16192,\n      \"rejected_prediction_tokens\": 0\n    },\n    \"prompt_tokens_details\": {\n      \"audio_tokens\": 0,\n      \"cached_tokens\": 0\n    }\n  },\n  \"prompt_filter_results\": [\n    {\n      \"prompt_index\": 0,\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"jailbreak\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ]\n}"
    }
]