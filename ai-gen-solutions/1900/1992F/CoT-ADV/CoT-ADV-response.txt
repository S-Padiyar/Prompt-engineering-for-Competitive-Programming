**Problem Restatement**

We have an array of n cards, the i-th card has a price a_i, and a target integer x (which does **not** appear exactly among the a_i). We wish to partition the array into the minimum possible number of contiguous segments so that _each_ segment is “bad,” meaning that within that segment there is **no** subsequence of card prices whose product equals x.

Formally, a segment \[L…R\] is _bad_ if there are _no_ indices L ≤ i₁ < i₂ < … < i_k ≤ R such that  
a_{i₁} · a_{i₂} · … · a_{i_k} = x.

We must cover the entire array by disjoint bad segments, minimizing the number of segments.

**Key Observations**

1.  
   Only cards whose value **divides** x can ever participate in a subsequence whose product is exactly x.  
   - If a_i does not divide x, it has some prime factor _outside_ those of x; including it in a product would introduce an extra prime, and that product cannot equal x.  
   - Similarly, a_i = 1 (trivially divides x) contributes nothing; including or excluding 1’s does not help form new products.

2.  
   Among cards that do divide x, we can think of each a_i as a “weight” in a subset‐product knapsack whose target is x.  
   - If we list all divisors D of x, we can maintain a boolean DP array `reachable[d]` (indexed by divisor) meaning “we can form product = d by some subset of cards in the current segment.”  
   - Initially, `reachable[1] = true` and all others are false.  
   - When we consider a new card of value g (where g divides x), we merge it into the DP by:  
       for each divisor d that is currently reachable, if (d * g) divides x, we mark (d * g) reachable.  

3.  
   A segment becomes “good” as soon as `reachable[x]` becomes true. But we need _bad_ segments only, so we must **break** (start a new segment) right before the card that completes it to x.  
   - Greedily, we try to extend the current segment as far as possible. As soon as adding a card would make x reachable, we make a cut just before that card, start a fresh DP from that card, and continue.  
   - This greedy strategy is optimal because delaying the cut only risks making earlier segments good; cutting as late as possible maximizes each segment’s length.

**Algorithm Outline**

For each test case:

1. Read n, x, and the array a[ ].
2. Enumerate all divisors of x into a sorted list `divs`. Let m = divs.size().
3. Build a map `divIndex` from each divisor → its index in `divs`.
4. Let `idx1 = divIndex.get(1)` and `idxX = divIndex.get(x)`.
5. Initialize:
   - `res = 1`  (we have at least one segment)
   - boolean array `reachable[ ]` of size m, all false except `reachable[idx1] = true`.
6. Iterate i = 0…n−1:
   a. Let ai = a[i].  
   b. If `x % ai != 0`, skip it (it cannot help form x).  
   c. Otherwise let `g = ai`, `gIdx = divIndex.get(g)`.
   d. Form a copy `nextReachable[ ] = reachable.clone()`.
   e. For each divisor index j where `reachable[j] == true`:
         let d = divs.get(j);  
         let prod = d * (long)g;  
         if `prod <= x && x % prod == 0`,  
            mark `nextReachable[ divIndex.get((int)prod) ] = true`.
   f. If `nextReachable[idxX]` is true, we would become good—so cut here:
      - `res++`
      - reset `reachable` to all false except `reachable[idx1] = true`
      - _re‐process_ the same card into the fresh DP:
        if `g > 1`, set `reachable[gIdx] = true`.
      - **continue** to next i.
   g. Else copy back `reachable = nextReachable`.
7. Print `res`.

Each test does O(√x) to list divisors plus O(n·D) DP steps, where D ≤ number of divisors of x (at most ~128). Since ∑n ≤ 10^5, this runs comfortably in time.

---

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        int t = Integer.parseInt(br.readLine().trim());
        StringBuilder sb = new StringBuilder();

        while (t-- > 0) {
            st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            int x = Integer.parseInt(st.nextToken());

            int[] a = new int[n];
            st = new StringTokenizer(br.readLine());
            for (int i = 0; i < n; i++) {
                a[i] = Integer.parseInt(st.nextToken());
            }

            // 1) Compute all divisors of x
            List<Integer> divs = new ArrayList<>();
            for (int d = 1; d * (long)d <= x; d++) {
                if (x % d == 0) {
                    divs.add(d);
                    if (d * d != x) {
                        divs.add(x / d);
                    }
                }
            }
            Collections.sort(divs);
            int m = divs.size();

            // 2) Map each divisor -> its index
            Map<Integer,Integer> divIndex = new HashMap<>();
            for (int i = 0; i < m; i++) {
                divIndex.put(divs.get(i), i);
            }
            int idx1 = divIndex.get(1);
            int idxX = divIndex.get(x);

            // 3) DP array for the "current segment"
            boolean[] reachable = new boolean[m];
            reachable[idx1] = true;  // we can always form product = 1 by choosing nothing

            int segments = 1;  // we will form at least one segment

            // 4) Process each card
            for (int val : a) {
                // If val does not divide x, it cannot help form x -> skip
                if (x % val != 0) {
                    continue;
                }
                int g = val;          // this card's “weight”
                int gIdx = divIndex.get(g);

                // Try merging this card into the current segment
                boolean[] nextReachable = reachable.clone();
                for (int j = 0; j < m; j++) {
                    if (!reachable[j]) continue;
                    long prod = divs.get(j) * (long)g;
                    if (prod <= x && x % prod == 0) {
                        int idx = divIndex.get((int)prod);
                        nextReachable[idx] = true;
                    }
                }

                // If we now can form x, this segment has become GOOD => we must cut
                if (nextReachable[idxX]) {
                    segments++;
                    // Reset DP for a new segment
                    reachable = new boolean[m];
                    reachable[idx1] = true;
                    // Re‐process this card in the fresh DP
                    if (g > 1) {
                        reachable[gIdx] = true;
                    }
                } else {
                    // Safe to accept this card in the current segment
                    reachable = nextReachable;
                }
            }

            sb.append(segments).append('\n');
        }

        System.out.print(sb);
    }
}
```

**Explanation of Key Steps**

- We only consider cards that exactly divide x; others cannot help form the product x, and we simply ignore them in our DP.
- We keep a small DP array `reachable[d]` over the _divisors_ of x:  
  - `reachable[d] = true` means “there is some subsequence in the current segment whose product is exactly d.”  
  - Starting from `reachable[1] = true`, adding a divisor‐card `g` extends reachable states by `d → d·g` (where that still divides x).
- As soon as `reachable[x]` would become true, the segment would be “good,” so we cannot allow that. We make a cut _right before_ the current card, increment our segment count, reset the DP, and then _re‐add_ the current card to the new segment’s DP.
- We process greedily, always extending as far as possible before cutting, yielding the minimum number of bad segments.

**Complexity Analysis**

- Let D = number of divisors of x. It is known D = O(x^(1/3)) worst‐case but in practice for x ≤ 10^5 it’s at most a few tens, up to ~128.
- Building divisors takes O(√x).
- For each card we do an O(D) DP update; in the worst case we might pay for a second “re‐add” when we cut, but that’s still O(D). Over all n cards (∑n ≤ 10^5) this is O(n·D) ≤ 10^5·128 ≃ 1.28·10^7 operations, which is comfortably within 4 seconds in Java.
- Space is O(D) per test case plus O(n) for input.

Thus, overall time is roughly O(∑ (√x + n·D)) ≤ O(10^5 · 128) which passes easily under the given limits.