[
  {
    "role": "user",
    "content": "E. Coloring Game\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nThis is an interactive problem.\n\n\n\nConsider an undirected connected graph consisting of n\n\n vertices and m\n\n edges. Each vertex can be colored with one of three colors: 1\n\n, 2\n\n, or 3\n\n. Initially, all vertices are uncolored.\n\n\n\nAlice and Bob are playing a game consisting of n\n\n rounds. In each round, the following two-step process happens:\n\n\n\nAlice chooses two different colors.\n\nBob chooses an uncolored vertex and colors it with one of the two colors chosen by Alice.\n\nAlice wins if there exists an edge connecting two vertices of the same color. Otherwise, Bob wins.\n\n\n\nYou are given the graph. Your task is to decide which player you wish to play as and win the game.\n\n\n\nInput\n\nEach test contains multiple test cases. The first line contains a single integer t\n\n (1≤t≤1000\n\n) — the number of test cases. The description of test cases follows.\n\n\n\nThe first line of each test case contains two integers n\n\n, m\n\n (1≤n≤104\n\n, n−1≤m≤min(n⋅(n−1)2,104)\n\n) — the number of vertices and the number of edges in the graph, respectively.\n\n\n\nEach of the next m\n\n lines of each test case contains two integers ui\n\n, vi\n\n (1≤ui,vi≤n\n\n) — the edges of the graph. It is guaranteed that the graph is connected and there are no multiple edges or self-loops.\n\n\n\nIt is guaranteed that the sum of n\n\n and the sum of m\n\n over all test cases does not exceed 104\n\n.\n\n\n\nInteraction\n\nFor each test case, you need to output a single line containing either \"Alice\" or \"Bob\", representing the player you choose.\n\n\n\nThen for each of the following n\n\n rounds, the following two-step process happens:\n\n\n\nAlice (either you or the interactor) will output two integers a\n\n and b\n\n (1≤a,b≤3\n\n, a≠b\n\n) — the colors chosen by Alice.\n\nBob (either you or the interactor) will output two integers i\n\n and c\n\n (1≤i≤n\n\n, c=a\n\n or c=b\n\n) — the vertex and the color chosen by Bob. Vertex i\n\n must be a previously uncolored vertex.\n\nIf any of your outputs are invalid, the jury will output \"-1\" and you will receive a Wrong Answer verdict.\n\n\n\nAt the end of all n\n\n turns, if you have lost the game, the jury will output \"-1\" and you will receive a Wrong Answer verdict.\n\n\n\nIf your program has received a −1\n\n instead of a valid value, it must terminate immediately. Otherwise, you may receive an arbitrary verdict because your solution might be reading from a closed stream.\n\n\n\nNote that if you are playing as Alice, and there already exists an edge connected two vertices of the same color, the interactor will not terminate early and you will keep playing all n\n\n rounds.\n\n\n\nAfter outputting, do not forget to output end of line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\n\n\n\nfflush(stdout) or cout.flush() in C++;\n\nSystem.out.flush() in Java;\n\nflush(output) in Pascal;\n\nstdout.flush() in Python;\n\nsee documentation for other languages.\n\nIn this problem, hacks are disabled.\n\n\n\nExample\n\nInputCopy\n\n2\n\n3 3\n\n1 2\n\n2 3\n\n3 1\n\n\n\n\n\n3 1\n\n\n\n2 2\n\n\n\n1 1\n\n4 4\n\n1 2\n\n2 3\n\n3 4\n\n4 1\n\n\n\n2 3\n\n\n\n1 2\n\n\n\n2 1\n\n\n\n3 1\n\n\n\nOutputCopy\n\n\n\n\n\n\n\n\n\n\n\nAlice\n\n3 1\n\n\n\n1 2\n\n\n\n2 1\n\n\n\n\n\n\n\n\n\n\n\n\n\nBob\n\n\n\n1 2\n\n\n\n2 1\n\n\n\n4 1\n\n\n\n3 3\n\nNote\n\nNote that the sample test cases are example games and do not necessarily represent the optimal strategy for both players.\n\n\n\nIn the first test case, you choose to play as Alice.\n\n\n\nAlice chooses two colors: 3\n\n and 1\n\n. Bob chooses vertex 3\n\n and colors it with color 1\n\n.\n\nAlice chooses two colors: 1\n\n and 2\n\n. Bob chooses vertex 2\n\n and colors it with color 2\n\n.\n\nAlice chooses two colors: 2\n\n and 1\n\n. Bob chooses vertex 1\n\n and colors it with color 1\n\n.\n\nAlice wins because the edge (3,1)\n\n connects two vertices of the same color.\n\n\n\nIn the second test case, you choose to play as Bob.\n\n\n\nAlice chooses two colors: 2\n\n and 3\n\n. Bob chooses vertex 1\n\n and colors it with color 2\n\n.\n\nAlice chooses two colors: 1\n\n and 2\n\n. Bob chooses vertex 2\n\n and colors it with color 1\n\n.\n\nAlice chooses two colors: 2\n\n and 1\n\n. Bob chooses vertex 4\n\n and colors it with color 1\n\n.\n\nAlice chooses two colors: 3\n\n and 1\n\n. Bob chooses vertex 3\n\n and colors it with color 3\n\n.\n\nBob wins because there are no edges with vertices of the same color.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        String line = br.readLine();\n        if (line == null || line.isEmpty()) {\n            out.flush();\n            return;\n        }\n        int t = Integer.parseInt(line.trim());\n        while (t-- > 0) {\n            String[] parts = br.readLine().trim().split(\"\\\\s+\");\n            int n = Integer.parseInt(parts[0]);\n            int m = Integer.parseInt(parts[1]);\n            List<int[]> edges = new ArrayList<>(m);\n            List<Integer>[] adj = new ArrayList[n+1];\n            for (int i = 1; i <= n; i++) {\n                adj[i] = new ArrayList<>();\n            }\n            for (int i = 0; i < m; i++) {\n                parts = br.readLine().trim().split(\"\\\\s+\");\n                int u = Integer.parseInt(parts[0]);\n                int v = Integer.parseInt(parts[1]);\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n            // check bipartiteness\n            int[] color = new int[n+1]; // 0 = unvisited, 1 or -1 for two colors\n            boolean isBip = true;\n            for (int i = 1; i <= n; i++) {\n                if (color[i] == 0) {\n                    // BFS\n                    Queue<Integer> q = new ArrayDeque<>();\n                    color[i] = 1;\n                    q.add(i);\n                    while (!q.isEmpty() && isBip) {\n                        int u = q.poll();\n                        for (int v : adj[u]) {\n                            if (color[v] == 0) {\n                                color[v] = -color[u];\n                                q.add(v);\n                            } else {\n                                if (color[v] == color[u]) {\n                                    isBip = false;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if (!isBip) break;\n                }\n            }\n            if (isBip) {\n                out.println(\"Bob\");\n            } else {\n                out.println(\"Alice\");\n            }\n        }\n        out.flush();\n    }\n}"
  }
]