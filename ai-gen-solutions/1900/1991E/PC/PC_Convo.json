[
  {
    "timestamp": "2025-07-24T05:53:14.796579",
    "role": "user",
    "content": "Your Java solution has compilation issues: you used a Unicode minus sign for initialization (`foundU=−1`), and you employed a lambda that captures non-final locals (`shrink` referencing `lastW`, `posW`, `cycle`), which is illegal. Please provide a single, self-contained Java code block (no lambdas capturing non-final variables) that compiles under Java 8+, correctly implements both Alice and Bob strategies, and handles interaction per the problem statement."
  },
  {
    "timestamp": "2025-07-24T05:55:58.840952",
    "role": "assistant",
    "content": "```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter out = new PrintWriter(System.out);\n    static StringTokenizer tok;\n\n    // --- fast input helpers ---\n    static String nextToken() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            String line = in.readLine();\n            if (line == null) return null;\n            tok = new StringTokenizer(line);\n        }\n        return tok.nextToken();\n    }\n    static int nextInt() throws IOException {\n        String s = nextToken();\n        if (s == null) System.exit(0);\n        return Integer.parseInt(s);\n    }\n    static void die() {\n        // must exit immediately on reading −1 from judge\n        System.exit(0);\n    }\n\n    // --- graph data ---\n    static int n, m;\n    static ArrayList<Integer>[] adj;\n    // for bipartiteness test\n    static int[] bcolor, parent, depth;\n    static boolean isBip;\n    static int foundU, foundV;\n\n    // for Alice's odd‐cycle strategy\n    static ArrayList<Integer> cycle;\n    static boolean[] inC;\n    static int[] posW;\n    static int lastW;\n    static int[] colState;\n    static int uncoloredLeft;\n\n    public static void main(String[] args) throws IOException {\n        int t = Integer.parseInt(in.readLine().trim());\n        while (t-- > 0) {\n            // read graph\n            String[] sp = in.readLine().trim().split(\"\\\\s+\");\n            n = Integer.parseInt(sp[0]);\n            m = Integer.parseInt(sp[1]);\n            adj = new ArrayList[n+1];\n            for (int i = 1; i <= n; i++) adj[i] = new ArrayList<>();\n            for (int i = 0; i < m; i++) {\n                sp = in.readLine().trim().split(\"\\\\s+\");\n                int u = Integer.parseInt(sp[0]);\n                int v = Integer.parseInt(sp[1]);\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n\n            // -- check bipartiteness with BFS, record an odd‐cycle edge if found --\n            bcolor = new int[n+1];\n            parent = new int[n+1];\n            depth  = new int[n+1];\n            isBip = true;\n            foundU = -1; \n            foundV = -1;\n            Queue<Integer> q = new ArrayDeque<>();\n            for (int i = 1; i <= n && isBip; i++) {\n                if (bcolor[i] == 0) {\n                    bcolor[i] = 1;\n                    parent[i] = -1;\n                    depth[i] = 0;\n                    q.add(i);\n                    while (!q.isEmpty() && isBip) {\n                        int u = q.poll();\n                        for (int v : adj[u]) {\n                            if (bcolor[v] == 0) {\n                                bcolor[v] = -bcolor[u];\n                                parent[v] = u;\n                                depth[v] = depth[u] + 1;\n                                q.add(v);\n                            } else if (bcolor[v] == bcolor[u]) {\n                                // found an odd‐cycle edge (u,v)\n                                isBip = false;\n                                foundU = u;\n                                foundV = v;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (isBip) {\n                playBob();\n            } else {\n                playAlice();\n            }\n        }\n        out.flush();\n    }\n\n    // --- Bob's strategy on bipartite graph ---\n    static void playBob() throws IOException {\n        out.println(\"Bob\");\n        out.flush();\n\n        // Partition A = bcolor==1, B = bcolor==-1\n        TreeSet<Integer> A = new TreeSet<>(), B = new TreeSet<>();\n        for (int i = 1; i <= n; i++) {\n            if (bcolor[i] == 1) A.add(i);\n            else               B.add(i);\n        }\n\n        for (int round = 0; round < n; round++) {\n            int a = nextInt();\n            int b = nextInt();\n            if (a < 0) die();  // judge error\n            int pick = -1, col = -1;\n            // try to use our fixed coloring: A→1, B→2\n            if ((a == 1 || b == 1) && !A.isEmpty()) {\n                pick = A.pollFirst();\n                col  = 1;\n            } else if ((a == 2 || b == 2) && !B.isEmpty()) {\n                pick = B.pollFirst();\n                col  = 2;\n            } else {\n                // fallback if something unexpected happens\n                if (!A.isEmpty()) {\n                    pick = A.pollFirst(); col = 1;\n                } else {\n                    pick = B.pollFirst(); col = 2;\n                }\n            }\n            out.printf(\"%d %d\\n\", pick, col);\n            out.flush();\n        }\n    }\n\n    // --- Alice's strategy on non‐bipartite graph ---\n    static void playAlice() throws IOException {\n        out.println(\"Alice\");\n        out.flush();\n\n        // Reconstruct an explicit odd cycle from foundU--foundV\n        ArrayList<Integer> pathU = new ArrayList<>(), pathV = new ArrayList<>();\n        int x = foundU, y = foundV;\n        while (x != y) {\n            if (depth[x] > depth[y]) {\n                pathU.add(x);\n                x = parent[x];\n            } else {\n                pathV.add(y);\n                y = parent[y];\n            }\n        }\n        // x==y is LCA\n        pathU.add(x);\n        Collections.reverse(pathV);\n        cycle = new ArrayList<>(pathU);\n        cycle.addAll(pathV);\n\n        inC = new boolean[n+1];\n        for (int v : cycle) inC[v] = true;\n        posW = new int[n+1];\n        colState = new int[n+1];\n        uncoloredLeft = n;\n\n        // Shrink the odd cycle until it has length 3\n        while (cycle.size() > 3) {\n            // build index‐map of current cycle\n            for (int i = 0; i < cycle.size(); i++) {\n                posW[ cycle.get(i) ] = i;\n            }\n            // force Bob to pick among colors {1,2}\n            out.println(\"1 2\");\n            out.flush();\n\n            int vtx = nextInt();\n            int c   = nextInt();\n            if (vtx < 0) die();\n            colState[vtx] = c;\n            uncoloredLeft--;\n\n            // if he colored outside the cycle, ignore\n            if (!inC[vtx]) continue;\n            // else we shrink around this cycle‐vertex\n            lastW = vtx;\n            shrinkCycle();\n        }\n\n        // Now cycle.size()==3.  Keep offering (1,2).  Eventually these\n        // 3 vertices on a triangle must get only 2 colors, forcing a mono‐edge.\n        while (uncoloredLeft > 0) {\n            out.println(\"1 2\");\n            out.flush();\n            int vtx = nextInt();\n            int c   = nextInt();\n            if (vtx < 0) die();\n            colState[vtx] = c;\n            uncoloredLeft--;\n        }\n    }\n\n    // Remove lastW from the current cycle and re‐attach so as to keep an odd cycle\n    static void shrinkCycle() {\n        int w = lastW;\n        int L = cycle.size();\n        int idx = posW[w];\n        // cycle neighbors of w in the current ring\n        int iNext = (idx + 1) % L;\n        int iPrev = (idx - 1 + L) % L;\n\n        // build the two chordless paths between these neighbors\n        ArrayList<Integer> P1 = new ArrayList<>(); // iNext → ... → iPrev\n        {\n            int cur = iNext;\n            while (true) {\n                P1.add(cycle.get(cur));\n                if (cur == iPrev) break;\n                cur = (cur + 1) % L;\n            }\n        }\n        ArrayList<Integer> P2 = new ArrayList<>(); // iPrev → ... → iNext\n        {\n            int cur = iPrev;\n            while (true) {\n                P2.add(cycle.get(cur));\n                if (cur == iNext) break;\n                cur = (cur - 1 + L) % L;\n            }\n        }\n\n        // we want the path whose number of edges is odd.\n        // Path P has (#vertices-1) edges, so edges%2==1 <=> vertices%2==0\n        ArrayList<Integer> keep = (P1.size() % 2 == 0 ? P1 : P2);\n\n        // rebuild cycle = w + keep\n        for (int v : cycle) inC[v] = false;\n        ArrayList<Integer> newC = new ArrayList<>();\n        newC.add(w);\n        newC.addAll(keep);\n        cycle = newC;\n        for (int v : cycle) inC[v] = true;\n    }\n}\n```\n\nExplanation of key points:\n\n1. We first read the whole graph and run a BFS‐based 2‐coloring test.  \n2. If the graph is bipartite, we immediately declare “Bob” and maintain two sets A/B (the two sides).  On each offered color‐pair \\[a,b\\], we pick any uncolored vertex from the unique side whose color (1 or 2) lies in \\{a,b\\}, thus never forcing a monochromatic edge.  \n3. Otherwise there is an odd cycle; we extract one by retracing parent pointers from a conflicting BFS edge (foundU,foundV).  Alice’s strategy is to repeatedly offer (1,2), ignoring Bob’s colorings outside the cycle, and whenever Bob colors one cycle‐vertex w, we “shrink” the cycle to a strictly smaller odd cycle.  Eventually a triangle remains, and with only two colors on three vertices Bob must create a monochromatic edge.  \n4. After every output we flush, and upon reading a −1 we immediately terminate to avoid timeouts or wrong‐answer feedback."
  }
]