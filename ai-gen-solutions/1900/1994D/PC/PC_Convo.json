[
  {
    "timestamp": "2025-07-24T05:50:30.380749",
    "role": "user",
    "content": "D. Funny Game\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nVanya has a graph with n\n\n vertices (numbered from 1\n\n to n\n\n) and an array a\n\n of n\n\n integers; initially, there are no edges in the graph. Vanya got bored, and to have fun, he decided to perform n−1\n\n operations.\n\n\n\nOperation number x\n\n (operations are numbered in order starting from 1\n\n) is as follows:\n\n\n\nChoose 2\n\n different numbers 1≤u,v≤n\n\n, such that |au−av|\n\n is divisible by x\n\n.\n\nAdd an undirected edge between vertices u\n\n and v\n\n to the graph.\n\nHelp Vanya get a connected∗\n\n graph using the n−1\n\n operations, or determine that it is impossible.\n\n\n\n∗\n\nA graph is called connected if it is possible to reach any vertex from any other by moving along the edges.\n\n\n\nInput\n\nEach test consists of multiple test cases. The first line contains an integer t\n\n (1≤t≤103\n\n) — the number of test cases. Then follows the description of the test cases.\n\n\n\nThe first line of each test case contains the number n\n\n (1≤n≤2000\n\n) — the number of vertices in the graph.\n\n\n\nThe second line of each test case contains n\n\n numbers a1,a2,⋯an\n\n (1≤ai≤109\n\n).\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2000\n\n.\n\n\n\nOutput\n\nFor each test case, if there is no solution, then output \"No\" (without quotes).\n\n\n\nOtherwise, output \"Yes\" (without quotes), and then output n−1\n\n lines, where in the i\n\n-th line, output the numbers u\n\n and v\n\n that need to be chosen for operation i\n\n.\n\n\n\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\n\n\n\nExample\n\nInputCopy\n\n8\n\n2\n\n1 4\n\n4\n\n99 7 1 13\n\n5\n\n10 2 31 44 73\n\n5\n\n87 6 81 44 32\n\n5\n\n62 35 33 79 16\n\n5\n\n6 51 31 69 42\n\n5\n\n52 63 25 21 5\n\n12\n\n33 40 3 11 31 43 37 8 50 5 12 22\n\nOutputCopy\n\nYES\n\n2 1\n\nYES\n\n4 1\n\n2 1\n\n3 2\n\nYES\n\n5 1\n\n4 1\n\n3 1\n\n2 1\n\nYES\n\n4 1\n\n3 1\n\n2 1\n\n5 4\n\nYES\n\n3 1\n\n5 1\n\n2 1\n\n4 2\n\nYES\n\n4 1\n\n5 1\n\n2 1\n\n3 2\n\nYES\n\n2 1\n\n5 2\n\n3 1\n\n4 3\n\nYES\n\n9 1\n\n12 9\n\n11 1\n\n10 1\n\n6 1\n\n7 6\n\n2 1\n\n8 2\n\n5 2\n\n3 1\n\n4 1\n\nNote\n\nLet's consider the second test case.\n\n\n\nFirst operation (x=1)\n\n: we can connect vertices 4\n\n and 1\n\n, since |a4−a1|=|13−99|=|−86|=86\n\n, and 86\n\n is divisible by 1\n\n.\n\n\n\nSecond operation (x=2)\n\n: we can connect vertices 2\n\n and 1\n\n, since |a2−a1|=|7−99|=|−92|=92\n\n, and 92\n\n is divisible by 2\n\n.\n\n\n\nThird operation (x=3)\n\n: we can connect vertices 3\n\n and 2\n\n, since |a3−a2|=|1−7|=|−6|=6\n\n, and 6\n\n is divisible by 3\n\n.\n\nFrom the picture, it can be seen that a connected graph is obtained.\n\nUse Java."
  },
  {
    "timestamp": "2025-07-24T05:52:20.353608",
    "role": "assistant",
    "content": "**Analysis**\n\nWe have \\(n\\) vertices (initially no edges) and an array \\(a\\) of length \\(n\\).  We must perform exactly \\(n-1\\) operations, numbered \\(1,2,\\dots,n-1\\).  In operation \\(x\\), we must choose two distinct vertices \\(u,v\\) so that\n\n\\[\n|a_u - a_v| \\equiv 0 \\pmod x\n\\]\n\nand add the edge \\((u,v)\\).  At the end of all \\(n-1\\) operations, the graph must be connected and has exactly \\(n-1\\) edges, and thus must form a spanning tree (no cycles, since a connected \\(n\\)-vertex graph with \\(n-1\\) edges is a tree).\n\nHence in *each* operation \\(x\\), we must add exactly one edge that joins two previously disconnected components; otherwise either we create a cycle (if we connect within the same component) or we fail to add an edge (and so do fewer than \\(n-1\\) edges total).\n\nKey idea: process the operations in **descending** order of \\(x\\), from \\(x=n-1\\) down to \\(1\\).  At each step \\(x\\),\n\n1.  We look for two vertices \\(u\\) and \\(v\\) lying in *different* current DSU‐components, whose values \\(a_u\\) and \\(a_v\\) are congruent modulo \\(x\\).  Indeed\n   \\[\n     |a_u - a_v|\\equiv 0\\pmod x\n     \\quad\\Longleftrightarrow\\quad\n     a_u \\bmod x = a_v \\bmod x.\n   \\]\n2.  Whenever we find such a pair \\((u,v)\\), we union their two components in our DSU and record that \\((u,v)\\) is the edge chosen in operation \\(x\\).  \n3.  If *no* such cross‐component pair exists for the current \\(x\\), then it is impossible to keep the graph cycle‐free while still using exactly one edge in this operation, so the answer is **No**.\n\nIf we succeed in finding exactly one cross‐component edge for all \\(x=n-1,n-2,\\dots,1\\), then we have added exactly \\(n-1\\) edges, each reducing the component count by one, so we end with a single component.  Thus we have formed a spanning tree, and we output **Yes** and the list of edges in the order of increasing \\(x\\) (since operation \\(x\\) must be reported on the \\(x\\)-th output line).\n\nThe running time is\n\\[\n  \\sum_{x=1}^{n-1}\\bigl(O(x)\\text{ to clear an array of size }x\\;+\\;O(n)\\text{ to scan all vertices}\\bigr)\n  \\;=\\;O(n^2),\n\\]\nwhich is fine for \\(n\\le2000\\).  \n\nBelow is a Java implementation using a standard DSU (union–find) with path compression.\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class DSU {\n        int[] p, r;\n        public DSU(int n) {\n            p = new int[n];\n            r = new int[n];\n            for (int i = 0; i < n; i++) {\n                p[i] = i;\n                r[i] = 0;\n            }\n        }\n        int find(int x) {\n            if (p[x] != x) p[x] = find(p[x]);\n            return p[x];\n        }\n        boolean union(int x, int y) {\n            x = find(x);\n            y = find(y);\n            if (x == y) return false;\n            if (r[x] < r[y]) {\n                p[x] = y;\n            } else if (r[y] < r[x]) {\n                p[y] = x;\n            } else {\n                p[y] = x;\n                r[x]++;\n            }\n            return true;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int t = Integer.parseInt(br.readLine().trim());\n        while (t-- > 0) {\n            int n = Integer.parseInt(br.readLine().trim());\n            int[] a = new int[n];\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            for (int i = 0; i < n; i++) {\n                a[i] = Integer.parseInt(st.nextToken());\n            }\n\n            // ansU[x], ansV[x] will store the edge chosen at operation x (1-based).\n            int[] ansU = new int[n], ansV = new int[n];\n            boolean possible = true;\n            DSU dsu = new DSU(n);\n\n            // For each x = n-1 down to 1, pick exactly one cross-component pair\n            for (int x = n - 1; x >= 1; x--) {\n                // remToRoot[r] = a DSU-root that we've seen with remainder r = a[u]%x\n                // nodeWithRem[r] = one example vertex index that achieves that remainder\n                int[] remToRoot = new int[x];\n                int[] nodeWithRem = new int[x];\n                // initialize to -1 meaning \"unseen\"\n                for (int r = 0; r < x; r++) {\n                    remToRoot[r] = -1;\n                }\n\n                boolean found = false;\n                for (int u = 0; u < n; u++) {\n                    int ru = dsu.find(u);\n                    int r = a[u] % x;\n                    if (remToRoot[r] == -1) {\n                        // first time we see this remainder in this operation\n                        remToRoot[r] = ru;\n                        nodeWithRem[r] = u;\n                    } else if (remToRoot[r] != ru) {\n                        // we found two vertices in different components\n                        int v = nodeWithRem[r];\n                        dsu.union(u, v);\n                        ansU[x] = u + 1;    // convert to 1-based\n                        ansV[x] = v + 1;\n                        found = true;\n                        break;\n                    }\n                    // else same component -> skip\n                }\n                if (!found) {\n                    // no valid cross-component edge at this x\n                    possible = false;\n                    break;\n                }\n            }\n\n            if (!possible) {\n                pw.println(\"No\");\n            } else {\n                pw.println(\"Yes\");\n                // Output the edges in the order of operations 1..n-1\n                for (int x = 1; x < n; x++) {\n                    pw.println(ansU[x] + \" \" + ansV[x]);\n                }\n            }\n        }\n        pw.flush();\n    }\n}\n```\n\nExplanation of the main points:\n\n1. **DSU**  \n   We keep a union–find (disjoint‐set) over the \\(n\\) vertices so that each added edge merges two different components.\n\n2. **Descending \\(x\\)**  \n   Larger \\(x\\) is more restrictive (harder to satisfy divisibility), so we reserve those early.  If at some \\(x\\) we cannot find any edge joining two distinct DSU components that also satisfies\n   \\(\\,|a_u-a_v|\\equiv0\\pmod x\\), we must declare `No`.\n\n3. **Remainder buckets**  \n   Two numbers differ by a multiple of \\(x\\) exactly when they are congruent modulo \\(x\\).  We sweep through the vertices, reduce each \\(a[u]\\bmod x\\), and record the DSU‐root and the vertex index of the *first* occurrence of each remainder.  On seeing a second occurrence whose root is *different*, we have found a valid cross‐component edge for operation \\(x\\).\n\n4. **Tree property**  \n   We add exactly one edge per \\(x\\) from \\(n-1\\) down to \\(1\\), so \\(n-1\\) edges in all, each time reducing the number of components by one.  At the end, we have a single component (i.e.\\ a connected graph) with \\(n-1\\) edges, hence a spanning tree.\n\nThis runs in \\(O(n^2)\\) per test case (clearing an array of size \\(x\\) and scanning \\(n\\) vertices for each \\(x\\)), which is fine for \\(n\\le 2000\\)."
  }
]