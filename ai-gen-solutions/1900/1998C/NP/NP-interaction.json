[
    {
        "request_timestamp": "2025-07-23T18:28:51.253730",
        "response_timestamp": "2025-07-23T18:31:23.838329",
        "sent_messages": [
            {
                "role": "user",
                "content": "Codeforces Problem:\n\nC. Perform Operations to Maximize Score\n\ntime limit per test3 seconds\n\nmemory limit per test256 megabytes\n\nI see satyam343. I'm shaking. Please more median problems this time. I love those. Please satyam343 we believe in you.\n\n— satyam343's biggest fan\n\nYou are given an array a\n\n of length n\n\n and an integer k\n\n. You are also given a binary array b\n\n of length n\n\n.\n\n\n\nYou can perform the following operation at most k\n\n times:\n\n\n\nSelect an index i\n\n (1≤i≤n\n\n) such that bi=1\n\n. Set ai=ai+1\n\n (i.e., increase ai\n\n by 1\n\n).\n\nYour score is defined to be maxi=1n(ai+median(ci))\n\n, where ci\n\n denotes the array of length n−1\n\n that you get by deleting ai\n\n from a\n\n. In other words, your score is the maximum value of ai+median(ci)\n\n over all i\n\n from 1\n\n to n\n\n.\n\n\n\nFind the maximum score that you can achieve if you perform the operations optimally.\n\n\n\nFor an arbitrary array p\n\n, median(p)\n\n is defined as the ⌊|p|+12⌋\n\n-th smallest element of p\n\n. For example, median([3,2,1,3])=2\n\n and median([6,2,4,5,1])=4\n\n.\n\n\n\nInput\n\nThe first line contains an integer t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nEach test case begins with two integers n\n\n and k\n\n (2≤n≤2⋅105\n\n, 0≤k≤109\n\n) — the length of the a\n\n and the number of operations you can perform.\n\n\n\nThe following line contains n\n\n space separated integers a1,a2,…,an\n\n (1≤ai≤109\n\n) — denoting the array a\n\n.\n\n\n\nThe following line contains n\n\n space separated integers b1,b2,…,bn\n\n (bi\n\n is 0\n\n or 1\n\n) — denoting the array b\n\n.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output the maximum value of score you can get on a new line.\n\n\n\nExample\n\nInputCopy\n\n8\n\n2 10\n\n3 3\n\n1 1\n\n3 10\n\n3 3 3\n\n0 0 0\n\n4 4\n\n2 1 5 1\n\n0 1 0 1\n\n5 4\n\n7 5 2 5 4\n\n0 0 1 0 1\n\n5 1\n\n5 15 15 2 11\n\n1 0 0 1 1\n\n5 2\n\n10 11 4 10 15\n\n1 1 0 1 0\n\n4 4\n\n1 1 2 5\n\n1 1 0 0\n\n2 1000000000\n\n1000000000 1000000000\n\n1 1\n\nOutputCopy\n\n16\n\n6\n\n8\n\n13\n\n21\n\n26\n\n8\n\n3000000000\n\nNote\n\nFor the first test case, it is optimal to perform 5\n\n operations on both elements so a=[8,8]\n\n. So, the maximum score we can achieve is max(8+median[8],8+median[8])=16\n\n, as c1=[a2]=[8]\n\n. It can be proven that you cannot get a better score.\n\n\n\nFor the second test case, you are not able to perform operations on any elements, so a\n\n remains [3,3,3]\n\n. So, the maximum score we can achieve is 3+median[3,3]=6\n\n, as c1=[a2,a3]=[3,3]\n\n. It can be proven that you cannot get a better score.\n\n---\n\nUse Java."
            }
        ],
        "received_response": "{\n  \"id\": \"chatcmpl-BwcFEcghkc8lr20Im5g7jW8bCsd9u\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"**Analysis**\\n\\nWe have an array a of length n and a binary mask b of length n.  We may perform up to k “+1” operations, each on an index ​i​ with ​b[i]=1​, to increase ​a[i]​.  After all our operations we look at the resulting array \\\\(a'\\\\), sort it into non‐decreasing order\\n\\\\[\\na'_1 \\\\le a'_2 \\\\le \\\\cdots \\\\le a'_n,\\n\\\\]\\nand our score is\\n\\\\[\\n\\\\;\\\\;a'_n \\\\;+\\\\;a'_{d}\\\\,,\\\\quad\\nd = \\\\left\\\\lfloor \\\\frac{n}{2}\\\\right\\\\rfloor\\\\,.\\n\\\\]\\nWe wish to distribute the ≤ k increments so as to maximize \\\\(a'_n + a'_d\\\\).\\n\\n---\\n\\n**Key reduction**\\n\\n1.  After all operations, let the maximum element be \\\\(a'_n\\\\), and let the “median‐position” be \\\\(a'_d\\\\).  Then the score is\\n   \\\\[\\n     S \\\\;=\\\\; a'_n \\\\;+\\\\;a'_d.\\n   \\\\]\\n2.  We may spend some of our \\\\(k\\\\) increments to raise up the element that ends up in position \\\\(n\\\\); call its initial maximum among \\\\(b[i]=1\\\\) positions \\n   \\\\[\\n      M_1 = \\\\max\\\\,\\\\{\\\\,a_i: b_i=1\\\\},\\n   \\\\]\\n   or \\\\(-\\\\infty\\\\) if no \\\\(b_i=1\\\\).  Similarly, let\\n   \\\\[\\n      M_0 = \\\\max\\\\,\\\\{\\\\,a_i: b_i=0\\\\},\\n   \\\\]\\n   which cannot be incremented.\\n3.  If we spend \\\\(r\\\\) of our \\\\(k\\\\) operations on that “max”‐slot, its final value becomes\\n   \\\\[\\n     \\\\max\\\\Bigl(M_0,\\\\;M_1 + r\\\\Bigr).\\n   \\\\]\\n4.  The other \\\\(k-r\\\\) (or fewer) must be spent raising up small elements so that the \\\\(d\\\\)th‐smallest (of all \\\\(n\\\\)) becomes as large as possible.  Call that target \\\\(m\\\\).  To get \\\\(a'_d\\\\ge m\\\\) in the final sorted array of length \\\\(n\\\\) we need\\n   \\\\[\\n     \\\\underbrace{\\\\#\\\\{i: a_i \\\\ge m\\\\}}_{\\\\text{already }\\\\ge m}\\\\;+\\\\;\\n     \\\\underbrace{\\\\#\\\\{i: b_i=1,\\\\;a_i<m\\\\text{ that we boost}\\\\}}_{\\\\text{exactly enough}}\\n     \\\\;\\\\ge\\\\;\\n     (n-d+1),\\n   \\\\]\\n   i.e.\\\\ we must ensure at least \\\\(n-d+1\\\\) elements are \\\\(\\\\ge m\\\\).  \\n\\n   Let\\n   \\\\[\\n     \\\\text{freeCount}(m)\\n       = \\\\#\\\\{i: a_i\\\\ge m\\\\},\\n   \\\\qquad\\n     t = \\\\max\\\\bigl(0,\\\\,(n-d+1) - \\\\text{freeCount}(m)\\\\bigr).\\n   \\\\]\\n   We must take the \\\\(t\\\\) cheapest \\\\(b_i=1\\\\), \\\\(a_i<m\\\\) elements and raise them to \\\\(m\\\\).  If there are not \\\\(t\\\\) such, it is impossible to reach median \\\\(\\\\ge m\\\\).  Otherwise the cost is\\n   \\\\[\\n     \\\\sum_{j=1}^t \\\\bigl[m - a_{(j)}\\\\bigr],\\n   \\\\]\\n   where \\\\(a_{(1)}\\\\le a_{(2)}\\\\le\\\\cdots\\\\) are those \\\\(b_i=1\\\\), \\\\(a_i<m\\\\).  \\n\\n5.  Thus for each candidate \\\\(m\\\\) we can compute\\n\\n   -  `costMed(m)`: the minimal ops needed to make \\\\(a'_d\\\\ge m\\\\),\\n   -  and hence the remainder `rem = k - costMed(m)` can go to boosting the max‐slot from \\\\(M_1\\\\) up.\\n\\n   The resulting score if `costMed(m) ≤ k` is\\n   \\\\[\\n     S(m)\\n     = m \\\\;+\\\\;\\\\max\\\\bigl(M_0,\\\\;M_1 + (k - \\\\text{costMed}(m))\\\\bigr).\\n   \\\\]\\n   We take the maximum of \\\\(S(m)\\\\) over all feasible \\\\(m\\\\).\\n\\n6.  One sees that a feasible optimum \\\\(m\\\\) will occur either at one of the existing \\\\(a_i\\\\), or at the (integer) largest \\\\(m\\\\) for which `costMed(m) ≤ k`.  Hence we\\n\\n   A.  gather the unique values of \\\\(a_i\\\\) as candidate \\\\(m\\\\)′s,\\n\\n   B.  also binary‐search for the largest integer \\\\(m\\\\) (possibly not in the original list) with `costMed(m) ≤ k`, call it `m_max`,\\n\\n   C.  evaluate \\\\(S(m)\\\\) for all those candidate \\\\(m\\\\), and take the maximum.\\n\\nAll operations run in \\\\(O(n\\\\log n)\\\\) per test (sorting plus binary‐search and a few lookups), which is fine up to total \\\\(n\\\\le 2\\\\cdot10^5\\\\).\\n\\n---\\n\\n```java\\nimport java.io.*;\\nimport java.util.*;\\n\\npublic class Main {\\n    static final long INF = (long)4e18;\\n\\n    public static void main(String[] args) throws IOException {\\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n        StringTokenizer st;\\n\\n        int T = Integer.parseInt(br.readLine());\\n        // We will reuse buffers across testcases but \\n        // total n over all tests <= 2e5 so it's safe.\\n        while (T-- > 0) {\\n            st = new StringTokenizer(br.readLine());\\n            int n = Integer.parseInt(st.nextToken());\\n            long k = Long.parseLong(st.nextToken());\\n\\n            long[] a = new long[n];\\n            int[] b = new int[n];\\n            st = new StringTokenizer(br.readLine());\\n            for (int i = 0; i < n; i++) {\\n                a[i] = Long.parseLong(st.nextToken());\\n            }\\n            st = new StringTokenizer(br.readLine());\\n            for (int i = 0; i < n; i++) {\\n                b[i] = Integer.parseInt(st.nextToken());\\n            }\\n\\n            // Sort all a[] for quick rank queries\\n            Arrays.sort(a);\\n\\n            // Build list of those a[i] where b[i]=1, also sorted\\n            List<Long> B1 = new ArrayList<>();\\n            long M0 = -INF, M1 = -INF;\\n            for (int i = 0; i < n; i++) {\\n                if (b[i] == 1) {\\n                    B1.add(a[i]);\\n                    M1 = Math.max(M1, a[i]);\\n                } else {\\n                    M0 = Math.max(M0, a[i]);\\n                }\\n            }\\n            Collections.sort(B1);\\n\\n            // Prefix sums of B1 for quick \\\"sum of largest t of B1< m\\\"\\n            int sz1 = B1.size();\\n            long[] prefB1 = new long[sz1+1];\\n            prefB1[0] = 0;\\n            for (int i = 0; i < sz1; i++) {\\n                prefB1[i+1] = prefB1[i] + B1.get(i);\\n            }\\n\\n            // Our d = floor(n/2), but to have a'_d >= m in size-n array\\n            // we need at least (n - d + 1) elements >= m.\\n            int d = n/2;\\n            int needed = n - d + 1;\\n\\n            // Extract the unique sorted values of a[] as candidate m's\\n            List<Long> uniq = new ArrayList<>();\\n            uniq.add(a[0]);\\n            for (int i = 1; i < n; i++) {\\n                if (a[i] != a[i-1]) {\\n                    uniq.add(a[i]);\\n                }\\n            }\\n\\n            // A helper to compute costMed(m): the min ops to ensure a'_d >= m,\\n            // or INF if impossible.\\n            class CostMed {\\n                long get(long m) {\\n                    // how many a[] < m ?\\n                    int lt = Arrays.binarySearch(a, m);\\n                    if (lt < 0) lt = -lt - 1;\\n                    // freeCount = how many already >= m\\n                    int freeCnt = n - lt;\\n                    int t = Math.max(0, needed - freeCnt);\\n                    if (t == 0) {\\n                        return 0;\\n                    }\\n                    // among B1, how many are < m ?\\n                    int idx = Collections.binarySearch(B1, m);\\n                    if (idx < 0) idx = -idx - 1;\\n                    if (idx < t) return INF; // not enough boostable\\n                    // sum of the t largest in B1[0..idx-1]\\n                    long sumLastT = prefB1[idx] - prefB1[idx - t];\\n                    return t * m - sumLastT;\\n                }\\n            }\\n            CostMed cm = new CostMed();\\n\\n            // Evaluate S(m) for each unique a[i]\\n            long answer = 0;\\n            for (long m : uniq) {\\n                long c = cm.get(m);\\n                if (c > k) continue;\\n                long rem = k - c;\\n                long bestMax;\\n                // we may choose the b=0 max if that is larger,\\n                // or else boost M1 by rem (if M1 exists).\\n                bestMax = M0;\\n                if (M1 > -INF/2) {\\n                    bestMax = Math.max(bestMax, M1 + rem);\\n                }\\n                answer = Math.max(answer, m + bestMax);\\n            }\\n\\n            // Also binary‐search for the largest m (not necessarily in uniq)\\n            // for which costMed(m) <= k\\n            long lo = 0, hi = a[n-1] + k + 1;\\n            while (lo < hi) {\\n                long mid = (lo + hi + 1) >>> 1;\\n                if (cm.get(mid) <= k) {\\n                    lo = mid;\\n                } else {\\n                    hi = mid - 1;\\n                }\\n            }\\n            // lo is now the maximum m s.t. costMed(m)<=k\\n            if (lo > 0) {\\n                long c = cm.get(lo);\\n                if (c <= k) {\\n                    long rem = k - c;\\n                    long bestMax = M0;\\n                    if (M1 > -INF/2) {\\n                        bestMax = Math.max(bestMax, M1 + rem);\\n                    }\\n                    answer = Math.max(answer, lo + bestMax);\\n                }\\n            }\\n\\n            System.out.println(answer);\\n        }\\n    }\\n}\\n```\\n\\n**Explanation of Key Steps**\\n\\n1.  **Sorting & Prefix Sums**  \\n    We sort the entire array `a[]` (for quick “how many < m” queries via `lower_bound`)  \\n    and we separately gather the subarray of those indices with `b[i]=1`, also sorted,  \\n    with a prefix‐sum array so that in \\\\(O(1)\\\\) we can compute  \\n    \\\\(\\\\sum\\\\) of any consecutive block in that list.\\n\\n2.  **Computing `costMed(m)`**  \\n    To force the \\\\(d\\\\)th smallest of all \\\\(n\\\\) to be at least \\\\(m\\\\), we need at least\\n    \\\\(\\\\,(n-d+1)\\\\) elements \\\\(\\\\ge m\\\\).  Some are already \\\\(\\\\ge m\\\\) (the “freeCount”),\\n    the rest we must boost from among the `b=1` entries that are below \\\\(m\\\\).  \\n    If that set has size `< t`, impossibility \\\\(\\\\to\\\\infty\\\\).  Otherwise\\n    we take the \\\\(t\\\\) largest initial values below \\\\(m\\\\) (so the cheapest “\\\\(m - a_i\\\\)”\\n    costs) and sum those costs.  That is `costMed(m)`.\\n\\n3.  **Maximizing the score**  \\n    Having spent `costMed(m)` operations to make the median \\\\(\\\\ge m\\\\), we have\\n    `k - costMed(m)` left to pump up our eventual maximum‐slot.  If among `b=1`\\n    the max is `M1`, we can raise it by the remainder.  If we also have some\\n    index with `b=0` whose original value `M0` is even higher, we may instead\\n    choose that (we cannot boost it).  Hence the final “max” is\\n    `max(M0, M1 + (k - costMed(m)))`.  We add that to \\\\(m\\\\), producing one\\n    candidate final score\\n    \\\\[\\n      S(m) = m + \\\\max(M_0,\\\\;M_1 + (k - \\\\text{costMed}(m))).\\n    \\\\]\\n    We sweep all “interesting” \\\\(m\\\\).\\n\\n4.  **Candidate \\\\(m\\\\)**  \\n    The cost‐function `costMed(m)` is a piecewise‐linear, nondecreasing function\\n    of \\\\(m\\\\) with break‐points precisely at the distinct \\\\(a_i\\\\).  Hence an\\n    optimum occurs either at one of the original \\\\(a_i\\\\) or at the largest\\n    integer \\\\(m\\\\) for which `costMed(m) ≤ k`.  We therefore:\\n\\n    - Enumerate all distinct \\\\(a_i\\\\) (the “uniq” list).\\n    - Also binary‐search for the maximal \\\\(m\\\\) (not necessarily in that list)\\n      satisfying `costMed(m) ≤ k`.\\n    - Evaluate \\\\(S(m)\\\\) for all these, and take the maximum.\\n\\nThis runs in \\\\(O(n\\\\log n)\\\\) per test (sorting plus a few binary searches), easily\\nwithin the \\\\(n\\\\le2\\\\cdot10^5\\\\), \\\\(T\\\\le10^4\\\\) constraints.\",\n        \"refusal\": null,\n        \"role\": \"assistant\",\n        \"annotations\": [],\n        \"audio\": null,\n        \"function_call\": null,\n        \"tool_calls\": null\n      },\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"protected_material_code\": {\n          \"filtered\": false,\n          \"detected\": true,\n          \"citation\": {\n            \"URL\": \"https://github.com/JDWOON/baekjoon/tree/b200585e57f68f832aa75f61941bc9e19f68c670/10001~20000%2F13401~13500%2F13458%2FMain.java\",\n            \"license\": \"NOASSERTION\"\n          }\n        },\n        \"protected_material_text\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ],\n  \"created\": 1753309736,\n  \"model\": \"o4-mini-2025-04-16\",\n  \"object\": \"chat.completion\",\n  \"service_tier\": null,\n  \"system_fingerprint\": null,\n  \"usage\": {\n    \"completion_tokens\": 22810,\n    \"prompt_tokens\": 836,\n    \"total_tokens\": 23646,\n    \"completion_tokens_details\": {\n      \"accepted_prediction_tokens\": 0,\n      \"audio_tokens\": 0,\n      \"reasoning_tokens\": 19776,\n      \"rejected_prediction_tokens\": 0\n    },\n    \"prompt_tokens_details\": {\n      \"audio_tokens\": 0,\n      \"cached_tokens\": 0\n    }\n  },\n  \"prompt_filter_results\": [\n    {\n      \"prompt_index\": 0,\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"jailbreak\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ]\n}"
    }
]