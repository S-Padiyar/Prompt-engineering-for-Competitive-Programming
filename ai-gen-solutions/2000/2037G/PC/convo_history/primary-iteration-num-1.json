[
  {
    "role": "user",
    "content": "G. Natlan Exploring\n\ntime limit per test4 seconds\n\nmemory limit per test256 megabytes\n\nYou are exploring the stunning region of Natlan! This region consists of n\n\n cities, and each city is rated with an attractiveness ai\n\n. A directed edge exists from City i\n\n to City j\n\n if and only if i<j\n\n and gcd(ai,aj)≠1\n\n, where gcd(x,y)\n\n denotes the greatest common divisor (GCD) of integers x\n\n and y\n\n.\n\n\n\nStarting from City 1\n\n, your task is to determine the total number of distinct paths you can take to reach City n\n\n, modulo 998244353\n\n. Two paths are different if and only if the set of cities visited is different.\n\n\n\nInput\n\nThe first line contains an integer n\n\n (2≤n≤2⋅105\n\n) — the number of cities.\n\n\n\nThe second line contains n\n\n integers a1,a2,…,an\n\n (2≤ai≤106\n\n) — the attractiveness of each city.\n\n\n\nOutput\n\nOutput the total number of distinct paths you can take to reach City n\n\n, modulo 998244353\n\n.\n\n\n\nExamples\n\nInputCopy\n\n5\n\n2 6 3 4 6\n\nOutputCopy\n\n5\n\nInputCopy\n\n5\n\n4 196 2662 2197 121\n\nOutputCopy\n\n2\n\nInputCopy\n\n7\n\n3 6 8 9 11 12 20\n\nOutputCopy\n\n7\n\nInputCopy\n\n2\n\n2 3\n\nOutputCopy\n\n0\n\nNote\n\nIn the first example, the five paths are the following:\n\n\n\nCity 1→\n\n City 5\n\nCity 1→\n\n City 2→\n\n City 5\n\nCity 1→\n\n City 2→\n\n City 3→\n\n City 5\n\nCity 1→\n\n City 2→\n\n City 4→\n\n City 5\n\nCity 1→\n\n City 4→\n\n City 5\n\nIn the second example, the two paths are the following:\n\n\n\nCity 1→\n\n City 3→\n\n City 5\n\nCity 1→\n\n City 2→\n\n City 3→\n\n City 5\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have \\(n\\) cities in a directed acyclic graph (DAG).  City \\(i\\) has an attractiveness \\(a_i\\).  There is a directed edge \\(i \\to j\\) if and only if \\(i<j\\) and \\(\\gcd(a_i,a_j)>1\\).  We want the number of distinct paths from city \\(1\\) to city \\(n\\), modulo \\(998244353\\).\n\nA straightforward DP would be\n\n\\[\n\\mathrm{dp}[j]\n  = \\sum_{\\substack{i<j\\\\\\gcd(a_i,a_j)>1}} \\mathrm{dp}[i],\n\\]\nwith \\(\\mathrm{dp}[1]=1\\).  But a naive \\(\\mathcal O(n^2)\\) check of all earlier \\(i\\) is too large for \\(n\\) up to \\(2\\times10^5\\).\n\nInstead, observe that \\(\\gcd(a_i,a_j)>1\\) exactly when \\(a_i\\) and \\(a_j\\) share at least one prime factor.  If we let for every integer \\(d>1\\)\n\n\\[\nF[d] \\;=\\; \\sum_{\\substack{i<j \\\\ d\\mid a_i}} \\mathrm{dp}[i],\n\\]\n\nthen by the principle of inclusion–exclusion on the prime divisors of \\(a_j\\), one can compute\n\n\\[\n\\mathrm{dp}[j]\n = \\sum_{\\emptyset\\neq S\\subseteq P_j}\n   (-1)^{|S|\\!-\\!1}\\;F\\Bigl(\\prod_{p\\in S}p\\Bigr),\n\\]\nwhere \\(P_j\\) is the (distinct) set of prime divisors of \\(a_j\\).  Equivalently, if we let bitmasks over the \\(k\\) primes of \\(a_j\\) enumerate all its nonempty square‐free divisors \\(d\\), the sign is \\(+1\\) if the subset‐size is odd and \\(-1\\) if it is even.\n\nOnce \\(\\mathrm{dp}[j]\\) is known, we have to update\n\\[\nF\\bigl(\\prod_{p\\in S}p\\bigr)\\;\\mathrel{+}= \\;\\mathrm{dp}[j]\n\\quad\n\\forall\\,\\emptyset\\neq S\\subseteq P_j,\n\\]\nso that future cities \\(k>j\\) can incorporate paths ending at \\(j\\) whenever \\(\\gcd(a_j,a_k)>1\\).\n\nSince each \\(a_i\\le10^6\\) has at most \\(\\sim7\\) distinct prime factors, we do at most \\(2^7-1=127\\) inclusion‐exclusion steps per city.  Thus the overall complexity is\n\\[\nO\\!\\bigl(n\\log a_i \\;+\\; n\\cdot 2^{\\omega(a_i)}\\bigr)\n\\]\nwhich is acceptable for \\(n\\le2\\cdot10^5\\).\n\n**Implementation in Java**\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int MOD = 998244353;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st;\n\n        // Read n\n        int n = Integer.parseInt(in.readLine());\n        // Read a[1..n]\n        int[] a = new int[n+1];\n        int maxA = 0;\n        st = new StringTokenizer(in.readLine());\n        for (int i = 1; i <= n; i++) {\n            a[i] = Integer.parseInt(st.nextToken());\n            if (a[i] > maxA) maxA = a[i];\n        }\n\n        // Sieve for least prime factor up to maxA\n        int[] lpf = new int[maxA+1];\n        for (int i = 2; i <= maxA; i++) {\n            if (lpf[i] == 0) {\n                for (int j = i; j <= maxA; j += i) {\n                    if (lpf[j] == 0) lpf[j] = i;\n                }\n            }\n        }\n\n        // dp[i] = number of paths from 1 to i\n        int[] dp = new int[n+1];\n        // F[d] = sum of dp[i] for all i<current that are divisible by d\n        int[] F = new int[maxA+1];\n\n        // Temporary arrays for building the inclusion-exclusion subsets\n        // max number of distinct primes of any a[i] <= 7,\n        // so 1<<7 = 128 is enough.\n        int[] ds = new int[128];\n        int[] popc = new int[128];\n\n        // Reusable array to hold the distinct prime divisors\n        int[] primes = new int[8];\n\n        // Main DP loop\n        for (int i = 1; i <= n; i++) {\n            // Factor a[i] into distinct primes\n            int x = a[i];\n            int k = 0;\n            while (x > 1) {\n                int p = lpf[x];\n                primes[k++] = p;\n                while (x % p == 0) {\n                    x /= p;\n                }\n            }\n\n            // Build all subset‐products ds[mask] and popcount\n            int limit = 1 << k;\n            ds[0] = 1;\n            popc[0] = 0;\n            for (int mask = 1; mask < limit; mask++) {\n                int low = mask & -mask;               // least significant bit\n                int j = Integer.numberOfTrailingZeros(low);\n                int prev = mask ^ low;\n                ds[mask] = ds[prev] * primes[j];\n                popc[mask] = popc[prev] + 1;\n            }\n\n            // Compute dp[i] by inclusion‐exclusion, except for i=1\n            int dpi = 0;\n            if (i == 1) {\n                dpi = 1;\n            } else {\n                for (int mask = 1; mask < limit; mask++) {\n                    int d = ds[mask];\n                    if ((popc[mask] & 1) == 1) {\n                        // odd number of primes => add F[d]\n                        dpi += F[d];\n                        if (dpi >= MOD) dpi -= MOD;\n                    } else {\n                        // even => subtract F[d]\n                        dpi -= F[d];\n                        if (dpi < 0) dpi += MOD;\n                    }\n                }\n            }\n            dp[i] = dpi;\n\n            // Update F[d] += dp[i] for all nonempty subsets d\n            for (int mask = 1; mask < limit; mask++) {\n                int d = ds[mask];\n                F[d] += dpi;\n                if (F[d] >= MOD) F[d] -= MOD;\n            }\n        }\n\n        // Answer = dp[n]\n        System.out.println(dp[n]);\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Sieve for least prime factor**  \n   We build an array `lpf[v]` which holds the smallest prime dividing `v`, for all \\(v\\le10^6\\).  This lets us factor each \\(a_i\\) in \\(O(\\log a_i)\\) time by repeatedly dividing out `lpf[x]`.\n\n2. **DP with inclusion–exclusion**  \n   - `dp[i]` = number of ways to reach city \\(i\\).  \n   - We keep `F[d]` = sum of `dp[i]` over all previously processed \\(i\\) with \\(d\\mid a_i\\).  \n   - To compute `dp[j]`, we sum over all nonempty subsets \\(S\\) of prime divisors of \\(a_j\\), adding or subtracting `F[d]` where \\(d=\\prod_{p\\in S}p\\).  The sign alternates by the parity of \\(|S|\\).\n\n3. **Updating the data structure**  \n   After we know `dp[i]`, we again loop over all nonempty subsets of its primes and add `dp[i]` to `F[d]`.  This makes city \\(i\\) available for all future cities \\(j>i\\) that share a divisor \\(d>1\\).\n\nBecause each \\(a_i\\) has at most 7 distinct primes (any product of 8 or more distinct primes already exceeds \\(10^6\\)), each city requires at most \\(2^7-1=127\\) subset operations for both the inclusion–exclusion sum and the update, i.e.\\ \\(O(127n)\\).  This runs very comfortably for \\(n\\le2\\times10^5\\)."
  }
]