[
  {
    "role": "user",
    "content": "F. Ardent Flames\n\ntime limit per test4 seconds\n\nmemory limit per test256 megabytes\n\nYou have obtained the new limited event character Xilonen. You decide to use her in combat.\n\n\n\nThere are n\n\n enemies in a line. The i\n\n'th enemy from the left has health hi\n\n and is currently at position xi\n\n. Xilonen has an attack damage of m\n\n, and you are ready to defeat the enemies with her.\n\n\n\nXilonen has a powerful \"ground stomp\" attack. Before you perform any attacks, you select an integer p\n\n and position Xilonen there (p\n\n can be any integer position, including a position with an enemy currently). Afterwards, for each attack, she deals m\n\n damage to an enemy at position p\n\n (if there are any), m−1\n\n damage to enemies at positions p−1\n\n and p+1\n\n, m−2\n\n damage to enemies at positions p−2\n\n and p+2\n\n, and so on. Enemies that are at least a distance of m\n\n away from Xilonen take no damage from attacks.\n\n\n\nFormally, if there is an enemy at position x\n\n, she will deal max(0,m−|p−x|)\n\n damage to that enemy each hit. Note that you may not choose a different p\n\n for different attacks.\n\n\n\nOver all possible p\n\n, output the minimum number of attacks Xilonen must perform to defeat at least k\n\n enemies. If it is impossible to find a p\n\n such that eventually at least k\n\n enemies will be defeated, output −1\n\n instead. Note that an enemy is considered to be defeated if its health reaches 0\n\n or below.\n\n\n\nInput\n\nThe first line contains an integer t\n\n (1≤t≤104\n\n) – the number of test cases.\n\n\n\nThe first line of each test case contains three integers n\n\n, m\n\n, and k\n\n (1≤k≤n≤105\n\n, 1≤m≤109\n\n).\n\n\n\nThe following line contains n\n\n integers h1,h2,...,hn\n\n (1≤hi≤109\n\n).\n\n\n\nThe last line of each testcase contains n\n\n integers x1,x2,...,xn\n\n (1≤xi≤109\n\n, xi<xi+1\n\n for all 1≤i<n\n\n)\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 105\n\n.\n\n\n\nOutput\n\nFor each test case, output an integer on a new line, the minimum number of attacks that must be performed to defeat at least k\n\n enemies. If it is impossible to find a p\n\n such that eventually at least k\n\n enemies will be defeated, output −1\n\n instead.\n\n\n\nExample\n\nInputCopy\n\n6\n\n5 5 3\n\n7 7 7 7 7\n\n1 2 3 4 5\n\n9 5 9\n\n2 4 6 8 10 8 6 4 2\n\n1 2 3 4 5 6 7 8 9\n\n2 10 2\n\n1 1\n\n1 20\n\n2 10 1\n\n69696969 420420420\n\n1 20\n\n2 10 2\n\n10 15\n\n1 19\n\n2 2 2\n\n1000000000 1\n\n1 3\n\nOutputCopy\n\n2\n\n2\n\n-1\n\n6969697\n\n15\n\n1000000000\n\nNote\n\nIn the first testcase, it is optimal to select p=2\n\n. Each attack, the first enemy takes 5−|2−1|=4\n\n damage, the second enemy takes 5\n\n damage, the third enemy takes 4\n\n damage, the fourth enemy takes 3\n\n damage, and the fifth enemy takes 2\n\n damage. After 2\n\n attacks, the first three enemies will be defeated. It can be shown that it is impossible to defeat 3\n\n enemies in less than 2\n\n attacks, no matter which p\n\n is selected.\n\n\n\nIn the second testcase, we must kill all 9\n\n enemies. By selecting p=5\n\n, all nine enemies will be defeated in 2\n\n attacks.\n\n\n\nIn the third testcase, we must kill both enemies. However, it can be shown that no p\n\n selected will damage both enemies at the same time, so the answer is −1\n\n.\n\n\n\nIn the fourth testcase, selecting p=1\n\n will enable us to defeat the first enemy in 6969697\n\n attacks.\n\n\n\nIn the fifth testcase, selecting p=10\n\n will make each enemy take 1\n\n damage per attack. Both enemies will be defeated in 15\n\n attacks.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have \\(n\\) enemies in a line, the \\(i\\)-th enemy at position \\(x_i\\) has health \\(h_i\\).  We pick once and for all a stomp position \\(p\\) (an integer), and each attack deals\n\n\\[\nd_i \\;=\\;\\max\\bigl(0,\\,m - |p - x_i|\\bigr)\n\\]\n\ndamage to enemy \\(i\\).  We repeat the same attack pattern \\(t\\) times.  An enemy \\(i\\) dies if\n\n\\[\nt \\cdot d_i \\;\\ge\\; h_i.\n\\]\n\nWe want to kill at least \\(k\\) enemies, and we wish to minimize the number of attacks \\(t\\).  If no choice of \\(p\\) can ever kill \\(k\\) enemies, we print \\(-1\\).\n\n---\n\n### Reformulation\n\n1.  For a fixed number of attacks \\(t\\), when can we kill enemy \\(i\\)?  \n    We need\n    \\[\n      t\\;\\bigl(m - |p - x_i|\\bigr)\\;\\ge\\;h_i,\\quad\n      \\text{i.e.}\\quad\n      m - |p - x_i|\\;\\ge\\;\\left\\lceil\\frac{h_i}{t}\\right\\rceil.\n    \\]\n    Let\n    \\[\n      \\mathit{need}_i = \\left\\lceil\\frac{h_i}{t}\\right\\rceil.\n    \\]\n    Then \n    \\[\n      |p - x_i|\\;\\le\\; m - \\mathit{need}_i,\n    \\]\n    must hold for \\(i\\) to be killed.  If \\(m - \\mathit{need}_i<0\\), that enemy is impossible to kill in \\(t\\) hits.\n\n2.  Hence each enemy \\(i\\) that *can* be killed in \\(t\\) hits gives an interval of allowed \\(p\\) values,\n    \\[\n      p\\in [\\,x_i - w_i,\\;x_i + w_i],\\quad\n      w_i = m - \\mathit{need}_i\\ge0.\n    \\]\n    We collect all those intervals, and ask: is there an integer \\(p\\) contained in *at least* \\(k\\) of these intervals?\n\n3.  That is exactly the “maximum interval‐overlap” problem: we have a multiset of intervals \\(\\{[L_j,R_j]\\}\\).  We ask if the maximum number of intervals covering any single integer point \\(p\\) is at least \\(k\\).\n\n4.  To decide “is there a \\(p\\) covered by at least \\(k\\) intervals?” we do a standard line‐sweep:  \n   – for each interval \\([L,R]\\), we add an event \\((L,+1)\\) and an event \\((R+1,-1)\\).  \n   – Sort all events by position; sweep a counter.  As soon as the counter hits \\(k\\) or more, we succeed.\n\n5.  We binary‐search on \\(t\\) (the number of attacks) from \\(1\\) up to \\(\\max_i h_i\\).  For each midpoint \\(t\\) we check feasibility in \\(O(n\\log n)\\).  Since \\(\\max h_i\\le10^9\\), the binary search takes about 32 steps, and sorting \\(O(n)\\) intervals costs \\(O(n\\log n)\\) per step.  With the sum of all \\(n\\)\\( \\le10^5\\), this is fast enough in optimized Java.\n\n---\n\n**Implementation**\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    // Fast reader\n    static class FastInput {\n        BufferedInputStream in = new BufferedInputStream(System.in);\n        byte[] buf = new byte[1 << 15];\n        int len, pos;\n        int read() throws IOException {\n            if (len == pos) {\n                len = in.read(buf);\n                pos = 0;\n                if (len == -1) return -1;\n            }\n            return buf[pos++];\n        }\n        int nextInt() throws IOException {\n            int c, x = 0;\n            do {\n                c = read();\n                if (c == -1) return -1;\n            } while (c <= ' ');\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            for (; c >= '0' && c <= '9'; c = read()) {\n                x = x * 10 + (c - '0');\n            }\n            return neg ? -x : x;\n        }\n        long nextLong() throws IOException {\n            int c;\n            long x = 0;\n            do {\n                c = read();\n                if (c == -1) return -1;\n            } while (c <= ' ');\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            for (; c >= '0' && c <= '9'; c = read()) {\n                x = x * 10 + (c - '0');\n            }\n            return neg ? -x : x;\n        }\n    }\n\n    static int n, k;\n    static long m;\n    static long[] h, x;\n\n    // Check if t attacks suffice to kill at least k enemies for some stomp position p\n    static boolean feasible(long t) {\n        // We'll build intervals [L, R] of p that kill each enemy in t hits\n        // Then check if any p is covered by >= k of those intervals.\n        int cnt = 0;\n        int[] start = new int[n], end = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            // need = ceil(h[i]/t)\n            long need = (h[i] + t - 1) / t;\n            if (need > m) continue;   // this enemy cannot be killed in t hits\n            long w = m - need;        // we need |p - x[i]| <= w\n            // interval for p is [x[i]-w, x[i]+w]\n            int L = (int)(x[i] - w);\n            int R = (int)(x[i] + w);\n            start[cnt] = L;\n            end[cnt] = R + 1;  // we'll do a +1 at R+1 for sweep\n            cnt++;\n        }\n\n        if (cnt < k) return false;\n\n        // Sort events\n        Arrays.sort(start, 0, cnt);\n        Arrays.sort(end, 0, cnt);\n\n        // Sweep line\n        int iStart = 0, iEnd = 0, covered = 0;\n        while (iStart < cnt) {\n            if (start[iStart] < end[iEnd]) {\n                // entering an interval\n                covered++;\n                if (covered >= k) return true;\n                iStart++;\n            } else {\n                // leaving an interval\n                covered--;\n                iEnd++;\n            }\n        }\n        // never reached k\n        return false;\n    }\n\n    public static void main(String[] args) throws IOException {\n        FastInput in = new FastInput();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int tcs = in.nextInt();\n        while (tcs-- > 0) {\n            n = in.nextInt();\n            m = in.nextLong();\n            k = in.nextInt();\n\n            h = new long[n];\n            x = new long[n];\n            long maxH = 0;\n            for (int i = 0; i < n; i++) {\n                h[i] = in.nextLong();\n                maxH = Math.max(maxH, h[i]);\n            }\n            for (int i = 0; i < n; i++) {\n                x[i] = in.nextLong();\n            }\n\n            // Binary search on t = number of attacks\n            long left = 1, right = maxH, ans = -1;\n            while (left <= right) {\n                long mid = (left + right) >>> 1;\n                if (feasible(mid)) {\n                    ans = mid;\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n\n            out.println(ans);\n        }\n        out.flush();\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Binary Search**  \n   We search the minimum \\(t\\) in \\([1..\\,\\max_i h_i]\\) for which it is *possible* to kill at least \\(k\\) enemies.  If no such \\(t\\) exists even at \\(t=\\max h_i\\), we output \\(-1\\).\n\n2. **Feasibility Check** (for a fixed \\(t\\))  \n   - For each enemy \\(i\\), compute  \n     \\(\\mathit{need}_i = \\lceil h_i/t\\rceil\\).  \n     If \\(\\mathit{need}_i>m\\), that enemy cannot be killed (damage per hit at best is \\(m\\)), so discard it.\n   - Otherwise the condition \\(t\\bigl(m - |p - x_i|\\bigr)\\ge h_i\\) becomes  \n     \\(|p - x_i|\\le m - \\mathit{need}_i\\).  \n     Thus \\(p\\) must lie in the integer interval  \n     \\([\\,x_i - (m-\\mathit{need}_i),\\;x_i + (m-\\mathit{need}_i)]\\).\n   - We collect these intervals for all “killable” enemies, and check whether there is an integer \\(p\\) that lies in at least \\(k\\) of them.\n   - To do that in \\(O(n\\log n)\\), we use the classic “interval‐overlap” sweep:  \n     – Mark \\((L,+1)\\) and \\((R+1,-1)\\).  \n     – Sort the “start” and “end” arrays.  \n     – Line‐sweep with two pointers, accumulating a coverage counter; if it ever reaches \\(k\\), we return true.\n\n3. **Complexity**  \n   - Each feasibility check is \\(O(n\\log n)\\).  \n   - We do up to \\(\\log(\\max h_i)\\approx 30\\) binary‐search steps.  \n   - Since the sum of \\(n\\) over all test cases is \\(\\le10^5\\), total is about  \n     \\[\n       30\\times(10^5\\log(10^5))\\;\\approx\\;30\\times10^5\\times17\\;\\approx\\;5\\times10^7\n     \\]\n     operations, which runs comfortably within the 4 sec limit in Java."
  }
]