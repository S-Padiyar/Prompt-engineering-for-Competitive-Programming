[
  {
    "role": "user",
    "content": "E. Rendez-vous de Marian et Robin\n\ntime limit per test5 seconds\n\nmemory limit per test256 megabytes\n\nIn the humble act of meeting, joy doth unfold like a flower in bloom.\n\nAbsence makes the heart grow fonder. Marian sold her last ware at the Market at the same time Robin finished training at the Major Oak. They couldn't wait to meet, so they both start without delay.\n\n\n\nThe travel network is represented as n\n\n vertices numbered from 1\n\n to n\n\n and m\n\n edges. The i\n\n-th edge connects vertices ui\n\n and vi\n\n, and takes wi\n\n seconds to travel (all wi\n\n are even). Marian starts at vertex 1\n\n (Market) and Robin starts at vertex n\n\n (Major Oak).\n\n\n\nIn addition, h\n\n of the n\n\n vertices each has a single horse available. Both Marian and Robin are capable riders, and could mount horses in no time (i.e. in 0\n\n seconds). Travel times are halved when riding. Once mounted, a horse lasts the remainder of the travel. Meeting must take place on a vertex (i.e. not on an edge). Either could choose to wait on any vertex.\n\n\n\nOutput the earliest time Robin and Marian can meet. If vertices 1\n\n and n\n\n are disconnected, output −1\n\n as the meeting is cancelled.\n\n\n\nInput\n\nThe first line of the input contains a single integer t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nThe first line of each test case consists of three integers n\n\n, m\n\n, h\n\n (2≤n≤2⋅105,1≤m≤2⋅105,1≤h≤n\n\n) — the number of vertices, the number of edges and the number of vertices that have a single horse.\n\n\n\nThe second line of each test case contains h\n\n distinct integers a1,a2,…,ah\n\n (1≤ai≤n\n\n) — the vertices that have a single horse available.\n\n\n\nThen follow m\n\n lines of each test case, each with three integers ui\n\n, vi\n\n, wi\n\n (1≤ui,vi≤n,2≤wi≤106\n\n) — meaning that there is an edge between vertices ui\n\n and vi\n\n with travel cost wi\n\n seconds without a horse.\n\n\n\nThere are no self loops or multiple edges. By good fortune, all wi\n\n are even integers.\n\n\n\nIt is guaranteed that the sums of both n\n\n and m\n\n over all test cases do not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each test case, output a single integer, the earliest time Robin and Marian can meet. If it is impossible for them to meet, output −1\n\n.\n\n\n\nExample\n\nInputCopy\n\n6\n\n2 1 1\n\n1\n\n1 2 10\n\n3 1 2\n\n2 3\n\n1 2 10\n\n3 3 1\n\n2\n\n1 2 4\n\n1 3 10\n\n2 3 6\n\n4 3 2\n\n2 3\n\n1 2 10\n\n2 3 18\n\n3 4 16\n\n3 2 1\n\n2\n\n1 2 4\n\n1 3 16\n\n7 7 1\n\n3\n\n1 5 2\n\n2 6 12\n\n1 2 12\n\n6 4 8\n\n7 3 4\n\n6 3 4\n\n7 6 4\n\nOutputCopy\n\n5\n\n-1\n\n6\n\n19\n\n14\n\n12\n\nNote\n\nIn the first test case, Marian rides from vertex 1\n\n to vertex 2\n\n, Robin waits.\n\n\n\nIn the second test case, vertices 1\n\n and 3\n\n are not connected.\n\n\n\nIn the third test case, both Marian and Robin travel to vertex 2\n\n to meet.\n\n\n\nIn the fourth test case, Marian travels to vertex 2\n\n without a horse, mounts the horse at vertex 2\n\n and rides to vertex 3\n\n to meet Robin.\n\n\n\nIn the fifth test case, Marian travels to vertex 2\n\n without a horse, mounts the horse at vertex 2\n\n and rides back to vertex 1\n\n and then to vertex 3\n\n. Robin waits.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have an undirected graph on \\(n\\) vertices and \\(m\\) edges.  Marian starts at vertex \\(1\\), Robin at vertex \\(n\\).  Some of the vertices \\(a_1,\\dots,a_h\\) each hold a single horse.  A horse, once mounted, immediately halves the remaining travel‐time on every subsequent edge.  You may mount at most one horse (and it lasts to the end), you cannot dismount, and mounting costs zero time.  Both travelers depart at time \\(0\\), may wait at vertices for the other, and the meeting must occur at a vertex.  We want to minimize the time \\(T\\) such that they can both be at the same vertex at or before \\(T\\).\n\nKey observation:  Since waiting is allowed, the meeting time is\n\\[\n  T = \\min_{v\\in V}\\,\\max\\bigl(\\text{time\\_Marian\\_to}(v),\\;\\text{time\\_Robin\\_to}(v)\\bigr),\n\\]\nwhere each “time\\_X\\_to(\\(v\\))” is the minimum travel‐time from X’s start to \\(v\\), using at most one horse along the way (and paying full cost on edges up to mounting and half cost after).\n\nWe can compute for each start (1 for Marian, \\(n\\) for Robin) the distance to every vertex in **two states**:\n\n  • **State 0** = “on foot, not yet mounted.”  \n  • **State 1** = “already mounted, travelling at half‐speed.”\n\nWe do a 0–1 (well, nonnegative) Dijkstra on \\(2n\\) nodes:\n\n  – Node \\((u,0)\\) is “we are at \\(u\\) on foot.”  \n  – Node \\((u,1)\\) is “we are at \\(u\\) on horseback.”  \n\nTransitions:\n\n  1. From \\((u,0)\\) to \\((u,1)\\) at cost 0 if \\(u\\) has a horse.  \n  2. From \\((u,0)\\) to \\((v,0)\\) at cost \\(w\\) for each edge \\(u\\!-\\!v\\) of weight \\(w\\).  \n  3. From \\((u,1)\\) to \\((v,1)\\) at cost \\(w/2\\) for each edge \\(u\\!-\\!v\\).  \n\nWe run this Dijkstra twice: once from \\((1,0)\\) for Marian, once from \\((n,0)\\) for Robin.  Let\n\n\\[\n  d_{M,0}[u],\\,d_{M,1}[u]\n  \\quad\\text{be Marian’s best times to \\((u,0)\\) and \\((u,1)\\)}, \n\\]\nand similarly \\(\\;d_{R,0}[u],\\,d_{R,1}[u]\\) for Robin.  Then the actual best time to reach vertex \\(u\\) is\n\n\\[\n  D_M[u] = \\min\\bigl(d_{M,0}[u],\\,d_{M,1}[u]\\bigr),\n  \\quad\n  D_R[u] = \\min\\bigl(d_{R,0}[u],\\,d_{R,1}[u]\\bigr).\n\\]\n\nFinally\n\n\\[\n  \\text{answer}\n  \\;=\\;\n  \\min_{u=1\\ldots n}\n  \\max\\bigl(D_M[u],\\,D_R[u]\\bigr),\n\\]\nor \\(-1\\) if no vertex \\(u\\) is reachable by both.\n\nEach test case takes \\(O\\bigl((n+m)\\log(n)\\bigr)\\) for one Dijkstra, so \\(O\\bigl((n+m)\\log n\\bigr)\\) per test.  Since \\(\\sum n,\\sum m\\le 2\\times10^5\\), this easily fits under the 5s limit with a good priority queue implementation in Java.\n\n---\n\n**Implementation in Java**\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final long INF = Long.MAX_VALUE / 4;\n\n    static class Edge {\n        int to;\n        int w;\n        Edge(int t, int ww) { to = t; w = ww; }\n    }\n\n    // Dijkstra over 2*n states: (u,0) = on foot, (u,1) = on horseback.\n    // horse[u] = true if there's a horse at u.\n    // Returns an array best[u] = min time to reach u in either state.\n    static long[] multiStateDijkstra(int n, List<Edge>[] adj, boolean[] horse, int start) {\n        int N = 2 * n;\n        long[] dist = new long[N];\n        Arrays.fill(dist, INF);\n        // priority queue of (dist, nodeIndex)\n        PriorityQueue<long[]> pq = new PriorityQueue<>(Comparator.comparingLong(a -> a[0]));\n\n        // start at (start, state=0)\n        dist[start] = 0L;\n        pq.add(new long[]{0L, start});\n\n        while (!pq.isEmpty()) {\n            long[] cur = pq.poll();\n            long cd = cur[0];\n            int idx = (int) cur[1];\n            if (cd > dist[idx]) continue;\n            \n            int u = idx < n ? idx : (idx - n);\n            int state = idx < n ? 0 : 1;\n\n            // If on foot and there's a horse here, try mounting for 0 cost:\n            if (state == 0 && horse[u]) {\n                int nxt = u + n; // (u,1)\n                if (dist[nxt] > cd) {\n                    dist[nxt] = cd;\n                    pq.add(new long[]{cd, nxt});\n                }\n            }\n\n            // Traverse edges\n            for (Edge e : adj[u]) {\n                int v = e.to;\n                long cost = cd + (state == 0 ? e.w : e.w / 2);\n                int nxtIdx = (state == 0 ? v : v + n);\n                if (dist[nxtIdx] > cost) {\n                    dist[nxtIdx] = cost;\n                    pq.add(new long[]{cost, nxtIdx});\n                }\n            }\n        }\n\n        // Build the best[u] = min(dist[u,0], dist[u,1])\n        long[] best = new long[n];\n        for (int u = 0; u < n; u++) {\n            best[u] = Math.min(dist[u], dist[u + n]);\n        }\n        return best;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        int t = Integer.parseInt(in.readLine().trim());\n        while (t-- > 0) {\n            StringTokenizer st = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int m = Integer.parseInt(st.nextToken());\n            int h = Integer.parseInt(st.nextToken());\n\n            // read horse locations\n            boolean[] horse = new boolean[n];\n            st = new StringTokenizer(in.readLine());\n            for (int i = 0; i < h; i++) {\n                int v = Integer.parseInt(st.nextToken()) - 1;\n                horse[v] = true;\n            }\n\n            // build graph\n            List<Edge>[] adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();\n            for (int i = 0; i < m; i++) {\n                st = new StringTokenizer(in.readLine());\n                int u = Integer.parseInt(st.nextToken()) - 1;\n                int v = Integer.parseInt(st.nextToken()) - 1;\n                int w = Integer.parseInt(st.nextToken());\n                adj[u].add(new Edge(v, w));\n                adj[v].add(new Edge(u, w));\n            }\n\n            // Dijkstra from Marian's start (1 → index 0)\n            long[] Dm = multiStateDijkstra(n, adj, horse, 0);\n            // Dijkstra from Robin's start (n → index n-1)\n            long[] Dr = multiStateDijkstra(n, adj, horse, n - 1);\n\n            // find min over vertices of max(Dm[u], Dr[u])\n            long ans = INF;\n            for (int u = 0; u < n; u++) {\n                if (Dm[u] < INF && Dr[u] < INF) {\n                    long meet = Math.max(Dm[u], Dr[u]);\n                    if (meet < ans) ans = meet;\n                }\n            }\n            out.println(ans == INF ? -1 : ans);\n        }\n        out.flush();\n    }\n}\n```\n\n**Explanation of the Main Steps**\n\n1. We convert each vertex \\(u\\) into two “states” in our Dijkstra:\n   - \\((u,0)\\) = on foot, not yet mounted.\n   - \\((u,1)\\) = on horseback.\n\n2. From \\((u,0)\\) you may  \n   - do a zero‐cost transition to \\((u,1)\\) if there is a horse at \\(u\\).  \n   - traverse any edge \\(u\\!-\\!v\\) at full cost \\(w\\), staying in on‐foot state.\n\n3. From \\((u,1)\\) you traverse edges \\(u\\!-\\!v\\) at half cost \\(w/2\\), staying mounted.\n\n4. We run Dijkstra on this \\(2n\\)-node graph **twice**—once from \\((1,0)\\) for Marian, once from \\((n,0)\\) for Robin—to get, for each \\(u\\), the best time to reach \\(u\\) in either state.\n\n5. Finally we take  \n\\[\n   \\min_{u=1\\ldots n}\\max\\bigl(\\text{MarianTime}(u),\\;\\text{RobinTime}(u)\\bigr).\n\\]\nIf no vertex is reachable by both, we output \\(-1\\).\n\nThis runs in \\(O((n+m)\\log n)\\) per test, which is efficient enough for \\(\\sum n,\\sum m\\le 2\\cdot10^5\\)."
  }
]