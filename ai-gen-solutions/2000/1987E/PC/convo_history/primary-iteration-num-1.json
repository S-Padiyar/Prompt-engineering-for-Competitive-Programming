[
  {
    "role": "user",
    "content": "E. Wonderful Tree!\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nGod's Blessing on This ArrayForces!\n\nA Random Pebble\n\nYou are given a tree with n\n\n vertices, rooted at vertex 1\n\n. The i\n\n-th vertex has an integer ai\n\n written on it.\n\n\n\nLet L\n\n be the set of all direct children∗\n\n of v\n\n. A tree is called wonderful, if for all vertices v\n\n where L\n\n is not empty,\n\nav≤∑u∈Lau.\n\nIn one operation, you choose any vertex v\n\n and increase av\n\n by 1\n\n.\n\n\n\nFind the minimum number of operations needed to make the given tree wonderful!\n\n\n\n∗\n\n Vertex u\n\n is called a direct child of vertex v\n\n if:\n\n\n\nu\n\n and v\n\n are connected by an edge, and\n\nv\n\n is on the (unique) path from u\n\n to the root of the tree.\n\nInput\n\nEach test contains multiple test cases. The first line of input contains a single integer t\n\n (1≤t≤1000\n\n) — the number of test cases. The description of the test cases follows.\n\n\n\nThe first line of each test case contains a single integer n\n\n (2≤n≤5000\n\n) — the number of vertices in the tree.\n\n\n\nThe second line of each test case contains n\n\n integers a1,a2,…,an\n\n (0≤ai≤109\n\n) — the values initially written on the vertices.\n\n\n\nThe third line of each test case contains n−1\n\n integers p2,p3,…,pn\n\n (1≤pi<i\n\n), indicating that there is an edge from vertex pi\n\n to vertex i\n\n. It is guaranteed that the given edges form a tree.\n\n\n\nIt is guaranteed that the sum of n\n\n over all test cases does not exceed 5000\n\n.\n\n\n\nOutput\n\nFor each test case, output a single integer — the minimum number of operations needed to make the tree wonderful.\n\n\n\nExample\n\nInputCopy\n\n4\n\n5\n\n9 3 4 1 2\n\n1 1 3 3\n\n2\n\n5 3\n\n1\n\n2\n\n36 54\n\n1\n\n3\n\n0 0 0\n\n1 2\n\nOutputCopy\n\n3\n\n2\n\n0\n\n0\n\nNote\n\nThe tree in the first test case:\n\n\n\n\n\nYou can apply the operation once on vertex 5\n\n and twice on vertex 2\n\n to get a wonderful tree.\n\n\n\nIn the second test case, you can apply the operation twice on vertex 2\n\n to get a wonderful tree.\n\n\n\nIn the third and fourth test cases, the tree is already wonderful, so you don't need to apply any operations.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have a rooted tree (root = 1) of \\(n\\) vertices, each vertex \\(v\\) carrying an initial value \\(a_v\\).  We may do any number of operations; each operation picks a single vertex and increments its current value by 1.  We wish to make the tree *wonderful*, meaning that for every non‐leaf vertex \\(v\\) with direct children \\(C(v)\\), we have\n\n\\[\n   a_{v}\\;\\le\\;\\sum_{u\\in C(v)}a_{u}\\,.\n\\]\n\nWe must find the minimum total number of increments (operations) needed.\n\nA key observation is that we never gain by incrementing an internal node: if an internal node \\(v\\) has “slack” to grow without violating its own child‐sum constraint, that slack costs exactly 1 per unit (just operating on \\(v\\) itself).  But once that slack is used up, further increments on \\(v\\) would force us to also increment its children so as to maintain \\(a_v\\le\\sum a_{u\\in C(v)}\\).  In contrast, if we push all needed increments *down* to leaves in the subtrees, those leaves have no constraints of their own and so we never force any cascading further increments.\n\nThis suggests a bottom‐up (post‐order) DP.  For each node \\(v\\), after we have processed all its children, we will know for each child \\(c\\):\n\n- `b[c]` = the *final* value of child \\(c\\) after all increments in the sub‐tree of \\(c\\).\n- `s[c]` = “slack” in \\(c\\), i.e.\\ how many times we can still increment \\(c\\) itself at cost 1 each without ever having to push more increments into \\(c\\)’s own children.\n- `r[c]` = the cost of *one* increment to the *value* of \\(c\\) *once that slack is exhausted*.  Equivalently, if slack is 0, one more unit to \\(a_c\\) forces us to pay 1 for the increment on \\(c\\) plus whatever is the cheapest cost among its children to raise their sum by 1.  \n\nConcretely, for a leaf \\(c\\), we set\n\n- `b[c] = a[c]` (no increments yet in that subtree),\n- `s[c] = +∞` (we can pump as many increments into a leaf as we like, at cost 1 each, with no further obligations),\n- `r[c] = 1`  (even beyond slack we just pay 1 per unit on the leaf).\n\nFor an internal node \\(v\\) with children \\(c_1,\\dots,c_k\\), suppose each child has its final `(b[c_i], s[c_i], r[c_i])`.  We compute:\n\n1.  `sumB = b[c_1]+…+b[c_k]`.  \n2.  If `sumB >= a[v]`, we have no deficit; define  \n      ```\n        s[v] = sumB - a[v],   // leftover slack\n        r[v] = (s[v]>0 ? 1 : 1 + min_i r[c_i]),\n        b[v] = a[v].\n      ```\n3.  Otherwise there is a deficit `D = a[v] - sumB`.  To fix it, we *must* increment some of the children.  Each child c_i has up to `s[c_i]` “cheap” units at cost 1 each, plus infinite units at cost `r[c_i]` each.  \n   -  First we consume cheap slack from those children **with largest** `r[c_i]` first (so as to preserve the cheap slack of the low‐`r` children for higher‐level needs).  Each unit of slack we use costs 1.  \n   -  If we still have residual deficit, we buy those units at the **smallest** `r[c_i]` (because once slack runs out, each further unit from child \\(c_i\\) costs `r[c_i]`).  \n\n   We update the total cost by the exact number of units \\(\\times\\) their per‐unit cost, we also update each `b[c_i]` and its remaining `s[c_i]` accordingly (slack reduces as we use it; once we buy unlimited we leave slack at 0), and after satisfying the deficit we end up with `sumB = a[v]`, so slack of \\(v\\) is `s[v]=0`.  \n\nFinally, the answer is the total cost accumulated when we call this DP on the root.\n\nThe overall complexity is \\(O(n\\log n)\\) per tree (the dominant cost is sorting the children of each node by their rates), which is fine for \\(n\\le5000\\) in total.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final long INF = (long)1e18;\n    static ArrayList<Integer>[] children;\n    static long[] a, b, s, r;\n    static long totalCost;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(in.readLine().trim());\n        StringBuilder sb = new StringBuilder();\n        while (t-- > 0) {\n            int n = Integer.parseInt(in.readLine().trim());\n            a = new long[n+1];\n            b = new long[n+1];\n            s = new long[n+1];\n            r = new long[n+1];\n            children = new ArrayList[n+1];\n            for (int i = 1; i <= n; i++) {\n                children[i] = new ArrayList<>();\n            }\n            String[] parts = in.readLine().trim().split(\" \");\n            for (int i = 1; i <= n; i++) {\n                a[i] = Long.parseLong(parts[i-1]);\n            }\n            parts = in.readLine().trim().split(\" \");\n            for (int i = 2; i <= n; i++) {\n                int p = Integer.parseInt(parts[i-2]);\n                children[p].add(i);\n            }\n\n            totalCost = 0;\n            dfs(1);\n\n            sb.append(totalCost).append('\\n');\n        }\n        System.out.print(sb);\n    }\n\n    // Post-order\n    static void dfs(int v) {\n        // Leaf?\n        if (children[v].isEmpty()) {\n            b[v] = a[v];\n            s[v] = INF;    // infinite slack\n            r[v] = 1;      // cost 1 per unit always\n            return;\n        }\n\n        // First process children\n        for (int c : children[v]) {\n            dfs(c);\n        }\n\n        // Gather child data\n        int k = children[v].size();\n        long sumB = 0;\n        long minR = Long.MAX_VALUE;\n        for (int c : children[v]) {\n            sumB += b[c];\n            minR = Math.min(minR, r[c]);\n        }\n\n        // If we are below a[v], pay increments on children\n        long deficit = Math.max(0L, a[v] - sumB);\n        if (deficit > 0) {\n            // Build list of (r[c], c) pairs\n            List<Map.Entry<Long,Integer>> list = new ArrayList<>();\n            for (int c : children[v]) {\n                list.add(new AbstractMap.SimpleEntry<>(r[c], c));\n            }\n            // 1) consume cheap slack from largest r[c] first\n            list.sort((e1, e2) -> Long.compare(e2.getKey(), e1.getKey()));\n\n            long need = deficit;\n            for (var ent : list) {\n                if (need <= 0) break;\n                int c = ent.getValue();\n                long use = Math.min(s[c], need);\n                if (use > 0) {\n                    s[c] -= use;\n                    b[c] += use;\n                    totalCost += use;  // cost 1 per unit\n                    need -= use;\n                }\n            }\n\n            // 2) if still need > 0, buy at smallest r[c]\n            if (need > 0) {\n                long bestR = Long.MAX_VALUE;\n                int bestChild = -1;\n                for (int c : children[v]) {\n                    if (r[c] < bestR) {\n                        bestR = r[c];\n                        bestChild = c;\n                    }\n                }\n                // buy 'need' units from bestChild\n                totalCost += bestR * need;\n                b[bestChild] += need;\n                // its slack is already 0 or was used up\n                need = 0;\n            }\n\n            sumB = a[v];  // we've made sumB reach a[v]\n        }\n\n        // Now no deficit remains\n        b[v] = a[v];\n        s[v] = sumB - a[v];  // slack for v\n\n        // cost to push one more unit into v\n        if (s[v] > 0) {\n            r[v] = 1;\n        } else {\n            // slack==0: must pay 1 + cheapest child's rate\n            long best = Long.MAX_VALUE;\n            for (int c : children[v]) {\n                best = Math.min(best, r[c]);\n            }\n            r[v] = 1 + best;\n        }\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1.  **Leaf initialization**  \n    A leaf has no child‐sum constraint on its own.  We can increment a leaf by 1 any number of times at cost 1 each, and it will never force us to “pay again” downwards.  \n    Hence we set  \n    ```\n      b[leaf] = a[leaf];\n      s[leaf] = +∞;   // unlimited “cheap” slack\n      r[leaf] = 1;    // each extra unit costs exactly 1\n    ```\n\n2.  **Processing an internal node**  \n    After processing all children we know:\n    - `b[c]`: the *final* value at child \\(c\\).  \n    - `s[c]`: how many units of “slack” \\(c\\) still has at cost 1 per unit.  \n    - `r[c]`: once that slack is exhausted, each further unit on \\(c\\) effectively costs `r[c]`.  \n\n    We sum up `sumB = sum b[c]`.  \n    - If `sumB >= a[v]`, no extra work is needed to make \\(v\\) satisfy `a[v] ≤ sum b[c]`.  We set  \n      ```\n        s[v] = sumB − a[v];\n        r[v] = (s[v]>0 ? 1 : 1 + min_c r[c]);\n        b[v] = a[v];\n      ```\n    - Otherwise we have a deficit `D = a[v] − sumB`.  We *must* push exactly `D` units of increment down onto the children.  \n      1.  First consume up to `s[c]` units (each at cost 1) from those children with the *highest* `r[c]`—so that if future steps need “cheap slack,” we still have it in the children that force us to pay more later.  \n      2.  If we still have leftover deficit, we buy those units at the *minimum* `r[c]` among the children (since beyond slack each unit on child \\(c\\) costs `r[c]`).  \n      We add all those costs to our global `totalCost`, and we also update each child’s `b[c]` and reduce its `s[c]` if we used slack.  \n\n3.  **Answer**  \n   After we run `dfs(1)`, `totalCost` is the minimal number of increments needed to make the entire tree wonderful.  \n\nThis solves the problem in \\(O(n\\log n)\\) per test by sorting each node’s children at most once, easily handling \\(n\\le5000\\)."
  }
]