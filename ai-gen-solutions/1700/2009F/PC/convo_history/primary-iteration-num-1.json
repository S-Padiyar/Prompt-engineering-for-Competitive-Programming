[
  {
    "role": "user",
    "content": "F. Firefly's Queries\n\ntime limit per test2 seconds\n\nmemory limit per test256 megabytes\n\nFirefly is given an array a\n\n of length n\n\n. Let ci\n\n denote the i\n\n'th cyclic shift∗\n\n of a\n\n. She creates a new array b\n\n such that b=c1+c2+⋯+cn\n\n where +\n\n represents concatenation†\n\n.\n\n\n\nThen, she asks you q\n\n queries. For each query, output the sum of all elements in the subarray of b\n\n that starts from the l\n\n-th element and ends at the r\n\n-th element, inclusive of both ends.\n\n\n\n∗\n\nThe x\n\n-th (1≤x≤n\n\n) cyclic shift of the array a\n\n is ax,ax+1…an,a1,a2…ax−1\n\n. Note that the 1\n\n-st shift is the initial a\n\n.\n\n\n\n†\n\nThe concatenation of two arrays p\n\n and q\n\n of length n\n\n (in other words, p+q\n\n) is p1,p2,...,pn,q1,q2,...,qn\n\n.\n\n\n\nInput\n\nThe first line contains t\n\n (1≤t≤104\n\n) — the number of test cases.\n\n\n\nThe first line of each test case contains two integers n\n\n and q\n\n (1≤n,q≤2⋅105\n\n) — the length of the array and the number of queries.\n\n\n\nThe following line contains n\n\n integers a1,a2,...,an\n\n (1≤ai≤106\n\n).\n\n\n\nThe following q\n\n lines contain two integers l\n\n and r\n\n (1≤l≤r≤n2\n\n) — the left and right bounds of the query.\n\n\n\nNote that the large inputs may require the use of 64-bit integers.\n\n\n\nIt is guaranteed that the sum of n\n\n does not exceed 2⋅105\n\n and the sum of q\n\n does not exceed 2⋅105\n\n.\n\n\n\nOutput\n\nFor each query, output the answer on a new line.\n\n\n\nExample\n\nInputCopy\n\n5\n\n3 3\n\n1 2 3\n\n1 9\n\n3 5\n\n8 8\n\n5 5\n\n4 8 3 2 4\n\n1 14\n\n3 7\n\n7 10\n\n2 11\n\n1 25\n\n1 1\n\n6\n\n1 1\n\n5 7\n\n3 1 6 10 4\n\n3 21\n\n6 17\n\n2 2\n\n1 5\n\n1 14\n\n9 15\n\n12 13\n\n5 3\n\n4 9 10 10 1\n\n20 25\n\n3 11\n\n20 22\n\nOutputCopy\n\n18\n\n8\n\n1\n\n55\n\n20\n\n13\n\n41\n\n105\n\n6\n\n96\n\n62\n\n1\n\n24\n\n71\n\n31\n\n14\n\n44\n\n65\n\n15\n\nNote\n\nFor the first test case, b=[1,2,3,2,3,1,3,1,2]\n\n.\n\nUse Java."
  },
  {
    "role": "assistant",
    "content": "**Analysis**\n\nWe have an array \\(a\\) of length \\(n\\).  Define its cyclic shifts\n\n  \\(c_1 = a_1,a_2,\\dots,a_n\\),  \n  \\(c_2 = a_2,a_3,\\dots,a_n,a_1\\),  \n  \\(\\dots\\)  \n  \\(c_n = a_n,a_1,\\dots,a_{n-1}\\).  \n\nWe then form a huge array \\(b\\) by concatenating all these shifts:\n\n\\[\n  b = c_1 \\;+\\; c_2 \\;+\\;\\cdots+\\; c_n.\n\\]\nEach \\(c_i\\) has length \\(n\\), so \\(|b| = n^2\\).  We must answer \\(q\\) queries, each asking for\n\\[\n  \\sum_{x=\\ell}^{r} b_x\n\\]\n(1-based indices).  Of course \\(n^2\\) can be as large as \\((2\\cdot10^5)^2=4\\cdot10^{10}\\), so we\ncannot build \\(b\\) explicitly nor precompute a prefix‐sum array of length \\(n^2\\).\n\nHowever, each block \\(c_t\\) (with \\(t\\) from \\(1\\) to \\(n\\)) has the same total sum, namely\n\\[\n   \\sum_{i=1}^n a_i \\;=\\; S_a.\n\\]\nThus if we want the prefix‐sum of \\(b\\) up to position \\(x\\) (0‐based), we can write\n\\[\n  \\text{Let }t = \\lfloor x / n\\rfloor,\\quad p = x \\bmod n.\n\\]\nThen\n\\[\n  \\sum_{i=0}^{x} b_i \n     = t \\times S_a \\;\\;+\\;\\;\n       \\bigl(\\text{sum of the first }(p+1)\\text{ entries of the }t\\text{-th block}\\bigr).\n\\]\nIn the \\(t\\)-th block (0‐based), the \\(p\\)-th element is\n\\[\n  b_{\\,t\\cdot n + p} \\;=\\; a_{(t+p)\\bmod n}.\n\\]\nSo we need the sum of \n\\[\n  a_{\\,t\\bmod n},\\,a_{(t+1)\\bmod n},\\dots,a_{(t+p)\\bmod n}.\n\\]\nTo handle that wrap‐around cleanly in \\(O(1)\\), we duplicate the array \\(a\\) end‐to‐end to form\nan array of length \\(2n\\), build its prefix sums, and then any interval of length \\(\\le n\\)\ncan be fetched in \\(O(1)\\).  Concretely:\n\n  1. Read \\(a[0\\dots n-1]\\) and compute \\(S_a = \\sum_{i=0}^{n-1} a_i\\).\n  2. Build `pre2[0..2n-1]` where  \n     \\(\\displaystyle \\text{pre2}[i] = \\sum_{j=0}^{i} a_{\\,j \\bmod n}.\\)\n  3. Define a function\n     \\[\n       \\mathrm{prefixB}(x) = \n          \\begin{cases}\n            0, & x < 0,\\\\\n            t\\cdot S_a \\;+\\; \\bigl(\\mathrm{pre2}[\\,t+p\\,] \n                   - (\\,t>0 ? \\mathrm{pre2}[\\,t-1\\,]:0)\\bigr),\n             & x \\ge 0,\n          \\end{cases}\n       \\quad\\text{where }t = \\lfloor x / n\\rfloor,\\,p = x \\bmod n.\n     \\]\n  4. Then the answer to the query \\(\\ell,r\\) (1‐based) is\n     \\[\n       \\mathrm{prefixB}(r-1)\\;-\\;\\mathrm{prefixB}(\\ell-1-1).\n     \\]\n\nEach query is answered in \\(O(1)\\) time after \\(O(n)\\) preprocessing for one test case.  Since\n\\(\\sum n, \\sum q\\le 2\\cdot 10^5\\), the total time is \\(O(\\sum n + \\sum q)\\), which is efficient.\n\n---\n\n```java\nimport java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader  br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter     out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        StringTokenizer st;\n\n        int t = Integer.parseInt(br.readLine().trim());\n        while (t-- > 0) {\n            st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int q = Integer.parseInt(st.nextToken());\n\n            // Read the array a[0..n-1]\n            int[] a = new int[n];\n            st = new StringTokenizer(br.readLine());\n            long sumA = 0;\n            for (int i = 0; i < n; i++) {\n                a[i] = Integer.parseInt(st.nextToken());\n                sumA += a[i];\n            }\n\n            // Build prefix sums of the \"doubled\" array to handle wrap-around\n            // pre2[i] = sum of a[0..i] in the infinite repetition sense, for i in [0..2n-1].\n            long[] pre2 = new long[2 * n];\n            for (int i = 0; i < 2 * n; i++) {\n                pre2[i] = (i == 0 ? 0 : pre2[i - 1]) + a[i % n];\n            }\n\n            // A helper to get sum of b[0..x] (0-based).  If x<0, returns 0.\n            // Otherwise, number of full blocks = t = x / n, remainder = p = x % n.\n            // Sum = t * sumA + sum of a[t..t+p] in the circular manner, \n            // fetched via pre2.\n            java.util.function.LongUnaryOperator prefixB = (long x) -> {\n                if (x < 0) return 0L;\n                long tBlocks = x / n;\n                int p = (int)(x % n);\n                int start = (int)tBlocks;       // block start in the doubled array\n                int end   = start + p;          // end index in the doubled array\n                long partial = pre2[end] - (start > 0 ? pre2[start - 1] : 0L);\n                return tBlocks * sumA + partial;\n            };\n\n            // Answer queries\n            for (int i = 0; i < q; i++) {\n                st = new StringTokenizer(br.readLine());\n                long L = Long.parseLong(st.nextToken()) - 1;  // to 0-based\n                long R = Long.parseLong(st.nextToken()) - 1;\n                long answer = prefixB.applyAsLong(R)\n                                 - prefixB.applyAsLong(L - 1);\n                out.println(answer);\n            }\n        }\n        out.flush();\n    }\n}\n```\n\n**Explanation of Key Steps**\n\n1. **Avoid building** the \\(n^2\\)-length array \\(b\\).  We only need its *prefix‐sum function*.\n2. Any position \\(x\\) in \\(b\\) lies in block number \\(t = \\lfloor x/n\\rfloor\\) (0‐based), with\n   offset \\(p = x \\bmod n\\) inside that block.\n3. Each block has total sum \\(\\sum a_i\\).  Summing all full blocks is \\(t\\cdot\\sum a_i\\).\n4. The remainder is the first \\(p+1\\) elements of the \\(t\\)-th cyclic shift, i.e.\\  \n   \\(a_{t \\bmod n},a_{(t+1)\\bmod n},\\dots,a_{(t+p)\\bmod n}\\).  \n   We handle that quickly by doubling \\(a\\) end‐to‐end, building a prefix array of length \\(2n\\),\n   and extracting any run of length \\(\\le n\\) in \\(O(1)\\).\n5. Each query \\([\\ell,r]\\) turns into\n   \\[\n     \\text{answer} = \\PrefixB(r-1)\\;-\\;\\PrefixB(\\ell-1-1).\n   \\]\n   All computations are \\(O(1)\\) per query, after an \\(O(n)\\) build per test case."
  }
]