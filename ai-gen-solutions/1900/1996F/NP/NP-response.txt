**Analysis**

We have two arrays \(a\) and \(b\), each of length \(n\).  Initially our score is 0.  In each operation:

- We pick an index \(i\).
- We add \(a_i\) to our score.
- We then update  
  \[
    a_i \;\leftarrow\; \max\bigl(0,\,a_i - b_i\bigr).
  \]

We may perform up to \(k\) such operations, and we want to maximize the total score.

---

### Reformulation as “take the top-\(k\) values from many arithmetic sequences”

Observe that each index \(i\) generates an arithmetic sequence of values

\[
  a_i,\; a_i - b_i,\; a_i - 2b_i,\; \dots
\]

(and once we drop to \(0\) or below, further picks yield \(0\)).  Hence the problem of choosing \(k\) operations to maximize the total score is equivalent to choosing the \(k\) largest terms across all these sequences.

-  If there are fewer than \(k\) *positive* terms in total, then obviously we just take them all (the rest of our picks, if any, must be zeros).
-  Otherwise, let us only consider terms \(\ge1\).  We want the sum of the top \(k\) terms among all positive terms.

---

### Finding the “threshold” via binary search

Let us define for an integer \(x\ge1\):

\[
  C(x)\;=\;\sum_{i=1}^n
    \Bigl(\,\text{number of terms in the \(i\)th sequence that are }\ge x\Bigr).
\]

Concretely, if \(a_i < x\) then that sequence has 0 terms \(\ge x\).  Otherwise,

\[
  \text{#terms}\;\ge x
  \;=\;
  \left\lfloor\frac{a_i - x}{b_i}\right\rfloor + 1.
\]

Since the sequences are strictly decreasing by \(b_i\), the count is exactly that.  Then \(C(x)\) is the total number of all terms across all sequences that are at least \(x\).

-  As \(x\) grows, \(C(x)\) is nonincreasing.
-  If \(C(x)\ge k\), it means there are at least \(k\) terms \(\ge x\).  
-  We want the largest \(x\) (call it \(X\)) for which \(C(X)\ge k\).  

Once we have that threshold \(X\), we know:

1.  Exactly \(C(X)\) terms are \(\ge X\).
2.  Exactly \(C(X+1)\) terms are \(\ge X+1\), i.e. strictly \(>X\).
3.  Hence exactly
   \[
     M \;=\; C(X+1)
   \]
   terms are strictly greater than \(X\).  We will definitely take all \(M\) of those.
4.  Then to make our total operations up to \(k\), we need \((k-M)\) more picks, each of value exactly \(X\).  

So the total score is

\[
  \underbrace{\sum(\text{all values}>X)}_{\text{take all}} 
  \;+\;
  (k - M)\;\times\; X.
\]

We can compute

-  \(M = C(X+1)\) by the same counting formula,
-  and also the sum of all terms strictly greater than \(X\) by summing the first
   \(\lfloor\frac{a_i - (X+1)}{b_i}\rfloor + 1\) terms of each arithmetic sequence.

We must not forget the special case that there may be fewer than \(k\) *positive* terms in all.  In that case we simply sum *all* positive terms and stop (the remaining picks would be zero in any case).

---

### Complexity

-  We do a binary search on \(x\) in the range \([1,\max_i a_i]\), which takes \(O(\log A)\) steps where \(A=\max a_i\le10^9\).
-  Each step we do an \(O(n)\) pass to compute \(C(x)\) (but we clamp the running sum at \(k\) so we rarely overflow).
-  Summing and counting the final answer is another \(O(n)\) pass.

Since \(\sum n \le 2\times10^5\) over all testcases and each input is processed in \(O(n\log A)\), this easily runs in time.

---

```java
import java.io.*;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        // Fast I/O
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        int t = Integer.parseInt(br.readLine().trim());

        while (t-- > 0) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            long k = Long.parseLong(st.nextToken());

            long[] a = new long[n];
            long[] b = new long[n];
            long maxA = 0;

            // Read array a
            st = new StringTokenizer(br.readLine());
            for (int i = 0; i < n; i++) {
                a[i] = Long.parseLong(st.nextToken());
                if (a[i] > maxA) {
                    maxA = a[i];
                }
            }
            // Read array b
            st = new StringTokenizer(br.readLine());
            for (int i = 0; i < n; i++) {
                b[i] = Long.parseLong(st.nextToken());
            }

            // First compute how many strictly positive terms there are in all sequences
            long totalPositive = 0;
            for (int i = 0; i < n; i++) {
                // number of j >= 0 with a[i] - j*b[i] >= 1
                // => j <= (a[i]-1)/b[i]
                long count = (a[i] >= 1 ? ( (a[i]-1) / b[i] ) + 1 : 0);
                totalPositive += count;
                if (totalPositive > k) {
                    // no need to exceed k
                    totalPositive = k + 1;
                    break;
                }
            }

            // If there are fewer than k positive terms, just sum them all
            if (totalPositive <= k) {
                // Sum every positive term
                long answer = 0;
                for (int i = 0; i < n; i++) {
                    long tCount = (a[i] >= 1 ? ((a[i]-1)/b[i]) + 1 : 0);
                    // sum of arithmetic sequence: a[i] + (a[i]-b[i]) + ... up to tCount terms
                    // = tCount*a[i] - b[i]*(tCount*(tCount-1)/2)
                    if (tCount > 0) {
                        answer += tCount * a[i]
                                - b[i] * (tCount * (tCount - 1) / 2);
                    }
                }
                sb.append(answer).append('\n');
                continue;
            }

            // Otherwise we do a binary search for the threshold X in [1..maxA]
            long low = 1, high = maxA, X = 1;
            while (low <= high) {
                long mid = (low + high) >>> 1;
                if (countAtLeast(a, b, mid, k) >= k) {
                    // mid is feasible, try a larger threshold
                    X = mid;
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }

            // We found the largest X such that C(X) >= k.
            // Next compute M = C(X+1), the number of terms strictly greater than X,
            // and sumGt = sum of all those terms > X.
            long M = 0;
            long sumGt = 0;
            for (int i = 0; i < n; i++) {
                if (a[i] > X) {
                    long cnt = (a[i] - (X + 1)) / b[i] + 1;  // #terms > X
                    M += cnt;
                    // sum of the first cnt terms:  a[i] + (a[i]-b[i]) + ...  
                    // = cnt*a[i] - b[i]*(cnt*(cnt-1)/2)
                    sumGt += cnt * a[i] - b[i] * (cnt * (cnt - 1) / 2);
                }
            }

            // We need (k - M) more picks, each of value exactly X
            long answer = sumGt + (k - M) * X;
            sb.append(answer).append('\n');
        }

        // Output
        System.out.print(sb.toString());
    }

    /**
     * Count how many terms across all sequences are >= x,
     * stopping early if we exceed the limit 'cap'.
     */
    private static long countAtLeast(long[] a, long[] b, long x, long cap) {
        long total = 0;
        for (int i = 0; i < a.length; i++) {
            if (a[i] >= x) {
                long cnt = (a[i] - x) / b[i] + 1;
                total += cnt;
                if (total > cap) {
                    return cap + 1;
                }
            }
        }
        return total;
    }
}
```

**Explanation of the Key Steps**

1. **Counting positive terms.**  
   For each index \(i\), the sequence  
   \[
     a_i,\; a_i-b_i,\; a_i-2b_i,\;\dots
   \]
   remains positive as long as \(a_i - j b_i \ge 1\).  The largest \(j\) for which that holds is  
   \(\lfloor (a_i-1)/b_i\rfloor\).  Hence there are  
   \(\lfloor (a_i-1)/b_i\rfloor +1\) positive terms.  
   If the total number of positive terms is \(\le k\), we simply sum *all* of them and stop.

2. **Binary search on the threshold \(X\).**  
   Define  
   \[
     C(x) \;=\; \sum_{i=1}^n \bigl(\lfloor (a_i - x)/b_i\rfloor +1\bigr)
     \quad\text{(only when \(a_i\ge x\), otherwise 0).}
   \]
   This is the count of all terms \(\ge x\).  We find the largest \(X\) so that \(C(X)\ge k\).  

3. **Reconstruct the sum from that threshold.**  
   -  Let  
      \[
        M \;=\; C(X+1),
      \]
      the number of terms *strictly greater* than \(X\).  
   -  We take all these \(M\) terms (compute their sum via arithmetic series formula).  
   -  Then we still need \((k-M)\) more picks, each of which must be of value exactly \(X\).  
   -  Total score = \(\text{(sum of all >\(X\))} + (k-M)\times X\).

All steps run in \(O(n\log A)\) per test and comfortably meet the problem’s constraints.