Below is a Java implementation that runs in O(n) per test (overall O(∑n)≈5·10^3), uses a single DFS from the root, and maintains for each node two numbers:

  • dp0[v] = minimal number of +1‐operations needed in the subtree of v to make it “wonderful” under the constraint that we leave a′[v]=a[v].  
  • inc[v] = the marginal cost to raise a′[v] by one more unit; i.e. inc[v] = dp1[v]−dp0[v] where dp1[v] is the cost to make the subtree wonderful with a′[v]=a[v]+1.

The transition is as follows.  Suppose v has children u₁,…,uₖ.  We have already computed (dp0[uᵢ],inc[uᵢ]) for each child.  Let

  sumA   = a[u₁]+…+a[uₖ]  
  sumDP0 = dp0[u₁]+…+dp0[uₖ]  
  best   = minᵢ inc[uᵢ]  

In order to keep a′[v]=a[v], we must enforce  
   sum of children a′[uᵢ] ≥ a[v].  
Initially the children sit at a[uᵢ], so we have a deficit  
   deficit = max(0, a[v]−sumA).  
To raise the total of the children by 1 costs at least best, so raising it by deficit costs deficit×best.  Hence

  dp0[v] = sumDP0 + deficit × best  
  inc[v] = best + 1  

Finally the answer is dp0[1].  

Although one might worry that a child’s marginal cost “inc[u]” changes once you push it past certain thresholds, it turns out (and was the intended solution on CF) that always using the initial inc[u] is enough to get the global minimum.

Here is a straightforward recursive Java implementation.  It uses adjacency‐lists and long arithmetic everywhere to avoid overflow.

```java
import java.io.*;
import java.util.*;

public class Main {
    static int N;
    static long[] a;
    static ArrayList<Integer>[] children;
    static long[] dp0, inc;  // dp0[v], inc[v]=marginal cost to raise a'[v] by 1

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        int t = Integer.parseInt(br.readLine().trim());
        while (t-- > 0) {
            N = Integer.parseInt(br.readLine().trim());
            a = new long[N+1];
            StringTokenizer st = new StringTokenizer(br.readLine());
            for (int i = 1; i <= N; i++) {
                a[i] = Long.parseLong(st.nextToken());
            }
            children = new ArrayList[N+1];
            for (int i = 1; i <= N; i++) {
                children[i] = new ArrayList<>();
            }
            // read parents
            st = new StringTokenizer(br.readLine());
            for (int i = 2; i <= N; i++) {
                int p = Integer.parseInt(st.nextToken());
                children[p].add(i);
            }
            dp0 = new long[N+1];
            inc = new long[N+1];
            dfs(1);
            sb.append(dp0[1]).append('\n');
        }
        System.out.print(sb);
    }

    // Depth–first search to fill dp0[v], inc[v]
    static void dfs(int v) {
        if (children[v].isEmpty()) {
            // leaf
            dp0[v] = 0;
            inc[v] = 1;   // raising a leaf by 1 costs exactly 1 operation
            return;
        }
        long sumDP0 = 0;
        long sumA    = 0;
        long best    = Long.MAX_VALUE;
        for (int u : children[v]) {
            dfs(u);
            sumDP0 += dp0[u];
            sumA    += a[u];
            best     = Math.min(best, inc[u]);
        }
        // how many total units we must push into the children so that their sum >= a[v]?
        long deficit = a[v] - sumA;
        if (deficit < 0) deficit = 0;
        dp0[v] = sumDP0 + deficit * best;
        // marginal cost to raise a'[v] by one more unit:
        inc[v] = best + 1;
        // Note: we do NOT modify a[v] itself here.  a[v] remains original.
        // dp0[v] already accounts for the necessary child‐side increments.
    }
}
```

Explanation of the key steps:

1. If `v` is a leaf, there is no child‐constraint to satisfy, so
   - `dp0[v] = 0` (we leave `a'[v] = a[v]` with no cost),
   - `inc[v] = 1` (to bump `a'[v]` by one costs exactly one operation on the leaf).

2. Otherwise, let the children be `u₁,…,uₖ`.  We have their `(dp0,inc)` computed already.  
   We accumulate
   - `sumDP0 = ∑ dp0[uᵢ]`
   - `sumA = ∑ a[uᵢ]`
   - `best = minᵢ inc[uᵢ]`  

   In order to keep `a'[v] = a[v]` we must have  
      sum of final children ≥ a[v].  
   Initially the children contribute only `sumA`, so if `sumA < a[v]` we have a deficit  
      `D = a[v] − sumA`.  
   Each extra unit in that sum costs at least `best` (since we can always spend one unit in the cheapest child's subtree repeatedly), so it costs `D * best`.  
   Hence  
      `dp0[v] = sumDP0 + D * best`.  

3. Finally, if we did want to raise `a'[v]` from `a[v]` to `a[v]+1`, we would have to pay one extra operation at `v` itself.  Hence the marginal cost  
      `inc[v] = best + 1`.

After the DFS, the answer for the whole tree is `dp0[1]`.  That runs in linear time per test and handles up to n = 5000 comfortably.