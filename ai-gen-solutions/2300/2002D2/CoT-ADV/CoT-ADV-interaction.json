[
    {
        "request_timestamp": "2025-07-23T23:10:35.838180",
        "response_timestamp": "2025-07-23T23:12:18.306363",
        "sent_messages": [
            {
                "role": "user",
                "content": "Codeforces Problem:\n\nD2. DFS Checker (Hard Version)\n\ntime limit per test2 seconds\n\nmemory limit per test512 megabytes\n\nThis is the hard version of the problem. In this version, you are given a generic tree and the constraints on n\n\n and q\n\n are higher. You can make hacks only if both versions of the problem are solved.\n\n\n\nYou are given a rooted tree consisting of n\n\n vertices. The vertices are numbered from 1\n\n to n\n\n, and the root is the vertex 1\n\n. You are also given a permutation p1,p2,…,pn\n\n of [1,2,…,n]\n\n.\n\n\n\nYou need to answer q\n\n queries. For each query, you are given two integers x\n\n, y\n\n; you need to swap px\n\n and py\n\n and determine if p1,p2,…,pn\n\n is a valid DFS order†\n\n of the given tree.\n\n\n\nPlease note that the swaps are persistent through queries.\n\n\n\n†\n\n A DFS order is found by calling the following dfs\n\n function on the given tree.\n\n\n\ndfs_order = []\n\n\n\nfunction dfs(v):\n\n    append v to the back of dfs_order\n\n    pick an arbitrary permutation s of children of v\n\n    for child in s:\n\n        dfs(child)\n\ndfs(1)\n\nNote that the DFS order is not unique.\n\n\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n\n (1≤t≤104\n\n). The description of the test cases follows.\n\n\n\nThe first line of each test case contains two integers n\n\n, q\n\n (2≤n≤3⋅105\n\n, 2≤q≤105\n\n) — the number of vertices in the tree and the number of queries.\n\n\n\nThe next line contains n−1\n\n integers a2,a3,…,an\n\n (1≤ai<i\n\n) — the parent of each vertex in the given tree.\n\n\n\nThe next line contains n\n\n integers p1,p2,…,pn\n\n (1≤pi≤n\n\n, all pi\n\n are distinct) — the initial permutation p\n\n.\n\n\n\nThe next q\n\n lines each contain two integers x\n\n, y\n\n (1≤x,y≤n,x≠y\n\n) — the positions of the elements to swap in the permutation.\n\n\n\nIt is guaranteed that the sum of all n\n\n does not exceed 3⋅105\n\n, and the sum of all q\n\n does not exceed 105\n\n.\n\n\n\nOutput\n\nFor each test case, print q\n\n lines corresponding to the q\n\n queries. For each query, output YES\n\n if there is a DFS order that exactly equals the current permutation, and output NO\n\n otherwise.\n\n\n\nYou can output Yes\n\n and No\n\n in any case (for example, strings yEs\n\n, yes\n\n, Yes\n\n, and YES\n\n will be recognized as a positive response).\n\n\n\nExample\n\nInputCopy\n\n3\n\n3 3\n\n1 1\n\n1 2 3\n\n2 3\n\n3 2\n\n1 3\n\n7 4\n\n1 1 2 2 3 3\n\n1 2 3 4 5 6 7\n\n3 5\n\n2 5\n\n3 7\n\n4 6\n\n5 4\n\n1 1 3 4\n\n2 3 4 5 1\n\n5 1\n\n4 5\n\n3 4\n\n2 3\n\nOutputCopy\n\nYES\n\nYES\n\nNO\n\nYES\n\nNO\n\nNO\n\nYES\n\nYES\n\nNO\n\nNO\n\nYES\n\nNote\n\nIn the first test case, the permutation p1,p2,…,pn\n\n after each modification is [1,3,2],[1,2,3],[3,2,1]\n\n, respectively. The first two permutations are valid DFS orders; the third is not a DFS order.\n\n\n\nIn the second test case, the permutation p1,p2,…,pn\n\n after each modification is [1,2,5,4,3,6,7],[1,3,5,4,2,6,7],[1,3,7,4,2,6,5],[1,3,7,6,2,4,5]\n\n, respectively.\n\n---\n\nYou are a competitive programming assistant solving Codeforces problems using Java. First, carefully read and restate the problem in your own words to ensure full understanding. Identify the input and output formats, list the constraints, and consider any edge cases that might affect the logic. Next, determine which algorithmic pattern the problem fits best—such as greedy, binary search, two pointers, dynamic programming, or graph traversal—and briefly explain why that pattern applies. Then, plan your solution step by step, describing the key ideas, data structures, or mathematical insights you’ll use. Once your plan is clear, write a clean and fully working Java program. Use import java.util.*; and include a Main class with a main method, using Scanner or BufferedReader for input depending on the constraints. Add comments to explain important logic in the code. After coding, walk through a sample input manually to show how your solution works in practice. Finally, analyze the time and space complexity of your approach using Big-O notation, justifying your answer. Think step by step and only write code once the logic is sound and complete."
            }
        ],
        "received_response": "{\n  \"id\": \"chatcmpl-BwgdoIRoDA5uKthIjcu8gxf8sHX4X\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"The key observation is that in a preorder‐type DFS of a rooted tree (with arbitrary sibling‐orderings), each time we go from the previously visited node `v = p[i−1]` to the new node `u = p[i]`, we must be “finishing” whatever subtree we were in and then “descending” exactly one edge into `u`.  Equivalently, if `par[u]` is the parent of `u` in the rooted tree, then\\n\\n   LCA( p[i−1], p[i] )  must  equal  par[p[i]].\\n\\nMoreover, we must start with the root (vertex 1) in position 1 of the permutation.  It turns out (and can be proved by the usual stack‐simulation of DFS) that these two local conditions\\n\\n  1) p[1] == 1  \\n  2) for every i=2…n, LCA(p[i−1],p[i]) == par[p[i]]\\n\\nare both necessary and sufficient for the current array `p[]` to be *some* DFS‐preorder of the tree.\\n\\nWe only ever swap two entries of `p[]` per query.  Each swap can only affect adjacencies at positions near the two swapped indices (specifically the pairs `(x−1,x)`, `(x, x+1)`, `(y−1,y)`, `(y,y+1)`).  So we maintain a small boolean array `good[2…n]` where\\n\\n  good[i] = true  iff  LCA(p[i−1],p[i]) == par[p[i]].\\n\\nWe also maintain a counter `badCt` = the number of `i` in `[2..n]` with `!good[i]`, and a flag `badRoot = (p[1]!=1)`.  \\nAfter each swap of `p[x]` and `p[y]` we only re–check those at most four adjacencies, updating `badCt` in O(1) each, plus re–check `p[1]==1`.  Each adjacency check is one LCA query, and we do O(log n) preprocessing for LCA (binary‐lifting).  Hence each query is O(log n), overall O((n+q) log n).  \\n\\nBelow is a complete Java implementation.  We read T test‐cases (sum n≤3⋅10^5, sum q≤10^5), build the parent‐array and a small adjacency‐list, DFS for depths, build a 19‐level up[][] table for LCA, read the initial `p[]`, initialize all `good[i]` and `badCt`, then process queries online in O(log n) each, printing “YES” if and only if `badRoot==false && badCt==0`.\\n\\n\\n```java\\nimport java.io.*;\\nimport java.util.*;\\n\\npublic class Main {\\n    static final int MAXN = 300_000 + 5;\\n    static final int LOG  = 19; // enough for up to ~5e5 nodes\\n\\n    static int n, q;\\n    static int[] parent = new int[MAXN];\\n    static int[] depth  = new int[MAXN];\\n    static int[][] up   = new int[LOG][MAXN];\\n    // adjacency lists for building the tree\\n    static ArrayList<Integer>[] adj = new ArrayList[MAXN];\\n    // The current permutation p[1..n]\\n    static int[] p = new int[MAXN];\\n    // good[i]==true iff LCA(p[i-1],p[i]) == parent[p[i]]\\n    static boolean[] good = new boolean[MAXN];\\n    // temporary marker array when updating neighborhoods on swap\\n    static boolean[] seen = new boolean[MAXN];\\n\\n    public static void main(String[] args) throws IOException {\\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\\n        StringBuilder out = new StringBuilder();\\n        StringTokenizer st;\\n\\n        int T = Integer.parseInt(in.readLine().trim());\\n        while (T-- > 0) {\\n            st = new StringTokenizer(in.readLine());\\n            n = Integer.parseInt(st.nextToken());\\n            q = Integer.parseInt(st.nextToken());\\n\\n            // initialize adjacency\\n            for (int i = 1; i <= n; i++) {\\n                if (adj[i] == null) adj[i] = new ArrayList<>();\\n                else adj[i].clear();\\n            }\\n\\n            // read parents a[2..n]\\n            parent[1] = 0;  // root has no parent\\n            st = new StringTokenizer(in.readLine());\\n            for (int i = 2; i <= n; i++) {\\n                int a = Integer.parseInt(st.nextToken());\\n                parent[i] = a;\\n                adj[a].add(i);\\n            }\\n\\n            // Read initial permutation p[1..n]\\n            st = new StringTokenizer(in.readLine());\\n            for (int i = 1; i <= n; i++) {\\n                p[i] = Integer.parseInt(st.nextToken());\\n            }\\n\\n            // 1) DFS to compute depth[] and up[0][v] = parent[v]\\n            dfsCompute(1, 0);\\n\\n            // 2) Build the binary-lifting table\\n            for (int k = 1; k < LOG; k++) {\\n                for (int v = 1; v <= n; v++) {\\n                    up[k][v] = up[k-1][ up[k-1][v] ];\\n                }\\n            }\\n\\n            // 3) Initialize good[2..n] and count bad ones\\n            int badCt = 0;\\n            for (int i = 2; i <= n; i++) {\\n                good[i] = checkPair(i);\\n                if (!good[i]) badCt++;\\n            }\\n            // also require p[1]==1\\n            boolean badRoot = (p[1] != 1);\\n\\n            // Process queries\\n            for (int qi = 0; qi < q; qi++) {\\n                st = new StringTokenizer(in.readLine());\\n                int x = Integer.parseInt(st.nextToken());\\n                int y = Integer.parseInt(st.nextToken());\\n                // We will swap p[x] <-> p[y].\\n                // Only positions i in { x-1,x, x+1,  y-1,y, y+1 } (2..n) can change good[i].\\n                int[] cand = { x-1, x, x+1, y-1, y, y+1 };\\n                List<Integer> toRecalc = new ArrayList<>();\\n\\n                // remove old contributions\\n                for (int c : cand) {\\n                    if (c >= 2 && c <= n && !seen[c]) {\\n                        seen[c] = true;\\n                        if (!good[c]) badCt--;\\n                        toRecalc.add(c);\\n                    }\\n                }\\n\\n                // do the swap\\n                int tmp = p[x]; p[x] = p[y]; p[y] = tmp;\\n\\n                // recompute good[c] and add back\\n                for (int c : toRecalc) {\\n                    good[c] = checkPair(c);\\n                    if (!good[c]) badCt++;\\n                }\\n\\n                // clear seen[]\\n                for (int c : toRecalc) {\\n                    seen[c] = false;\\n                }\\n\\n                // update root check\\n                badRoot = (p[1] != 1);\\n\\n                // final answer\\n                out.append((!badRoot && badCt == 0) ? \\\"YES\\\\n\\\" : \\\"NO\\\\n\\\");\\n            }\\n        }\\n\\n        System.out.print(out);\\n    }\\n\\n    // DFS from root to fill depth[v] and up[0][v]\\n    static void dfsCompute(int v, int par) {\\n        up[0][v] = par;\\n        depth[v] = (par == 0 ? 0 : depth[par] + 1);\\n        for (int w : adj[v]) {\\n            dfsCompute(w, v);\\n        }\\n    }\\n\\n    // LCA by binary-lifting\\n    static int lca(int a, int b) {\\n        if (a == 0 || b == 0) return a|b; // handle degenerate\\n        if (depth[a] < depth[b]) {\\n            int t = a; a = b; b = t;\\n        }\\n        // lift a up to depth of b\\n        int diff = depth[a] - depth[b];\\n        for (int k = 0; k < LOG; k++) {\\n            if ((diff & (1<<k)) != 0) {\\n                a = up[k][a];\\n            }\\n        }\\n        if (a == b) return a;\\n        for (int k = LOG - 1; k >= 0; k--) {\\n            if (up[k][a] != up[k][b]) {\\n                a = up[k][a];\\n                b = up[k][b];\\n            }\\n        }\\n        return up[0][a]; // the parent\\n    }\\n\\n    // Test the adjacency condition at index i: we need\\n    //    LCA( p[i-1], p[i] )  ==  parent[ p[i] ]\\n    static boolean checkPair(int i) {\\n        int u = p[i], v = p[i-1];\\n        int w = lca(u, v);\\n        return w == parent[u];\\n    }\\n}\\n```\\n\\nExplanation of the core parts:\\n\\n1) We root the given tree at 1 and store `parent[v]` for each v, build an adjacency‐list and do a simple DFS to fill in `depth[v]` and `up[0][v]`.\\n\\n2) We lift with a 19×N table `up[k][v]` so LCA queries cost O(log n).\\n\\n3) We maintain a boolean array `good[2..n]`, where  \\n  `good[i] ≡ ( LCA(p[i−1],p[i]) == parent[p[i]] )`.  \\n   In a correct DFS preorder, every adjacent step must climb as many parents as needed (possibly zero) to reach exactly `parent[p[i]]`, and then take the single edge down, which is exactly the local LCA‐test above.\\n\\n4) We also separately check that `p[1]==1`, since any DFS preorder must start at the root.\\n\\n5) At each swap of `p[x]` and `p[y]`, only the pairs `(x−1,x)`, `(x,x+1)`, `(y−1,y)`, `(y,y+1)` can flip from good→bad or bad→good.  We peel off their old contributions in O(1) each, swap, re‐evaluate them (using LCA) in O(log n) each, and update a running `badCt` count.  We also re‐check `p[1]==1`.  \\n\\nTotal time per test is O(n log n) for the DFS + LCA build plus O(q log n) for the queries, which easily runs under 2 seconds for n up to 3⋅10^5 and q up to 10^5.\",\n        \"refusal\": null,\n        \"role\": \"assistant\",\n        \"annotations\": [],\n        \"audio\": null,\n        \"function_call\": null,\n        \"tool_calls\": null\n      },\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"protected_material_code\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"protected_material_text\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ],\n  \"created\": 1753326636,\n  \"model\": \"o4-mini-2025-04-16\",\n  \"object\": \"chat.completion\",\n  \"service_tier\": null,\n  \"system_fingerprint\": null,\n  \"usage\": {\n    \"completion_tokens\": 15507,\n    \"prompt_tokens\": 1089,\n    \"total_tokens\": 16596,\n    \"completion_tokens_details\": {\n      \"accepted_prediction_tokens\": 0,\n      \"audio_tokens\": 0,\n      \"reasoning_tokens\": 13120,\n      \"rejected_prediction_tokens\": 0\n    },\n    \"prompt_tokens_details\": {\n      \"audio_tokens\": 0,\n      \"cached_tokens\": 0\n    }\n  },\n  \"prompt_filter_results\": [\n    {\n      \"prompt_index\": 0,\n      \"content_filter_results\": {\n        \"hate\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"jailbreak\": {\n          \"filtered\": false,\n          \"detected\": false\n        },\n        \"self_harm\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"sexual\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        },\n        \"violence\": {\n          \"filtered\": false,\n          \"severity\": \"safe\"\n        }\n      }\n    }\n  ]\n}"
    }
]