**Analysis**

We have \(n\) enemies, the \(i\)-th at position \(x_i\) with health \(h_i\).  We place our hero at some integer position \(p\), and every attack deals

\[
d_i \;=\; \max\bigl(0,\;m - |p - x_i|\bigr)
\]

damage to enemy \(i\).  Since we must pick one \(p\) and then repeat the *same* attack \(T\) times, enemy \(i\) will take total damage
\[
T \times d_i,
\]
so it is defeated exactly if
\[
T\,d_i \;\ge\; h_i,
\]
i.e.
\[
d_i \;\ge\;\Bigl\lceil \frac{h_i}{T}\Bigr\rceil.
\]

We want to kill *at least* \(k\) enemies in \(T\) attacks, and we want the minimum such \(T\), or \(-1\) if impossible.

---

**Reformulation as intervals and coverage**

For a *fixed* \(T\), define
\[
r_i \;=\;\Bigl\lceil \frac{h_i}{T}\Bigr\rceil,
\quad
\text{and}\quad
w_i = m - r_i.
\]
Enemy \(i\) can only be defeated in \(T\) attacks if \(w_i\ge0\); in that case the condition
\[
m - |p - x_i| \;\ge\; r_i
\quad\Longleftrightarrow\quad
|p - x_i|\;\le\; w_i
\]
becomes
\[
x_i - w_i \;\le\; p \;\le\; x_i + w_i.
\]
Hence each *defeatable* enemy \(i\) corresponds to an integer interval
\[
[L_i,R_i] = [\,x_i - w_i,\;x_i + w_i\,].
\]
We can defeat enemy \(i\) if and only if our chosen \(p\) lies in that interval.

We need *some* integer \(p\) that lies in *at least* \(k\) of these intervals.  That is exactly the classical “maximum interval‐coverage” problem.  We

1.  Build all intervals \([L_i,R_i]\) with \(w_i\ge0\).
2.  If there are fewer than \(k\) such intervals at all, we cannot kill \(k\) enemies in \(T\) attacks.
3.  Otherwise we ask: does **some** integer point \(p\) lie in at least \(k\) of those intervals?

One can solve (3) in \(O(n\log n)\) by a simple sweep or by sorting the intervals by \(L_i\) and maintaining a min‐heap of the active \(R_i\).  Every time we push a new interval \([L_i,R_i]\), we pop from the heap all intervals whose \(R_j<L_i\) (they no longer cover \(L_i\)), and then check if the heap’s size has reached \(k\).  If so, we know there is a point (namely \(p=L_i\)) covered by at least \(k\) intervals.

Next, define the predicate
\[
\mathrm{possible}(T) =
\begin{cases}
\text{true}, &\text{if we can kill at least \(k\) enemies in \(T\) attacks},\\
\text{false},&\text{otherwise}.
\end{cases}
\]
One checks easily that if \(\mathrm{possible}(T)\) is true, then it remains true for any larger \(T'\ge T\).  Hence we can binary‐search for the minimum \(T\) in \([1,\;\max_i h_i]\) for which \(\mathrm{possible}(T)\) holds.

Overall complexity per test is
\[
O\!\bigl((\log H)\times(n\log n)\bigr),
\]
where \(H=\max_i h_i\).  Since \(\sum n\le10^5\) and \(H\le10^9\), this runs comfortably in the 4 s limit under a reasonably optimized Java implementation.

---

```java
import java.io.*;
import java.util.*;

public class Main {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;

    // Fast read of next token
    static String next() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            String line = br.readLine();
            if (line == null) return null;
            st = new StringTokenizer(line);
        }
        return st.nextToken();
    }

    static int nextInt() throws IOException {
        return Integer.parseInt(next());
    }

    // The "possible" check: can we kill >= k enemies in T attacks?
    // We build intervals [L_i, R_i] = [x_i - w_i, x_i + w_i], w_i = m - ceil(h_i/T),
    // keep only those with w_i >= 0, and see if some integer point is
    // covered by at least k intervals via a heap-based sweep.
    static boolean possible(int T, int n, int m, int k,
                            int[] h, int[] x,
                            long[] packed, int[] heap) {
        int tsize = 0;
        // Build intervals
        for (int i = 0; i < n; i++) {
            // ceil(h[i]/T)
            int need = (h[i] + T - 1) / T;
            int w = m - need;
            if (w < 0) continue;          // can't damage this enemy enough
            int L = x[i] - w;
            int R = x[i] + w;
            // pack L in high 32 bits (signed), R in low 32 bits
            packed[tsize++] = ((long) L << 32) | (R & 0xffffffffL);
        }
        if (tsize < k) return false;

        // Sort intervals by L ascending
        Arrays.sort(packed, 0, tsize);

        // We'll do a min-heap of R's in a plain array
        int heapSize = 0;

        for (int i = 0; i < tsize; i++) {
            long p = packed[i];
            int L = (int) (p >> 32);  // top 32 bits, sign-extended
            int R = (int) p;          // low 32 bits

            // Remove from heap all intervals whose R < L
            while (heapSize > 0 && heap[0] < L) {
                // pop min
                heapSize--;
                heap[0] = heap[heapSize];
                // heapify down
                int idx = 0;
                while (true) {
                    int left = 2 * idx + 1;
                    if (left >= heapSize) break;
                    int right = left + 1;
                    int smallChild = left;
                    if (right < heapSize && heap[right] < heap[left])
                        smallChild = right;
                    if (heap[smallChild] < heap[idx]) {
                        int tmp = heap[idx];
                        heap[idx] = heap[smallChild];
                        heap[smallChild] = tmp;
                        idx = smallChild;
                    } else {
                        break;
                    }
                }
            }

            // Insert R into heap
            int pos = heapSize++;
            heap[pos] = R;
            // heapify up
            while (pos > 0) {
                int par = (pos - 1) >>> 1;
                if (heap[par] <= heap[pos]) break;
                int tmp = heap[par];
                heap[par] = heap[pos];
                heap[pos] = tmp;
                pos = par;
            }

            // If we now have at least k intervals covering L, success
            if (heapSize >= k) return true;
        }
        return false;
    }

    public static void main(String[] args) throws IOException {
        int Tcases = nextInt();
        StringBuilder out = new StringBuilder();

        while (Tcases-- > 0) {
            int n = nextInt();
            int m = nextInt();
            int k = nextInt();

            int[] h = new int[n];
            int[] x = new int[n];
            int maxH = 0;

            for (int i = 0; i < n; i++) {
                h[i] = nextInt();
                if (h[i] > maxH) maxH = h[i];
            }
            for (int i = 0; i < n; i++) {
                x[i] = nextInt();
            }

            // Pre-allocate helper arrays
            long[] packed = new long[n];
            int[] heap = new int[n];

            // Quick check: if even with T = maxH we can't get k intervals covering some point,
            // then it's impossible in <anything>.
            if (!possible(maxH, n, m, k, h, x, packed, heap)) {
                out.append(-1).append('\n');
                continue;
            }

            // Binary search for the minimal T in [1..maxH] that is possible.
            int lo = 1, hi = maxH;
            while (lo < hi) {
                int mid = (lo + hi) >>> 1;
                if (possible(mid, n, m, k, h, x, packed, heap)) {
                    hi = mid;
                } else {
                    lo = mid + 1;
                }
            }
            out.append(lo).append('\n');
        }

        System.out.print(out);
    }
}
```

**Explanation of Key Steps**

1. **Damage / Interval Translation**  
   - In \(T\) attacks, enemy \(i\) must take a total of at least \(h_i\) damage.
   - Per‐attack it receives  
     \(\;d_i = \max(0,\,m - |p - x_i|)\).
   - We need \(T \times d_i \ge h_i\), i.e.\ \(d_i \ge \lceil h_i/T\rceil\).
   - Let \(\rho_i = \lceil h_i/T\rceil\).  Then \(m - |p - x_i| \ge \rho_i\)
     iff \(|p - x_i|\le m-\rho_i=:w_i\).  
   - Thus for each \(i\) with \(w_i\ge0\), we get an interval  
     \([L_i,R_i]=[x_i-w_i,\;x_i+w_i]\) of all \(p\) that defeat \(i\).  

2. **Checking “can we cover at least \(k\) intervals?”**  
   - If fewer than \(k\) intervals exist, it fails immediately.
   - Otherwise sort intervals by \(L_i\) and scan them, keeping a min‐heap of the \(R_i\) of *active* intervals.
   - When we insert \([L_i,R_i]\), we first pop out all intervals whose \(R_j < L_i\)
     (they no longer cover point \(L_i\)); then we push \(R_i\).  If the heap size
     ever reaches \(k\), we have found a point covered by \(k\) intervals.

3. **Binary Search on \(T\)**  
   - Define `possible(T)` as above.  One shows easily that if `possible(T)` is
     true then for every \(T'>T\) it remains true (intervals only grow larger with \(T\)),
     so a lower‐bound binary search on \(T\in[1,\max h_i]\) finds the minimum.

This runs in \(O\bigl(n\log n\cdot\log(\max h_i)\bigr)\), which is acceptable for
\(\sum n\le10^5\) and \(\max h_i\le10^9\) under a 4 s Java limit.