**Problem Restatement**

We have an array **b** and an initial set **S** containing all distinct values of **b**.  We say **b** is *orangutan-approved* if we can repeatedly remove a contiguous block of equal value *v* (that still lies in **S**), delete *all* copies of *v* in that block, remove *v* from **S**, re-index the array, and eventually make the array empty.

Concretely, each distinct value *v* in **b** can be “activated” exactly once, and when we do, we must remove *all* occurrences of *v* at once—so at that moment, all the copies of *v* must form one contiguous segment.  

We are given a fixed array **a** of length *n* and *q* queries.  Each query specifies a subarray **a**[l..r], and asks: *is that subarray orangutan-approved?*

---

**Key Observation / Characterization**

A subarray **b** = **a**[l..r] fails to be orangutan-approved precisely when there is some "interleaving" of two distinct values.  Formally, you get stuck (cannot ever make all the copies of *u* or *v* contiguous) if there exist indices

```
 x < y < z < w   all in [l..r],
 a[x] = a[z] = u,
 a[y] = a[w] = v,
 u ≠ v.
```

That pattern (often called an “abab” or “interleaving” pattern) makes it impossible to choose an order to delete *u* and *v* in single contiguous chunks.  Conversely, if *no* such quadruple exists, one can always delete in an order compatible with nesting/disjointness of the intervals of each value.

Thus our subarray is orangutan-approved ⇔ it **avoids** any interleaving pair **u**, **v** in that subarray.

---

**Offline Preprocessing + Range Minimum Query**

We will precompute, for every position *i* in the full array **a**, the *earliest* “trouble‐point” `badR[i]`: the smallest index *w* > *i* such that there is an interleaving pattern `u=v=a[i]` starting at *i* and finishing at *w*.  If no such *w* exists, we set `badR[i] = ∞` (we use `n+1` as “infinity”).

Once we have the array `badR[1..n]`, for any query [l..r] we simply check

    min{ badR[l], badR[l+1], …, badR[r] }  > r

—if that holds, no interleaving pattern lies fully inside [l..r], so answer “YES”; otherwise “NO.”

**How to Build `badR[i]` Efficiently**

1.  **Precompute next occurrence and last occurrence**  
    - `nextpos[i]` = index of next occurrence of **a**[i] to the right, or `n+1` if none.  
    - `lastpos[i]` = index of the last occurrence of **a**[i] in the entire array.

2.  **For each i with a next copy,** consider the pair `i, nextpos[i]`.  
    Any value **v** that appears somewhere `j` in `(i, nextpos[i])` **and** whose last occurrence `lastpos[j]` is *beyond* `nextpos[i]` will form an interleaving:  
     
       a[i]=u, a[j]=v, a[nextpos[i]]=u again, a[lastpos[j]]=v again
       with i < j < nextpos[i] < lastpos[j].

    We want the **smallest** such `lastpos[j]` for any `j` in that open interval.

3.  That becomes a two‐dimensional query:

    For each *i*,  
      - let `L = i+1, R = nextpos[i]-1`  
      - let threshold `t = nextpos[i]`.  
      We want  
      
        `badR[i] = min { lastpos[j] : L ≤ j ≤ R  and  lastpos[j] > t }`.

4.  We collect all these queries `(i, L, R, t)` offline.  We also list all positions *j* along with their `w = lastpos[j]`.  Sort the positions *j* in **descending** order of `lastpos[j]`.  Sort the queries in **descending** order of `t`.  Then we sweep:

    - Maintain a segment tree (or Fenwick tree) over `j = 1..n` that stores, at index *j*, the value `lastpos[j]` if and only if `lastpos[j] > currentT`; otherwise ∞.  
    - We begin with `currentT = ∞`, no positions added.  As we lower `currentT` to each query’s `t`, we keep inserting all positions *j* whose `lastpos[j] > t` into the tree (point‐update them with the value `lastpos[j]`).  
    - Then the query’s answer is `tree.query(L,R)`, the minimum in that index‐range.

   This yields all `badR[i]` in `O(n log n)` time.

5.  Finally, we build a second segment tree over `badR[1..n]` for range‐minimum queries.  Each input query `[l,r]` is answered by checking

        if ( seg2.min(l,r) > r )  YES
        else                    NO.

Overall preprocessing is `O(n log n)`, each of the *q* queries takes `O(log n)`.  With `n, q ≤ 2·10^5` (total), this is efficient.

---

**Java Implementation**

```java
import java.io.*;
import java.util.*;

public class Main {
    static final int INF = Integer.MAX_VALUE / 2;

    // A simple segment tree for point updates and range-min queries
    static class SegTree {
        int n;
        int[] st;
        SegTree(int _n) {
            n = _n;
            st = new int[4*n];
            Arrays.fill(st, INF);
        }
        // point update: set position pos to value val
        void update(int node, int L, int R, int pos, int val) {
            if (L == R) {
                st[node] = val;
                return;
            }
            int mid = (L+R) >>> 1;
            if (pos <= mid) update(node<<1, L, mid, pos, val);
            else            update(node<<1|1, mid+1, R, pos, val);
            st[node] = Math.min(st[node<<1], st[node<<1|1]);
        }
        void update(int pos, int val) {
            update(1, 1, n, pos, val);
        }
        // query min on [i..j]
        int query(int node, int L, int R, int i, int j) {
            if (j < L || R < i) return INF;
            if (i <= L && R <= j) return st[node];
            int mid = (L+R) >>> 1;
            return Math.min(
                query(node<<1, L, mid, i, j),
                query(node<<1|1, mid+1, R, i, j));
        }
        int query(int i, int j) {
            if (i > j) return INF;
            return query(1, 1, n, i, j);
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder output = new StringBuilder();
        int T = Integer.parseInt(br.readLine().trim());

        while (T-- > 0) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            int q = Integer.parseInt(st.nextToken());
            st = new StringTokenizer(br.readLine());
            int[] a = new int[n+1];
            for (int i = 1; i <= n; i++) {
                a[i] = Integer.parseInt(st.nextToken());
            }

            // 1) Compute last occurrence of each value
            int[] lastOcc = new int[n+1];
            for (int i = 1; i <= n; i++) {
                lastOcc[i] = 0;
            }
            for (int i = 1; i <= n; i++) {
                lastOcc[a[i]] = i;
            }
            // lastpos[i] = last occurrence of value a[i]
            int[] lastpos = new int[n+1];
            for (int i = 1; i <= n; i++) {
                lastpos[i] = lastOcc[a[i]];
            }

            // 2) Compute next occurrence of each a[i]
            int[] nextpos = new int[n+1];
            for (int v = 1; v <= n; v++) nextpos[v] = n+1;
            for (int i = n; i >= 1; i--) {
                nextpos[i] = nextpos[a[i]];
                nextpos[a[i]] = i;
            }

            // 3) Prepare queries for each i -> we want badR[i]
            class Q { int i, L, R, t; }
            ArrayList<Q> qlist = new ArrayList<>();

            for (int i = 1; i <= n; i++) {
                int nxt = nextpos[i];
                if (nxt <= n) {
                    int L = i+1, R = nxt-1;
                    if (L <= R) {
                        Q qq = new Q();
                        qq.i = i; qq.L = L; qq.R = R; qq.t = nxt;
                        qlist.add(qq);
                    }
                }
            }
            // sort queries by descending t
            qlist.sort((x,y) -> Integer.compare(y.t, x.t));

            // 4) Prepare positions j sorted by lastpos[j] descending
            Integer[] orderJ = new Integer[n];
            for (int i = 0; i < n; i++) orderJ[i] = i+1;
            Arrays.sort(orderJ, (x,y) -> Integer.compare(lastpos[y], lastpos[x]));

            // 5) Sweep to fill badR[i]
            SegTree st1 = new SegTree(n);
            int ptr = 0;
            int[] badR = new int[n+1];
            Arrays.fill(badR, n+1);

            for (Q qq : qlist) {
                // insert all j with lastpos[j] > qq.t
                while (ptr < n && lastpos[ orderJ[ptr] ] > qq.t) {
                    int j = orderJ[ptr];
                    st1.update(j, lastpos[j]);
                    ptr++;
                }
                // now query range L..R for minimal lastpos
                int best = st1.query(qq.L, qq.R);
                if (best <= n) {
                    // we found an interleaving reaching 'best'
                    badR[qq.i] = Math.min(badR[qq.i], best);
                }
            }

            // 6) Build a second segment tree over badR[]
            SegTree st2 = new SegTree(n);
            for (int i = 1; i <= n; i++) {
                st2.update(i, badR[i]);
            }

            // 7) Answer the input queries
            for (int _q = 0; _q < q; _q++) {
                st = new StringTokenizer(br.readLine());
                int L = Integer.parseInt(st.nextToken());
                int R = Integer.parseInt(st.nextToken());
                // if the minimum badR in [L..R] > R, it's clean
                int mn = st2.query(L, R);
                output.append( (mn > R) ? "YES\n" : "NO\n" );
            }
        }

        System.out.print(output);
    }
}
```

---

**Explanation of Key Steps**

1. **Defining “badR[i]”**  
   For each starting index *i*, we look at the very next occurrence of the same value `a[i]` at `nextpos[i]`.  Any value *v* that appears in between and whose *last* appearance is after `nextpos[i]` will form the pattern  
   
     u = a[i] at *i*,   v at some *j* ∈ (i,nextpos[i]),   u at nextpos[i],   v afterwards at lastpos[j].
   
   We record the earliest such `lastpos[j]` as `badR[i]`.  If none exists, `badR[i] = ∞`.  

2. **Offline 2D‐style Sweep**  
   We have many “range queries with threshold”:  for each *i*, ask  
     “over index‐range (i+1 .. nextpos[i]-1), find minimal `lastpos[j]` that exceeds threshold `t = nextpos[i]`.”  
   Sort queries by descending *t*, sort positions *j* by descending `lastpos[j]`, and maintain a segment tree where we only insert those *j* whose `lastpos[j]` are *above* the current threshold.  Then a standard range‐min‐query in the segment tree answers each query in `O(log n)`.  

3. **Answering Subarray Queries**  
   Once we know `badR[1..n]`, answering “is subarray [L..R] clean?” is just:  
     *If* `min(badR[L..R]) > R`  ⇒ “YES”  (no bad pattern falls entirely inside)  
     *else*                   ⇒ “NO”.  

This solves each test case in `O(n log n + q log n)` time, comfortably within the given limits. 

---

**Complexity Analysis**

- Preprocessing next/last occurrences: `O(n)`.  
- Building the *badR* queries and sorting them: `O(n log n)`.  
- 2D‐sweep with segment‐tree updates & queries: `O(n log n)`.  
- Building the final segment tree on *badR* and answering *q* queries: `O((n+q) log n)`.  

Overall across all test cases (sum of *n* and *q* ≤ 2·10<sup>5</sup>), the total complexity is `O((n+q) log n)`, which is efficient for the constraints.